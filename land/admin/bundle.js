(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
module.exports = /*#__PURE__*/function () {
  function DOMHelper() {
    _classCallCheck(this, DOMHelper);
  }
  return _createClass(DOMHelper, null, [{
    key: "parseStrToDom",
    value: function parseStrToDom(str) {
      var parser = new DOMParser();
      return parser.parseFromString(str, 'text/html');
    }
  }, {
    key: "serializeDomToStr",
    value: function serializeDomToStr(dom) {
      var serializer = new XMLSerializer();
      return serializer.serializeToString(dom);
    }
  }, {
    key: "wrapTextNodes",
    value: function wrapTextNodes(dom) {
      var body = dom.body;
      var textNodes = [];
      function recursy(element) {
        element.childNodes.forEach(function (node) {
          if (node.nodeName === '#text' && node.nodeValue.replace(/\s+/g, '').length > 0) {
            textNodes.push(node);
            // console.log(node);
          } else {
            recursy(node);
          }
        });
      }
      ;
      recursy(body);
      textNodes.forEach(function (node, i) {
        var wrapper = dom.createElement('text-editor');
        node.parentNode.replaceChild(wrapper, node);
        wrapper.appendChild(node);
        wrapper.contentEditable = true;
        wrapper.setAttribute('nodeId', i);
      });
      console.log(dom);
      return dom;
    }
  }, {
    key: "unwrapTextNodes",
    value: function unwrapTextNodes(dom) {
      dom.body.querySelectorAll('text-editor').forEach(function (element) {
        element.parentNode.replaceChild(element.firstChild, element);
      });
    }
  }, {
    key: "wrapImages",
    value: function wrapImages(dom) {
      dom.body.querySelectorAll('img').forEach(function (img, item) {
        // var im_im = new Image();
        // im_im.src = img.src;
        // console.log(im_im.width)
        img.setAttribute('editableimgid', item);
      });
      return dom;
    }
  }, {
    key: "unwrapImages",
    value: function unwrapImages(dom) {
      dom.body.querySelectorAll('[editableimgid]').forEach(function (img) {
        img.removeAttribute('editableimgid');
      });
    }
  }]);
}();

},{}],2:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var axios = require('axios');
module.exports = /*#__PURE__*/function () {
  function EditorImage(element, virtualElement) {
    var _this = this;
    _classCallCheck(this, EditorImage);
    this.element = element;
    this.virtualElement = virtualElement;
    this.element.addEventListener('click', function () {
      return _this.onClick();
    });
    this.imgUploader = document.querySelector('#img-upload');
  }
  return _createClass(EditorImage, [{
    key: "onClick",
    value: function onClick() {
      var _this2 = this;
      this.imgUploader.click();
      this.imgUploader.onchange = function () {
        if (_this2.imgUploader.files && _this2.imgUploader.files[0]) {
          window.vue.enableLoader();
          var formData = new FormData();
          formData.append('image', _this2.imgUploader.files[0]);
          axios.post('./api/upload_image.php', formData, {
            'headers': {
              'Content-Type': 'form/multipart'
            }
          }).then(function (res) {
            _this2.virtualElement.src = _this2.element.src = './img/' + res.data.src;
          })["catch"](function () {
            return window.vue.errorNotification('Ошибка загрузки изображения!');
          })["finally"](function () {
            _this2.imgUploader.value = '';
            window.vue.disableLoader();
          });
        }
      };
    }
  }]);
}();

},{"axios":8}],3:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
module.exports = /*#__PURE__*/function () {
  function EditorMeta(virtualDom) {
    _classCallCheck(this, EditorMeta);
    this.title = virtualDom.head.querySelector('title') || virtualDom.head.appendChild(virtualDom.createElement('title'));
    this.keywords = virtualDom.head.querySelector('meta[name="keywords"]');
    if (!this.keywords) {
      this.keywords = virtualDom.head.appendChild(virtualDom.createElement('meta'));
      this.keywords.setAttribute('name', 'keywords');
    }
    this.description = virtualDom.head.querySelector('meta[name="description"]');
    if (!this.description) {
      this.description = virtualDom.head.appendChild(virtualDom.createElement('meta'));
      this.description.setAttribute('name', 'description');
    }
  }
  return _createClass(EditorMeta, [{
    key: "getMeta",
    value: function getMeta() {
      return {
        title: this.title.innerHTML,
        description: this.description.getAttribute('content'),
        keywords: this.keywords.getAttribute('content')
      };
    }
  }, {
    key: "setMeta",
    value: function setMeta(title, description, keywords) {
      this.title.innerHTML = title;
      this.description.setAttribute('content', description);
      this.keywords.setAttribute('content', keywords);
    }
  }]);
}();

},{}],4:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
module.exports = /*#__PURE__*/function () {
  function EditorText(element, virtualElement) {
    var _this = this;
    _classCallCheck(this, EditorText);
    this.element = element;
    this.virtualElement = virtualElement;
    this.element.addEventListener('click', function () {
      return _this.onClick();
    });
    if (this.element.parentNode.nodeName === 'A' || this.element.parentNode.nodeName === 'BUTTON') {
      this.element.addEventListener('contextmenu', function (e) {
        return _this.onContextMenu(e);
      });
    }
    this.element.addEventListener('blur', function () {
      return _this.onBlur();
    });
    this.element.addEventListener('keypress', function (e) {
      return _this.onKeypress(e);
    });
    this.element.addEventListener('input', function () {
      return _this.onTextEdit();
    });
  }
  return _createClass(EditorText, [{
    key: "onClick",
    value: function onClick() {
      this.element.contentEditable = true;
      this.element.focus();
    }
  }, {
    key: "onContextMenu",
    value: function onContextMenu(e) {
      e.preventDefault();
      this.onClick();
    }
  }, {
    key: "onBlur",
    value: function onBlur() {
      this.element.removeAttribute('contenteditable');
    }
  }, {
    key: "onKeypress",
    value: function onKeypress(e) {
      if (e.keyCode === 13) {
        this.element.blur();
      }
    }
  }, {
    key: "onTextEdit",
    value: function onTextEdit() {
      this.virtualElement.innerHTML = this.element.innerHTML;
    }
  }]);
}();

},{}],5:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var axios = require('axios');
var DOMHelper = require('./dom-helper');
var EditorText = require('./editor-text');
var EditorImage = require('./editor-image');
var EditorMeta = require('./editor-meta');
require('./iframe-load');
module.exports = /*#__PURE__*/function () {
  function Editor() {
    _classCallCheck(this, Editor);
    this.iframe = document.querySelector('iframe');
  }
  return _createClass(Editor, [{
    key: "open",
    value: function open(page, callback) {
      var _this = this;
      this.current_page = page;
      axios.get('../' + page + '?rnd=' + Math.random()).then(function (res) {
        return DOMHelper.parseStrToDom(res.data);
      }).then(DOMHelper.wrapTextNodes).then(DOMHelper.wrapImages).then(function (dom) {
        _this.virtualDom = dom;
        return dom;
      }).then(DOMHelper.serializeDomToStr).then(function (html) {
        return axios.post('./api/save_temp_page.php', {
          html: html
        });
      }).then(function () {
        return _this.iframe.load('../fsferggd.html');
      }).then(function (html) {
        return axios.post('./api/delete_temp_page.php');
      }).then(function () {
        return _this.enableEditing();
      }).then(function () {
        return _this.injectStyles();
      }).then(callback);
    }
  }, {
    key: "enableEditing",
    value: function enableEditing() {
      var _this2 = this;
      this.iframe.contentDocument.body.querySelectorAll('text-editor').forEach(function (element) {
        var id = element.getAttribute('nodeId');
        var virtualElement = _this2.virtualDom.body.querySelector("[nodeId=\"".concat(id, "\"]"));
        new EditorText(element, virtualElement);
      });
      this.iframe.contentDocument.body.querySelectorAll('[editableimgid]').forEach(function (element) {
        var id = element.getAttribute('editableimgid');
        var virtualElement = _this2.virtualDom.body.querySelector("[editableimgid=\"".concat(id, "\"]"));
        new EditorImage(element, virtualElement);
      });
      this.metaEditor = new EditorMeta(this.virtualDom);
    }
  }, {
    key: "injectStyles",
    value: function injectStyles() {
      var style = this.iframe.contentDocument.createElement('style');
      style.innerHTML = "\n            text-editor:hover,\n            [editableimgid]:hover {\n                outline: 3px solid orange;\n                outline-offset: 8px;\n            }\n            text-editor:focus,\n            [editableimgid]:hover {\n                outline: 3px solid green;\n                outline-offset: 8px;\n            }\n        ";
      this.iframe.contentDocument.head.appendChild(style);
    }
  }, {
    key: "save",
    value: function save(onSucces, onError) {
      var new_dom = this.virtualDom.cloneNode(this.virtualDom);
      DOMHelper.unwrapTextNodes(new_dom);
      DOMHelper.unwrapImages(new_dom);
      var html = DOMHelper.serializeDomToStr(new_dom);
      axios.post('./api/save_page.php', {
        pageName: this.current_page,
        html: html
      }).then(onSucces)["catch"](onError);
    }
  }]);
}();

},{"./dom-helper":1,"./editor-image":2,"./editor-meta":3,"./editor-text":4,"./iframe-load":6,"axios":8}],6:[function(require,module,exports){
"use strict";

/*eslint-disable */
HTMLIFrameElement.prototype.load = function (url, callback) {
  var iframe = this;
  try {
    iframe.src = url + "?rnd=" + Math.random().toString().substring(2);
  } catch (error) {
    if (!callback) {
      return new Promise(function (resolve, reject) {
        reject(error);
      });
    } else {
      callback(error);
    }
  }
  var maxTime = 60000;
  var interval = 200;
  var timerCount = 0;
  if (!callback) {
    return new Promise(function (resolve, reject) {
      var timer = setInterval(function () {
        if (!iframe) return clearInterval(timer);
        timerCount++;
        if (iframe.contentDocument && iframe.contentDocument.readyState === "complete") {
          clearInterval(timer);
          resolve();
        } else if (timerCount * interval > maxTime) {
          reject(new Error("Iframe load fail!"));
        }
      }, interval);
    });
  } else {
    var timer = setInterval(function () {
      if (!iframe) return clearInterval(timer);
      if (iframe.contentDocument && iframe.contentDocument.readyState === "complete") {
        clearInterval(timer);
        callback();
      } else if (timerCount * interval > maxTime) {
        callback(new Error("Iframe load fail!"));
      }
    }, interval);
  }
};

},{}],7:[function(require,module,exports){
"use strict";

var Editor = require('./editor.js');
var Vue = require('vue');
var Uikit = require('uikit');
var axios = require('axios');
window.editor = new Editor();
window.vue = new Vue({
  el: '#app',
  data: {
    showLoader: true,
    page: 'index.html',
    'pageList': [],
    'backupList': [],
    meta: {
      title: '',
      description: '',
      keywords: ''
    },
    auth: false,
    password: '',
    loginError: false
  },
  methods: {
    onBtnSave: function onBtnSave() {
      var _this = this;
      this.showLoader = true;
      window.editor.save(function () {
        _this.loadBackupList();
        _this.showLoader = false;
        Uikit.notification({
          message: 'Успешное сохраниение.',
          status: 'success'
        });
      }, function () {
        _this.showLoader = false;
        Uikit.notification({
          message: 'Произошла ошибка сохранения.',
          status: 'danger'
        });
      });
    },
    openPage: function openPage(page) {
      var _this2 = this;
      this.page = page;
      this.loadBackupList();
      this.showLoader = true;
      window.editor.open(page, function () {
        _this2.showLoader = false;
        _this2.meta = window.editor.metaEditor.getMeta();
      });
    },
    updatePageList: function updatePageList() {
      var _this3 = this;
      axios.get('./api/page_list.php').then(function (response) {
        _this3.pageList = response.data;
      });
    },
    loadBackupList: function loadBackupList() {
      var _this4 = this;
      axios.get('./backups/backups.json').then(function (response) {
        _this4.backupList = response.data.filter(function (backup) {
          return backup.page === _this4.page;
        });
      });
    },
    restoreBackup: function restoreBackup(backup) {
      var _this5 = this;
      Uikit.modal.confirm('Вы действительно хотите восстановить резервную копию?', {
        labels: {
          ok: 'Восстановить',
          cancel: 'Отмена'
        }
      }).then(function () {
        _this5.showLoader = true;
        return axios.post('./api/restore_backup.php', {
          'file': backup.file,
          'page': _this5.page
        });
      }).then(function () {
        _this5.openPage(_this5.page);
      });
    },
    applyMeta: function applyMeta() {
      window.editor.metaEditor.setMeta(this.meta.title, this.meta.keywords, this.meta.description);
    },
    login: function login() {
      var _this6 = this;
      if (this.password.length > 5) {
        axios.post('./api/login.php', {
          password: this.password
        }).then(function (res) {
          console.log(res.data);
          if (res.data.auth === true) {
            _this6.auth = true;
            _this6.start();
          } else {
            _this6.loginError = true;
          }
        })["catch"](function (error) {
          console.log(error);
        });
      } else {
        this.loginError = true;
      }
    },
    logout: function logout() {
      axios.get('./api/log_out.php').then(function () {
        window.location.replace('/');
      });
    },
    start: function start() {
      this.openPage(this.page);
      this.updatePageList();
      this.loadBackupList();
    },
    enableLoader: function enableLoader() {
      this.showLoader = true;
    },
    disableLoader: function disableLoader() {
      this.showLoader = false;
    },
    errorNotification: function errorNotification(msg) {
      Uikit.notification({
        message: msg,
        status: 'danger'
      });
    }
  },
  created: function created() {
    var _this7 = this;
    axios.get('./api/check_auth.php').then(function (res) {
      // this.auth = res.data.auth;

      if (res.data.auth === true) {
        _this7.auth = true;
        _this7.start();
      }
    })["catch"](function (error) {
      console.log(error);
    });
  }
});

},{"./editor.js":5,"axios":8,"uikit":39,"vue":41}],8:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":10}],9:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(
        timeoutErrorMessage,
        config,
        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../core/buildFullPath":16,"../core/createError":17,"./../core/settle":21,"./../helpers/buildURL":25,"./../helpers/cookies":27,"./../helpers/isURLSameOrigin":30,"./../helpers/parseHeaders":32,"./../utils":35}],10:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":11,"./cancel/CancelToken":12,"./cancel/isCancel":13,"./core/Axios":14,"./core/mergeConfig":20,"./defaults":23,"./helpers/bind":24,"./helpers/isAxiosError":29,"./helpers/spread":33,"./utils":35}],11:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],12:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":11}],13:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],14:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var validator = require('../helpers/validator');

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"../helpers/buildURL":25,"../helpers/validator":34,"./../utils":35,"./InterceptorManager":15,"./dispatchRequest":18,"./mergeConfig":20}],15:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":35}],16:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":26,"../helpers/isAbsoluteURL":28}],17:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":19}],18:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":13,"../defaults":23,"./../utils":35,"./transformData":22}],19:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};

},{}],20:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = [
    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
  ];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys)
    .concat(directMergeKeys);

  var otherKeys = Object
    .keys(config1)
    .concat(Object.keys(config2))
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, mergeDeepProperties);

  return config;
};

},{"../utils":35}],21:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":17}],22:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var defaults = require('./../defaults');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

},{"./../defaults":23,"./../utils":35}],23:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');
var enhanceError = require('./core/enhanceError');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))

},{"./adapters/http":9,"./adapters/xhr":9,"./core/enhanceError":19,"./helpers/normalizeHeaderName":31,"./utils":35,"_process":37}],24:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],25:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":35}],26:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],27:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":35}],28:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],29:[function(require,module,exports){
'use strict';

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return (typeof payload === 'object') && (payload.isAxiosError === true);
};

},{}],30:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":35}],31:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":35}],32:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":35}],33:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],34:[function(require,module,exports){
'use strict';

var pkg = require('./../../package.json');

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');

/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */
function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}

/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new TypeError('options must be an object');
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};

},{"./../../package.json":36}],35:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

},{"./helpers/bind":24}],36:[function(require,module,exports){
module.exports={
  "name": "axios",
  "version": "0.21.4",
  "description": "Promise based HTTP client for the browser and node.js",
  "main": "index.js",
  "scripts": {
    "test": "grunt test",
    "start": "node ./sandbox/server.js",
    "build": "NODE_ENV=production grunt build",
    "preversion": "npm test",
    "version": "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
    "postversion": "git push && git push --tags",
    "examples": "node ./examples/server.js",
    "coveralls": "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    "fix": "eslint --fix lib/**/*.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/axios/axios.git"
  },
  "keywords": [
    "xhr",
    "http",
    "ajax",
    "promise",
    "node"
  ],
  "author": "Matt Zabriskie",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/axios/axios/issues"
  },
  "homepage": "https://axios-http.com",
  "devDependencies": {
    "coveralls": "^3.0.0",
    "es6-promise": "^4.2.4",
    "grunt": "^1.3.0",
    "grunt-banner": "^0.6.0",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-clean": "^1.1.0",
    "grunt-contrib-watch": "^1.0.0",
    "grunt-eslint": "^23.0.0",
    "grunt-karma": "^4.0.0",
    "grunt-mocha-test": "^0.13.3",
    "grunt-ts": "^6.0.0-beta.19",
    "grunt-webpack": "^4.0.2",
    "istanbul-instrumenter-loader": "^1.0.0",
    "jasmine-core": "^2.4.1",
    "karma": "^6.3.2",
    "karma-chrome-launcher": "^3.1.0",
    "karma-firefox-launcher": "^2.1.0",
    "karma-jasmine": "^1.1.1",
    "karma-jasmine-ajax": "^0.1.13",
    "karma-safari-launcher": "^1.0.0",
    "karma-sauce-launcher": "^4.3.6",
    "karma-sinon": "^1.0.5",
    "karma-sourcemap-loader": "^0.3.8",
    "karma-webpack": "^4.0.2",
    "load-grunt-tasks": "^3.5.2",
    "minimist": "^1.2.0",
    "mocha": "^8.2.1",
    "sinon": "^4.5.0",
    "terser-webpack-plugin": "^4.2.3",
    "typescript": "^4.0.5",
    "url-search-params": "^0.10.0",
    "webpack": "^4.44.2",
    "webpack-dev-server": "^3.11.0"
  },
  "browser": {
    "./lib/adapters/http.js": "./lib/adapters/xhr.js"
  },
  "jsdelivr": "dist/axios.min.js",
  "unpkg": "dist/axios.min.js",
  "typings": "./index.d.ts",
  "dependencies": {
    "follow-redirects": "^1.14.0"
  },
  "bundlesize": [
    {
      "path": "./dist/axios.min.js",
      "threshold": "5kB"
    }
  ]
}

},{}],37:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],38:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":37,"timers":38}],39:[function(require,module,exports){
/*! UIkit 3.22.0 | https://www.getuikit.com | (c) 2014 - 2025 YOOtheme | MIT License */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define('uikit', factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.UIkit = factory());
})(this, (function () { 'use strict';

    const { hasOwnProperty, toString } = Object.prototype;
    function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
    }
    const hyphenateRe = /\B([A-Z])/g;
    const hyphenate = memoize((str) => str.replace(hyphenateRe, "-$1").toLowerCase());
    const camelizeRe = /-(\w)/g;
    const camelize = memoize(
      (str) => (str.charAt(0).toLowerCase() + str.slice(1)).replace(camelizeRe, (_, c) => c.toUpperCase())
    );
    const ucfirst = memoize((str) => str.charAt(0).toUpperCase() + str.slice(1));
    function startsWith(str, search) {
      var _a;
      return (_a = str == null ? void 0 : str.startsWith) == null ? void 0 : _a.call(str, search);
    }
    function endsWith(str, search) {
      var _a;
      return (_a = str == null ? void 0 : str.endsWith) == null ? void 0 : _a.call(str, search);
    }
    function includes(obj, search) {
      var _a;
      return (_a = obj == null ? void 0 : obj.includes) == null ? void 0 : _a.call(obj, search);
    }
    function findIndex(array, predicate) {
      var _a;
      return (_a = array == null ? void 0 : array.findIndex) == null ? void 0 : _a.call(array, predicate);
    }
    const { isArray, from: toArray } = Array;
    const { assign } = Object;
    function isFunction(obj) {
      return typeof obj === "function";
    }
    function isObject(obj) {
      return obj !== null && typeof obj === "object";
    }
    function isPlainObject(obj) {
      return toString.call(obj) === "[object Object]";
    }
    function isWindow(obj) {
      return isObject(obj) && obj === obj.window;
    }
    function isDocument(obj) {
      return nodeType(obj) === 9;
    }
    function isNode(obj) {
      return nodeType(obj) >= 1;
    }
    function isElement(obj) {
      return nodeType(obj) === 1;
    }
    function nodeType(obj) {
      return !isWindow(obj) && isObject(obj) && obj.nodeType;
    }
    function isBoolean(value) {
      return typeof value === "boolean";
    }
    function isString(value) {
      return typeof value === "string";
    }
    function isNumber(value) {
      return typeof value === "number";
    }
    function isNumeric(value) {
      return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));
    }
    function isEmpty(obj) {
      return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false);
    }
    function isUndefined(value) {
      return value === void 0;
    }
    function toBoolean(value) {
      return isBoolean(value) ? value : value === "true" || value === "1" || value === "" ? true : value === "false" || value === "0" ? false : value;
    }
    function toNumber(value) {
      const number = Number(value);
      return isNaN(number) ? false : number;
    }
    function toFloat(value) {
      return parseFloat(value) || 0;
    }
    function toNode(element) {
      return element && toNodes(element)[0];
    }
    function toNodes(element) {
      return isNode(element) ? [element] : Array.from(element || []).filter(isNode);
    }
    function toWindow(element) {
      if (isWindow(element)) {
        return element;
      }
      element = toNode(element);
      const document = isDocument(element) ? element : element == null ? void 0 : element.ownerDocument;
      return (document == null ? void 0 : document.defaultView) || window;
    }
    function isEqual(value, other) {
      return value === other || isObject(value) && isObject(other) && Object.keys(value).length === Object.keys(other).length && each(value, (val, key) => val === other[key]);
    }
    function swap(value, a, b) {
      return value.replace(new RegExp(`${a}|${b}`, "g"), (match) => match === a ? b : a);
    }
    function last(array) {
      return array[array.length - 1];
    }
    function each(obj, cb) {
      for (const key in obj) {
        if (false === cb(obj[key], key)) {
          return false;
        }
      }
      return true;
    }
    function sortBy(array, prop) {
      return array.slice().sort(
        ({ [prop]: propA = 0 }, { [prop]: propB = 0 }) => propA > propB ? 1 : propB > propA ? -1 : 0
      );
    }
    function sumBy(array, iteratee) {
      return array.reduce(
        (sum, item) => sum + toFloat(isFunction(iteratee) ? iteratee(item) : item[iteratee]),
        0
      );
    }
    function uniqueBy(array, prop) {
      const seen = /* @__PURE__ */ new Set();
      return array.filter(({ [prop]: check }) => seen.has(check) ? false : seen.add(check));
    }
    function pick(obj, props) {
      return props.reduce((res, prop) => ({ ...res, [prop]: obj[prop] }), {});
    }
    function clamp(number, min = 0, max = 1) {
      return Math.min(Math.max(toNumber(number) || 0, min), max);
    }
    function noop() {
    }
    function intersectRect(...rects) {
      return [
        ["bottom", "top"],
        ["right", "left"]
      ].every(
        ([minProp, maxProp]) => Math.min(...rects.map(({ [minProp]: min }) => min)) - Math.max(...rects.map(({ [maxProp]: max }) => max)) > 0
      );
    }
    function pointInRect(point, rect) {
      return point.x <= rect.right && point.x >= rect.left && point.y <= rect.bottom && point.y >= rect.top;
    }
    function ratio(dimensions, prop, value) {
      const aProp = prop === "width" ? "height" : "width";
      return {
        [aProp]: dimensions[prop] ? Math.round(value * dimensions[aProp] / dimensions[prop]) : dimensions[aProp],
        [prop]: value
      };
    }
    function contain(dimensions, maxDimensions) {
      dimensions = { ...dimensions };
      for (const prop in dimensions) {
        dimensions = dimensions[prop] > maxDimensions[prop] ? ratio(dimensions, prop, maxDimensions[prop]) : dimensions;
      }
      return dimensions;
    }
    function cover$1(dimensions, maxDimensions) {
      dimensions = contain(dimensions, maxDimensions);
      for (const prop in dimensions) {
        dimensions = dimensions[prop] < maxDimensions[prop] ? ratio(dimensions, prop, maxDimensions[prop]) : dimensions;
      }
      return dimensions;
    }
    const Dimensions = { ratio, contain, cover: cover$1 };
    function getIndex(i, elements, current = 0, finite = false) {
      elements = toNodes(elements);
      const { length } = elements;
      if (!length) {
        return -1;
      }
      i = isNumeric(i) ? toNumber(i) : i === "next" ? current + 1 : i === "previous" ? current - 1 : i === "last" ? length - 1 : elements.indexOf(toNode(i));
      if (finite) {
        return clamp(i, 0, length - 1);
      }
      i %= length;
      return i < 0 ? i + length : i;
    }
    function memoize(fn) {
      const cache = /* @__PURE__ */ Object.create(null);
      return (key, ...args) => cache[key] || (cache[key] = fn(key, ...args));
    }

    function addClass(element, ...classes) {
      for (const node of toNodes(element)) {
        const add = toClasses(classes).filter((cls) => !hasClass(node, cls));
        if (add.length) {
          node.classList.add(...add);
        }
      }
    }
    function removeClass(element, ...classes) {
      for (const node of toNodes(element)) {
        const remove = toClasses(classes).filter((cls) => hasClass(node, cls));
        if (remove.length) {
          node.classList.remove(...remove);
        }
      }
    }
    function replaceClass(element, oldClass, newClass) {
      newClass = toClasses(newClass);
      oldClass = toClasses(oldClass).filter((cls) => !includes(newClass, cls));
      removeClass(element, oldClass);
      addClass(element, newClass);
    }
    function hasClass(element, cls) {
      [cls] = toClasses(cls);
      return toNodes(element).some((node) => node.classList.contains(cls));
    }
    function toggleClass(element, cls, force) {
      const classes = toClasses(cls);
      if (!isUndefined(force)) {
        force = !!force;
      }
      for (const node of toNodes(element)) {
        for (const cls2 of classes) {
          node.classList.toggle(cls2, force);
        }
      }
    }
    function toClasses(str) {
      return str ? isArray(str) ? str.map(toClasses).flat() : String(str).split(" ").filter(Boolean) : [];
    }

    function attr(element, name, value) {
      var _a;
      if (isObject(name)) {
        for (const key in name) {
          attr(element, key, name[key]);
        }
        return;
      }
      if (isUndefined(value)) {
        return (_a = toNode(element)) == null ? void 0 : _a.getAttribute(name);
      } else {
        for (const el of toNodes(element)) {
          if (isFunction(value)) {
            value = value.call(el, attr(el, name));
          }
          if (value === null) {
            removeAttr(el, name);
          } else {
            el.setAttribute(name, value);
          }
        }
      }
    }
    function hasAttr(element, name) {
      return toNodes(element).some((element2) => element2.hasAttribute(name));
    }
    function removeAttr(element, name) {
      toNodes(element).forEach((element2) => element2.removeAttribute(name));
    }
    function data(element, attribute) {
      for (const name of [attribute, `data-${attribute}`]) {
        if (hasAttr(element, name)) {
          return attr(element, name);
        }
      }
    }

    const inBrowser = typeof window !== "undefined";
    const isRtl = inBrowser && document.dir === "rtl";
    const hasTouch = inBrowser && "ontouchstart" in window;
    const hasPointerEvents = inBrowser && window.PointerEvent;
    const pointerDown$1 = hasPointerEvents ? "pointerdown" : hasTouch ? "touchstart" : "mousedown";
    const pointerMove$1 = hasPointerEvents ? "pointermove" : hasTouch ? "touchmove" : "mousemove";
    const pointerUp$1 = hasPointerEvents ? "pointerup" : hasTouch ? "touchend" : "mouseup";
    const pointerEnter = hasPointerEvents ? "pointerenter" : hasTouch ? "" : "mouseenter";
    const pointerLeave = hasPointerEvents ? "pointerleave" : hasTouch ? "" : "mouseleave";
    const pointerCancel = hasPointerEvents ? "pointercancel" : "touchcancel";

    const voidElements = {
      area: true,
      base: true,
      br: true,
      col: true,
      embed: true,
      hr: true,
      img: true,
      input: true,
      keygen: true,
      link: true,
      meta: true,
      param: true,
      source: true,
      track: true,
      wbr: true
    };
    function isVoidElement(element) {
      return toNodes(element).some((element2) => voidElements[element2.tagName.toLowerCase()]);
    }
    const isVisibleFn = inBrowser && Element.prototype.checkVisibility || function() {
      return this.offsetWidth || this.offsetHeight || this.getClientRects().length;
    };
    function isVisible(element) {
      return toNodes(element).some((element2) => isVisibleFn.call(element2));
    }
    const selInput = "input,select,textarea,button";
    function isInput(element) {
      return toNodes(element).some((element2) => matches(element2, selInput));
    }
    const selFocusable = `${selInput},a[href],[tabindex]`;
    function isFocusable(element) {
      return matches(element, selFocusable);
    }
    function parent(element) {
      var _a;
      return (_a = toNode(element)) == null ? void 0 : _a.parentElement;
    }
    function filter$1(element, selector) {
      return toNodes(element).filter((element2) => matches(element2, selector));
    }
    function matches(element, selector) {
      return toNodes(element).some((element2) => element2.matches(selector));
    }
    function parents(element, selector) {
      const elements = [];
      while (element = parent(element)) {
        if (!selector || matches(element, selector)) {
          elements.push(element);
        }
      }
      return elements;
    }
    function children(element, selector) {
      element = toNode(element);
      const children2 = element ? toArray(element.children) : [];
      return selector ? filter$1(children2, selector) : children2;
    }
    function index(element, ref) {
      return ref ? toNodes(element).indexOf(toNode(ref)) : children(parent(element)).indexOf(element);
    }
    function isSameSiteAnchor(el) {
      el = toNode(el);
      return el && ["origin", "pathname", "search"].every((part) => el[part] === location[part]);
    }
    function getTargetedElement(el) {
      if (isSameSiteAnchor(el)) {
        const { hash, ownerDocument } = toNode(el);
        const id = decodeURIComponent(hash).slice(1);
        return id ? ownerDocument.getElementById(id) || ownerDocument.getElementsByName(id)[0] : ownerDocument.documentElement;
      }
    }

    function query(selector, context) {
      return find(selector, getContext(selector, context));
    }
    function queryAll(selector, context) {
      return findAll(selector, getContext(selector, context));
    }
    function find(selector, context) {
      return toNode(_query(selector, toNode(context), "querySelector"));
    }
    function findAll(selector, context) {
      return toNodes(_query(selector, toNode(context), "querySelectorAll"));
    }
    function getContext(selector, context = document) {
      return isDocument(context) || parseSelector(selector).isContextSelector ? context : context.ownerDocument;
    }
    const addStarRe = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g;
    const splitSelectorRe = /(\([^)]*\)|[^,])+/g;
    const parseSelector = memoize((selector) => {
      let isContextSelector = false;
      if (!selector || !isString(selector)) {
        return {};
      }
      const selectors = [];
      for (let sel of selector.match(splitSelectorRe)) {
        sel = sel.trim().replace(addStarRe, "$1 *");
        isContextSelector || (isContextSelector = ["!", "+", "~", "-", ">"].includes(sel[0]));
        selectors.push(sel);
      }
      return {
        selector: selectors.join(","),
        selectors,
        isContextSelector
      };
    });
    const positionRe = /(\([^)]*\)|\S)*/;
    const parsePositionSelector = memoize((selector) => {
      selector = selector.slice(1).trim();
      const [position] = selector.match(positionRe);
      return [position, selector.slice(position.length + 1)];
    });
    function _query(selector, context = document, queryFn) {
      const parsed = parseSelector(selector);
      if (!parsed.isContextSelector) {
        return parsed.selector ? _doQuery(context, queryFn, parsed.selector) : selector;
      }
      selector = "";
      const isSingle = parsed.selectors.length === 1;
      for (let sel of parsed.selectors) {
        let positionSel;
        let ctx = context;
        if (sel[0] === "!") {
          [positionSel, sel] = parsePositionSelector(sel);
          ctx = context.parentElement.closest(positionSel);
          if (!sel && isSingle) {
            return ctx;
          }
        }
        if (ctx && sel[0] === "-") {
          [positionSel, sel] = parsePositionSelector(sel);
          ctx = ctx.previousElementSibling;
          ctx = matches(ctx, positionSel) ? ctx : null;
          if (!sel && isSingle) {
            return ctx;
          }
        }
        if (!ctx) {
          continue;
        }
        if (isSingle) {
          if (sel[0] === "~" || sel[0] === "+") {
            sel = `:scope > :nth-child(${index(ctx) + 1}) ${sel}`;
            ctx = ctx.parentElement;
          } else if (sel[0] === ">") {
            sel = `:scope ${sel}`;
          }
          return _doQuery(ctx, queryFn, sel);
        }
        selector += `${selector ? "," : ""}${domPath(ctx)} ${sel}`;
      }
      if (!isDocument(context)) {
        context = context.ownerDocument;
      }
      return _doQuery(context, queryFn, selector);
    }
    function _doQuery(context, queryFn, selector) {
      try {
        return context[queryFn](selector);
      } catch (e) {
        return null;
      }
    }
    function domPath(element) {
      const names = [];
      while (element.parentNode) {
        const id = attr(element, "id");
        if (id) {
          names.unshift(`#${escape(id)}`);
          break;
        } else {
          let { tagName } = element;
          if (tagName !== "HTML") {
            tagName += `:nth-child(${index(element) + 1})`;
          }
          names.unshift(tagName);
          element = element.parentNode;
        }
      }
      return names.join(" > ");
    }
    function escape(css) {
      return isString(css) ? CSS.escape(css) : "";
    }

    function on(...args) {
      let [targets, types, selector, listener, useCapture = false] = getArgs(args);
      if (listener.length > 1) {
        listener = detail(listener);
      }
      if (useCapture == null ? void 0 : useCapture.self) {
        listener = selfFilter(listener);
      }
      if (selector) {
        listener = delegate(selector, listener);
      }
      for (const type of types) {
        for (const target of targets) {
          target.addEventListener(type, listener, useCapture);
        }
      }
      return () => off(targets, types, listener, useCapture);
    }
    function off(...args) {
      let [targets, types, , listener, useCapture = false] = getArgs(args);
      for (const type of types) {
        for (const target of targets) {
          target.removeEventListener(type, listener, useCapture);
        }
      }
    }
    function once(...args) {
      const [element, types, selector, listener, useCapture = false, condition] = getArgs(args);
      const off2 = on(
        element,
        types,
        selector,
        (e) => {
          const result = !condition || condition(e);
          if (result) {
            off2();
            listener(e, result);
          }
        },
        useCapture
      );
      return off2;
    }
    function trigger(targets, event, detail2) {
      return toEventTargets(targets).every(
        (target) => target.dispatchEvent(createEvent(event, true, true, detail2))
      );
    }
    function createEvent(e, bubbles = true, cancelable = false, detail2) {
      if (isString(e)) {
        e = new CustomEvent(e, { bubbles, cancelable, detail: detail2 });
      }
      return e;
    }
    function getArgs(args) {
      args[0] = toEventTargets(args[0]);
      if (isString(args[1])) {
        args[1] = args[1].split(" ");
      }
      if (isFunction(args[2])) {
        args.splice(2, 0, false);
      }
      return args;
    }
    function delegate(selector, listener) {
      return (e) => {
        const current = selector[0] === ">" ? findAll(selector, e.currentTarget).reverse().find((element) => element.contains(e.target)) : e.target.closest(selector);
        if (current) {
          e.current = current;
          listener.call(this, e);
          delete e.current;
        }
      };
    }
    function detail(listener) {
      return (e) => isArray(e.detail) ? listener(e, ...e.detail) : listener(e);
    }
    function selfFilter(listener) {
      return function(e) {
        if (e.target === e.currentTarget || e.target === e.current) {
          return listener.call(null, e);
        }
      };
    }
    function isEventTarget(target) {
      return target && "addEventListener" in target;
    }
    function toEventTarget(target) {
      return isEventTarget(target) ? target : toNode(target);
    }
    function toEventTargets(target) {
      return isArray(target) ? target.map(toEventTarget).filter(Boolean) : isString(target) ? findAll(target) : isEventTarget(target) ? [target] : toNodes(target);
    }
    function isTouch(e) {
      return e.pointerType === "touch" || !!e.touches;
    }
    function getEventPos(e) {
      var _a, _b;
      const { clientX: x, clientY: y } = ((_a = e.touches) == null ? void 0 : _a[0]) || ((_b = e.changedTouches) == null ? void 0 : _b[0]) || e;
      return { x, y };
    }

    const cssNumber = {
      "animation-iteration-count": true,
      "column-count": true,
      "fill-opacity": true,
      "flex-grow": true,
      "flex-shrink": true,
      "font-weight": true,
      "line-height": true,
      opacity: true,
      order: true,
      orphans: true,
      "stroke-dasharray": true,
      "stroke-dashoffset": true,
      widows: true,
      "z-index": true,
      zoom: true
    };
    function css(element, property, value, priority) {
      const elements = toNodes(element);
      for (const element2 of elements) {
        if (isString(property)) {
          property = propName(property);
          if (isUndefined(value)) {
            return getComputedStyle(element2).getPropertyValue(property);
          } else {
            element2.style.setProperty(
              property,
              isNumeric(value) && !cssNumber[property] ? `${value}px` : value || isNumber(value) ? value : "",
              priority
            );
          }
        } else if (isArray(property)) {
          const props = {};
          for (const prop of property) {
            props[prop] = css(element2, prop);
          }
          return props;
        } else if (isObject(property)) {
          for (const prop in property) {
            css(element2, prop, property[prop], value);
          }
        }
      }
      return elements[0];
    }
    const propName = memoize((name) => {
      if (startsWith(name, "--")) {
        return name;
      }
      name = hyphenate(name);
      const { style } = document.documentElement;
      if (name in style) {
        return name;
      }
      for (const prefix of ["webkit", "moz"]) {
        const prefixedName = `-${prefix}-${name}`;
        if (prefixedName in style) {
          return prefixedName;
        }
      }
    });

    const clsTransition = "uk-transition";
    const transitionEnd = "transitionend";
    const transitionCanceled = "transitioncanceled";
    function transition$1(element, props, duration = 400, timing = "linear") {
      duration = Math.round(duration);
      return Promise.all(
        toNodes(element).map(
          (element2) => new Promise((resolve, reject) => {
            for (const name in props) {
              css(element2, name);
            }
            const timer = setTimeout(() => trigger(element2, transitionEnd), duration);
            once(
              element2,
              [transitionEnd, transitionCanceled],
              ({ type }) => {
                clearTimeout(timer);
                removeClass(element2, clsTransition);
                css(element2, {
                  transitionProperty: "",
                  transitionDuration: "",
                  transitionTimingFunction: ""
                });
                type === transitionCanceled ? reject() : resolve(element2);
              },
              { self: true }
            );
            addClass(element2, clsTransition);
            css(element2, {
              transitionProperty: Object.keys(props).map(propName).join(","),
              transitionDuration: `${duration}ms`,
              transitionTimingFunction: timing,
              ...props
            });
          })
        )
      );
    }
    const Transition = {
      start: transition$1,
      async stop(element) {
        trigger(element, transitionEnd);
        await Promise.resolve();
      },
      async cancel(element) {
        trigger(element, transitionCanceled);
        await Promise.resolve();
      },
      inProgress(element) {
        return hasClass(element, clsTransition);
      }
    };
    const clsAnimation = "uk-animation";
    const animationEnd = "animationend";
    const animationCanceled = "animationcanceled";
    function animate$2(element, animation, duration = 200, origin, out) {
      return Promise.all(
        toNodes(element).map(
          (element2) => new Promise((resolve, reject) => {
            if (hasClass(element2, clsAnimation)) {
              trigger(element2, animationCanceled);
            }
            const classes = [
              animation,
              clsAnimation,
              `${clsAnimation}-${out ? "leave" : "enter"}`,
              origin && `uk-transform-origin-${origin}`,
              out && `${clsAnimation}-reverse`
            ];
            const timer = setTimeout(() => trigger(element2, animationEnd), duration);
            once(
              element2,
              [animationEnd, animationCanceled],
              ({ type }) => {
                clearTimeout(timer);
                type === animationCanceled ? reject() : resolve(element2);
                css(element2, "animationDuration", "");
                removeClass(element2, classes);
              },
              { self: true }
            );
            css(element2, "animationDuration", `${duration}ms`);
            addClass(element2, classes);
          })
        )
      );
    }
    const Animation = {
      in: animate$2,
      out(element, animation, duration, origin) {
        return animate$2(element, animation, duration, origin, true);
      },
      inProgress(element) {
        return hasClass(element, clsAnimation);
      },
      cancel(element) {
        trigger(element, animationCanceled);
      }
    };

    function ready(fn) {
      if (document.readyState !== "loading") {
        fn();
        return;
      }
      once(document, "DOMContentLoaded", fn);
    }
    function isTag(element, ...tagNames) {
      return tagNames.some((tagName) => {
        var _a;
        return ((_a = element == null ? void 0 : element.tagName) == null ? void 0 : _a.toLowerCase()) === tagName.toLowerCase();
      });
    }
    function empty(element) {
      element = $(element);
      if (element) {
        element.innerHTML = "";
      }
      return element;
    }
    function html(parent2, html2) {
      return isUndefined(html2) ? $(parent2).innerHTML : append(empty(parent2), html2);
    }
    const prepend = applyFn("prepend");
    const append = applyFn("append");
    const before = applyFn("before");
    const after = applyFn("after");
    function applyFn(fn) {
      return function(ref, element) {
        var _a;
        const nodes = toNodes(isString(element) ? fragment(element) : element);
        (_a = $(ref)) == null ? void 0 : _a[fn](...nodes);
        return unwrapSingle(nodes);
      };
    }
    function remove$1(element) {
      toNodes(element).forEach((element2) => element2.remove());
    }
    function wrapAll(element, structure) {
      structure = toNode(before(element, structure));
      while (structure.firstElementChild) {
        structure = structure.firstElementChild;
      }
      append(structure, element);
      return structure;
    }
    function wrapInner(element, structure) {
      return toNodes(
        toNodes(element).map(
          (element2) => element2.hasChildNodes() ? wrapAll(toArray(element2.childNodes), structure) : append(element2, structure)
        )
      );
    }
    function unwrap(element) {
      toNodes(element).map(parent).filter((value, index, self) => self.indexOf(value) === index).forEach((parent2) => parent2.replaceWith(...parent2.childNodes));
    }
    const singleTagRe = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;
    function fragment(html2) {
      const matches = singleTagRe.exec(html2);
      if (matches) {
        return document.createElement(matches[1]);
      }
      const container = document.createElement("template");
      container.innerHTML = html2.trim();
      return unwrapSingle(container.content.childNodes);
    }
    function unwrapSingle(nodes) {
      return nodes.length > 1 ? nodes : nodes[0];
    }
    function apply(node, fn) {
      if (!isElement(node)) {
        return;
      }
      fn(node);
      node = node.firstElementChild;
      while (node) {
        apply(node, fn);
        node = node.nextElementSibling;
      }
    }
    function $(selector, context) {
      return isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);
    }
    function $$(selector, context) {
      return isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);
    }
    function isHtml(str) {
      return isString(str) && startsWith(str.trim(), "<");
    }

    const dirs$1 = {
      width: ["left", "right"],
      height: ["top", "bottom"]
    };
    function dimensions$1(element) {
      const rect = isElement(element) ? toNode(element).getBoundingClientRect() : { height: height(element), width: width(element), top: 0, left: 0 };
      return {
        height: rect.height,
        width: rect.width,
        top: rect.top,
        left: rect.left,
        bottom: rect.top + rect.height,
        right: rect.left + rect.width
      };
    }
    function offset(element, coordinates) {
      if (coordinates) {
        css(element, { left: 0, top: 0 });
      }
      const currentOffset = dimensions$1(element);
      if (element) {
        const { scrollY, scrollX } = toWindow(element);
        const offsetBy = { height: scrollY, width: scrollX };
        for (const dir in dirs$1) {
          for (const prop of dirs$1[dir]) {
            currentOffset[prop] += offsetBy[dir];
          }
        }
      }
      if (!coordinates) {
        return currentOffset;
      }
      for (const prop of ["left", "top"]) {
        css(element, prop, coordinates[prop] - currentOffset[prop]);
      }
    }
    function position(element) {
      let { top, left } = offset(element);
      const {
        ownerDocument: { body, documentElement },
        offsetParent
      } = toNode(element);
      let parent = offsetParent || documentElement;
      while (parent && (parent === body || parent === documentElement) && css(parent, "position") === "static") {
        parent = parent.parentNode;
      }
      if (isElement(parent)) {
        const parentOffset = offset(parent);
        top -= parentOffset.top + toFloat(css(parent, "borderTopWidth"));
        left -= parentOffset.left + toFloat(css(parent, "borderLeftWidth"));
      }
      return {
        top: top - toFloat(css(element, "marginTop")),
        left: left - toFloat(css(element, "marginLeft"))
      };
    }
    function offsetPosition(element) {
      element = toNode(element);
      const offset2 = [element.offsetTop, element.offsetLeft];
      while (element = element.offsetParent) {
        offset2[0] += element.offsetTop + toFloat(css(element, "borderTopWidth"));
        offset2[1] += element.offsetLeft + toFloat(css(element, "borderLeftWidth"));
        if (css(element, "position") === "fixed") {
          const win = toWindow(element);
          offset2[0] += win.scrollY;
          offset2[1] += win.scrollX;
          return offset2;
        }
      }
      return offset2;
    }
    const height = dimension("height");
    const width = dimension("width");
    function dimension(prop) {
      const propName = ucfirst(prop);
      return (element, value) => {
        if (isUndefined(value)) {
          if (isWindow(element)) {
            return element[`inner${propName}`];
          }
          if (isDocument(element)) {
            const doc = element.documentElement;
            return Math.max(doc[`offset${propName}`], doc[`scroll${propName}`]);
          }
          element = toNode(element);
          value = css(element, prop);
          value = value === "auto" ? element[`offset${propName}`] : toFloat(value) || 0;
          return value - boxModelAdjust(element, prop);
        } else {
          return css(
            element,
            prop,
            !value && value !== 0 ? "" : +value + boxModelAdjust(element, prop) + "px"
          );
        }
      };
    }
    function boxModelAdjust(element, prop, sizing = "border-box") {
      return css(element, "boxSizing") === sizing ? sumBy(
        dirs$1[prop],
        (prop2) => toFloat(css(element, `padding-${prop2}`)) + toFloat(css(element, `border-${prop2}-width`))
      ) : 0;
    }
    function flipPosition(pos) {
      for (const dir in dirs$1) {
        for (const i in dirs$1[dir]) {
          if (dirs$1[dir][i] === pos) {
            return dirs$1[dir][1 - i];
          }
        }
      }
      return pos;
    }
    function toPx(value, property = "width", element = window, offsetDim = false) {
      if (!isString(value)) {
        return toFloat(value);
      }
      return sumBy(parseCalc(value), (value2) => {
        const unit = parseUnit(value2);
        return unit ? percent(
          unit === "vh" ? getViewportHeight() : unit === "vw" ? width(toWindow(element)) : offsetDim ? element[`offset${ucfirst(property)}`] : dimensions$1(element)[property],
          value2
        ) : value2;
      });
    }
    const calcRe = /-?\d+(?:\.\d+)?(?:v[wh]|%|px)?/g;
    const parseCalc = memoize((calc) => calc.toString().replace(/\s/g, "").match(calcRe) || []);
    const unitRe$1 = /(?:v[hw]|%)$/;
    const parseUnit = memoize((str) => (str.match(unitRe$1) || [])[0]);
    function percent(base, value) {
      return base * toFloat(value) / 100;
    }
    let vh;
    let vhEl;
    function getViewportHeight() {
      if (vh) {
        return vh;
      }
      if (!vhEl) {
        vhEl = $("<div>");
        css(vhEl, {
          height: "100vh",
          position: "fixed"
        });
        on(window, "resize", () => vh = null);
      }
      append(document.body, vhEl);
      vh = vhEl.clientHeight;
      remove$1(vhEl);
      return vh;
    }

    const fastdom = { read, write, clear, flush };
    const reads = [];
    const writes = [];
    function read(task) {
      reads.push(task);
      scheduleFlush();
      return task;
    }
    function write(task) {
      writes.push(task);
      scheduleFlush();
      return task;
    }
    function clear(task) {
      remove(reads, task);
      remove(writes, task);
    }
    let scheduled = false;
    function flush() {
      runTasks(reads);
      runTasks(writes.splice(0));
      scheduled = false;
      if (reads.length || writes.length) {
        scheduleFlush();
      }
    }
    function scheduleFlush() {
      if (!scheduled) {
        scheduled = true;
        queueMicrotask(flush);
      }
    }
    function runTasks(tasks) {
      let task;
      while (task = tasks.shift()) {
        try {
          task();
        } catch (e) {
          console.error(e);
        }
      }
    }
    function remove(array, item) {
      const index = array.indexOf(item);
      return ~index && array.splice(index, 1);
    }

    class MouseTracker {
      init() {
        this.positions = [];
        let position;
        this.unbind = on(document, "mousemove", (e) => position = getEventPos(e));
        this.interval = setInterval(() => {
          if (!position) {
            return;
          }
          this.positions.push(position);
          if (this.positions.length > 5) {
            this.positions.shift();
          }
        }, 50);
      }
      cancel() {
        var _a;
        (_a = this.unbind) == null ? void 0 : _a.call(this);
        clearInterval(this.interval);
      }
      movesTo(target) {
        if (!this.positions || this.positions.length < 2) {
          return false;
        }
        const p = dimensions$1(target);
        const { left, right, top, bottom } = p;
        const [prevPosition] = this.positions;
        const position = last(this.positions);
        const path = [prevPosition, position];
        if (pointInRect(position, p)) {
          return false;
        }
        const diagonals = [
          [
            { x: left, y: top },
            { x: right, y: bottom }
          ],
          [
            { x: left, y: bottom },
            { x: right, y: top }
          ]
        ];
        return diagonals.some((diagonal) => {
          const intersection = intersect(path, diagonal);
          return intersection && pointInRect(intersection, p);
        });
      }
    }
    function intersect([{ x: x1, y: y1 }, { x: x2, y: y2 }], [{ x: x3, y: y3 }, { x: x4, y: y4 }]) {
      const denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
      if (denominator === 0) {
        return false;
      }
      const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
      if (ua < 0) {
        return false;
      }
      return { x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1) };
    }

    function observeIntersection(targets, cb, options = {}, { intersecting = true } = {}) {
      const observer = new IntersectionObserver(
        intersecting ? (entries, observer2) => {
          if (entries.some((entry) => entry.isIntersecting)) {
            cb(entries, observer2);
          }
        } : cb,
        options
      );
      for (const el of toNodes(targets)) {
        observer.observe(el);
      }
      return observer;
    }
    const hasResizeObserver = inBrowser && window.ResizeObserver;
    function observeResize(targets, cb, options = { box: "border-box" }) {
      if (hasResizeObserver) {
        return observe$1(ResizeObserver, targets, cb, options);
      }
      const off = [on(window, "load resize", cb), on(document, "loadedmetadata load", cb, true)];
      return { disconnect: () => off.map((cb2) => cb2()) };
    }
    function observeViewportResize(cb) {
      return { disconnect: on([window, window.visualViewport], "resize", cb) };
    }
    function observeMutation(targets, cb, options) {
      return observe$1(MutationObserver, targets, cb, options);
    }
    function observe$1(Observer, targets, cb, options) {
      const observer = new Observer(cb);
      for (const el of toNodes(targets)) {
        observer.observe(el, options);
      }
      return observer;
    }

    function play(el) {
      if (isIFrame(el)) {
        call(el, { func: "playVideo", method: "play" });
      }
      if (isHTML5(el)) {
        el.play().catch(noop);
      }
    }
    function pause(el) {
      if (isIFrame(el)) {
        call(el, { func: "pauseVideo", method: "pause" });
      }
      if (isHTML5(el)) {
        el.pause();
      }
    }
    function mute(el) {
      if (isIFrame(el)) {
        call(el, { func: "mute", method: "setVolume", value: 0 });
      }
      if (isHTML5(el)) {
        el.muted = true;
      }
    }
    function isHTML5(el) {
      return isTag(el, "video");
    }
    function isIFrame(el) {
      return isTag(el, "iframe") && (isYoutube(el) || isVimeo(el));
    }
    function isYoutube(el) {
      return !!el.src.match(
        /\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/
      );
    }
    function isVimeo(el) {
      return !!el.src.match(/vimeo\.com\/video\/.*/);
    }
    async function call(el, cmd) {
      await enableApi(el);
      post(el, cmd);
    }
    function post(el, cmd) {
      el.contentWindow.postMessage(JSON.stringify({ event: "command", ...cmd }), "*");
    }
    const stateKey = "_ukPlayer";
    let counter = 0;
    function enableApi(el) {
      if (el[stateKey]) {
        return el[stateKey];
      }
      const youtube = isYoutube(el);
      const vimeo = isVimeo(el);
      const id = ++counter;
      let poller;
      return el[stateKey] = new Promise((resolve) => {
        youtube && once(el, "load", () => {
          const listener = () => post(el, { event: "listening", id });
          poller = setInterval(listener, 100);
          listener();
        });
        once(window, "message", resolve, false, ({ data }) => {
          try {
            data = JSON.parse(data);
            return youtube && (data == null ? void 0 : data.id) === id && data.event === "onReady" || vimeo && Number(data == null ? void 0 : data.player_id) === id;
          } catch (e) {
          }
        });
        el.src = `${el.src}${includes(el.src, "?") ? "&" : "?"}${youtube ? "enablejsapi=1" : `api=1&player_id=${id}`}`;
      }).then(() => clearInterval(poller));
    }

    function isInView(element, offsetTop = 0, offsetLeft = 0) {
      if (!isVisible(element)) {
        return false;
      }
      return intersectRect(
        ...overflowParents(element).map((parent2) => {
          const { top, left, bottom, right } = offsetViewport(parent2);
          return {
            top: top - offsetTop,
            left: left - offsetLeft,
            bottom: bottom + offsetTop,
            right: right + offsetLeft
          };
        }).concat(offset(element))
      );
    }
    function scrollIntoView(element, { offset: offsetBy = 0 } = {}) {
      const parents2 = isVisible(element) ? scrollParents(element, false, ["hidden"]) : [];
      return parents2.reduce(
        (fn, scrollElement, i) => {
          const { scrollTop, scrollHeight, offsetHeight } = scrollElement;
          const viewport = offsetViewport(scrollElement);
          const maxScroll = scrollHeight - viewport.height;
          const { height: elHeight, top: elTop } = parents2[i - 1] ? offsetViewport(parents2[i - 1]) : offset(element);
          let top = Math.ceil(elTop - viewport.top - offsetBy + scrollTop);
          if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {
            top += offsetBy;
          } else {
            offsetBy = 0;
          }
          if (top > maxScroll) {
            offsetBy -= top - maxScroll;
            top = maxScroll;
          } else if (top < 0) {
            offsetBy -= top;
            top = 0;
          }
          return () => scrollTo(scrollElement, top - scrollTop, element, maxScroll).then(fn);
        },
        () => Promise.resolve()
      )();
      function scrollTo(element2, top, targetEl, maxScroll) {
        return new Promise((resolve) => {
          const scroll = element2.scrollTop;
          const duration = getDuration(Math.abs(top));
          const start = Date.now();
          const isScrollingElement = scrollingElement(element2) === element2;
          const targetTop = offset(targetEl).top + (isScrollingElement ? 0 : scroll);
          let prev = 0;
          let frames = 15;
          (function step() {
            const percent = ease(clamp((Date.now() - start) / duration));
            let diff = 0;
            if (parents2[0] === element2 && scroll + top < maxScroll) {
              diff = offset(targetEl).top + (isScrollingElement ? 0 : element2.scrollTop) - targetTop - dimensions$1(getCoveringElement(targetEl)).height;
            }
            if (css(element2, "scrollBehavior") !== "auto") {
              css(element2, "scrollBehavior", "auto");
            }
            element2.scrollTop = scroll + (top + diff) * percent;
            css(element2, "scrollBehavior", "");
            if (percent === 1 && (prev === diff || !frames--)) {
              resolve();
            } else {
              prev = diff;
              requestAnimationFrame(step);
            }
          })();
        });
      }
      function getDuration(dist) {
        return 40 * Math.pow(dist, 0.375);
      }
      function ease(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
      }
    }
    function scrolledOver(element, startOffset = 0, endOffset = 0) {
      if (!isVisible(element)) {
        return 0;
      }
      const scrollElement = scrollParent(element, true);
      const { scrollHeight, scrollTop } = scrollElement;
      const { height: viewportHeight } = offsetViewport(scrollElement);
      const maxScroll = scrollHeight - viewportHeight;
      const elementOffsetTop = offsetPosition(element)[0] - offsetPosition(scrollElement)[0];
      const start = Math.max(0, elementOffsetTop - viewportHeight + startOffset);
      const end = Math.min(maxScroll, elementOffsetTop + element.offsetHeight - endOffset);
      return start < end ? clamp((scrollTop - start) / (end - start)) : 1;
    }
    function scrollParents(element, scrollable = false, props = []) {
      const scrollEl = scrollingElement(element);
      let ancestors = parents(element).reverse();
      ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);
      const fixedIndex = findIndex(ancestors, (el) => css(el, "position") === "fixed");
      if (~fixedIndex) {
        ancestors = ancestors.slice(fixedIndex);
      }
      return [scrollEl].concat(
        ancestors.filter(
          (parent2) => css(parent2, "overflow").split(" ").some((prop) => includes(["auto", "scroll", ...props], prop)) && (!scrollable || parent2.scrollHeight > offsetViewport(parent2).height)
        )
      ).reverse();
    }
    function scrollParent(...args) {
      return scrollParents(...args)[0];
    }
    function overflowParents(element) {
      return scrollParents(element, false, ["hidden", "clip"]);
    }
    function offsetViewport(scrollElement) {
      const window = toWindow(scrollElement);
      const documentScrollingElement = scrollingElement(scrollElement);
      const useWindow = !isNode(scrollElement) || scrollElement.contains(documentScrollingElement);
      if (useWindow && window.visualViewport) {
        let { height, width, scale, pageTop: top, pageLeft: left } = window.visualViewport;
        height = Math.round(height * scale);
        width = Math.round(width * scale);
        return { height, width, top, left, bottom: top + height, right: left + width };
      }
      let rect = offset(useWindow ? window : scrollElement);
      if (css(scrollElement, "display") === "inline") {
        return rect;
      }
      const { body, documentElement } = window.document;
      const viewportElement = useWindow ? documentScrollingElement === documentElement || // In quirks mode the scrolling element is body, even though the viewport is html
      documentScrollingElement.clientHeight < body.clientHeight ? documentScrollingElement : body : scrollElement;
      for (let [prop, dir, start, end] of [
        ["width", "x", "left", "right"],
        ["height", "y", "top", "bottom"]
      ]) {
        const subpixel = rect[prop] % 1;
        rect[start] += toFloat(css(viewportElement, `border-${start}-width`));
        rect[prop] = rect[dir] = viewportElement[`client${ucfirst(prop)}`] - (subpixel ? subpixel < 0.5 ? -subpixel : 1 - subpixel : 0);
        rect[end] = rect[prop] + rect[start];
      }
      return rect;
    }
    function getCoveringElement(target) {
      const { left, width, top } = dimensions$1(target);
      for (const position of top ? [0, top] : [0]) {
        let coverEl;
        for (const el of toWindow(target).document.elementsFromPoint(left + width / 2, position)) {
          if (!el.contains(target) && // If e.g. Offcanvas is not yet closed
          !hasClass(el, "uk-togglable-leave") && (hasPosition(el, "fixed") && zIndex(
            parents(target).reverse().find(
              (parent2) => !parent2.contains(el) && !hasPosition(parent2, "static")
            )
          ) < zIndex(el) || hasPosition(el, "sticky") && parent(el).contains(target)) && (!coverEl || dimensions$1(coverEl).height < dimensions$1(el).height)) {
            coverEl = el;
          }
        }
        if (coverEl) {
          return coverEl;
        }
      }
    }
    function zIndex(element) {
      return toFloat(css(element, "zIndex"));
    }
    function hasPosition(element, position) {
      return css(element, "position") === position;
    }
    function scrollingElement(element) {
      return toWindow(element).document.scrollingElement;
    }

    const dirs = [
      ["width", "x", "left", "right"],
      ["height", "y", "top", "bottom"]
    ];
    function positionAt(element, target, options) {
      options = {
        attach: {
          element: ["left", "top"],
          target: ["left", "top"],
          ...options.attach
        },
        offset: [0, 0],
        placement: [],
        ...options
      };
      if (!isArray(target)) {
        target = [target, target];
      }
      offset(element, getPosition(element, target, options));
    }
    function getPosition(element, target, options) {
      const position = attachTo(element, target, options);
      const { boundary, viewportOffset = 0, placement } = options;
      let offsetPosition = position;
      for (const [i, [prop, , start, end]] of Object.entries(dirs)) {
        const viewport = getViewport$2(element, target[i], viewportOffset, boundary, i);
        if (isWithin(position, viewport, i)) {
          continue;
        }
        let offsetBy = 0;
        if (placement[i] === "flip") {
          const attach = options.attach.target[i];
          if (attach === end && position[end] <= viewport[end] || attach === start && position[start] >= viewport[start]) {
            continue;
          }
          offsetBy = flip(element, target, options, i)[start] - position[start];
          const scrollArea = getScrollArea(element, target[i], viewportOffset, i);
          if (!isWithin(applyOffset(position, offsetBy, i), scrollArea, i)) {
            if (isWithin(position, scrollArea, i)) {
              continue;
            }
            if (options.recursion) {
              return false;
            }
            const newPos = flipAxis(element, target, options);
            if (newPos && isWithin(newPos, scrollArea, 1 - i)) {
              return newPos;
            }
            continue;
          }
        } else if (placement[i] === "shift") {
          const targetDim = offset(target[i]);
          const { offset: elOffset } = options;
          offsetBy = clamp(
            clamp(position[start], viewport[start], viewport[end] - position[prop]),
            targetDim[start] - position[prop] + elOffset[i],
            targetDim[end] - elOffset[i]
          ) - position[start];
        }
        offsetPosition = applyOffset(offsetPosition, offsetBy, i);
      }
      return offsetPosition;
    }
    function attachTo(element, target, options) {
      let { attach, offset: offsetBy } = {
        attach: {
          element: ["left", "top"],
          target: ["left", "top"],
          ...options.attach
        },
        offset: [0, 0],
        ...options
      };
      let elOffset = offset(element);
      for (const [i, [prop, , start, end]] of Object.entries(dirs)) {
        const targetOffset = attach.target[i] === attach.element[i] ? offsetViewport(target[i]) : offset(target[i]);
        elOffset = applyOffset(
          elOffset,
          targetOffset[start] - elOffset[start] + moveBy(attach.target[i], end, targetOffset[prop]) - moveBy(attach.element[i], end, elOffset[prop]) + +offsetBy[i],
          i
        );
      }
      return elOffset;
    }
    function applyOffset(position, offset2, i) {
      const [, dir, start, end] = dirs[i];
      const newPos = { ...position };
      newPos[start] = position[dir] = position[start] + offset2;
      newPos[end] += offset2;
      return newPos;
    }
    function moveBy(attach, end, dim) {
      return attach === "center" ? dim / 2 : attach === end ? dim : 0;
    }
    function getViewport$2(element, target, viewportOffset, boundary, i) {
      let viewport = getIntersectionArea(...commonScrollParents(element, target).map(offsetViewport));
      if (viewportOffset) {
        viewport[dirs[i][2]] += viewportOffset;
        viewport[dirs[i][3]] -= viewportOffset;
      }
      if (boundary) {
        viewport = getIntersectionArea(
          viewport,
          offset(isArray(boundary) ? boundary[i] : boundary)
        );
      }
      return viewport;
    }
    function getScrollArea(element, target, viewportOffset, i) {
      const [prop, axis, start, end] = dirs[i];
      const [scrollElement] = commonScrollParents(element, target);
      const viewport = offsetViewport(scrollElement);
      if (["auto", "scroll"].includes(css(scrollElement, `overflow-${axis}`))) {
        viewport[start] -= scrollElement[`scroll${ucfirst(start)}`];
        viewport[end] = viewport[start] + scrollElement[`scroll${ucfirst(prop)}`];
      }
      viewport[start] += viewportOffset;
      viewport[end] -= viewportOffset;
      return viewport;
    }
    function commonScrollParents(element, target) {
      return overflowParents(target).filter((parent) => parent.contains(element));
    }
    function getIntersectionArea(...rects) {
      let area = {};
      for (const rect of rects) {
        for (const [, , start, end] of dirs) {
          area[start] = Math.max(area[start] || 0, rect[start]);
          area[end] = Math.min(...[area[end], rect[end]].filter(Boolean));
        }
      }
      return area;
    }
    function isWithin(positionA, positionB, i) {
      const [, , start, end] = dirs[i];
      return positionA[start] >= positionB[start] && positionA[end] <= positionB[end];
    }
    function flip(element, target, { offset: offset2, attach }, i) {
      return attachTo(element, target, {
        attach: {
          element: flipAttach(attach.element, i),
          target: flipAttach(attach.target, i)
        },
        offset: flipOffset(offset2, i)
      });
    }
    function flipAxis(element, target, options) {
      return getPosition(element, target, {
        ...options,
        attach: {
          element: options.attach.element.map(flipAttachAxis).reverse(),
          target: options.attach.target.map(flipAttachAxis).reverse()
        },
        offset: options.offset.reverse(),
        placement: options.placement.reverse(),
        recursion: true
      });
    }
    function flipAttach(attach, i) {
      const newAttach = [...attach];
      const index = dirs[i].indexOf(attach[i]);
      if (~index) {
        newAttach[i] = dirs[i][1 - index % 2 + 2];
      }
      return newAttach;
    }
    function flipAttachAxis(prop) {
      for (let i = 0; i < dirs.length; i++) {
        const index = dirs[i].indexOf(prop);
        if (~index) {
          return dirs[1 - i][index % 2 + 2];
        }
      }
    }
    function flipOffset(offset2, i) {
      offset2 = [...offset2];
      offset2[i] *= -1;
      return offset2;
    }

    var util = /*#__PURE__*/Object.freeze({
        __proto__: null,
        $: $,
        $$: $$,
        Animation: Animation,
        Dimensions: Dimensions,
        MouseTracker: MouseTracker,
        Transition: Transition,
        addClass: addClass,
        after: after,
        append: append,
        apply: apply,
        assign: assign,
        attr: attr,
        before: before,
        boxModelAdjust: boxModelAdjust,
        camelize: camelize,
        children: children,
        clamp: clamp,
        createEvent: createEvent,
        css: css,
        data: data,
        dimensions: dimensions$1,
        each: each,
        empty: empty,
        endsWith: endsWith,
        escape: escape,
        fastdom: fastdom,
        filter: filter$1,
        find: find,
        findAll: findAll,
        findIndex: findIndex,
        flipPosition: flipPosition,
        fragment: fragment,
        getCoveringElement: getCoveringElement,
        getEventPos: getEventPos,
        getIndex: getIndex,
        getTargetedElement: getTargetedElement,
        hasAttr: hasAttr,
        hasClass: hasClass,
        hasOwn: hasOwn,
        hasTouch: hasTouch,
        height: height,
        html: html,
        hyphenate: hyphenate,
        inBrowser: inBrowser,
        includes: includes,
        index: index,
        intersectRect: intersectRect,
        isArray: isArray,
        isBoolean: isBoolean,
        isDocument: isDocument,
        isElement: isElement,
        isEmpty: isEmpty,
        isEqual: isEqual,
        isFocusable: isFocusable,
        isFunction: isFunction,
        isInView: isInView,
        isInput: isInput,
        isNode: isNode,
        isNumber: isNumber,
        isNumeric: isNumeric,
        isObject: isObject,
        isPlainObject: isPlainObject,
        isRtl: isRtl,
        isSameSiteAnchor: isSameSiteAnchor,
        isString: isString,
        isTag: isTag,
        isTouch: isTouch,
        isUndefined: isUndefined,
        isVisible: isVisible,
        isVoidElement: isVoidElement,
        isWindow: isWindow,
        last: last,
        matches: matches,
        memoize: memoize,
        mute: mute,
        noop: noop,
        observeIntersection: observeIntersection,
        observeMutation: observeMutation,
        observeResize: observeResize,
        observeViewportResize: observeViewportResize,
        off: off,
        offset: offset,
        offsetPosition: offsetPosition,
        offsetViewport: offsetViewport,
        on: on,
        once: once,
        overflowParents: overflowParents,
        parent: parent,
        parents: parents,
        pause: pause,
        pick: pick,
        play: play,
        pointInRect: pointInRect,
        pointerCancel: pointerCancel,
        pointerDown: pointerDown$1,
        pointerEnter: pointerEnter,
        pointerLeave: pointerLeave,
        pointerMove: pointerMove$1,
        pointerUp: pointerUp$1,
        position: position,
        positionAt: positionAt,
        prepend: prepend,
        propName: propName,
        query: query,
        queryAll: queryAll,
        ready: ready,
        remove: remove$1,
        removeAttr: removeAttr,
        removeClass: removeClass,
        replaceClass: replaceClass,
        scrollIntoView: scrollIntoView,
        scrollParent: scrollParent,
        scrollParents: scrollParents,
        scrolledOver: scrolledOver,
        selFocusable: selFocusable,
        selInput: selInput,
        sortBy: sortBy,
        startsWith: startsWith,
        sumBy: sumBy,
        swap: swap,
        toArray: toArray,
        toBoolean: toBoolean,
        toEventTargets: toEventTargets,
        toFloat: toFloat,
        toNode: toNode,
        toNodes: toNodes,
        toNumber: toNumber,
        toPx: toPx,
        toWindow: toWindow,
        toggleClass: toggleClass,
        trigger: trigger,
        ucfirst: ucfirst,
        uniqueBy: uniqueBy,
        unwrap: unwrap,
        width: width,
        wrapAll: wrapAll,
        wrapInner: wrapInner
    });

    var Class = {
      connected() {
        addClass(this.$el, this.$options.id);
      }
    };

    const units = ["days", "hours", "minutes", "seconds"];
    var countdown = {
      mixins: [Class],
      props: {
        date: String,
        clsWrapper: String,
        role: String,
        reload: Boolean
      },
      data: {
        date: "",
        clsWrapper: ".uk-countdown-%unit%",
        role: "timer",
        reload: false
      },
      connected() {
        attr(this.$el, "role", this.role);
        this.date = toFloat(Date.parse(this.$props.date));
        this.started = this.end = false;
        this.start();
      },
      disconnected() {
        this.stop();
      },
      events: {
        name: "visibilitychange",
        el: () => document,
        handler() {
          if (document.hidden) {
            this.stop();
          } else {
            this.start();
          }
        }
      },
      methods: {
        start() {
          this.stop();
          this.update();
        },
        stop() {
          if (this.timer) {
            clearInterval(this.timer);
            trigger(this.$el, "countdownstop");
            this.timer = null;
          }
        },
        update() {
          const timespan = getTimeSpan(this.date);
          if (!timespan.total) {
            this.stop();
            if (!this.end) {
              trigger(this.$el, "countdownend");
              this.end = true;
              if (this.reload && this.started) {
                window.location.reload();
              }
            }
          } else if (!this.timer) {
            this.started = true;
            trigger(this.$el, "countdownstart");
            this.timer = setInterval(this.update, 1e3);
          }
          for (const unit of units) {
            const el = $(this.clsWrapper.replace("%unit%", unit), this.$el);
            if (!el) {
              continue;
            }
            let digits = Math.trunc(timespan[unit]).toString().padStart(2, "0");
            if (el.textContent !== digits) {
              digits = digits.split("");
              if (digits.length !== el.children.length) {
                html(el, digits.map(() => "<span></span>").join(""));
              }
              digits.forEach((digit, i) => el.children[i].textContent = digit);
            }
          }
        }
      }
    };
    function getTimeSpan(date) {
      const total = Math.max(0, date - Date.now()) / 1e3;
      return {
        total,
        seconds: total % 60,
        minutes: total / 60 % 60,
        hours: total / 60 / 60 % 24,
        days: total / 60 / 60 / 24
      };
    }

    const strats = {};
    strats.events = strats.watch = strats.observe = strats.created = strats.beforeConnect = strats.connected = strats.beforeDisconnect = strats.disconnected = strats.destroy = concatStrat;
    strats.args = function(parentVal, childVal) {
      return childVal !== false && concatStrat(childVal || parentVal);
    };
    strats.update = function(parentVal, childVal) {
      return sortBy(
        concatStrat(parentVal, isFunction(childVal) ? { read: childVal } : childVal),
        "order"
      );
    };
    strats.props = function(parentVal, childVal) {
      if (isArray(childVal)) {
        const value = {};
        for (const key of childVal) {
          value[key] = String;
        }
        childVal = value;
      }
      return strats.methods(parentVal, childVal);
    };
    strats.computed = strats.methods = function(parentVal, childVal) {
      return childVal ? parentVal ? { ...parentVal, ...childVal } : childVal : parentVal;
    };
    strats.i18n = strats.data = function(parentVal, childVal, vm) {
      if (!vm) {
        if (!childVal) {
          return parentVal;
        }
        if (!parentVal) {
          return childVal;
        }
        return function(vm2) {
          return mergeFnData(parentVal, childVal, vm2);
        };
      }
      return mergeFnData(parentVal, childVal, vm);
    };
    function mergeFnData(parentVal, childVal, vm) {
      return strats.computed(
        isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal,
        isFunction(childVal) ? childVal.call(vm, vm) : childVal
      );
    }
    function concatStrat(parentVal, childVal) {
      parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;
      return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
    }
    function defaultStrat(parentVal, childVal) {
      return isUndefined(childVal) ? parentVal : childVal;
    }
    function mergeOptions(parent, child, vm) {
      const options = {};
      if (isFunction(child)) {
        child = child.options;
      }
      if (child.extends) {
        parent = mergeOptions(parent, child.extends, vm);
      }
      if (child.mixins) {
        for (const mixin of child.mixins) {
          parent = mergeOptions(parent, mixin, vm);
        }
      }
      for (const key in parent) {
        mergeKey(key);
      }
      for (const key in child) {
        if (!hasOwn(parent, key)) {
          mergeKey(key);
        }
      }
      function mergeKey(key) {
        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);
      }
      return options;
    }
    function parseOptions(options, args = []) {
      try {
        return options ? startsWith(options, "{") ? JSON.parse(options) : args.length && !includes(options, ":") ? { [args[0]]: options } : options.split(";").reduce((options2, option) => {
          const [key, value] = option.split(/:(.*)/);
          if (key && !isUndefined(value)) {
            options2[key.trim()] = value.trim();
          }
          return options2;
        }, {}) : {};
      } catch (e) {
        return {};
      }
    }
    function coerce$1(type, value) {
      if (type === Boolean) {
        return toBoolean(value);
      } else if (type === Number) {
        return toNumber(value);
      } else if (type === "list") {
        return toList(value);
      } else if (type === Object && isString(value)) {
        return parseOptions(value);
      }
      return type ? type(value) : value;
    }
    const listRe = /,(?![^(]*\))/;
    function toList(value) {
      return isArray(value) ? value : isString(value) ? value.split(listRe).map((value2) => isNumeric(value2) ? toNumber(value2) : toBoolean(value2.trim())) : [value];
    }

    function initUpdates(instance) {
      instance._data = {};
      instance._updates = [...instance.$options.update || []];
      instance._disconnect.push(() => instance._updates = instance._data = null);
    }
    function prependUpdate(instance, update) {
      instance._updates.unshift(update);
    }
    function callUpdate(instance, e = "update") {
      if (!instance._connected) {
        return;
      }
      if (!instance._updates.length) {
        return;
      }
      if (!instance._queued) {
        instance._queued = /* @__PURE__ */ new Set();
        fastdom.read(() => {
          if (instance._connected) {
            runUpdates(instance, instance._queued);
          }
          instance._queued = null;
        });
      }
      instance._queued.add(e.type || e);
    }
    function runUpdates(instance, types) {
      for (const { read, write, events = [] } of instance._updates) {
        if (!types.has("update") && !events.some((type) => types.has(type))) {
          continue;
        }
        let result;
        if (read) {
          result = read.call(instance, instance._data, types);
          if (result && isPlainObject(result)) {
            assign(instance._data, result);
          }
        }
        if (write && result !== false) {
          fastdom.write(() => {
            if (instance._connected) {
              write.call(instance, instance._data, types);
            }
          });
        }
      }
    }

    function resize(options) {
      return observe(observeResize, options, "resize");
    }
    function intersection(options) {
      return observe(observeIntersection, options);
    }
    function mutation(options) {
      return observe(observeMutation, options);
    }
    function lazyload(options = {}) {
      return intersection({
        handler: function(entries, observer) {
          const { targets = this.$el, preload = 5 } = options;
          for (const el of toNodes(isFunction(targets) ? targets(this) : targets)) {
            $$('[loading="lazy"]', el).slice(0, preload - 1).forEach((el2) => removeAttr(el2, "loading"));
          }
          for (const el of entries.filter(({ isIntersecting }) => isIntersecting).map(({ target }) => target)) {
            observer.unobserve(el);
          }
        },
        ...options
      });
    }
    function viewport(options) {
      return observe((target, handler) => observeViewportResize(handler), options, "resize");
    }
    function scroll$1(options) {
      return observe(
        (target, handler) => ({
          disconnect: on(toScrollTargets(target), "scroll", handler, { passive: true })
        }),
        options,
        "scroll"
      );
    }
    function swipe(options) {
      return {
        observe(target, handler) {
          return {
            observe: noop,
            unobserve: noop,
            disconnect: on(target, pointerDown$1, handler, { passive: true })
          };
        },
        handler(e) {
          if (!isTouch(e)) {
            return;
          }
          const pos = getEventPos(e);
          const target = "tagName" in e.target ? e.target : parent(e.target);
          once(document, `${pointerUp$1} ${pointerCancel} scroll`, (e2) => {
            const { x, y } = getEventPos(e2);
            if (e2.type !== "scroll" && target && x && Math.abs(pos.x - x) > 100 || y && Math.abs(pos.y - y) > 100) {
              setTimeout(() => {
                trigger(target, "swipe");
                trigger(target, `swipe${swipeDirection(pos.x, pos.y, x, y)}`);
              });
            }
          });
        },
        ...options
      };
    }
    function observe(observe2, options, emit) {
      return {
        observe: observe2,
        handler() {
          callUpdate(this, emit);
        },
        ...options
      };
    }
    function swipeDirection(x1, y1, x2, y2) {
      return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? "Left" : "Right" : y1 - y2 > 0 ? "Up" : "Down";
    }
    function toScrollTargets(elements) {
      return toNodes(elements).map((node) => {
        const { ownerDocument } = node;
        const parent2 = scrollParent(node, true);
        return parent2 === ownerDocument.scrollingElement ? ownerDocument : parent2;
      });
    }

    var Margin = {
      props: {
        margin: String,
        firstColumn: Boolean
      },
      data: {
        margin: "uk-margin-small-top",
        firstColumn: "uk-first-column"
      },
      observe: [
        mutation({
          options: {
            childList: true
          }
        }),
        mutation({
          options: {
            attributes: true,
            attributeFilter: ["style"]
          },
          target: ({ $el }) => [$el, ...children($el)]
        }),
        resize({
          target: ({ $el }) => [$el, ...children($el)]
        })
      ],
      update: {
        read() {
          return {
            rows: getRows(children(this.$el))
          };
        },
        write({ rows }) {
          for (const row of rows) {
            for (const el of row) {
              toggleClass(el, this.margin, rows[0] !== row);
              toggleClass(el, this.firstColumn, row[isRtl ? row.length - 1 : 0] === el);
            }
          }
        },
        events: ["resize"]
      }
    };
    function getRows(elements) {
      const sorted = [[]];
      const withOffset = elements.some(
        (el, i) => i && elements[i - 1].offsetParent !== el.offsetParent
      );
      for (const el of elements) {
        if (!isVisible(el)) {
          continue;
        }
        const offset = getOffset(el, withOffset);
        for (let i = sorted.length - 1; i >= 0; i--) {
          const current = sorted[i];
          if (!current[0]) {
            current.push(el);
            break;
          }
          const offsetCurrent = getOffset(current[0], withOffset);
          if (offset.top >= offsetCurrent.bottom - 1 && offset.top !== offsetCurrent.top) {
            sorted.push([el]);
            break;
          }
          if (offset.bottom - 1 > offsetCurrent.top || offset.top === offsetCurrent.top) {
            let j = current.length - 1;
            for (; j >= 0; j--) {
              const offsetCurrent2 = getOffset(current[j], withOffset);
              if (offset.left >= offsetCurrent2.left) {
                break;
              }
            }
            current.splice(j + 1, 0, el);
            break;
          }
          if (i === 0) {
            sorted.unshift([el]);
            break;
          }
        }
      }
      return sorted;
    }
    function getOffset(element, offset = false) {
      let { offsetTop, offsetLeft, offsetHeight, offsetWidth } = element;
      if (offset) {
        [offsetTop, offsetLeft] = offsetPosition(element);
      }
      return {
        top: offsetTop,
        left: offsetLeft,
        bottom: offsetTop + offsetHeight,
        right: offsetLeft + offsetWidth
      };
    }

    async function slide(action, target, duration) {
      await awaitFrame();
      let nodes = children(target);
      const currentProps = nodes.map((el) => getProps$1(el, true));
      const targetProps = { ...css(target, ["height", "padding"]), display: "block" };
      const targets = nodes.concat(target);
      await Promise.all(targets.map(Transition.cancel));
      css(targets, "transitionProperty", "none");
      await action();
      nodes = nodes.concat(children(target).filter((el) => !includes(nodes, el)));
      await Promise.resolve();
      css(targets, "transitionProperty", "");
      const targetStyle = attr(target, "style");
      const targetPropsTo = css(target, ["height", "padding"]);
      const [propsTo, propsFrom] = getTransitionProps(target, nodes, currentProps);
      const attrsTo = nodes.map((el) => ({ style: attr(el, "style") }));
      nodes.forEach((el, i) => propsFrom[i] && css(el, propsFrom[i]));
      css(target, targetProps);
      trigger(target, "scroll");
      await awaitFrame();
      const transitions = nodes.map((el, i) => parent(el) === target && Transition.start(el, propsTo[i], duration, "ease")).concat(Transition.start(target, targetPropsTo, duration, "ease"));
      try {
        await Promise.all(transitions);
        nodes.forEach((el, i) => {
          attr(el, attrsTo[i]);
          if (parent(el) === target) {
            css(el, "display", propsTo[i].opacity === 0 ? "none" : "");
          }
        });
        attr(target, "style", targetStyle);
      } catch (e) {
        attr(nodes, "style", "");
        resetProps(target, targetProps);
      }
    }
    function getProps$1(el, opacity) {
      const zIndex = css(el, "zIndex");
      return isVisible(el) ? {
        display: "",
        opacity: opacity ? css(el, "opacity") : "0",
        pointerEvents: "none",
        position: "absolute",
        zIndex: zIndex === "auto" ? index(el) : zIndex,
        ...getPositionWithMargin(el)
      } : false;
    }
    function getTransitionProps(target, nodes, currentProps) {
      const propsTo = nodes.map(
        (el, i) => parent(el) && i in currentProps ? currentProps[i] ? isVisible(el) ? getPositionWithMargin(el) : { opacity: 0 } : { opacity: isVisible(el) ? 1 : 0 } : false
      );
      const propsFrom = propsTo.map((props, i) => {
        const from = parent(nodes[i]) === target && (currentProps[i] || getProps$1(nodes[i]));
        if (!from) {
          return false;
        }
        if (!props) {
          delete from.opacity;
        } else if (!("opacity" in props)) {
          const { opacity } = from;
          if (opacity % 1) {
            props.opacity = 1;
          } else {
            delete from.opacity;
          }
        }
        return from;
      });
      return [propsTo, propsFrom];
    }
    function resetProps(el, props) {
      for (const prop in props) {
        css(el, prop, "");
      }
    }
    function getPositionWithMargin(el) {
      const { height, width } = dimensions$1(el);
      return {
        height,
        width,
        transform: "",
        ...position(el),
        ...css(el, ["marginTop", "marginLeft"])
      };
    }
    function awaitFrame() {
      return new Promise((resolve) => requestAnimationFrame(resolve));
    }

    const clsLeave = "uk-transition-leave";
    const clsEnter = "uk-transition-enter";
    function fade(action, target, duration, stagger = 0) {
      const index = transitionIndex(target, true);
      const propsIn = { opacity: 1 };
      const propsOut = { opacity: 0 };
      const wrapIndexFn = (fn) => () => index === transitionIndex(target) ? fn() : Promise.reject();
      const leaveFn = wrapIndexFn(async () => {
        addClass(target, clsLeave);
        await Promise.all(
          getTransitionNodes(target).map(
            (child, i) => new Promise(
              (resolve) => setTimeout(
                () => Transition.start(child, propsOut, duration / 2, "ease").then(
                  resolve
                ),
                i * stagger
              )
            )
          )
        );
        removeClass(target, clsLeave);
      });
      const enterFn = wrapIndexFn(async () => {
        const oldHeight = height(target);
        addClass(target, clsEnter);
        action();
        css(children(target), { opacity: 0 });
        await awaitFrame();
        const nodes = children(target);
        const newHeight = height(target);
        css(target, "alignContent", "flex-start");
        height(target, oldHeight);
        const transitionNodes = getTransitionNodes(target);
        css(nodes, propsOut);
        const transitions = transitionNodes.map(async (child, i) => {
          await awaitTimeout(i * stagger);
          await Transition.start(child, propsIn, duration / 2, "ease");
        });
        if (oldHeight !== newHeight) {
          transitions.push(
            Transition.start(
              target,
              { height: newHeight },
              duration / 2 + transitionNodes.length * stagger,
              "ease"
            )
          );
        }
        await Promise.all(transitions).then(() => {
          removeClass(target, clsEnter);
          if (index === transitionIndex(target)) {
            css(target, { height: "", alignContent: "" });
            css(nodes, { opacity: "" });
            delete target.dataset.transition;
          }
        });
      });
      return hasClass(target, clsLeave) ? waitTransitionend(target).then(enterFn) : hasClass(target, clsEnter) ? waitTransitionend(target).then(leaveFn).then(enterFn) : leaveFn().then(enterFn);
    }
    function transitionIndex(target, next) {
      if (next) {
        target.dataset.transition = 1 + transitionIndex(target);
      }
      return toNumber(target.dataset.transition) || 0;
    }
    function waitTransitionend(target) {
      return Promise.all(
        children(target).filter(Transition.inProgress).map(
          (el) => new Promise((resolve) => once(el, "transitionend transitioncanceled", resolve))
        )
      );
    }
    function getTransitionNodes(target) {
      return getRows(children(target)).flat().filter(isVisible);
    }
    function awaitTimeout(timeout) {
      return new Promise((resolve) => setTimeout(resolve, timeout));
    }

    var Animate = {
      props: {
        duration: Number,
        animation: Boolean
      },
      data: {
        duration: 150,
        animation: "slide"
      },
      methods: {
        animate(action, target = this.$el) {
          const name = this.animation;
          const animationFn = name === "fade" ? fade : name === "delayed-fade" ? (...args) => fade(...args, 40) : name ? slide : () => {
            action();
            return Promise.resolve();
          };
          return animationFn(action, target, this.duration).catch(noop);
        }
      }
    };

    const keyMap = {
      TAB: 9,
      ESC: 27,
      SPACE: 32,
      END: 35,
      HOME: 36,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40
    };

    var filter = {
      mixins: [Animate],
      args: "target",
      props: {
        target: String,
        selActive: Boolean
      },
      data: {
        target: "",
        selActive: false,
        attrItem: "uk-filter-control",
        cls: "uk-active",
        duration: 250
      },
      computed: {
        children: ({ target }, $el) => $$(`${target} > *`, $el),
        toggles: ({ attrItem }, $el) => $$(`[${attrItem}],[data-${attrItem}]`, $el)
      },
      watch: {
        toggles(toggles) {
          this.updateState();
          const actives = $$(this.selActive, this.$el);
          for (const toggle of toggles) {
            if (this.selActive !== false) {
              toggleClass(toggle, this.cls, includes(actives, toggle));
            }
            const button = findButton(toggle);
            if (isTag(button, "a")) {
              attr(button, "role", "button");
            }
          }
        },
        children(list, prev) {
          if (prev) {
            this.updateState();
          }
        }
      },
      events: {
        name: "click keydown",
        delegate: ({ attrItem }) => `[${attrItem}],[data-${attrItem}]`,
        handler(e) {
          if (e.type === "keydown" && e.keyCode !== keyMap.SPACE) {
            return;
          }
          if (e.target.closest("a,button")) {
            e.preventDefault();
            this.apply(e.current);
          }
        }
      },
      methods: {
        apply(el) {
          const prevState = this.getState();
          const newState = mergeState(el, this.attrItem, this.getState());
          if (!isEqualState(prevState, newState)) {
            this.setState(newState);
          }
        },
        getState() {
          return this.toggles.filter((item) => hasClass(item, this.cls)).reduce((state, el) => mergeState(el, this.attrItem, state), {
            filter: { "": "" },
            sort: []
          });
        },
        async setState(state, animate = true) {
          state = { filter: { "": "" }, sort: [], ...state };
          trigger(this.$el, "beforeFilter", [this, state]);
          for (const toggle of this.toggles) {
            toggleClass(toggle, this.cls, matchFilter(toggle, this.attrItem, state));
          }
          await Promise.all(
            $$(this.target, this.$el).map((target) => {
              const filterFn = () => applyState(state, target, children(target));
              return animate ? this.animate(filterFn, target) : filterFn();
            })
          );
          trigger(this.$el, "afterFilter", [this]);
        },
        updateState() {
          fastdom.write(() => this.setState(this.getState(), false));
        }
      }
    };
    function getFilter(el, attr2) {
      return parseOptions(data(el, attr2), ["filter"]);
    }
    function isEqualState(stateA, stateB) {
      return ["filter", "sort"].every((prop) => isEqual(stateA[prop], stateB[prop]));
    }
    function applyState(state, target, children) {
      for (const el of children) {
        css(
          el,
          "display",
          Object.values(state.filter).every((selector) => !selector || matches(el, selector)) ? "" : "none"
        );
      }
      const [sort, order] = state.sort;
      if (sort) {
        const sorted = sortItems(children, sort, order);
        if (!isEqual(sorted, children)) {
          append(target, sorted);
        }
      }
    }
    function mergeState(el, attr2, state) {
      const { filter, group, sort, order = "asc" } = getFilter(el, attr2);
      if (filter || isUndefined(sort)) {
        if (group) {
          if (filter) {
            delete state.filter[""];
            state.filter[group] = filter;
          } else {
            delete state.filter[group];
            if (isEmpty(state.filter) || "" in state.filter) {
              state.filter = { "": filter || "" };
            }
          }
        } else {
          state.filter = { "": filter || "" };
        }
      }
      if (!isUndefined(sort)) {
        state.sort = [sort, order];
      }
      return state;
    }
    function matchFilter(el, attr2, { filter: stateFilter = { "": "" }, sort: [stateSort, stateOrder] }) {
      const { filter = "", group = "", sort, order = "asc" } = getFilter(el, attr2);
      return isUndefined(sort) ? group in stateFilter && filter === stateFilter[group] || !filter && group && !(group in stateFilter) && !stateFilter[""] : stateSort === sort && stateOrder === order;
    }
    function sortItems(nodes, sort, order) {
      return [...nodes].sort(
        (a, b) => data(a, sort).localeCompare(data(b, sort), void 0, { numeric: true }) * (order === "asc" || -1)
      );
    }
    function findButton(el) {
      return $("a,button", el) || el;
    }

    var img = {
      args: "dataSrc",
      props: {
        dataSrc: String,
        sources: String,
        margin: String,
        target: String,
        loading: String
      },
      data: {
        dataSrc: "",
        sources: false,
        margin: "50%",
        target: false,
        loading: "lazy"
      },
      connected() {
        if (this.loading !== "lazy") {
          this.load();
        } else if (isImg(this.$el)) {
          this.$el.loading = "lazy";
          setSrcAttrs(this.$el);
        }
      },
      disconnected() {
        if (this.img) {
          this.img.onload = "";
        }
        delete this.img;
      },
      observe: intersection({
        handler(entries, observer) {
          this.load();
          observer.disconnect();
        },
        options: ({ margin }) => ({ rootMargin: margin }),
        filter: ({ loading }) => loading === "lazy",
        target: ({ $el, $props }) => $props.target ? [$el, ...queryAll($props.target, $el)] : $el
      }),
      methods: {
        load() {
          if (this.img) {
            return this.img;
          }
          const image = isImg(this.$el) ? this.$el : getImageFromElement(this.$el, this.dataSrc, this.sources);
          removeAttr(image, "loading");
          setSrcAttrs(this.$el, image.currentSrc);
          return this.img = image;
        }
      }
    };
    function setSrcAttrs(el, src) {
      if (isImg(el)) {
        const parentNode = parent(el);
        const elements = isTag(parentNode, "picture") ? children(parentNode) : [el];
        elements.forEach((el2) => setSourceProps(el2, el2));
      } else if (src) {
        const change = !includes(el.style.backgroundImage, src);
        if (change) {
          css(el, "backgroundImage", `url(${escape(src)})`);
          trigger(el, createEvent("load", false));
        }
      }
    }
    const srcProps = ["data-src", "data-srcset", "sizes"];
    function setSourceProps(sourceEl, targetEl) {
      for (const prop of srcProps) {
        const value = data(sourceEl, prop);
        if (value) {
          attr(targetEl, prop.replace(/data-/g, ""), value);
        }
      }
    }
    function getImageFromElement(el, src, sources) {
      const img = new Image();
      wrapInPicture(img, sources);
      setSourceProps(el, img);
      img.onload = () => setSrcAttrs(el, img.currentSrc);
      attr(img, "src", src);
      return img;
    }
    function wrapInPicture(img, sources) {
      sources = parseSources(sources);
      if (sources.length) {
        const picture = fragment("<picture>");
        for (const attrs of sources) {
          const source = fragment("<source>");
          attr(source, attrs);
          append(picture, source);
        }
        append(picture, img);
      }
    }
    function parseSources(sources) {
      if (!sources) {
        return [];
      }
      if (startsWith(sources, "[")) {
        try {
          sources = JSON.parse(sources);
        } catch (e) {
          sources = [];
        }
      } else {
        sources = parseOptions(sources);
      }
      if (!isArray(sources)) {
        sources = [sources];
      }
      return sources.filter((source) => !isEmpty(source));
    }
    function isImg(el) {
      return isTag(el, "img");
    }

    let prevented;
    function preventBackgroundScroll(el) {
      const off = on(
        el,
        "touchstart",
        (e) => {
          if (e.targetTouches.length !== 1 || matches(e.target, 'input[type="range"')) {
            return;
          }
          let prev = getEventPos(e).y;
          const offMove = on(
            el,
            "touchmove",
            (e2) => {
              const pos = getEventPos(e2).y;
              if (pos === prev) {
                return;
              }
              prev = pos;
              if (!scrollParents(e2.target).some((scrollParent) => {
                if (!el.contains(scrollParent)) {
                  return false;
                }
                let { scrollHeight, clientHeight } = scrollParent;
                return clientHeight < scrollHeight;
              })) {
                e2.preventDefault();
              }
            },
            { passive: false }
          );
          once(el, "scroll touchend touchcanel", offMove, { capture: true });
        },
        { passive: true }
      );
      if (prevented) {
        return off;
      }
      prevented = true;
      const { scrollingElement } = document;
      css(scrollingElement, {
        overflowY: CSS.supports("overflow", "clip") ? "clip" : "hidden",
        touchAction: "none",
        paddingRight: width(window) - scrollingElement.clientWidth || ""
      });
      return () => {
        prevented = false;
        off();
        css(scrollingElement, { overflowY: "", touchAction: "", paddingRight: "" });
      };
    }

    var Container = {
      props: {
        container: Boolean
      },
      data: {
        container: true
      },
      computed: {
        container({ container }) {
          return container === true && this.$container || container && $(container);
        }
      }
    };

    var Position = {
      props: {
        pos: String,
        offset: Boolean,
        flip: Boolean,
        shift: Boolean,
        inset: Boolean
      },
      data: {
        pos: `bottom-${isRtl ? "right" : "left"}`,
        offset: false,
        flip: true,
        shift: true,
        inset: false
      },
      connected() {
        this.pos = this.$props.pos.split("-").concat("center").slice(0, 2);
        [this.dir, this.align] = this.pos;
        this.axis = includes(["top", "bottom"], this.dir) ? "y" : "x";
      },
      methods: {
        positionAt(element, target, boundary) {
          let offset = [this.getPositionOffset(element), this.getShiftOffset(element)];
          const placement = [this.flip && "flip", this.shift && "shift"];
          const attach = {
            element: [this.inset ? this.dir : flipPosition(this.dir), this.align],
            target: [this.dir, this.align]
          };
          if (this.axis === "y") {
            for (const prop in attach) {
              attach[prop].reverse();
            }
            offset.reverse();
            placement.reverse();
          }
          const restoreScrollPosition = storeScrollPosition(element);
          const elDim = dimensions$1(element);
          css(element, { top: -elDim.height, left: -elDim.width });
          positionAt(element, target, {
            attach,
            offset,
            boundary,
            placement,
            viewportOffset: this.getViewportOffset(element)
          });
          restoreScrollPosition();
        },
        getPositionOffset(element = this.$el) {
          return toPx(
            this.offset === false ? css(element, "--uk-position-offset") : this.offset,
            this.axis === "x" ? "width" : "height",
            element
          ) * (includes(["left", "top"], this.dir) ? -1 : 1) * (this.inset ? -1 : 1);
        },
        getShiftOffset(element = this.$el) {
          return this.align === "center" ? 0 : toPx(
            css(element, "--uk-position-shift-offset"),
            this.axis === "y" ? "width" : "height",
            element
          ) * (includes(["left", "top"], this.align) ? 1 : -1);
        },
        getViewportOffset(element) {
          return toPx(css(element, "--uk-position-viewport-offset"));
        }
      }
    };
    function storeScrollPosition(element) {
      const scrollElement = scrollParent(element);
      const { scrollTop } = scrollElement;
      return () => {
        if (scrollTop !== scrollElement.scrollTop) {
          scrollElement.scrollTop = scrollTop;
        }
      };
    }

    var Togglable = {
      props: {
        cls: Boolean,
        animation: "list",
        duration: Number,
        velocity: Number,
        origin: String,
        transition: String
      },
      data: {
        cls: false,
        animation: [false],
        duration: 200,
        velocity: 0.2,
        origin: false,
        transition: "ease",
        clsEnter: "uk-togglable-enter",
        clsLeave: "uk-togglable-leave"
      },
      computed: {
        hasAnimation: ({ animation }) => !!animation[0],
        hasTransition: ({ animation }) => ["slide", "reveal"].some((transition) => startsWith(animation[0], transition))
      },
      methods: {
        async toggleElement(targets, toggle, animate) {
          try {
            await Promise.all(
              toNodes(targets).map((el) => {
                const show = isBoolean(toggle) ? toggle : !this.isToggled(el);
                if (!trigger(el, `before${show ? "show" : "hide"}`, [this])) {
                  return Promise.reject();
                }
                const promise = (isFunction(animate) ? animate : animate === false || !this.hasAnimation ? toggleInstant : this.hasTransition ? toggleTransition : toggleAnimation)(el, show, this);
                const cls = show ? this.clsEnter : this.clsLeave;
                addClass(el, cls);
                trigger(el, show ? "show" : "hide", [this]);
                const done = () => {
                  var _a;
                  removeClass(el, cls);
                  trigger(el, show ? "shown" : "hidden", [this]);
                  if (show) {
                    const restoreScrollPosition = storeScrollPosition(el);
                    (_a = $$("[autofocus]", el).find(isVisible)) == null ? void 0 : _a.focus();
                    restoreScrollPosition();
                  }
                };
                return promise ? promise.then(done, () => {
                  removeClass(el, cls);
                  return Promise.reject();
                }) : done();
              })
            );
            return true;
          } catch (e) {
            return false;
          }
        },
        isToggled(el = this.$el) {
          el = toNode(el);
          return hasClass(el, this.clsEnter) ? true : hasClass(el, this.clsLeave) ? false : this.cls ? hasClass(el, this.cls.split(" ")[0]) : isVisible(el);
        },
        _toggle(el, toggled) {
          if (!el) {
            return;
          }
          toggled = Boolean(toggled);
          let changed;
          if (this.cls) {
            changed = includes(this.cls, " ") || toggled !== hasClass(el, this.cls);
            changed && toggleClass(el, this.cls, includes(this.cls, " ") ? void 0 : toggled);
          } else {
            changed = toggled === el.hidden;
            changed && (el.hidden = !toggled);
          }
          if (changed) {
            trigger(el, "toggled", [toggled, this]);
          }
        }
      }
    };
    function toggleInstant(el, show, { _toggle }) {
      Animation.cancel(el);
      Transition.cancel(el);
      return _toggle(el, show);
    }
    async function toggleTransition(el, show, { animation, duration, velocity, transition, _toggle }) {
      var _a;
      const [mode = "reveal", startProp = "top"] = ((_a = animation[0]) == null ? void 0 : _a.split("-")) || [];
      const dirs = [
        ["left", "right"],
        ["top", "bottom"]
      ];
      const dir = dirs[includes(dirs[0], startProp) ? 0 : 1];
      const end = dir[1] === startProp;
      const props = ["width", "height"];
      const dimProp = props[dirs.indexOf(dir)];
      const marginProp = `margin-${dir[0]}`;
      const marginStartProp = `margin-${startProp}`;
      let currentDim = dimensions$1(el)[dimProp];
      const inProgress = Transition.inProgress(el);
      await Transition.cancel(el);
      if (show) {
        _toggle(el, true);
      }
      const prevProps = Object.fromEntries(
        [
          "padding",
          "border",
          "width",
          "height",
          "minWidth",
          "minHeight",
          "overflowY",
          "overflowX",
          marginProp,
          marginStartProp
        ].map((key) => [key, el.style[key]])
      );
      const dim = dimensions$1(el);
      const currentMargin = toFloat(css(el, marginProp));
      const marginStart = toFloat(css(el, marginStartProp));
      const endDim = dim[dimProp] + marginStart;
      if (!inProgress && !show) {
        currentDim += marginStart;
      }
      const [wrapper] = wrapInner(el, "<div>");
      css(wrapper, {
        boxSizing: "border-box",
        height: dim.height,
        width: dim.width,
        ...css(el, [
          "overflow",
          "padding",
          "borderTop",
          "borderRight",
          "borderBottom",
          "borderLeft",
          "borderImage",
          marginStartProp
        ])
      });
      css(el, {
        padding: 0,
        border: 0,
        minWidth: 0,
        minHeight: 0,
        [marginStartProp]: 0,
        width: dim.width,
        height: dim.height,
        overflow: "hidden",
        [dimProp]: currentDim
      });
      const percent = currentDim / endDim;
      duration = (velocity * endDim + duration) * (show ? 1 - percent : percent);
      const endProps = { [dimProp]: show ? endDim : 0 };
      if (end) {
        css(el, marginProp, endDim - currentDim + currentMargin);
        endProps[marginProp] = show ? currentMargin : endDim + currentMargin;
      }
      if (!end ^ mode === "reveal") {
        css(wrapper, marginProp, -endDim + currentDim);
        Transition.start(wrapper, { [marginProp]: show ? 0 : -endDim }, duration, transition);
      }
      try {
        await Transition.start(el, endProps, duration, transition);
      } finally {
        css(el, prevProps);
        unwrap(wrapper.firstChild);
        if (!show) {
          _toggle(el, false);
        }
      }
    }
    function toggleAnimation(el, show, cmp) {
      const { animation, duration, _toggle } = cmp;
      if (show) {
        _toggle(el, true);
        return Animation.in(el, animation[0], duration, cmp.origin);
      }
      return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(
        () => _toggle(el, false)
      );
    }

    const active$1 = [];
    var Modal = {
      mixins: [Class, Container, Togglable],
      props: {
        selPanel: String,
        selClose: String,
        escClose: Boolean,
        bgClose: Boolean,
        stack: Boolean,
        role: String
      },
      data: {
        cls: "uk-open",
        escClose: true,
        bgClose: true,
        overlay: true,
        stack: false,
        role: "dialog"
      },
      computed: {
        panel: ({ selPanel }, $el) => $(selPanel, $el),
        transitionElement() {
          return this.panel;
        }
      },
      connected() {
        attr(this.panel || this.$el, "role", this.role);
        if (this.overlay) {
          attr(this.panel || this.$el, "aria-modal", true);
        }
      },
      beforeDisconnect() {
        if (includes(active$1, this)) {
          this.toggleElement(this.$el, false, false);
        }
      },
      events: [
        {
          name: "click",
          delegate: ({ selClose }) => `${selClose},a[href*="#"]`,
          handler(e) {
            const { current, defaultPrevented } = e;
            const { hash } = current;
            if (!defaultPrevented && hash && isSameSiteAnchor(current) && !this.$el.contains($(hash))) {
              this.hide();
            } else if (matches(current, this.selClose)) {
              e.preventDefault();
              this.hide();
            }
          }
        },
        {
          name: "toggle",
          self: true,
          handler(e) {
            if (e.defaultPrevented) {
              return;
            }
            e.preventDefault();
            if (this.isToggled() === includes(active$1, this)) {
              this.toggle();
            }
          }
        },
        {
          name: "beforeshow",
          self: true,
          handler(e) {
            if (includes(active$1, this)) {
              return false;
            }
            if (!this.stack && active$1.length) {
              Promise.all(active$1.map((modal) => modal.hide())).then(this.show);
              e.preventDefault();
            } else {
              active$1.push(this);
            }
          }
        },
        {
          name: "show",
          self: true,
          handler() {
            if (this.stack) {
              css(this.$el, "zIndex", toFloat(css(this.$el, "zIndex")) + active$1.length);
            }
            const handlers = [
              this.overlay && preventBackgroundFocus(this),
              this.overlay && preventBackgroundScroll(this.$el),
              this.bgClose && listenForBackgroundClose$1(this),
              this.escClose && listenForEscClose$1(this)
            ];
            once(
              this.$el,
              "hidden",
              () => handlers.forEach((handler) => handler && handler()),
              { self: true }
            );
            addClass(document.documentElement, this.clsPage);
          }
        },
        {
          name: "shown",
          self: true,
          handler() {
            if (!isFocusable(this.$el)) {
              attr(this.$el, "tabindex", "-1");
            }
            if (!matches(this.$el, ":focus-within")) {
              this.$el.focus();
            }
          }
        },
        {
          name: "hidden",
          self: true,
          handler() {
            if (includes(active$1, this)) {
              active$1.splice(active$1.indexOf(this), 1);
            }
            css(this.$el, "zIndex", "");
            if (!active$1.some((modal) => modal.clsPage === this.clsPage)) {
              removeClass(document.documentElement, this.clsPage);
            }
          }
        }
      ],
      methods: {
        toggle() {
          return this.isToggled() ? this.hide() : this.show();
        },
        show() {
          if (this.container && parent(this.$el) !== this.container) {
            append(this.container, this.$el);
            return new Promise(
              (resolve) => requestAnimationFrame(() => this.show().then(resolve))
            );
          }
          return this.toggleElement(this.$el, true, animate$1);
        },
        hide() {
          return this.toggleElement(this.$el, false, animate$1);
        }
      }
    };
    function animate$1(el, show, { transitionElement, _toggle }) {
      return new Promise(
        (resolve, reject) => once(el, "show hide", () => {
          var _a;
          (_a = el._reject) == null ? void 0 : _a.call(el);
          el._reject = reject;
          _toggle(el, show);
          const off = once(
            transitionElement,
            "transitionstart",
            () => {
              once(transitionElement, "transitionend transitioncancel", resolve, {
                self: true
              });
              clearTimeout(timer);
            },
            { self: true }
          );
          const timer = setTimeout(
            () => {
              off();
              resolve();
            },
            toMs(css(transitionElement, "transitionDuration"))
          );
        })
      ).then(() => delete el._reject);
    }
    function toMs(time) {
      return time ? endsWith(time, "ms") ? toFloat(time) : toFloat(time) * 1e3 : 0;
    }
    function preventBackgroundFocus(modal) {
      return on(document, "focusin", (e) => {
        if (last(active$1) === modal && !modal.$el.contains(e.target)) {
          modal.$el.focus();
        }
      });
    }
    function listenForBackgroundClose$1(modal) {
      return on(document, pointerDown$1, ({ target }) => {
        if (last(active$1) !== modal || modal.overlay && !modal.$el.contains(target) || !modal.panel || modal.panel.contains(target)) {
          return;
        }
        once(
          document,
          `${pointerUp$1} ${pointerCancel} scroll`,
          ({ defaultPrevented, type, target: newTarget }) => {
            if (!defaultPrevented && type === pointerUp$1 && target === newTarget) {
              modal.hide();
            }
          },
          true
        );
      });
    }
    function listenForEscClose$1(modal) {
      return on(document, "keydown", (e) => {
        if (e.keyCode === 27 && last(active$1) === modal) {
          modal.hide();
        }
      });
    }

    var Animations$2 = {
      slide: {
        show(dir) {
          return [{ transform: translate(dir * -100) }, { transform: translate() }];
        },
        percent(current) {
          return translated(current);
        },
        translate(percent, dir) {
          return [
            { transform: translate(dir * -100 * percent) },
            { transform: translate(dir * 100 * (1 - percent)) }
          ];
        }
      }
    };
    function translated(el) {
      return Math.abs(new DOMMatrix(css(el, "transform")).m41 / el.offsetWidth);
    }
    function translate(value = 0, unit = "%") {
      return value ? `translate3d(${value + unit}, 0, 0)` : "";
    }

    function Transitioner$1(prev, next, dir, { animation, easing }) {
      const { percent, translate, show = noop } = animation;
      const props = show(dir);
      const { promise, resolve } = withResolvers();
      return {
        dir,
        show(duration, percent2 = 0, linear) {
          const timing = linear ? "linear" : easing;
          duration -= Math.round(duration * clamp(percent2, -1, 1));
          this.translate(percent2);
          triggerUpdate(next, "itemin", { percent: percent2, duration, timing, dir });
          triggerUpdate(prev, "itemout", { percent: 1 - percent2, duration, timing, dir });
          Promise.all([
            Transition.start(next, props[1], duration, timing),
            Transition.start(prev, props[0], duration, timing)
          ]).then(() => {
            this.reset();
            resolve();
          }, noop);
          return promise;
        },
        cancel() {
          return Transition.cancel([next, prev]);
        },
        reset() {
          for (const prop in props[0]) {
            css([next, prev], prop, "");
          }
        },
        async forward(duration, percent2 = this.percent()) {
          await this.cancel();
          return this.show(duration, percent2, true);
        },
        translate(percent2) {
          this.reset();
          const props2 = translate(percent2, dir);
          css(next, props2[1]);
          css(prev, props2[0]);
          triggerUpdate(next, "itemtranslatein", { percent: percent2, dir });
          triggerUpdate(prev, "itemtranslateout", { percent: 1 - percent2, dir });
        },
        percent() {
          return percent(prev || next, next, dir);
        },
        getDistance() {
          return prev == null ? void 0 : prev.offsetWidth;
        }
      };
    }
    function triggerUpdate(el, type, data) {
      trigger(el, createEvent(type, false, false, data));
    }
    function withResolvers() {
      let resolve;
      return { promise: new Promise((res) => resolve = res), resolve };
    }

    var I18n = {
      props: {
        i18n: Object
      },
      data: {
        i18n: null
      },
      methods: {
        t(key, ...params) {
          var _a, _b, _c;
          let i = 0;
          return ((_c = ((_a = this.i18n) == null ? void 0 : _a[key]) || ((_b = this.$options.i18n) == null ? void 0 : _b[key])) == null ? void 0 : _c.replace(
            /%s/g,
            () => params[i++] || ""
          )) || "";
        }
      }
    };

    var SliderAutoplay = {
      props: {
        autoplay: Boolean,
        autoplayInterval: Number,
        pauseOnHover: Boolean
      },
      data: {
        autoplay: false,
        autoplayInterval: 7e3,
        pauseOnHover: true
      },
      connected() {
        attr(this.list, "aria-live", this.autoplay ? "off" : "polite");
        this.autoplay && this.startAutoplay();
      },
      disconnected() {
        this.stopAutoplay();
      },
      update() {
        attr(this.slides, "tabindex", "-1");
      },
      events: [
        {
          name: "visibilitychange",
          el: () => document,
          filter: ({ autoplay }) => autoplay,
          handler() {
            if (document.hidden) {
              this.stopAutoplay();
            } else {
              this.startAutoplay();
            }
          }
        }
      ],
      methods: {
        startAutoplay() {
          this.stopAutoplay();
          this.interval = setInterval(() => {
            if (!(this.stack.length || this.draggable && matches(this.$el, ":focus-within") && !matches(this.$el, ":focus") || this.pauseOnHover && matches(this.$el, ":hover"))) {
              this.show("next");
            }
          }, this.autoplayInterval);
        },
        stopAutoplay() {
          clearInterval(this.interval);
        }
      }
    };

    const pointerOptions = { passive: false, capture: true };
    const pointerUpOptions = { passive: true, capture: true };
    const pointerDown = "touchstart mousedown";
    const pointerMove = "touchmove mousemove";
    const pointerUp = "touchend touchcancel mouseup click input scroll";
    var SliderDrag = {
      props: {
        draggable: Boolean
      },
      data: {
        draggable: true,
        threshold: 10
      },
      created() {
        for (const key of ["start", "move", "end"]) {
          const fn = this[key];
          this[key] = (e) => {
            const pos = getEventPos(e).x * (isRtl ? -1 : 1);
            this.prevPos = pos === this.pos ? this.prevPos : this.pos;
            this.pos = pos;
            fn(e);
          };
        }
      },
      events: [
        {
          name: pointerDown,
          passive: true,
          delegate: ({ selList }) => `${selList} > *`,
          handler(e) {
            if (!this.draggable || this.parallax || !isTouch(e) && hasSelectableText(e.target) || e.target.closest(selInput) || e.button > 0 || this.length < 2) {
              return;
            }
            this.start(e);
          }
        },
        {
          name: "dragstart",
          handler(e) {
            e.preventDefault();
          }
        },
        {
          // iOS workaround for slider stopping if swiping fast
          name: pointerMove,
          el: ({ list }) => list,
          handler: noop,
          ...pointerOptions
        }
      ],
      methods: {
        start() {
          this.drag = this.pos;
          if (this._transitioner) {
            this.percent = this._transitioner.percent();
            this.drag += this._transitioner.getDistance() * this.percent * this.dir;
            this._transitioner.cancel();
            this._transitioner.translate(this.percent);
            this.dragging = true;
            this.stack = [];
          } else {
            this.prevIndex = this.index;
          }
          on(document, pointerMove, this.move, pointerOptions);
          on(document, pointerUp, this.end, pointerUpOptions);
          css(this.list, "userSelect", "none");
        },
        move(e) {
          const distance = this.pos - this.drag;
          if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) {
            return;
          }
          e.cancelable && e.preventDefault();
          this.dragging = true;
          this.dir = distance < 0 ? 1 : -1;
          let { slides, prevIndex } = this;
          let dis = Math.abs(distance);
          let nextIndex = this.getIndex(prevIndex + this.dir);
          let width = getDistance.call(this, prevIndex, nextIndex);
          while (nextIndex !== prevIndex && dis > width) {
            this.drag -= width * this.dir;
            prevIndex = nextIndex;
            dis -= width;
            nextIndex = this.getIndex(prevIndex + this.dir);
            width = getDistance.call(this, prevIndex, nextIndex);
          }
          this.percent = dis / width;
          const prev = slides[prevIndex];
          const next = slides[nextIndex];
          const changed = this.index !== nextIndex;
          const edge = prevIndex === nextIndex;
          let itemShown;
          for (const i of [this.index, this.prevIndex]) {
            if (!includes([nextIndex, prevIndex], i)) {
              trigger(slides[i], "itemhidden", [this]);
              if (edge) {
                itemShown = true;
                this.prevIndex = prevIndex;
              }
            }
          }
          if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {
            trigger(slides[this.index], "itemshown", [this]);
          }
          if (changed) {
            this.prevIndex = prevIndex;
            this.index = nextIndex;
            if (!edge) {
              trigger(prev, "beforeitemhide", [this]);
              trigger(prev, "itemhide", [this]);
            }
            trigger(next, "beforeitemshow", [this]);
            trigger(next, "itemshow", [this]);
          }
          this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);
        },
        end() {
          off(document, pointerMove, this.move, pointerOptions);
          off(document, pointerUp, this.end, pointerUpOptions);
          if (this.dragging) {
            setTimeout(on(this.list, "click", (e) => e.preventDefault(), pointerOptions));
            this.dragging = null;
            if (this.index === this.prevIndex) {
              this.percent = 1 - this.percent;
              this.dir *= -1;
              this._show(false, this.index, true);
              this._transitioner = null;
            } else {
              const dirChange = (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos;
              this.index = dirChange ? this.index : this.prevIndex;
              if (dirChange) {
                trigger(this.slides[this.prevIndex], "itemhidden", [this]);
                trigger(this.slides[this.index], "itemshown", [this]);
                this.percent = 1 - this.percent;
              }
              this.show(
                this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? "next" : "previous",
                true
              );
            }
          }
          css(this.list, { userSelect: "" });
          this.drag = this.percent = null;
        }
      }
    };
    function getDistance(prev, next) {
      return this._getTransitioner(prev, prev !== next && next).getDistance() || this.slides[prev].offsetWidth;
    }
    function hasSelectableText(el) {
      return css(el, "userSelect") !== "none" && toArray(el.childNodes).some((el2) => el2.nodeType === 3 && el2.textContent.trim());
    }

    function initWatches(instance) {
      instance._watches = [];
      for (const watches of instance.$options.watch || []) {
        for (const [name, watch] of Object.entries(watches)) {
          registerWatch(instance, watch, name);
        }
      }
      instance._initial = true;
    }
    function registerWatch(instance, watch, name) {
      instance._watches.push({
        name,
        ...isPlainObject(watch) ? watch : { handler: watch }
      });
    }
    function runWatches(instance, values) {
      for (const { name, handler, immediate = true } of instance._watches) {
        if (instance._initial && immediate || hasOwn(values, name) && !isEqual(values[name], instance[name])) {
          handler.call(instance, instance[name], values[name]);
        }
      }
      instance._initial = false;
    }

    function initComputed(instance) {
      const { computed } = instance.$options;
      instance._computed = {};
      if (computed) {
        for (const key in computed) {
          registerComputed(instance, key, computed[key]);
        }
      }
    }
    const mutationOptions = { subtree: true, childList: true };
    function registerComputed(instance, key, cb) {
      instance._hasComputed = true;
      Object.defineProperty(instance, key, {
        enumerable: true,
        get() {
          const { _computed, $props, $el } = instance;
          if (!hasOwn(_computed, key)) {
            _computed[key] = (cb.get || cb).call(instance, $props, $el);
            if (cb.observe && instance._computedObserver) {
              const selector = cb.observe.call(instance, $props);
              instance._computedObserver.observe(
                ["~", "+", "-"].includes(selector[0]) ? $el.parentElement : $el.getRootNode(),
                mutationOptions
              );
            }
          }
          return _computed[key];
        },
        set(value) {
          const { _computed } = instance;
          _computed[key] = cb.set ? cb.set.call(instance, value) : value;
          if (isUndefined(_computed[key])) {
            delete _computed[key];
          }
        }
      });
    }
    function initComputedUpdates(instance) {
      if (!instance._hasComputed) {
        return;
      }
      prependUpdate(instance, {
        read: () => runWatches(instance, resetComputed(instance)),
        events: ["resize", "computed"]
      });
      instance._computedObserver = observeMutation(
        instance.$el,
        () => callUpdate(instance, "computed"),
        mutationOptions
      );
      instance._disconnect.push(() => {
        instance._computedObserver.disconnect();
        instance._computedObserver = null;
        resetComputed(instance);
      });
    }
    function resetComputed(instance) {
      const values = { ...instance._computed };
      instance._computed = {};
      return values;
    }

    function initEvents(instance) {
      for (const event of instance.$options.events || []) {
        if (hasOwn(event, "handler")) {
          registerEvent(instance, event);
        } else {
          for (const key in event) {
            registerEvent(instance, { name: key, handler: event[key] });
          }
        }
      }
    }
    function registerEvent(instance, { name, el, handler, capture, passive, delegate, filter, self }) {
      if (filter && !filter.call(instance, instance)) {
        return;
      }
      instance._disconnect.push(
        on(
          el ? el.call(instance, instance) : instance.$el,
          name,
          delegate == null ? void 0 : delegate.call(instance, instance),
          handler.bind(instance),
          {
            passive,
            capture,
            self
          }
        )
      );
    }

    function initObservers(instance) {
      for (const observer of instance.$options.observe || []) {
        registerObservable(instance, observer);
      }
    }
    function registerObservable(instance, observable) {
      let { observe, target = instance.$el, handler, options, filter, args } = observable;
      if (filter && !filter.call(instance, instance)) {
        return;
      }
      const key = `_observe${instance._disconnect.length}`;
      if (isFunction(target) && !hasOwn(instance, key)) {
        registerComputed(instance, key, () => {
          const targets2 = target.call(instance, instance);
          return isArray(targets2) ? toNodes(targets2) : targets2;
        });
      }
      handler = isString(handler) ? instance[handler] : handler.bind(instance);
      if (isFunction(options)) {
        options = options.call(instance, instance);
      }
      const targets = hasOwn(instance, key) ? instance[key] : target;
      const observer = observe(targets, handler, options, args);
      if (isFunction(target) && isArray(instance[key])) {
        registerWatch(
          instance,
          { handler: updateTargets(observer, options), immediate: false },
          key
        );
      }
      instance._disconnect.push(() => observer.disconnect());
    }
    function updateTargets(observer, options) {
      return (targets, prev) => {
        for (const target of prev) {
          if (!includes(targets, target)) {
            if (observer.unobserve) {
              observer.unobserve(target);
            } else if (observer.observe) {
              observer.disconnect();
            }
          }
        }
        for (const target of targets) {
          if (!includes(prev, target) || !observer.unobserve) {
            observer.observe(target, options);
          }
        }
      };
    }

    function initProps(instance) {
      const { $options, $props } = instance;
      const props = getProps($options);
      assign($props, props);
      const { computed, methods } = $options;
      for (let key in $props) {
        if (key in props && (!computed || !hasOwn(computed, key)) && (!methods || !hasOwn(methods, key))) {
          instance[key] = $props[key];
        }
      }
    }
    function getProps(opts) {
      const data$1 = {};
      const { args = [], props = {}, el, id } = opts;
      if (!props) {
        return data$1;
      }
      for (const key in props) {
        const prop = hyphenate(key);
        let value = data(el, prop);
        if (isUndefined(value)) {
          continue;
        }
        value = props[key] === Boolean && value === "" ? true : coerce$1(props[key], value);
        if (prop === "target" && startsWith(value, "_")) {
          continue;
        }
        data$1[key] = value;
      }
      const options = parseOptions(data(el, id), args);
      for (const key in options) {
        const prop = camelize(key);
        if (!isUndefined(props[prop])) {
          data$1[prop] = coerce$1(props[prop], options[key]);
        }
      }
      return data$1;
    }
    const getAttributes = memoize((id, props) => {
      const attributes = Object.keys(props);
      const filter = attributes.concat(id).map((key) => [hyphenate(key), `data-${hyphenate(key)}`]).flat();
      return { attributes, filter };
    });
    function initPropsObserver(instance) {
      const { $options, $props } = instance;
      const { id, props, el } = $options;
      if (!props) {
        return;
      }
      const { attributes, filter } = getAttributes(id, props);
      const observer = new MutationObserver((records) => {
        const data = getProps($options);
        if (records.some(({ attributeName }) => {
          const prop = attributeName.replace("data-", "");
          return (prop === id ? attributes : [camelize(prop), camelize(attributeName)]).some(
            (prop2) => !isUndefined(data[prop2]) && data[prop2] !== $props[prop2]
          );
        })) {
          instance.$reset();
        }
      });
      observer.observe(el, {
        attributes: true,
        attributeFilter: filter
      });
      instance._disconnect.push(() => observer.disconnect());
    }

    function callHook(instance, hook) {
      var _a;
      (_a = instance.$options[hook]) == null ? void 0 : _a.forEach((handler) => handler.call(instance));
    }
    function callConnected(instance) {
      if (instance._connected) {
        return;
      }
      initProps(instance);
      callHook(instance, "beforeConnect");
      instance._connected = true;
      instance._disconnect = [];
      initEvents(instance);
      initUpdates(instance);
      initWatches(instance);
      initObservers(instance);
      initPropsObserver(instance);
      initComputedUpdates(instance);
      callHook(instance, "connected");
      callUpdate(instance);
    }
    function callDisconnected(instance) {
      if (!instance._connected) {
        return;
      }
      callHook(instance, "beforeDisconnect");
      instance._disconnect.forEach((off) => off());
      instance._disconnect = null;
      callHook(instance, "disconnected");
      instance._connected = false;
    }

    let uid = 0;
    function init$1(instance, options = {}) {
      options.data = normalizeData(options, instance.constructor.options);
      instance.$options = mergeOptions(instance.constructor.options, options, instance);
      instance.$props = {};
      instance._uid = uid++;
      initData(instance);
      initMethods(instance);
      initComputed(instance);
      callHook(instance, "created");
      if (options.el) {
        instance.$mount(options.el);
      }
    }
    function initData(instance) {
      const { data = {} } = instance.$options;
      for (const key in data) {
        instance.$props[key] = instance[key] = data[key];
      }
    }
    function initMethods(instance) {
      const { methods } = instance.$options;
      if (methods) {
        for (const key in methods) {
          instance[key] = methods[key].bind(instance);
        }
      }
    }
    function normalizeData({ data = {} }, { args = [], props = {} }) {
      if (isArray(data)) {
        data = data.slice(0, args.length).reduce((data2, value, index) => {
          if (isPlainObject(value)) {
            assign(data2, value);
          } else {
            data2[args[index]] = value;
          }
          return data2;
        }, {});
      }
      for (const key in data) {
        if (isUndefined(data[key])) {
          delete data[key];
        } else if (props[key]) {
          data[key] = coerce$1(props[key], data[key]);
        }
      }
      return data;
    }

    const App = function(options) {
      init$1(this, options);
    };
    App.util = util;
    App.options = {};
    App.version = "3.22.0";

    const PREFIX = "uk-";
    const DATA = "__uikit__";
    const components$2 = {};
    function component(name, options) {
      var _a, _b;
      const id = PREFIX + hyphenate(name);
      if (!options) {
        if (!components$2[id].options) {
          components$2[id] = App.extend(components$2[id]);
        }
        return components$2[id];
      }
      name = camelize(name);
      App[name] = (element, data) => createComponent(name, element, data);
      const opt = (_a = options.options) != null ? _a : { ...options };
      opt.id = id;
      opt.name = name;
      (_b = opt.install) == null ? void 0 : _b.call(opt, App, opt, name);
      if (App._initialized && !opt.functional) {
        requestAnimationFrame(() => createComponent(name, `[${id}],[data-${id}]`));
      }
      return components$2[id] = opt;
    }
    function createComponent(name, element, data, ...args) {
      const Component = component(name);
      return Component.options.functional ? new Component({ data: isPlainObject(element) ? element : [element, data, ...args] }) : element ? $$(element).map(init)[0] : init();
      function init(element2) {
        const instance = getComponent(element2, name);
        if (instance) {
          if (data) {
            instance.$destroy();
          } else {
            return instance;
          }
        }
        return new Component({ el: element2, data });
      }
    }
    function getComponents(element) {
      return (element == null ? void 0 : element[DATA]) || {};
    }
    function getComponent(element, name) {
      return getComponents(element)[name];
    }
    function attachToElement(element, instance) {
      if (!element[DATA]) {
        element[DATA] = {};
      }
      element[DATA][instance.$options.name] = instance;
    }
    function detachFromElement(element, instance) {
      var _a;
      (_a = element[DATA]) == null ? true : delete _a[instance.$options.name];
      if (isEmpty(element[DATA])) {
        delete element[DATA];
      }
    }

    function globalApi(App) {
      App.component = component;
      App.getComponents = getComponents;
      App.getComponent = getComponent;
      App.update = update;
      App.use = function(plugin) {
        if (plugin.installed) {
          return;
        }
        plugin.call(null, this);
        plugin.installed = true;
        return this;
      };
      App.mixin = function(mixin, component2) {
        component2 = (isString(component2) ? this.component(component2) : component2) || this;
        component2.options = mergeOptions(component2.options, mixin);
      };
      App.extend = function(options) {
        options || (options = {});
        const Super = this;
        const Sub = function UIkitComponent(options2) {
          init$1(this, options2);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.options = mergeOptions(Super.options, options);
        Sub.super = Super;
        Sub.extend = Super.extend;
        return Sub;
      };
      let container;
      Object.defineProperty(App, "container", {
        get() {
          return container || document.body;
        },
        set(element) {
          container = $(element);
        }
      });
    }
    function update(element, e) {
      element = element ? toNode(element) : document.body;
      for (const parentEl of parents(element).reverse()) {
        updateElement(parentEl, e);
      }
      apply(element, (element2) => updateElement(element2, e));
    }
    function updateElement(element, e) {
      const components = getComponents(element);
      for (const name in components) {
        callUpdate(components[name], e);
      }
    }

    function instanceApi(App) {
      App.prototype.$mount = function(el) {
        const instance = this;
        attachToElement(el, instance);
        instance.$options.el = el;
        if (el.isConnected) {
          callConnected(instance);
        }
      };
      App.prototype.$destroy = function(removeEl = false) {
        const instance = this;
        const { el } = instance.$options;
        if (el) {
          callDisconnected(instance);
        }
        callHook(instance, "destroy");
        detachFromElement(el, instance);
        if (removeEl) {
          remove$1(instance.$el);
        }
      };
      App.prototype.$create = createComponent;
      App.prototype.$emit = function(e) {
        callUpdate(this, e);
      };
      App.prototype.$update = function(element = this.$el, e) {
        update(element, e);
      };
      App.prototype.$reset = function() {
        callDisconnected(this);
        callConnected(this);
      };
      App.prototype.$getComponent = getComponent;
      Object.defineProperties(App.prototype, {
        $el: {
          get() {
            return this.$options.el;
          }
        },
        $container: Object.getOwnPropertyDescriptor(App, "container")
      });
    }
    let id = 1;
    function generateId(instance, el = null) {
      return (el == null ? void 0 : el.id) || `${instance.$options.id}-${id++}`;
    }

    var SliderNav = {
      i18n: {
        next: "Next slide",
        previous: "Previous slide",
        slideX: "Slide %s",
        slideLabel: "%s of %s",
        role: "String"
      },
      data: {
        selNav: false,
        role: "region"
      },
      computed: {
        nav: ({ selNav }, $el) => $(selNav, $el),
        navChildren() {
          return children(this.nav);
        },
        selNavItem: ({ attrItem }) => `[${attrItem}],[data-${attrItem}]`,
        navItems(_, $el) {
          return $$(this.selNavItem, $el);
        }
      },
      watch: {
        nav(nav, prev) {
          attr(nav, "role", "tablist");
          this.padNavitems();
          if (prev) {
            this.$emit();
          }
        },
        list(list) {
          if (isTag(list, "ul")) {
            attr(list, "role", "presentation");
          }
        },
        navChildren(children2) {
          attr(children2, "role", "presentation");
          this.padNavitems();
          this.updateNav();
        },
        navItems(items) {
          for (const el of items) {
            const cmd = data(el, this.attrItem);
            const button = $("a,button", el) || el;
            let ariaLabel;
            let ariaControls = null;
            if (isNumeric(cmd)) {
              const item = toNumber(cmd);
              const slide = this.slides[item];
              if (slide) {
                if (!slide.id) {
                  slide.id = generateId(this, slide);
                }
                ariaControls = slide.id;
              }
              ariaLabel = this.t("slideX", toFloat(cmd) + 1);
              attr(button, "role", "tab");
            } else {
              if (this.list) {
                if (!this.list.id) {
                  this.list.id = generateId(this, this.list);
                }
                ariaControls = this.list.id;
              }
              ariaLabel = this.t(cmd);
            }
            attr(button, {
              "aria-controls": ariaControls,
              "aria-label": attr(button, "aria-label") || ariaLabel
            });
          }
        },
        slides(slides) {
          slides.forEach(
            (slide, i) => attr(slide, {
              role: this.nav ? "tabpanel" : "group",
              "aria-label": this.t("slideLabel", i + 1, this.length),
              "aria-roledescription": this.nav ? null : "slide"
            })
          );
          this.padNavitems();
        }
      },
      connected() {
        attr(this.$el, {
          role: this.role,
          "aria-roledescription": "carousel"
        });
      },
      update: [
        {
          write() {
            this.navItems.concat(this.nav).forEach((el) => el && (el.hidden = !this.maxIndex));
            this.updateNav();
          },
          events: ["resize"]
        }
      ],
      events: [
        {
          name: "click keydown",
          delegate: ({ selNavItem }) => selNavItem,
          filter: ({ parallax }) => !parallax,
          handler(e) {
            if (e.target.closest("a,button") && (e.type === "click" || e.keyCode === keyMap.SPACE)) {
              e.preventDefault();
              this.show(data(e.current, this.attrItem));
            }
          }
        },
        {
          name: "itemshow",
          handler() {
            this.updateNav();
          }
        },
        {
          name: "keydown",
          delegate: ({ selNavItem }) => selNavItem,
          filter: ({ parallax }) => !parallax,
          handler(e) {
            const { current, keyCode } = e;
            const cmd = data(current, this.attrItem);
            if (!isNumeric(cmd)) {
              return;
            }
            let i = keyCode === keyMap.HOME ? 0 : keyCode === keyMap.END ? "last" : keyCode === keyMap.LEFT ? "previous" : keyCode === keyMap.RIGHT ? "next" : -1;
            if (~i) {
              e.preventDefault();
              this.show(i);
            }
          }
        }
      ],
      methods: {
        updateNav() {
          const index = this.getValidIndex();
          for (const el of this.navItems) {
            const cmd = data(el, this.attrItem);
            const button = $("a,button", el) || el;
            if (isNumeric(cmd)) {
              const item = toNumber(cmd);
              const active = item === index;
              toggleClass(el, this.clsActive, active);
              toggleClass(button, "uk-disabled", !!this.parallax);
              attr(button, {
                "aria-selected": active,
                tabindex: active && !this.parallax ? null : -1
              });
              if (active && button && matches(parent(el), ":focus-within")) {
                button.focus();
              }
            } else {
              toggleClass(
                el,
                "uk-invisible",
                this.finite && (cmd === "previous" && index === 0 || cmd === "next" && index >= this.maxIndex)
              );
            }
          }
        },
        padNavitems() {
          if (!this.nav) {
            return;
          }
          const children2 = [];
          for (let i = 0; i < this.length; i++) {
            const attr2 = `${this.attrItem}="${i}"`;
            children2[i] = this.navChildren.findLast((el) => el.matches(`[${attr2}]`)) || $(`<li ${attr2}><a href></a></li>`);
          }
          if (!isEqual(children2, this.navChildren)) {
            html(this.nav, children2);
          }
        }
      }
    };

    const easeOutQuad = "cubic-bezier(0.25, 0.46, 0.45, 0.94)";
    const easeOutQuart = "cubic-bezier(0.165, 0.84, 0.44, 1)";
    var Slider = {
      mixins: [SliderAutoplay, SliderDrag, SliderNav, I18n],
      props: {
        clsActivated: String,
        easing: String,
        index: Number,
        finite: Boolean,
        velocity: Number
      },
      data: () => ({
        easing: "ease",
        finite: false,
        velocity: 1,
        index: 0,
        prevIndex: -1,
        stack: [],
        percent: 0,
        clsActive: "uk-active",
        clsActivated: "",
        clsEnter: "uk-slide-enter",
        clsLeave: "uk-slide-leave",
        clsSlideActive: "uk-slide-active",
        Transitioner: false,
        transitionOptions: {}
      }),
      connected() {
        this.prevIndex = -1;
        this.index = this.getValidIndex(this.$props.index);
        this.stack = [];
      },
      disconnected() {
        removeClass(this.slides, this.clsActive);
      },
      computed: {
        duration: ({ velocity }, $el) => speedUp($el.offsetWidth / velocity),
        list: ({ selList }, $el) => $(selList, $el),
        maxIndex() {
          return this.length - 1;
        },
        slides() {
          return children(this.list);
        },
        length() {
          return this.slides.length;
        }
      },
      watch: {
        slides(slides, prev) {
          if (prev) {
            this.$emit();
          }
        }
      },
      events: {
        itemshow({ target }) {
          addClass(target, this.clsEnter, this.clsSlideActive);
        },
        itemshown({ target }) {
          removeClass(target, this.clsEnter);
        },
        itemhide({ target }) {
          addClass(target, this.clsLeave);
        },
        itemhidden({ target }) {
          removeClass(target, this.clsLeave, this.clsSlideActive);
        }
      },
      methods: {
        async show(index, force = false) {
          var _a;
          if (this.dragging || !this.length || this.parallax) {
            return;
          }
          const { stack } = this;
          const queueIndex = force ? 0 : stack.length;
          const reset = () => {
            stack.splice(queueIndex, 1);
            if (stack.length) {
              this.show(stack.shift(), true);
            }
          };
          stack[force ? "unshift" : "push"](index);
          if (!force && stack.length > 1) {
            if (stack.length === 2) {
              (_a = this._transitioner) == null ? void 0 : _a.forward(Math.min(this.duration, 200));
            }
            return;
          }
          const prevIndex = this.getIndex(this.index);
          const prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];
          const nextIndex = this.getIndex(index, this.index);
          const next = this.slides[nextIndex];
          if (prev === next) {
            reset();
            return;
          }
          this.dir = getDirection(index, prevIndex);
          this.prevIndex = prevIndex;
          this.index = nextIndex;
          if (prev && !trigger(prev, "beforeitemhide", [this]) || !trigger(next, "beforeitemshow", [this, prev])) {
            this.index = this.prevIndex;
            reset();
            return;
          }
          prev && trigger(prev, "itemhide", [this]);
          trigger(next, "itemshow", [this]);
          await this._show(prev, next, force);
          prev && trigger(prev, "itemhidden", [this]);
          trigger(next, "itemshown", [this]);
          stack.shift();
          this._transitioner = null;
          if (stack.length) {
            requestAnimationFrame(() => stack.length && this.show(stack.shift(), true));
          }
        },
        getIndex(index = this.index, prev = this.index) {
          return clamp(
            getIndex(index, this.slides, prev, this.finite),
            0,
            Math.max(0, this.maxIndex)
          );
        },
        getValidIndex(index = this.index, prevIndex = this.prevIndex) {
          return this.getIndex(index, prevIndex);
        },
        async _show(prev, next, force) {
          this._transitioner = this._getTransitioner(prev, next, this.dir, {
            easing: force ? next.offsetWidth < 600 ? easeOutQuad : easeOutQuart : this.easing,
            ...this.transitionOptions
          });
          if (!force && !prev) {
            this._translate(1);
            return;
          }
          const { length } = this.stack;
          return this._transitioner[length > 1 ? "forward" : "show"](
            length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration,
            this.percent
          );
        },
        _translate(percent, prev = this.prevIndex, next = this.index) {
          const transitioner = this._getTransitioner(prev === next ? false : prev, next);
          transitioner.translate(percent);
          return transitioner;
        },
        _getTransitioner(prev = this.prevIndex, next = this.index, dir = this.dir || 1, options = this.transitionOptions) {
          return new this.Transitioner(
            isNumber(prev) ? this.slides[prev] : prev,
            isNumber(next) ? this.slides[next] : next,
            dir * (isRtl ? -1 : 1),
            options
          );
        }
      }
    };
    function getDirection(index, prevIndex) {
      return index === "next" ? 1 : index === "previous" ? -1 : index < prevIndex ? -1 : 1;
    }
    function speedUp(x) {
      return 0.5 * x + 300;
    }

    var Slideshow = {
      mixins: [Slider],
      props: {
        animation: String
      },
      data: {
        animation: "slide",
        clsActivated: "uk-transition-active",
        Animations: Animations$2,
        Transitioner: Transitioner$1
      },
      computed: {
        animation({ animation, Animations: Animations2 }) {
          return { ...Animations2[animation] || Animations2.slide, name: animation };
        },
        transitionOptions() {
          return { animation: this.animation };
        }
      },
      observe: resize(),
      events: {
        itemshow({ target }) {
          addClass(target, this.clsActive);
        },
        itemshown({ target }) {
          addClass(target, this.clsActivated);
        },
        itemhidden({ target }) {
          removeClass(target, this.clsActive, this.clsActivated);
        }
      }
    };

    var Animations$1 = {
      ...Animations$2,
      fade: {
        show() {
          return [{ opacity: 0, zIndex: 0 }, { zIndex: -1 }];
        },
        percent(current) {
          return 1 - css(current, "opacity");
        },
        translate(percent) {
          return [{ opacity: 1 - percent, zIndex: 0 }, { zIndex: -1 }];
        }
      },
      scale: {
        show() {
          return [{ opacity: 0, transform: scale3d(1 + 0.5), zIndex: 0 }, { zIndex: -1 }];
        },
        percent(current) {
          return 1 - css(current, "opacity");
        },
        translate(percent) {
          return [
            { opacity: 1 - percent, transform: scale3d(1 + 0.5 * percent), zIndex: 0 },
            { zIndex: -1 }
          ];
        }
      },
      pull: {
        show(dir) {
          return dir < 0 ? [
            { transform: translate(30), zIndex: -1 },
            { transform: translate(), zIndex: 0 }
          ] : [
            { transform: translate(-100), zIndex: 0 },
            { transform: translate(), zIndex: -1 }
          ];
        },
        percent(current, next, dir) {
          return dir < 0 ? 1 - translated(next) : translated(current);
        },
        translate(percent, dir) {
          return dir < 0 ? [
            { transform: translate(30 * percent), zIndex: -1 },
            { transform: translate(-100 * (1 - percent)), zIndex: 0 }
          ] : [
            { transform: translate(-percent * 100), zIndex: 0 },
            { transform: translate(30 * (1 - percent)), zIndex: -1 }
          ];
        }
      },
      push: {
        show(dir) {
          return dir < 0 ? [
            { transform: translate(100), zIndex: 0 },
            { transform: translate(), zIndex: -1 }
          ] : [
            { transform: translate(-30), zIndex: -1 },
            { transform: translate(), zIndex: 0 }
          ];
        },
        percent(current, next, dir) {
          return dir > 0 ? 1 - translated(next) : translated(current);
        },
        translate(percent, dir) {
          return dir < 0 ? [
            { transform: translate(percent * 100), zIndex: 0 },
            { transform: translate(-30 * (1 - percent)), zIndex: -1 }
          ] : [
            { transform: translate(-30 * percent), zIndex: -1 },
            { transform: translate(100 * (1 - percent)), zIndex: 0 }
          ];
        }
      }
    };
    function scale3d(value) {
      return `scale3d(${value}, ${value}, 1)`;
    }

    var Animations = {
      ...Animations$2,
      fade: {
        show() {
          return [{ opacity: 0 }, { opacity: 1 }];
        },
        percent(current) {
          return 1 - css(current, "opacity");
        },
        translate(percent) {
          return [{ opacity: 1 - percent }, { opacity: percent }];
        }
      },
      scale: {
        show() {
          return [
            { opacity: 0, transform: scale3d(1 - 0.2) },
            { opacity: 1, transform: scale3d(1) }
          ];
        },
        percent(current) {
          return 1 - css(current, "opacity");
        },
        translate(percent) {
          return [
            { opacity: 1 - percent, transform: scale3d(1 - 0.2 * percent) },
            { opacity: percent, transform: scale3d(1 - 0.2 + 0.2 * percent) }
          ];
        }
      }
    };

    var LightboxPanel = {
      i18n: {
        counter: "%s / %s"
      },
      mixins: [Modal, Slideshow],
      functional: true,
      props: {
        counter: Boolean,
        preload: Number,
        nav: Boolean,
        slidenav: Boolean,
        delayControls: Number,
        videoAutoplay: Boolean,
        template: String
      },
      data: () => ({
        counter: false,
        preload: 1,
        nav: false,
        slidenav: true,
        delayControls: 3e3,
        videoAutoplay: false,
        items: [],
        cls: "uk-open",
        clsPage: "uk-lightbox-page",
        clsFit: "uk-lightbox-items-fit",
        clsZoom: "uk-lightbox-zoom",
        attrItem: "uk-lightbox-item",
        selList: ".uk-lightbox-items",
        selClose: ".uk-close-large",
        selNav: ".uk-lightbox-thumbnav, .uk-lightbox-dotnav",
        selCaption: ".uk-lightbox-caption",
        selCounter: ".uk-lightbox-counter",
        pauseOnHover: false,
        velocity: 2,
        Animations,
        template: `<div class="uk-lightbox uk-overflow-hidden"> <div class="uk-lightbox-items"></div> <div class="uk-position-top-right uk-position-small uk-transition-fade" uk-inverse> <button class="uk-lightbox-close uk-close-large" type="button" uk-close></button> </div> <div class="uk-lightbox-slidenav uk-position-center-left uk-position-medium uk-transition-fade" uk-inverse> <a href uk-slidenav-previous uk-lightbox-item="previous"></a> </div> <div class="uk-lightbox-slidenav uk-position-center-right uk-position-medium uk-transition-fade" uk-inverse> <a href uk-slidenav-next uk-lightbox-item="next"></a> </div> <div class="uk-position-center-right uk-position-medium uk-transition-fade" uk-inverse style="max-height: 90vh; overflow: auto;"> <ul class="uk-lightbox-thumbnav uk-lightbox-thumbnav-vertical uk-thumbnav uk-thumbnav-vertical"></ul> <ul class="uk-lightbox-dotnav uk-dotnav uk-dotnav-vertical"></ul> </div> <div class="uk-lightbox-counter uk-text-large uk-position-top-left uk-position-small uk-transition-fade" uk-inverse></div> <div class="uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque"></div> </div>`
      }),
      created() {
        let $el = $(this.template);
        if (isTag($el, "template")) {
          $el = fragment(html($el));
        }
        const list = $(this.selList, $el);
        const navType = this.$props.nav;
        remove$1($$(this.selNav, $el).filter((el) => !matches(el, `.uk-${navType}`)));
        for (const [i, item] of this.items.entries()) {
          append(list, "<div>");
          if (navType === "thumbnav") {
            wrapAll(
              toThumbnavItem(item, this.videoAutoplay),
              append($(this.selNav, $el), `<li uk-lightbox-item="${i}"><a href></a></li>`)
            );
          }
        }
        if (!this.slidenav) {
          remove$1($$(".uk-lightbox-slidenav", $el));
        }
        if (!this.counter) {
          remove$1($(this.selCounter, $el));
        }
        addClass(list, this.clsFit);
        const close = $("[uk-close]", $el);
        const closeLabel = this.t("close");
        if (close && closeLabel) {
          close.dataset.i18n = JSON.stringify({ label: closeLabel });
        }
        this.$mount(append(this.container, $el));
      },
      events: [
        {
          name: "click",
          self: true,
          filter: ({ bgClose }) => bgClose,
          delegate: ({ selList }) => `${selList} > *`,
          handler(e) {
            if (!e.defaultPrevented) {
              this.hide();
            }
          }
        },
        {
          name: "click",
          self: true,
          delegate: ({ clsZoom }) => `.${clsZoom}`,
          handler(e) {
            if (!e.defaultPrevented) {
              toggleClass(this.list, this.clsFit);
            }
          }
        },
        {
          name: `${pointerMove$1} ${pointerDown$1} keydown`,
          filter: ({ delayControls }) => delayControls,
          handler() {
            this.showControls();
          }
        },
        {
          name: "shown",
          self: true,
          handler() {
            this.showControls();
          }
        },
        {
          name: "hide",
          self: true,
          handler() {
            this.hideControls();
            removeClass(this.slides, this.clsActive);
            Transition.stop(this.slides);
          }
        },
        {
          name: "hidden",
          self: true,
          handler() {
            this.$destroy(true);
          }
        },
        {
          name: "keyup",
          el: () => document,
          handler({ keyCode }) {
            if (!this.isToggled(this.$el) || !this.draggable) {
              return;
            }
            let i = -1;
            if (keyCode === keyMap.LEFT) {
              i = "previous";
            } else if (keyCode === keyMap.RIGHT) {
              i = "next";
            } else if (keyCode === keyMap.HOME) {
              i = 0;
            } else if (keyCode === keyMap.END) {
              i = "last";
            }
            if (~i) {
              this.show(i);
            }
          }
        },
        {
          name: "beforeitemshow",
          handler(e) {
            html($(this.selCaption, this.$el), this.getItem().caption || "");
            html(
              $(this.selCounter, this.$el),
              this.t("counter", this.index + 1, this.slides.length)
            );
            for (let j = -this.preload; j <= this.preload; j++) {
              this.loadItem(this.index + j);
            }
            if (this.isToggled()) {
              return;
            }
            this.draggable = false;
            e.preventDefault();
            this.toggleElement(this.$el, true, false);
            this.animation = Animations.scale;
            removeClass(e.target, this.clsActive);
            this.stack.splice(1, 0, this.index);
          }
        },
        {
          name: "itemshown",
          handler() {
            this.draggable = this.$props.draggable;
          }
        },
        {
          name: "itemload",
          async handler(_, item) {
            const { source: src, type, attrs = {} } = item;
            this.setItem(item, "<span uk-spinner uk-inverse></span>");
            if (!src) {
              return;
            }
            let matches2;
            const iframeAttrs = {
              allowfullscreen: "",
              style: "max-width: 100%; box-sizing: border-box;",
              "uk-responsive": "",
              "uk-video": `${Boolean(this.videoAutoplay)}`
            };
            if (type === "image" || isImage(src)) {
              const img = createEl("img");
              wrapInPicture(img, item.sources);
              attr(img, {
                src,
                ...pick(item, ["alt", "srcset", "sizes"]),
                ...attrs
              });
              on(img, "load", () => this.setItem(item, parent(img) || img));
              on(img, "error", () => this.setError(item));
            } else if (type === "video" || isVideo(src)) {
              const inline = this.videoAutoplay === "inline";
              const video = createEl("video", {
                src,
                playsinline: "",
                controls: inline ? null : "",
                loop: inline ? "" : null,
                poster: this.videoAutoplay ? null : item.poster,
                "uk-video": inline ? "automute: true" : Boolean(this.videoAutoplay),
                ...attrs
              });
              on(video, "loadedmetadata", () => this.setItem(item, video));
              on(video, "error", () => this.setError(item));
            } else if (type === "iframe" || src.match(/\.(html|php)($|\?)/i)) {
              this.setItem(
                item,
                createEl("iframe", {
                  src,
                  allowfullscreen: "",
                  class: "uk-lightbox-iframe",
                  ...attrs
                })
              );
            } else if (matches2 = src.match(
              /\/\/(?:.*?youtube(-nocookie)?\..*?(?:[?&]v=|\/shorts\/)|youtu\.be\/)([\w-]{11})[&?]?(.*)?/
            )) {
              this.setItem(
                item,
                createEl("iframe", {
                  src: `https://www.youtube${matches2[1] || ""}.com/embed/${matches2[2]}${matches2[3] ? `?${matches2[3]}` : ""}`,
                  width: 1920,
                  height: 1080,
                  ...iframeAttrs,
                  ...attrs
                })
              );
            } else if (matches2 = src.match(/\/\/.*?vimeo\.[a-z]+\/(\d+)[&?]?(.*)?/)) {
              try {
                const { height, width } = await (await fetch(
                  `https://vimeo.com/api/oembed.json?maxwidth=1920&url=${encodeURI(
                src
              )}`,
                  { credentials: "omit" }
                )).json();
                this.setItem(
                  item,
                  createEl("iframe", {
                    src: `https://player.vimeo.com/video/${matches2[1]}${matches2[2] ? `?${matches2[2]}` : ""}`,
                    width,
                    height,
                    ...iframeAttrs,
                    ...attrs
                  })
                );
              } catch (e) {
                this.setError(item);
              }
            }
          }
        },
        {
          name: "itemloaded",
          handler() {
            this.$emit("resize");
          }
        }
      ],
      update: {
        read() {
          for (const media of $$(`${this.selList} :not([controls]):is(img,video)`, this.$el)) {
            toggleClass(
              media,
              this.clsZoom,
              (media.naturalHeight || media.videoHeight) - this.$el.offsetHeight > Math.max(
                0,
                (media.naturalWidth || media.videoWidth) - this.$el.offsetWidth
              )
            );
          }
        },
        events: ["resize"]
      },
      methods: {
        loadItem(index = this.index) {
          const item = this.getItem(index);
          if (!this.getSlide(item).childElementCount) {
            trigger(this.$el, "itemload", [item]);
          }
        },
        getItem(index = this.index) {
          return this.items[getIndex(index, this.slides)];
        },
        setItem(item, content) {
          trigger(this.$el, "itemloaded", [this, html(this.getSlide(item), content)]);
        },
        getSlide(item) {
          return this.slides[this.items.indexOf(item)];
        },
        setError(item) {
          this.setItem(item, '<span uk-icon="icon: bolt; ratio: 2" uk-inverse></span>');
        },
        showControls() {
          clearTimeout(this.controlsTimer);
          this.controlsTimer = this.delayControls && setTimeout(this.hideControls, this.delayControls);
          addClass(this.$el, "uk-active", "uk-transition-active");
        },
        hideControls() {
          removeClass(this.$el, "uk-active", "uk-transition-active");
        }
      }
    };
    function createEl(tag, attrs) {
      const el = fragment(`<${tag}>`);
      attr(el, attrs);
      return el;
    }
    function toThumbnavItem(item, videoAutoplay) {
      const el = item.poster || item.thumb && (item.type === "image" || isImage(item.thumb)) ? createEl("img", { src: item.poster || item.thumb, alt: "" }) : item.thumb && (item.type === "video" || isVideo(item.thumb)) ? createEl("video", {
        src: item.thumb,
        loop: "",
        playsinline: "",
        "uk-video": `autoplay: ${Boolean(videoAutoplay)}; automute: true`
      }) : createEl("canvas");
      if (item.thumbRatio) {
        el.style.aspectRatio = item.thumbRatio;
      }
      return el;
    }
    function isImage(src) {
      return src == null ? void 0 : src.match(/\.(avif|jpe?g|jfif|a?png|gif|svg|webp)($|\?)/i);
    }
    function isVideo(src) {
      return src == null ? void 0 : src.match(/\.(mp4|webm|ogv)($|\?)/i);
    }

    const selDisabled$1 = ".uk-disabled *, .uk-disabled, [disabled]";
    var lightbox = {
      install: install$3,
      props: { toggle: String },
      data: { toggle: "a" },
      computed: {
        toggles: ({ toggle }, $el) => $$(toggle, $el)
      },
      watch: {
        toggles(toggles) {
          this.hide();
          for (const toggle of toggles) {
            if (isTag(toggle, "a")) {
              attr(toggle, "role", "button");
            }
          }
        }
      },
      disconnected() {
        this.hide();
      },
      events: {
        name: "click",
        delegate: ({ toggle }) => toggle,
        handler(e) {
          if (!e.defaultPrevented) {
            e.preventDefault();
            if (!matches(e.current, selDisabled$1)) {
              this.show(e.current);
            }
          }
        }
      },
      methods: {
        show(index) {
          let items = this.toggles.map(toItem);
          if (this.nav === "thumbnav") {
            ensureThumb.call(this, this.toggles, items);
          }
          items = uniqueBy(items, "source");
          if (isElement(index)) {
            const { source } = toItem(index);
            index = findIndex(items, ({ source: src }) => source === src);
          }
          this.panel = this.panel || this.$create("lightboxPanel", { ...this.$props, items });
          on(this.panel.$el, "hidden", () => this.panel = null);
          return this.panel.show(index);
        },
        hide() {
          var _a;
          return (_a = this.panel) == null ? void 0 : _a.hide();
        }
      }
    };
    function install$3(UIkit, Lightbox) {
      if (!UIkit.lightboxPanel) {
        UIkit.component("lightboxPanel", LightboxPanel);
      }
      assign(Lightbox.props, UIkit.component("lightboxPanel").options.props);
    }
    function ensureThumb(toggles, items) {
      for (const [i, toggle] of Object.entries(toggles)) {
        if (items[i].thumb) {
          continue;
        }
        const parent = parents(toggle).reverse().concat(toggle).find(
          (parent2) => this.$el.contains(parent2) && (parent2 === toggle || $$(this.toggle, parent2).length === 1)
        );
        if (!parent) {
          continue;
        }
        const media = $("img,video", parent);
        if (media) {
          items[i].thumb = media.currentSrc || media.poster || media.src;
          items[i].thumbRatio = (media.naturalWidth || media.videoWidth) / (media.naturalHeight || media.videoHeight);
        }
      }
    }
    function toItem(el) {
      const item = {};
      for (const attribute of el.getAttributeNames()) {
        const key = attribute.replace(/^data-/, "");
        item[key === "href" ? "source" : key] = el.getAttribute(attribute);
      }
      item.attrs = parseOptions(item.attrs);
      return item;
    }

    var notification = {
      mixins: [Container],
      functional: true,
      args: ["message", "status"],
      data: {
        message: "",
        status: "",
        timeout: 5e3,
        group: "",
        pos: "top-center",
        clsContainer: "uk-notification",
        clsClose: "uk-notification-close",
        clsMsg: "uk-notification-message"
      },
      install: install$2,
      computed: {
        marginProp: ({ pos }) => `margin-${pos.match(/[a-z]+(?=-)/)[0]}`,
        startProps() {
          return { opacity: 0, [this.marginProp]: -this.$el.offsetHeight };
        }
      },
      created() {
        const posClass = `${this.clsContainer}-${this.pos}`;
        const containerAttr = `data-${this.clsContainer}-container`;
        const container = $(`.${posClass}[${containerAttr}]`, this.container) || append(
          this.container,
          `<div class="${this.clsContainer} ${posClass}" ${containerAttr}></div>`
        );
        this.$mount(
          append(
            container,
            `<div class="${this.clsMsg}${this.status ? ` ${this.clsMsg}-${this.status}` : ""}" role="alert"> <a href class="${this.clsClose}" data-uk-close></a> <div>${this.message}</div> </div>`
          )
        );
      },
      async connected() {
        const margin = toFloat(css(this.$el, this.marginProp));
        await Transition.start(css(this.$el, this.startProps), {
          opacity: 1,
          [this.marginProp]: margin
        });
        if (this.timeout) {
          this.timer = setTimeout(this.close, this.timeout);
        }
      },
      events: {
        click(e) {
          if (e.target.closest('a[href="#"],a[href=""]')) {
            e.preventDefault();
          }
          this.close();
        },
        [pointerEnter]() {
          if (this.timer) {
            clearTimeout(this.timer);
          }
        },
        [pointerLeave]() {
          if (this.timeout) {
            this.timer = setTimeout(this.close, this.timeout);
          }
        }
      },
      methods: {
        async close(immediate) {
          const removeFn = (el) => {
            const container = parent(el);
            trigger(el, "close", [this]);
            remove$1(el);
            if (!(container == null ? void 0 : container.hasChildNodes())) {
              remove$1(container);
            }
          };
          if (this.timer) {
            clearTimeout(this.timer);
          }
          if (!immediate) {
            await Transition.start(this.$el, this.startProps);
          }
          removeFn(this.$el);
        }
      }
    };
    function install$2(UIkit) {
      UIkit.notification.closeAll = function(group, immediate) {
        apply(document.body, (el) => {
          const notification = UIkit.getComponent(el, "notification");
          if (notification && (!group || group === notification.group)) {
            notification.close(immediate);
          }
        });
      };
    }

    var Media = {
      props: {
        media: Boolean
      },
      data: {
        media: false
      },
      connected() {
        const media = toMedia(this.media, this.$el);
        this.matchMedia = true;
        if (media) {
          this.mediaObj = window.matchMedia(media);
          const handler = () => {
            this.matchMedia = this.mediaObj.matches;
            trigger(this.$el, createEvent("mediachange", false, true, [this.mediaObj]));
          };
          this.offMediaObj = on(this.mediaObj, "change", () => {
            handler();
            this.$emit("resize");
          });
          handler();
        }
      },
      disconnected() {
        var _a;
        (_a = this.offMediaObj) == null ? void 0 : _a.call(this);
      }
    };
    function toMedia(value, element) {
      if (isString(value)) {
        if (startsWith(value, "@")) {
          value = toFloat(css(element, `--uk-breakpoint-${value.slice(1)}`));
        } else if (isNaN(value)) {
          return value;
        }
      }
      return value && isNumeric(value) ? `(min-width: ${value}px)` : "";
    }

    function getMaxPathLength(el) {
      return isVisible(el) ? Math.ceil(
        Math.max(0, ...$$("[stroke]", el).map((stroke) => {
          var _a;
          return ((_a = stroke.getTotalLength) == null ? void 0 : _a.call(stroke)) || 0;
        }))
      ) : 0;
    }

    const props = {
      x: transformFn,
      y: transformFn,
      rotate: transformFn,
      scale: transformFn,
      color: colorFn,
      backgroundColor: colorFn,
      borderColor: colorFn,
      blur: filterFn,
      hue: filterFn,
      fopacity: filterFn,
      grayscale: filterFn,
      invert: filterFn,
      saturate: filterFn,
      sepia: filterFn,
      opacity: cssPropFn,
      stroke: strokeFn,
      bgx: backgroundFn,
      bgy: backgroundFn
    };
    const { keys } = Object;
    var Parallax = {
      mixins: [Media],
      props: fillObject(keys(props), "list"),
      data: fillObject(keys(props), void 0),
      computed: {
        props(properties, $el) {
          const stops = {};
          for (const prop in properties) {
            if (prop in props && !isUndefined(properties[prop])) {
              stops[prop] = properties[prop].slice();
            }
          }
          const result = {};
          for (const prop in stops) {
            result[prop] = props[prop](prop, $el, stops[prop], stops);
          }
          return result;
        }
      },
      events: {
        load() {
          this.$emit();
        }
      },
      methods: {
        reset() {
          for (const prop in this.getCss(0)) {
            css(this.$el, prop, "");
          }
        },
        getCss(percent) {
          const css2 = {};
          for (const prop in this.props) {
            this.props[prop](css2, clamp(percent));
          }
          css2.willChange = Object.keys(css2).map(propName).join(",");
          return css2;
        }
      }
    };
    function transformFn(prop, el, stops) {
      let unit = getUnit(stops) || { x: "px", y: "px", rotate: "deg" }[prop] || "";
      let transformFn2;
      if (prop === "x" || prop === "y") {
        prop = `translate${ucfirst(prop)}`;
        transformFn2 = (stop) => toFloat(toFloat(stop).toFixed(unit === "px" ? 0 : 6));
      } else if (prop === "scale") {
        unit = "";
        transformFn2 = (stop) => {
          var _a;
          return getUnit([stop]) ? toPx(stop, "width", el, true) / el[`offset${((_a = stop.endsWith) == null ? void 0 : _a.call(stop, "vh")) ? "Height" : "Width"}`] : toFloat(stop);
        };
      }
      if (stops.length === 1) {
        stops.unshift(prop === "scale" ? 1 : 0);
      }
      stops = parseStops(stops, transformFn2);
      return (css2, percent) => {
        css2.transform = `${css2.transform || ""} ${prop}(${getValue(stops, percent)}${unit})`;
      };
    }
    function colorFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(getCssValue(el, prop, ""));
      }
      stops = parseStops(stops, (stop) => parseColor(el, stop));
      return (css2, percent) => {
        const [start, end, p] = getStop(stops, percent);
        const value = start.map((value2, i) => {
          value2 += p * (end[i] - value2);
          return i === 3 ? toFloat(value2) : parseInt(value2, 10);
        }).join(",");
        css2[prop] = `rgba(${value})`;
      };
    }
    function parseColor(el, color) {
      return getCssValue(el, "color", color).split(/[(),]/g).slice(1, -1).concat(1).slice(0, 4).map(toFloat);
    }
    function filterFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(0);
      }
      const unit = getUnit(stops) || { blur: "px", hue: "deg" }[prop] || "%";
      prop = { fopacity: "opacity", hue: "hue-rotate" }[prop] || prop;
      stops = parseStops(stops);
      return (css2, percent) => {
        const value = getValue(stops, percent);
        css2.filter = `${css2.filter || ""} ${prop}(${value + unit})`;
      };
    }
    function cssPropFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(getCssValue(el, prop, ""));
      }
      stops = parseStops(stops);
      return (css2, percent) => {
        css2[prop] = getValue(stops, percent);
      };
    }
    function strokeFn(prop, el, stops) {
      if (stops.length === 1) {
        stops.unshift(0);
      }
      const unit = getUnit(stops);
      const length = getMaxPathLength(el);
      stops = parseStops(stops.reverse(), (stop) => {
        stop = toFloat(stop);
        return unit === "%" ? stop * length / 100 : stop;
      });
      if (!stops.some(([value]) => value)) {
        return noop;
      }
      css(el, "strokeDasharray", length);
      return (css2, percent) => {
        css2.strokeDashoffset = getValue(stops, percent);
      };
    }
    function backgroundFn(prop, el, stops, props2) {
      if (stops.length === 1) {
        stops.unshift(0);
      }
      const attr = prop === "bgy" ? "height" : "width";
      props2[prop] = parseStops(stops, (stop) => toPx(stop, attr, el));
      const bgProps = ["bgx", "bgy"].filter((prop2) => prop2 in props2);
      if (bgProps.length === 2 && prop === "bgx") {
        return noop;
      }
      if (getCssValue(el, "backgroundSize", "") === "cover") {
        return backgroundCoverFn(prop, el, stops, props2);
      }
      const positions = {};
      for (const prop2 of bgProps) {
        positions[prop2] = getBackgroundPos(el, prop2);
      }
      return setBackgroundPosFn(bgProps, positions, props2);
    }
    function backgroundCoverFn(prop, el, stops, props2) {
      const dimImage = getBackgroundImageDimensions(el);
      if (!dimImage.width) {
        return noop;
      }
      const dimEl = {
        width: el.offsetWidth,
        height: el.offsetHeight
      };
      const bgProps = ["bgx", "bgy"].filter((prop2) => prop2 in props2);
      const positions = {};
      for (const prop2 of bgProps) {
        const values = props2[prop2].map(([value]) => value);
        const min = Math.min(...values);
        const max = Math.max(...values);
        const down = values.indexOf(min) < values.indexOf(max);
        const diff = max - min;
        positions[prop2] = `${(down ? -diff : 0) - (down ? min : max)}px`;
        dimEl[prop2 === "bgy" ? "height" : "width"] += diff;
      }
      const dim = Dimensions.cover(dimImage, dimEl);
      for (const prop2 of bgProps) {
        const attr = prop2 === "bgy" ? "height" : "width";
        const overflow = dim[attr] - dimEl[attr];
        positions[prop2] = `max(${getBackgroundPos(el, prop2)},-${overflow}px) + ${positions[prop2]}`;
      }
      const fn = setBackgroundPosFn(bgProps, positions, props2);
      return (css2, percent) => {
        fn(css2, percent);
        css2.backgroundSize = `${dim.width}px ${dim.height}px`;
        css2.backgroundRepeat = "no-repeat";
      };
    }
    function getBackgroundPos(el, prop) {
      return getCssValue(el, `background-position-${prop.slice(-1)}`, "");
    }
    function setBackgroundPosFn(bgProps, positions, props2) {
      return function(css2, percent) {
        for (const prop of bgProps) {
          const value = getValue(props2[prop], percent);
          css2[`background-position-${prop.slice(-1)}`] = `calc(${positions[prop]} + ${value}px)`;
        }
      };
    }
    const loading = {};
    const dimensions = {};
    function getBackgroundImageDimensions(el) {
      const src = css(el, "backgroundImage").replace(/^none|url\(["']?(.+?)["']?\)$/, "$1");
      if (dimensions[src]) {
        return dimensions[src];
      }
      const image = new Image();
      if (src) {
        image.src = src;
        if (!image.naturalWidth && !loading[src]) {
          once(image, "error load", () => {
            dimensions[src] = toDimensions(image);
            trigger(el, createEvent("load", false));
          });
          loading[src] = true;
          return toDimensions(image);
        }
      }
      return dimensions[src] = toDimensions(image);
    }
    function toDimensions(image) {
      return {
        width: image.naturalWidth,
        height: image.naturalHeight
      };
    }
    function parseStops(stops, fn = toFloat) {
      const result = [];
      const { length } = stops;
      let nullIndex = 0;
      for (let i = 0; i < length; i++) {
        let [value, percent] = isString(stops[i]) ? stops[i].trim().split(/ (?![^(]*\))/) : [stops[i]];
        value = fn(value);
        percent = percent ? toFloat(percent) / 100 : null;
        if (i === 0) {
          if (percent === null) {
            percent = 0;
          } else if (percent) {
            result.push([value, 0]);
          }
        } else if (i === length - 1) {
          if (percent === null) {
            percent = 1;
          } else if (percent !== 1) {
            result.push([value, percent]);
            percent = 1;
          }
        }
        result.push([value, percent]);
        if (percent === null) {
          nullIndex++;
        } else if (nullIndex) {
          const leftPercent = result[i - nullIndex - 1][1];
          const p = (percent - leftPercent) / (nullIndex + 1);
          for (let j = nullIndex; j > 0; j--) {
            result[i - j][1] = leftPercent + p * (nullIndex - j + 1);
          }
          nullIndex = 0;
        }
      }
      return result;
    }
    function getStop(stops, percent) {
      const index = findIndex(stops.slice(1), ([, targetPercent]) => percent <= targetPercent) + 1;
      return [
        stops[index - 1][0],
        stops[index][0],
        (percent - stops[index - 1][1]) / (stops[index][1] - stops[index - 1][1])
      ];
    }
    function getValue(stops, percent) {
      const [start, end, p] = getStop(stops, percent);
      return start + Math.abs(start - end) * p * (start < end ? 1 : -1);
    }
    const unitRe = /^-?\d+(?:\.\d+)?(\S+)?/;
    function getUnit(stops, defaultUnit) {
      var _a;
      for (const stop of stops) {
        const match = (_a = stop.match) == null ? void 0 : _a.call(stop, unitRe);
        if (match) {
          return match[1];
        }
      }
      return defaultUnit;
    }
    function getCssValue(el, prop, value) {
      const prev = el.style[prop];
      const val = css(css(el, prop, value), prop);
      el.style[prop] = prev;
      return val;
    }
    function fillObject(keys2, value) {
      return keys2.reduce((data, prop) => {
        data[prop] = value;
        return data;
      }, {});
    }
    function ease(percent, easing) {
      return easing >= 0 ? Math.pow(percent, easing + 1) : 1 - Math.pow(1 - percent, 1 - easing);
    }

    var parallax = {
      mixins: [Parallax],
      props: {
        target: String,
        viewport: Number,
        // Deprecated
        easing: Number,
        start: String,
        end: String
      },
      data: {
        target: false,
        viewport: 1,
        easing: 1,
        start: 0,
        end: 0
      },
      computed: {
        target: ({ target }, $el) => getOffsetElement(target && query(target, $el) || $el),
        start({ start }) {
          return toPx(start, "height", this.target, true);
        },
        end({ end, viewport: viewport2 }) {
          return toPx(
            end || (viewport2 = (1 - viewport2) * 100) && `${viewport2}vh+${viewport2}%`,
            "height",
            this.target,
            true
          );
        }
      },
      observe: [
        viewport(),
        scroll$1({ target: ({ target }) => target }),
        resize({ target: ({ $el, target }) => [$el, target, scrollParent(target, true)] })
      ],
      update: {
        read({ percent }, types) {
          if (!types.has("scroll")) {
            percent = false;
          }
          if (!isVisible(this.$el)) {
            return false;
          }
          if (!this.matchMedia) {
            return;
          }
          const prev = percent;
          percent = ease(scrolledOver(this.target, this.start, this.end), this.easing);
          return {
            percent,
            style: prev === percent ? false : this.getCss(percent)
          };
        },
        write({ style }) {
          if (!this.matchMedia) {
            this.reset();
            return;
          }
          style && css(this.$el, style);
        },
        events: ["scroll", "resize"]
      }
    };
    function getOffsetElement(el) {
      return el ? "offsetTop" in el ? el : getOffsetElement(parent(el)) : document.documentElement;
    }

    var SliderParallax = {
      props: {
        parallax: Boolean,
        parallaxTarget: Boolean,
        parallaxStart: String,
        parallaxEnd: String,
        parallaxEasing: Number
      },
      data: {
        parallax: false,
        parallaxTarget: false,
        parallaxStart: 0,
        parallaxEnd: 0,
        parallaxEasing: 0
      },
      observe: [
        resize({
          target: ({ $el, parallaxTarget }) => [$el, parallaxTarget],
          filter: ({ parallax }) => parallax
        }),
        scroll$1({ filter: ({ parallax }) => parallax })
      ],
      computed: {
        parallaxTarget({ parallaxTarget }, $el) {
          return parallaxTarget && query(parallaxTarget, $el) || this.list;
        }
      },
      update: {
        read() {
          if (!this.parallax) {
            return false;
          }
          const target = this.parallaxTarget;
          if (!target) {
            return false;
          }
          const start = toPx(this.parallaxStart, "height", target, true);
          const end = toPx(this.parallaxEnd, "height", target, true);
          const percent = ease(scrolledOver(target, start, end), this.parallaxEasing);
          return { parallax: this.getIndexAt(percent) };
        },
        write({ parallax }) {
          const [prevIndex, slidePercent] = parallax;
          const nextIndex = this.getValidIndex(prevIndex + Math.ceil(slidePercent));
          const prev = this.slides[prevIndex];
          const next = this.slides[nextIndex];
          const { triggerShow, triggerShown, triggerHide, triggerHidden } = useTriggers(this);
          if (~this.prevIndex) {
            for (const i of /* @__PURE__ */ new Set([this.index, this.prevIndex])) {
              if (!includes([nextIndex, prevIndex], i)) {
                triggerHide(this.slides[i]);
                triggerHidden(this.slides[i]);
              }
            }
          }
          const changed = this.prevIndex !== prevIndex || this.index !== nextIndex;
          this.dir = 1;
          this.prevIndex = prevIndex;
          this.index = nextIndex;
          if (prev !== next) {
            triggerHide(prev);
          }
          triggerShow(next);
          if (changed) {
            triggerShown(prev);
          }
          this._translate(prev === next ? 1 : slidePercent, prev, next);
        },
        events: ["scroll", "resize"]
      },
      methods: {
        getIndexAt(percent) {
          const index = percent * (this.length - 1);
          return [Math.floor(index), index % 1];
        }
      }
    };
    function useTriggers(cmp) {
      const { clsSlideActive, clsEnter, clsLeave } = cmp;
      return { triggerShow, triggerShown, triggerHide, triggerHidden };
      function triggerShow(el) {
        if (hasClass(el, clsLeave)) {
          triggerHide(el);
          triggerHidden(el);
        }
        if (!hasClass(el, clsSlideActive)) {
          trigger(el, "beforeitemshow", [cmp]);
          trigger(el, "itemshow", [cmp]);
        }
      }
      function triggerShown(el) {
        if (hasClass(el, clsEnter)) {
          trigger(el, "itemshown", [cmp]);
        }
      }
      function triggerHide(el) {
        if (!hasClass(el, clsSlideActive)) {
          triggerShow(el);
        }
        if (hasClass(el, clsEnter)) {
          triggerShown(el);
        }
        if (!hasClass(el, clsLeave)) {
          trigger(el, "beforeitemhide", [cmp]);
          trigger(el, "itemhide", [cmp]);
        }
      }
      function triggerHidden(el) {
        if (hasClass(el, clsLeave)) {
          trigger(el, "itemhidden", [cmp]);
        }
      }
    }

    var SliderReactive = {
      update: {
        write() {
          if (this.stack.length || this.dragging || this.parallax) {
            return;
          }
          const index = this.getValidIndex();
          if (!~this.prevIndex || this.index !== index) {
            this.show(index);
          } else {
            this._translate(1);
          }
        },
        events: ["resize"]
      }
    };

    var SliderPreload = {
      observe: lazyload({
        target: ({ slides }) => slides,
        targets: (instance) => instance.getAdjacentSlides()
      }),
      methods: {
        getAdjacentSlides() {
          return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]);
        }
      }
    };

    function Transitioner(prev, next, dir, { center, easing, list }) {
      const from = prev ? getLeft(prev, list, center) : getLeft(next, list, center) + dimensions$1(next).width * dir;
      const to = next ? getLeft(next, list, center) : from + dimensions$1(prev).width * dir * (isRtl ? -1 : 1);
      const { promise, resolve } = withResolvers();
      return {
        dir,
        show(duration, percent = 0, linear) {
          const timing = linear ? "linear" : easing;
          duration -= Math.round(duration * clamp(percent, -1, 1));
          css(list, "transitionProperty", "none");
          this.translate(percent);
          css(list, "transitionProperty", "");
          percent = prev ? percent : clamp(percent, 0, 1);
          triggerUpdate(this.getItemIn(), "itemin", { percent, duration, timing, dir });
          prev && triggerUpdate(this.getItemIn(true), "itemout", {
            percent: 1 - percent,
            duration,
            timing,
            dir
          });
          Transition.start(
            list,
            { transform: translate(-to * (isRtl ? -1 : 1), "px") },
            duration,
            timing
          ).then(resolve, noop);
          return promise;
        },
        cancel() {
          return Transition.cancel(list);
        },
        reset() {
          css(list, "transform", "");
        },
        async forward(duration, percent = this.percent()) {
          await this.cancel();
          return this.show(duration, percent, true);
        },
        translate(percent) {
          if (percent === this.percent()) {
            return;
          }
          const distance = this.getDistance() * dir * (isRtl ? -1 : 1);
          css(
            list,
            "transform",
            translate(
              clamp(
                -to + (distance - distance * percent),
                -getWidth(list),
                dimensions$1(list).width
              ) * (isRtl ? -1 : 1),
              "px"
            )
          );
          const actives = this.getActives();
          const itemIn = this.getItemIn();
          const itemOut = this.getItemIn(true);
          percent = prev ? clamp(percent, -1, 1) : 0;
          for (const slide of children(list)) {
            const isActive = includes(actives, slide);
            const isIn = slide === itemIn;
            const isOut = slide === itemOut;
            const translateIn = isIn || !isOut && (isActive || dir * (isRtl ? -1 : 1) === -1 ^ getElLeft(slide, list) > getElLeft(prev || next));
            triggerUpdate(slide, `itemtranslate${translateIn ? "in" : "out"}`, {
              dir,
              percent: isOut ? 1 - percent : isIn ? percent : isActive ? 1 : 0
            });
          }
        },
        percent() {
          return Math.abs(
            (new DOMMatrix(css(list, "transform")).m41 * (isRtl ? -1 : 1) + from) / (to - from)
          );
        },
        getDistance() {
          return Math.abs(to - from);
        },
        getItemIn(out = false) {
          let actives = this.getActives();
          let nextActives = inView(list, getLeft(next || prev, list, center));
          if (out) {
            const temp = actives;
            actives = nextActives;
            nextActives = temp;
          }
          return nextActives[findIndex(nextActives, (el) => !includes(actives, el))];
        },
        getActives() {
          return inView(list, getLeft(prev || next, list, center));
        }
      };
    }
    function getLeft(el, list, center) {
      const left = getElLeft(el, list);
      return center ? left - centerEl(el, list) : Math.min(left, getMax(list));
    }
    function getMax(list) {
      return Math.max(0, getWidth(list) - dimensions$1(list).width);
    }
    function getWidth(list, index) {
      return sumBy(children(list).slice(0, index), (el) => dimensions$1(el).width);
    }
    function centerEl(el, list) {
      return dimensions$1(list).width / 2 - dimensions$1(el).width / 2;
    }
    function getElLeft(el, list) {
      return el && (position(el).left + (isRtl ? dimensions$1(el).width - dimensions$1(list).width : 0)) * (isRtl ? -1 : 1) || 0;
    }
    function inView(list, listLeft) {
      listLeft -= 1;
      const listWidth = dimensions$1(list).width;
      const listRight = listLeft + listWidth + 2;
      return children(list).filter((slide) => {
        const slideLeft = getElLeft(slide, list);
        const slideRight = slideLeft + Math.min(dimensions$1(slide).width, listWidth);
        return slideLeft >= listLeft && slideRight <= listRight;
      });
    }

    var slider = {
      mixins: [Class, Slider, SliderReactive, SliderParallax, SliderPreload],
      props: {
        center: Boolean,
        sets: Boolean,
        active: String
      },
      data: {
        center: false,
        sets: false,
        attrItem: "uk-slider-item",
        selList: ".uk-slider-items",
        selNav: ".uk-slider-nav",
        clsContainer: "uk-slider-container",
        active: "all",
        Transitioner
      },
      computed: {
        finite({ finite }) {
          return finite || isFinite(this.list, this.center);
        },
        maxIndex() {
          if (!this.finite || this.center && !this.sets) {
            return this.length - 1;
          }
          if (this.center) {
            return last(this.sets);
          }
          let lft = 0;
          const max = getMax(this.list);
          const index = findIndex(this.slides, (el) => {
            if (lft >= max - 5e-3) {
              return true;
            }
            lft += dimensions$1(el).width;
          });
          return ~index ? index : this.length - 1;
        },
        sets({ sets: enabled }) {
          if (!enabled || this.parallax) {
            return;
          }
          let left = 0;
          const sets = [];
          const width = dimensions$1(this.list).width;
          for (let i = 0; i < this.length; i++) {
            const slideWidth = dimensions$1(this.slides[i]).width;
            if (left + slideWidth > width) {
              left = 0;
            }
            if (this.center) {
              if (left < width / 2 && left + slideWidth + dimensions$1(this.slides[getIndex(i + 1, this.slides)]).width / 2 > width / 2) {
                sets.push(i);
                left = width / 2 - slideWidth / 2;
              }
            } else if (left === 0) {
              sets.push(Math.min(i, this.maxIndex));
            }
            left += slideWidth;
          }
          if (sets.length) {
            return sets;
          }
        },
        transitionOptions() {
          return {
            center: this.center,
            list: this.list
          };
        },
        slides() {
          return children(this.list).filter(isVisible);
        }
      },
      connected() {
        toggleClass(this.$el, this.clsContainer, !$(`.${this.clsContainer}`, this.$el));
      },
      observe: resize({
        target: ({ slides, $el }) => [$el, ...slides]
      }),
      update: {
        write() {
          for (const el of this.navItems) {
            const index = toNumber(data(el, this.attrItem));
            if (index !== false) {
              el.hidden = !this.maxIndex || index > this.maxIndex || this.sets && !includes(this.sets, index);
            }
          }
          this.reorder();
          if (!this.parallax) {
            this._translate(1);
          }
          this.updateActiveClasses();
        },
        events: ["resize"]
      },
      events: {
        beforeitemshow(e) {
          if (!this.dragging && this.sets && this.stack.length < 2 && !includes(this.sets, this.index)) {
            this.index = this.getValidIndex();
          }
          const diff = Math.abs(
            this.index - this.prevIndex + (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) * this.dir : 0)
          );
          if (!this.dragging && diff > 1) {
            for (let i = 0; i < diff; i++) {
              this.stack.splice(1, 0, this.dir > 0 ? "next" : "previous");
            }
            e.preventDefault();
            return;
          }
          const index = this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex;
          const avgWidth = getWidth(this.list) / this.length;
          this.duration = speedUp(avgWidth / this.velocity) * (dimensions$1(this.slides[index]).width / avgWidth);
          this.reorder();
        },
        itemshow() {
          if (~this.prevIndex) {
            addClass(this._getTransitioner().getItemIn(), this.clsActive);
          }
          this.updateActiveClasses(this.prevIndex);
        },
        itemshown() {
          this.updateActiveClasses();
        }
      },
      methods: {
        reorder() {
          if (this.finite) {
            css(this.slides, "order", "");
            return;
          }
          const index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;
          this.slides.forEach(
            (slide, i) => css(
              slide,
              "order",
              this.dir > 0 && i < index ? 1 : this.dir < 0 && i >= this.index ? -1 : ""
            )
          );
          if (!this.center || !this.length) {
            return;
          }
          const next = this.slides[index];
          let width = dimensions$1(this.list).width / 2 - dimensions$1(next).width / 2;
          let j = 0;
          while (width > 0) {
            const slideIndex = this.getIndex(--j + index, index);
            const slide = this.slides[slideIndex];
            css(slide, "order", slideIndex > index ? -2 : -1);
            width -= dimensions$1(slide).width;
          }
        },
        updateActiveClasses(currentIndex = this.index) {
          let actives = this._getTransitioner(currentIndex).getActives();
          if (this.active !== "all") {
            actives = [this.slides[this.getValidIndex(currentIndex)]];
          }
          const activeClasses = [
            this.clsActive,
            !this.sets || includes(this.sets, toFloat(this.index)) ? this.clsActivated : ""
          ];
          for (const slide of this.slides) {
            const active = includes(actives, slide);
            toggleClass(slide, activeClasses, active);
            attr(slide, "aria-hidden", !active);
            for (const focusable of $$(selFocusable, slide)) {
              if (!hasOwn(focusable, "_tabindex")) {
                focusable._tabindex = attr(focusable, "tabindex");
              }
              attr(focusable, "tabindex", active ? focusable._tabindex : -1);
            }
          }
        },
        getValidIndex(index = this.index, prevIndex = this.prevIndex) {
          index = this.getIndex(index, prevIndex);
          if (!this.sets) {
            return index;
          }
          let prev;
          do {
            if (includes(this.sets, index)) {
              return index;
            }
            prev = index;
            index = this.getIndex(index + this.dir, prevIndex);
          } while (index !== prev);
          return index;
        },
        getAdjacentSlides() {
          const { width } = dimensions$1(this.list);
          const left = -width;
          const right = width * 2;
          const slideWidth = dimensions$1(this.slides[this.index]).width;
          const slideLeft = this.center ? width / 2 - slideWidth / 2 : 0;
          const slides = /* @__PURE__ */ new Set();
          for (const i of [-1, 1]) {
            let currentLeft = slideLeft + (i > 0 ? slideWidth : 0);
            let j = 0;
            do {
              const slide = this.slides[this.getIndex(this.index + i + j++ * i)];
              currentLeft += dimensions$1(slide).width * i;
              slides.add(slide);
            } while (this.length > j && currentLeft > left && currentLeft < right);
          }
          return Array.from(slides);
        },
        getIndexAt(percent) {
          let index = -1;
          const scrollDist = this.center ? getWidth(this.list) - (dimensions$1(this.slides[0]).width / 2 + dimensions$1(last(this.slides)).width / 2) : getWidth(this.list, this.maxIndex);
          let dist = percent * scrollDist;
          let slidePercent = 0;
          do {
            const slideWidth = dimensions$1(this.slides[++index]).width;
            const slideDist = this.center ? slideWidth / 2 + dimensions$1(this.slides[index + 1]).width / 2 : slideWidth;
            slidePercent = dist / slideDist % 1;
            dist -= slideDist;
          } while (dist >= 0 && index < this.maxIndex);
          return [index, slidePercent];
        }
      }
    };
    function isFinite(list, center) {
      if (!list || list.length < 2) {
        return true;
      }
      const { width: listWidth } = dimensions$1(list);
      if (!center) {
        return Math.ceil(getWidth(list)) < Math.trunc(listWidth + getMaxElWidth(list));
      }
      const slides = children(list);
      const listHalf = Math.trunc(listWidth / 2);
      for (const index in slides) {
        const slide = slides[index];
        const slideWidth = dimensions$1(slide).width;
        const slidesInView = /* @__PURE__ */ new Set([slide]);
        let diff = 0;
        for (const i of [-1, 1]) {
          let left = slideWidth / 2;
          let j = 0;
          while (left < listHalf) {
            const nextSlide = slides[getIndex(+index + i + j++ * i, slides)];
            if (slidesInView.has(nextSlide)) {
              return true;
            }
            left += dimensions$1(nextSlide).width;
            slidesInView.add(nextSlide);
          }
          diff = Math.max(
            diff,
            slideWidth / 2 + dimensions$1(slides[getIndex(+index + i, slides)]).width / 2 - (left - listHalf)
          );
        }
        if (Math.trunc(diff) > sumBy(
          slides.filter((slide2) => !slidesInView.has(slide2)),
          (slide2) => dimensions$1(slide2).width
        )) {
          return true;
        }
      }
      return false;
    }
    function getMaxElWidth(list) {
      return Math.max(0, ...children(list).map((el) => dimensions$1(el).width));
    }

    var sliderParallax = {
      mixins: [Parallax],
      beforeConnect() {
        this.item = this.$el.closest(`.${this.$options.id.replace("parallax", "items")} > *`);
      },
      disconnected() {
        this.item = null;
      },
      events: [
        {
          name: "itemin itemout",
          self: true,
          el: ({ item }) => item,
          handler({ type, detail: { percent, duration, timing, dir } }) {
            fastdom.read(() => {
              if (!this.matchMedia) {
                return;
              }
              const propsFrom = this.getCss(getCurrentPercent(type, dir, percent));
              const propsTo = this.getCss(isIn(type) ? 0.5 : dir > 0 ? 1 : 0);
              fastdom.write(() => {
                css(this.$el, propsFrom);
                Transition.start(this.$el, propsTo, duration, timing).catch(noop);
              });
            });
          }
        },
        {
          name: "transitioncanceled transitionend",
          self: true,
          el: ({ item }) => item,
          handler() {
            Transition.cancel(this.$el);
          }
        },
        {
          name: "itemtranslatein itemtranslateout",
          self: true,
          el: ({ item }) => item,
          handler({ type, detail: { percent, dir } }) {
            fastdom.read(() => {
              if (!this.matchMedia) {
                this.reset();
                return;
              }
              const props = this.getCss(getCurrentPercent(type, dir, percent));
              fastdom.write(() => css(this.$el, props));
            });
          }
        }
      ]
    };
    function isIn(type) {
      return endsWith(type, "in");
    }
    function getCurrentPercent(type, dir, percent) {
      percent /= 2;
      return isIn(type) ^ dir < 0 ? percent : 1 - percent;
    }

    var slideshow = {
      mixins: [Class, Slideshow, SliderReactive, SliderParallax, SliderPreload],
      props: {
        ratio: String,
        minHeight: String,
        maxHeight: String
      },
      data: {
        ratio: "16:9",
        minHeight: void 0,
        maxHeight: void 0,
        selList: ".uk-slideshow-items",
        attrItem: "uk-slideshow-item",
        selNav: ".uk-slideshow-nav",
        Animations: Animations$1
      },
      watch: {
        list(list) {
          css(list, {
            aspectRatio: this.ratio ? this.ratio.replace(":", "/") : void 0,
            minHeight: this.minHeight,
            maxHeight: this.maxHeight,
            width: "100%"
          });
        }
      },
      methods: {
        getAdjacentSlides() {
          return [1, -1].map((i) => this.slides[this.getIndex(this.index + i)]);
        }
      }
    };

    var sortable = {
      mixins: [Class, Animate],
      props: {
        group: String,
        threshold: Number,
        clsItem: String,
        clsPlaceholder: String,
        clsDrag: String,
        clsDragState: String,
        clsBase: String,
        clsNoDrag: String,
        clsEmpty: String,
        clsCustom: String,
        handle: String
      },
      data: {
        group: false,
        threshold: 5,
        clsItem: "uk-sortable-item",
        clsPlaceholder: "uk-sortable-placeholder",
        clsDrag: "uk-sortable-drag",
        clsDragState: "uk-drag",
        clsBase: "uk-sortable",
        clsNoDrag: "uk-sortable-nodrag",
        clsEmpty: "uk-sortable-empty",
        clsCustom: "",
        handle: false,
        pos: {}
      },
      events: {
        name: pointerDown$1,
        passive: false,
        handler(e) {
          this.init(e);
        }
      },
      computed: {
        target: (_, $el) => ($el.tBodies || [$el])[0],
        items() {
          return children(this.target);
        },
        isEmpty() {
          return !this.items.length;
        },
        handles({ handle }, $el) {
          return handle ? $$(handle, $el) : this.items;
        }
      },
      watch: {
        isEmpty(empty) {
          toggleClass(this.target, this.clsEmpty, empty);
        },
        handles(handles, prev) {
          css(prev, { touchAction: "", userSelect: "" });
          css(handles, { touchAction: "none", userSelect: "none" });
        }
      },
      update: {
        write(data) {
          if (!this.drag || !parent(this.placeholder)) {
            return;
          }
          const {
            pos: { x, y },
            origin: { offsetTop, offsetLeft },
            placeholder
          } = this;
          css(this.drag, {
            top: y - offsetTop,
            left: x - offsetLeft
          });
          const sortable = this.getSortable(document.elementFromPoint(x, y));
          if (!sortable) {
            return;
          }
          const { items } = sortable;
          if (items.some(Transition.inProgress)) {
            return;
          }
          const target = findTarget(items, { x, y });
          if (items.length && (!target || target === placeholder)) {
            return;
          }
          const previous = this.getSortable(placeholder);
          const insertTarget = findInsertTarget(
            sortable.target,
            target,
            placeholder,
            x,
            y,
            sortable === previous && data.moved !== target
          );
          if (insertTarget === false) {
            return;
          }
          if (insertTarget && placeholder === insertTarget) {
            return;
          }
          if (sortable !== previous) {
            previous.remove(placeholder);
            data.moved = target;
          } else {
            delete data.moved;
          }
          sortable.insert(placeholder, insertTarget);
          this.touched.add(sortable);
        },
        events: ["move"]
      },
      methods: {
        init(e) {
          const { target, button, defaultPrevented } = e;
          const [placeholder] = this.items.filter((el) => el.contains(target));
          if (!placeholder || defaultPrevented || button > 0 || isInput(target) || target.closest(`.${this.clsNoDrag}`) || this.handle && !target.closest(this.handle)) {
            return;
          }
          e.preventDefault();
          this.pos = getEventPos(e);
          this.touched = /* @__PURE__ */ new Set([this]);
          this.placeholder = placeholder;
          this.origin = { target, index: index(placeholder), ...this.pos };
          on(document, pointerMove$1, this.move);
          on(document, pointerUp$1, this.end);
          if (!this.threshold) {
            this.start(e);
          }
        },
        start(e) {
          this.drag = appendDrag(this.$container, this.placeholder);
          const { left, top } = dimensions$1(this.placeholder);
          assign(this.origin, { offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top });
          addClass(this.drag, this.clsDrag, this.clsCustom);
          addClass(this.placeholder, this.clsPlaceholder);
          addClass(this.items, this.clsItem);
          addClass(document.documentElement, this.clsDragState);
          trigger(this.$el, "start", [this, this.placeholder]);
          trackScroll(this.pos);
          this.move(e);
        },
        move: throttle(function(e) {
          assign(this.pos, getEventPos(e));
          if (!this.drag && (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold)) {
            this.start(e);
          }
          this.$emit("move");
        }),
        end() {
          off(document, pointerMove$1, this.move);
          off(document, pointerUp$1, this.end);
          if (!this.drag) {
            return;
          }
          untrackScroll();
          const sortable = this.getSortable(this.placeholder);
          if (this === sortable) {
            if (this.origin.index !== index(this.placeholder)) {
              trigger(this.$el, "moved", [this, this.placeholder]);
            }
          } else {
            trigger(sortable.$el, "added", [sortable, this.placeholder]);
            trigger(this.$el, "removed", [this, this.placeholder]);
          }
          trigger(this.$el, "stop", [this, this.placeholder]);
          remove$1(this.drag);
          this.drag = null;
          for (const { clsPlaceholder, clsItem } of this.touched) {
            for (const sortable2 of this.touched) {
              removeClass(sortable2.items, clsPlaceholder, clsItem);
            }
          }
          this.touched = null;
          removeClass(document.documentElement, this.clsDragState);
        },
        insert(element, target) {
          addClass(this.items, this.clsItem);
          if (target && target.previousElementSibling !== element) {
            this.animate(() => before(target, element));
          } else if (!target && this.target.lastElementChild !== element) {
            this.animate(() => append(this.target, element));
          }
        },
        remove(element) {
          if (this.target.contains(element)) {
            this.animate(() => remove$1(element));
          }
        },
        getSortable(element) {
          do {
            const sortable = this.$getComponent(element, "sortable");
            if (sortable && (sortable === this || this.group !== false && sortable.group === this.group)) {
              return sortable;
            }
          } while (element = parent(element));
        }
      }
    };
    let trackTimer;
    function trackScroll(pos) {
      let last = Date.now();
      trackTimer = setInterval(() => {
        let { x, y } = pos;
        y += document.scrollingElement.scrollTop;
        const dist = (Date.now() - last) * 0.3;
        last = Date.now();
        scrollParents(document.elementFromPoint(x, pos.y)).reverse().some((scrollEl) => {
          let { scrollTop: scroll, scrollHeight } = scrollEl;
          const { top, bottom, height: height2 } = offsetViewport(scrollEl);
          if (top < y && top + 35 > y) {
            scroll -= dist;
          } else if (bottom > y && bottom - 35 < y) {
            scroll += dist;
          } else {
            return;
          }
          if (scroll > 0 && scroll < scrollHeight - height2) {
            scrollEl.scrollTop = scroll;
            return true;
          }
        });
      }, 15);
    }
    function untrackScroll() {
      clearInterval(trackTimer);
    }
    function appendDrag(container, element) {
      let clone;
      if (isTag(element, "li", "tr")) {
        clone = $("<div>");
        append(clone, element.cloneNode(true).children);
        for (const attribute of element.getAttributeNames()) {
          attr(clone, attribute, element.getAttribute(attribute));
        }
      } else {
        clone = element.cloneNode(true);
      }
      append(container, clone);
      css(clone, "margin", "0", "important");
      css(clone, {
        boxSizing: "border-box",
        width: element.offsetWidth,
        height: element.offsetHeight,
        padding: css(element, "padding")
      });
      height(clone.firstElementChild, height(element.firstElementChild));
      return clone;
    }
    function findTarget(items, point) {
      return items[findIndex(items, (item) => pointInRect(point, dimensions$1(item)))];
    }
    function findInsertTarget(list, target, placeholder, x, y, sameList) {
      if (!children(list).length) {
        return;
      }
      const rect = dimensions$1(target);
      if (!sameList) {
        if (!isHorizontal(list, placeholder)) {
          return y < rect.top + rect.height / 2 ? target : target.nextElementSibling;
        }
        return target;
      }
      const placeholderRect = dimensions$1(placeholder);
      const sameRow = linesIntersect(
        [rect.top, rect.bottom],
        [placeholderRect.top, placeholderRect.bottom]
      );
      const [pointerPos, lengthProp, startProp, endProp] = sameRow ? [x, "width", "left", "right"] : [y, "height", "top", "bottom"];
      const diff = placeholderRect[lengthProp] < rect[lengthProp] ? rect[lengthProp] - placeholderRect[lengthProp] : 0;
      if (placeholderRect[startProp] < rect[startProp]) {
        if (diff && pointerPos < rect[startProp] + diff) {
          return false;
        }
        return target.nextElementSibling;
      }
      if (diff && pointerPos > rect[endProp] - diff) {
        return false;
      }
      return target;
    }
    function isHorizontal(list, placeholder) {
      const single = children(list).length === 1;
      if (single) {
        append(list, placeholder);
      }
      const items = children(list);
      const isHorizontal2 = items.some((el, i) => {
        const rectA = dimensions$1(el);
        return items.slice(i + 1).some((el2) => {
          const rectB = dimensions$1(el2);
          return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]);
        });
      });
      if (single) {
        remove$1(placeholder);
      }
      return isHorizontal2;
    }
    function linesIntersect(lineA, lineB) {
      return lineA[1] > lineB[0] && lineB[1] > lineA[0];
    }
    function throttle(fn) {
      let throttled;
      return function(...args) {
        if (!throttled) {
          throttled = true;
          fn.call(this, ...args);
          requestAnimationFrame(() => throttled = false);
        }
      };
    }

    var tooltip = {
      mixins: [Container, Togglable, Position],
      data: {
        pos: "top",
        animation: ["uk-animation-scale-up"],
        duration: 100,
        cls: "uk-active"
      },
      connected() {
        makeFocusable(this.$el);
      },
      disconnected() {
        this.hide();
      },
      methods: {
        show() {
          if (this.isToggled(this.tooltip || null)) {
            return;
          }
          const { delay = 0, title } = parseProps(this.$options);
          if (!title) {
            return;
          }
          const titleAttr = attr(this.$el, "title");
          const off = on(this.$el, ["blur", pointerLeave], (e) => !isTouch(e) && this.hide());
          this.reset = () => {
            attr(this.$el, { title: titleAttr, "aria-describedby": null });
            off();
          };
          const id = generateId(this);
          attr(this.$el, { title: null, "aria-describedby": id });
          clearTimeout(this.showTimer);
          this.showTimer = setTimeout(() => this._show(title, id), delay);
        },
        async hide() {
          var _a;
          if (matches(this.$el, "input:focus")) {
            return;
          }
          clearTimeout(this.showTimer);
          if (this.isToggled(this.tooltip || null)) {
            await this.toggleElement(this.tooltip, false, false);
          }
          (_a = this.reset) == null ? void 0 : _a.call(this);
          remove$1(this.tooltip);
          this.tooltip = null;
        },
        async _show(title, id) {
          this.tooltip = append(
            this.container,
            `<div id="${id}" class="uk-${this.$options.name}" role="tooltip"> <div class="uk-${this.$options.name}-inner">${title}</div> </div>`
          );
          on(this.tooltip, "toggled", (e, toggled) => {
            if (!toggled) {
              return;
            }
            const update = () => this.positionAt(this.tooltip, this.$el);
            update();
            const [dir, align] = getAlignment(this.tooltip, this.$el, this.pos);
            this.origin = this.axis === "y" ? `${flipPosition(dir)}-${align}` : `${align}-${flipPosition(dir)}`;
            const handlers = [
              once(
                document,
                `keydown ${pointerDown$1}`,
                this.hide,
                false,
                (e2) => e2.type === pointerDown$1 && !this.$el.contains(e2.target) || e2.type === "keydown" && e2.keyCode === keyMap.ESC
              ),
              on([document, ...overflowParents(this.$el)], "scroll", update, {
                passive: true
              })
            ];
            once(this.tooltip, "hide", () => handlers.forEach((handler) => handler()), {
              self: true
            });
          });
          if (!await this.toggleElement(this.tooltip, true)) {
            this.hide();
          }
        }
      },
      events: {
        // Clicking a button does not give it focus on all browsers and platforms
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus
        [`focus ${pointerEnter} ${pointerDown$1}`](e) {
          if ((!isTouch(e) || e.type === pointerDown$1) && document.readyState !== "loading") {
            this.show();
          }
        }
      }
    };
    function makeFocusable(el) {
      if (!isFocusable(el)) {
        attr(el, "tabindex", "0");
      }
    }
    function getAlignment(el, target, [dir, align]) {
      const elOffset = offset(el);
      const targetOffset = offset(target);
      const properties = [
        ["left", "right"],
        ["top", "bottom"]
      ];
      for (const props2 of properties) {
        if (elOffset[props2[0]] >= targetOffset[props2[1]]) {
          dir = props2[1];
          break;
        }
        if (elOffset[props2[1]] <= targetOffset[props2[0]]) {
          dir = props2[0];
          break;
        }
      }
      const props = includes(properties[0], dir) ? properties[1] : properties[0];
      align = props.find((prop) => elOffset[prop] === targetOffset[prop]) || "center";
      return [dir, align];
    }
    function parseProps(options) {
      const { el, id, data: data$1 } = options;
      return ["delay", "title"].reduce((obj, key) => ({ [key]: data(el, key), ...obj }), {
        ...parseOptions(data(el, id), ["title"]),
        ...data$1
      });
    }

    var upload = {
      mixins: [I18n],
      i18n: {
        invalidMime: "Invalid File Type: %s",
        invalidName: "Invalid File Name: %s",
        invalidSize: "Invalid File Size: %s Kilobytes Max"
      },
      props: {
        allow: String,
        clsDragover: String,
        concurrent: Number,
        maxSize: Number,
        method: String,
        mime: String,
        multiple: Boolean,
        name: String,
        params: Object,
        type: String,
        url: String
      },
      data: {
        allow: false,
        clsDragover: "uk-dragover",
        concurrent: 1,
        maxSize: 0,
        method: "POST",
        mime: false,
        multiple: false,
        name: "files[]",
        params: {},
        type: "",
        url: "",
        abort: noop,
        beforeAll: noop,
        beforeSend: noop,
        complete: noop,
        completeAll: noop,
        error: noop,
        fail: noop,
        load: noop,
        loadEnd: noop,
        loadStart: noop,
        progress: noop
      },
      events: {
        change(e) {
          if (!matches(e.target, 'input[type="file"]')) {
            return;
          }
          e.preventDefault();
          if (e.target.files) {
            this.upload(e.target.files);
          }
          e.target.value = "";
        },
        drop(e) {
          stop(e);
          const transfer = e.dataTransfer;
          if (!(transfer == null ? void 0 : transfer.files)) {
            return;
          }
          removeClass(this.$el, this.clsDragover);
          this.upload(transfer.files);
        },
        dragenter(e) {
          stop(e);
        },
        dragover(e) {
          stop(e);
          addClass(this.$el, this.clsDragover);
        },
        dragleave(e) {
          stop(e);
          removeClass(this.$el, this.clsDragover);
        }
      },
      methods: {
        async upload(files) {
          files = toArray(files);
          if (!files.length) {
            return;
          }
          trigger(this.$el, "upload", [files]);
          for (const file of files) {
            if (this.maxSize && this.maxSize * 1e3 < file.size) {
              this.fail(this.t("invalidSize", this.maxSize));
              return;
            }
            if (this.allow && !match$1(this.allow, file.name)) {
              this.fail(this.t("invalidName", this.allow));
              return;
            }
            if (this.mime && !match$1(this.mime, file.type)) {
              this.fail(this.t("invalidMime", this.mime));
              return;
            }
          }
          if (!this.multiple) {
            files = files.slice(0, 1);
          }
          this.beforeAll(this, files);
          const chunks = chunk(files, this.concurrent);
          const upload = async (files2) => {
            const data = new FormData();
            files2.forEach((file) => data.append(this.name, file));
            for (const key in this.params) {
              data.append(key, this.params[key]);
            }
            try {
              const xhr = await ajax(this.url, {
                data,
                method: this.method,
                responseType: this.type,
                beforeSend: (env) => {
                  const { xhr: xhr2 } = env;
                  on(xhr2.upload, "progress", this.progress);
                  for (const type of ["loadStart", "load", "loadEnd", "abort"]) {
                    on(xhr2, type.toLowerCase(), this[type]);
                  }
                  return this.beforeSend(env);
                }
              });
              this.complete(xhr);
              if (chunks.length) {
                await upload(chunks.shift());
              } else {
                this.completeAll(xhr);
              }
            } catch (e) {
              this.error(e);
            }
          };
          await upload(chunks.shift());
        }
      }
    };
    function match$1(pattern, path) {
      return path.match(
        new RegExp(
          `^${pattern.replace(/\//g, "\\/").replace(/\*\*/g, "(\\/[^\\/]+)*").replace(/\*/g, "[^\\/]+").replace(/((?!\\))\?/g, "$1.")}$`,
          "i"
        )
      );
    }
    function chunk(files, size) {
      const chunks = [];
      for (let i = 0; i < files.length; i += size) {
        chunks.push(files.slice(i, i + size));
      }
      return chunks;
    }
    function stop(e) {
      e.preventDefault();
      e.stopPropagation();
    }
    async function ajax(url, options) {
      const env = {
        data: null,
        method: "GET",
        headers: {},
        xhr: new XMLHttpRequest(),
        beforeSend: noop,
        responseType: "",
        ...options
      };
      await env.beforeSend(env);
      return send(url, env);
    }
    function send(url, env) {
      return new Promise((resolve, reject) => {
        const { xhr } = env;
        for (const prop in env) {
          if (prop in xhr) {
            try {
              xhr[prop] = env[prop];
            } catch (e) {
            }
          }
        }
        xhr.open(env.method.toUpperCase(), url);
        for (const header in env.headers) {
          xhr.setRequestHeader(header, env.headers[header]);
        }
        on(xhr, "load", () => {
          if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
            resolve(xhr);
          } else {
            reject(
              assign(Error(xhr.statusText), {
                xhr,
                status: xhr.status
              })
            );
          }
        });
        on(xhr, "error", () => reject(assign(Error("Network Error"), { xhr })));
        on(xhr, "timeout", () => reject(assign(Error("Network Timeout"), { xhr })));
        xhr.send(env.data);
      });
    }

    var components$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Countdown: countdown,
        Filter: filter,
        Lightbox: lightbox,
        LightboxPanel: LightboxPanel,
        Notification: notification,
        Parallax: parallax,
        Slider: slider,
        SliderParallax: sliderParallax,
        Slideshow: slideshow,
        SlideshowParallax: sliderParallax,
        Sortable: sortable,
        Tooltip: tooltip,
        Upload: upload
    });

    function boot(App) {
      if (inBrowser && window.MutationObserver) {
        if (document.body) {
          requestAnimationFrame(() => init(App));
        } else {
          new MutationObserver((records, observer) => {
            if (document.body) {
              init(App);
              observer.disconnect();
            }
          }).observe(document.documentElement, { childList: true });
        }
      }
    }
    function init(App) {
      trigger(document, "uikit:init", App);
      if (document.body) {
        apply(document.body, connect);
      }
      new MutationObserver(handleMutation).observe(document, {
        subtree: true,
        childList: true,
        attributes: true
      });
      App._initialized = true;
    }
    function handleMutation(records) {
      var _a;
      for (const { addedNodes, removedNodes, target, attributeName } of records) {
        for (const node of addedNodes) {
          apply(node, connect);
        }
        for (const node of removedNodes) {
          apply(node, disconnect);
        }
        const name = attributeName && getComponentName(attributeName);
        if (name) {
          if (hasAttr(target, attributeName)) {
            createComponent(name, target);
          } else {
            (_a = getComponent(target, name)) == null ? void 0 : _a.$destroy();
          }
        }
      }
    }
    function connect(node) {
      const components2 = getComponents(node);
      for (const name in components2) {
        callConnected(components2[name]);
      }
      for (const attributeName of node.getAttributeNames()) {
        const name = getComponentName(attributeName);
        name && createComponent(name, node);
      }
    }
    function disconnect(node) {
      const components2 = getComponents(node);
      for (const name in components2) {
        callDisconnected(components2[name]);
      }
    }
    function getComponentName(attribute) {
      if (startsWith(attribute, "data-")) {
        attribute = attribute.slice(5);
      }
      const cmp = components$2[attribute];
      return cmp && (cmp.options || cmp).name;
    }

    globalApi(App);
    instanceApi(App);

    var Accordion = {
      mixins: [Class, Togglable],
      props: {
        animation: Boolean,
        targets: String,
        active: null,
        collapsible: Boolean,
        multiple: Boolean,
        toggle: String,
        content: String,
        offset: Number
      },
      data: {
        targets: "> *",
        active: false,
        animation: true,
        collapsible: true,
        multiple: false,
        clsOpen: "uk-open",
        toggle: "> .uk-accordion-title",
        content: "> .uk-accordion-content",
        offset: 0
      },
      computed: {
        items: ({ targets }, $el) => $$(targets, $el),
        toggles({ toggle }) {
          return this.items.map((item) => $(toggle, item));
        },
        contents({ content }) {
          return this.items.map((item) => {
            var _a;
            return ((_a = item._wrapper) == null ? void 0 : _a.firstElementChild) || $(content, item);
          });
        }
      },
      watch: {
        items(items, prev) {
          if (prev || hasClass(items, this.clsOpen)) {
            return;
          }
          const active = this.active !== false && items[Number(this.active)] || !this.collapsible && items[0];
          if (active) {
            this.toggle(active, false);
          }
        },
        toggles() {
          this.$emit();
        },
        contents(items) {
          for (const el of items) {
            const isOpen = hasClass(
              this.items.find((item) => item.contains(el)),
              this.clsOpen
            );
            hide(el, !isOpen);
          }
          this.$emit();
        }
      },
      observe: lazyload(),
      events: [
        {
          name: "click keydown",
          delegate: ({ targets, $props }) => `${targets} ${$props.toggle}`,
          async handler(e) {
            var _a;
            if (e.type === "keydown" && e.keyCode !== keyMap.SPACE) {
              return;
            }
            e.preventDefault();
            (_a = this._off) == null ? void 0 : _a.call(this);
            this._off = keepScrollPosition(e.target);
            await this.toggle(index(this.toggles, e.current));
            this._off();
          }
        },
        {
          name: "shown hidden",
          self: true,
          delegate: ({ targets }) => targets,
          handler() {
            this.$emit();
          }
        }
      ],
      update() {
        const activeItems = filter$1(this.items, `.${this.clsOpen}`);
        for (const index2 in this.items) {
          const toggle = this.toggles[index2];
          const content = this.contents[index2];
          if (!toggle || !content) {
            continue;
          }
          toggle.id = generateId(this, toggle);
          content.id = generateId(this, content);
          const active = includes(activeItems, this.items[index2]);
          attr(toggle, {
            role: isTag(toggle, "a") ? "button" : null,
            "aria-controls": content.id,
            "aria-expanded": active,
            "aria-disabled": !this.collapsible && activeItems.length < 2 && active
          });
          attr(content, { role: "region", "aria-labelledby": toggle.id });
          if (isTag(content, "ul")) {
            attr(children(content), "role", "presentation");
          }
        }
      },
      methods: {
        toggle(item, animate) {
          item = this.items[getIndex(item, this.items)];
          let items = [item];
          const activeItems = filter$1(this.items, `.${this.clsOpen}`);
          if (!this.multiple && !includes(activeItems, items[0])) {
            items = items.concat(activeItems);
          }
          if (!this.collapsible && activeItems.length < 2 && includes(activeItems, item)) {
            return;
          }
          return Promise.all(
            items.map(
              (el) => this.toggleElement(el, !includes(activeItems, el), (el2, show) => {
                toggleClass(el2, this.clsOpen, show);
                if (animate === false || !this.animation) {
                  hide($(this.content, el2), !show);
                  return;
                }
                return transition(el2, show, this);
              })
            )
          );
        }
      }
    };
    function hide(el, hide2) {
      el && (el.hidden = hide2);
    }
    async function transition(el, show, { content, duration, velocity, transition: transition2 }) {
      var _a;
      content = ((_a = el._wrapper) == null ? void 0 : _a.firstElementChild) || $(content, el);
      if (!el._wrapper) {
        el._wrapper = wrapAll(content, "<div>");
      }
      const wrapper = el._wrapper;
      css(wrapper, "overflow", "hidden");
      const currentHeight = toFloat(css(wrapper, "height"));
      await Transition.cancel(wrapper);
      hide(content, false);
      const endHeight = sumBy(["marginTop", "marginBottom"], (prop) => css(content, prop)) + dimensions$1(content).height;
      const percent = currentHeight / endHeight;
      duration = (velocity * endHeight + duration) * (show ? 1 - percent : percent);
      css(wrapper, "height", currentHeight);
      await Transition.start(wrapper, { height: show ? endHeight : 0 }, duration, transition2);
      unwrap(content);
      delete el._wrapper;
      if (!show) {
        hide(content, true);
      }
    }
    function keepScrollPosition(el) {
      const scrollElement = scrollParent(el, true);
      let frame;
      (function scroll() {
        frame = requestAnimationFrame(() => {
          const { top } = dimensions$1(el);
          if (top < 0) {
            scrollElement.scrollTop += top;
          }
          scroll();
        });
      })();
      return () => requestAnimationFrame(() => cancelAnimationFrame(frame));
    }

    var alert = {
      mixins: [Class, Togglable],
      args: "animation",
      props: {
        animation: Boolean,
        close: String
      },
      data: {
        animation: true,
        selClose: ".uk-alert-close",
        duration: 150
      },
      events: {
        name: "click",
        delegate: ({ selClose }) => selClose,
        handler(e) {
          e.preventDefault();
          this.close();
        }
      },
      methods: {
        async close() {
          await this.toggleElement(this.$el, false, animate);
          this.$destroy(true);
        }
      }
    };
    function animate(el, show, { duration, transition, velocity }) {
      const height = toFloat(css(el, "height"));
      css(el, "height", height);
      return Transition.start(
        el,
        {
          height: 0,
          marginTop: 0,
          marginBottom: 0,
          paddingTop: 0,
          paddingBottom: 0,
          borderTop: 0,
          borderBottom: 0,
          opacity: 0
        },
        velocity * height + duration,
        transition
      );
    }

    var Video = {
      args: "autoplay",
      props: {
        automute: Boolean,
        autoplay: Boolean
      },
      data: {
        automute: false,
        autoplay: true
      },
      beforeConnect() {
        if (this.autoplay === "inview" && !hasAttr(this.$el, "preload")) {
          this.$el.preload = "none";
        }
        if (isTag(this.$el, "iframe") && !hasAttr(this.$el, "allow")) {
          this.$el.allow = "autoplay";
        }
        if (this.autoplay === "hover") {
          if (isTag(this.$el, "video")) {
            this.$el.tabindex = 0;
          } else {
            this.autoplay = true;
          }
        }
        if (this.automute) {
          mute(this.$el);
        }
      },
      events: [
        {
          name: `${pointerEnter} focusin`,
          filter: ({ autoplay }) => includes(autoplay, "hover"),
          handler(e) {
            if (!isTouch(e) || !isPlaying(this.$el)) {
              play(this.$el);
            } else {
              pause(this.$el);
            }
          }
        },
        {
          name: `${pointerLeave} focusout`,
          filter: ({ autoplay }) => includes(autoplay, "hover"),
          handler(e) {
            if (!isTouch(e)) {
              pause(this.$el);
            }
          }
        }
      ],
      observe: [
        intersection({
          filter: ({ autoplay }) => autoplay !== "hover",
          handler([{ isIntersecting }]) {
            if (!document.fullscreenElement) {
              if (isIntersecting) {
                if (this.autoplay) {
                  play(this.$el);
                }
              } else {
                pause(this.$el);
              }
            }
          },
          args: { intersecting: false },
          options: ({ $el, autoplay }) => ({
            root: autoplay === "inview" ? null : parent($el).closest(":not(a)")
          })
        })
      ]
    };
    function isPlaying(videoEl) {
      return !videoEl.paused && !videoEl.ended;
    }

    var cover = {
      mixins: [Video],
      props: {
        width: Number,
        height: Number
      },
      data: {
        automute: true
      },
      created() {
        this.useObjectFit = isTag(this.$el, "img", "video");
      },
      observe: resize({
        target: ({ $el }) => getPositionedParent($el) || parent($el),
        filter: ({ useObjectFit }) => !useObjectFit
      }),
      update: {
        read() {
          if (this.useObjectFit) {
            return false;
          }
          const { ratio, cover } = Dimensions;
          const { $el, width, height } = this;
          let dim = { width, height };
          if (!width || !height) {
            const intrinsic = {
              width: $el.naturalWidth || $el.videoWidth || $el.clientWidth,
              height: $el.naturalHeight || $el.videoHeight || $el.clientHeight
            };
            if (width) {
              dim = ratio(intrinsic, "width", width);
            } else if (height) {
              dim = ratio(intrinsic, "height", height);
            } else {
              dim = intrinsic;
            }
          }
          const { offsetHeight: coverHeight, offsetWidth: coverWidth } = getPositionedParent($el) || parent($el);
          const coverDim = cover(dim, { width: coverWidth, height: coverHeight });
          if (!coverDim.width || !coverDim.height) {
            return false;
          }
          return coverDim;
        },
        write({ height, width }) {
          css(this.$el, { height, width });
        },
        events: ["resize"]
      }
    };
    function getPositionedParent(el) {
      while (el = parent(el)) {
        if (css(el, "position") !== "static") {
          return el;
        }
      }
    }

    let active;
    var drop = {
      mixins: [Container, Position, Togglable],
      args: "pos",
      props: {
        mode: "list",
        toggle: Boolean,
        boundary: Boolean,
        boundaryX: Boolean,
        boundaryY: Boolean,
        target: Boolean,
        targetX: Boolean,
        targetY: Boolean,
        stretch: Boolean,
        delayShow: Number,
        delayHide: Number,
        autoUpdate: Boolean,
        clsDrop: String,
        animateOut: Boolean,
        bgScroll: Boolean,
        closeOnScroll: Boolean
      },
      data: {
        mode: ["click", "hover"],
        toggle: "- *",
        boundary: false,
        boundaryX: false,
        boundaryY: false,
        target: false,
        targetX: false,
        targetY: false,
        stretch: false,
        delayShow: 0,
        delayHide: 800,
        autoUpdate: true,
        clsDrop: false,
        animateOut: false,
        bgScroll: true,
        animation: ["uk-animation-fade"],
        cls: "uk-open",
        container: false,
        closeOnScroll: false
      },
      computed: {
        boundary({ boundary, boundaryX, boundaryY }, $el) {
          return [
            query(boundaryX || boundary, $el) || window,
            query(boundaryY || boundary, $el) || window
          ];
        },
        target({ target, targetX, targetY }, $el) {
          targetX || (targetX = target || this.targetEl);
          targetY || (targetY = target || this.targetEl);
          return [
            targetX === true ? window : query(targetX, $el),
            targetY === true ? window : query(targetY, $el)
          ];
        }
      },
      created() {
        this.tracker = new MouseTracker();
      },
      beforeConnect() {
        this.clsDrop = this.$props.clsDrop || this.$options.id;
      },
      connected() {
        addClass(this.$el, "uk-drop", this.clsDrop);
        if (this.toggle && !this.targetEl) {
          this.targetEl = createToggleComponent(this);
        }
        this._style = pick(this.$el.style, ["width", "height"]);
      },
      disconnected() {
        if (this.isActive()) {
          this.hide(false);
          active = null;
        }
        css(this.$el, this._style);
      },
      events: [
        {
          name: "click",
          delegate: () => ".uk-drop-close",
          handler(e) {
            e.preventDefault();
            this.hide(false);
          }
        },
        {
          name: "click",
          delegate: () => 'a[href*="#"]',
          handler({ defaultPrevented, current }) {
            const { hash } = current;
            if (!defaultPrevented && hash && isSameSiteAnchor(current) && !this.$el.contains($(hash))) {
              this.hide(false);
            }
          }
        },
        {
          name: "beforescroll",
          handler() {
            this.hide(false);
          }
        },
        {
          name: "toggle",
          self: true,
          handler(e, toggle) {
            e.preventDefault();
            if (this.isToggled()) {
              this.hide(false);
            } else {
              this.show(toggle == null ? void 0 : toggle.$el, false);
            }
          }
        },
        {
          name: "toggleshow",
          self: true,
          handler(e, toggle) {
            e.preventDefault();
            this.show(toggle == null ? void 0 : toggle.$el);
          }
        },
        {
          name: "togglehide",
          self: true,
          handler(e) {
            e.preventDefault();
            if (!matches(this.$el, ":focus,:hover")) {
              this.hide();
            }
          }
        },
        {
          name: `${pointerEnter} focusin`,
          filter: ({ mode }) => includes(mode, "hover"),
          handler(e) {
            if (!isTouch(e)) {
              this.clearTimers();
            }
          }
        },
        {
          name: `${pointerLeave} focusout`,
          filter: ({ mode }) => includes(mode, "hover"),
          handler(e) {
            if (!isTouch(e) && e.relatedTarget) {
              this.hide();
            }
          }
        },
        {
          name: "toggled",
          self: true,
          handler(e, toggled) {
            if (toggled) {
              this.clearTimers();
              this.position();
            }
          }
        },
        {
          name: "show",
          self: true,
          handler() {
            active = this;
            this.tracker.init();
            attr(this.targetEl, "aria-expanded", true);
            const handlers = [
              listenForResize(this),
              listenForEscClose(this),
              listenForBackgroundClose(this),
              this.autoUpdate && listenForScroll(this),
              this.closeOnScroll && listenForScrollClose(this)
            ];
            once(this.$el, "hide", () => handlers.forEach((handler) => handler && handler()), {
              self: true
            });
            if (!this.bgScroll) {
              once(this.$el, "hidden", preventBackgroundScroll(this.$el), { self: true });
            }
          }
        },
        {
          name: "beforehide",
          self: true,
          handler() {
            this.clearTimers();
          }
        },
        {
          name: "hide",
          handler({ target }) {
            if (this.$el !== target) {
              active = active === null && this.$el.contains(target) && this.isToggled() ? this : active;
              return;
            }
            active = this.isActive() ? null : active;
            this.tracker.cancel();
            attr(this.targetEl, "aria-expanded", null);
          }
        }
      ],
      update: {
        write() {
          if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) {
            this.position();
          }
        }
      },
      methods: {
        show(target = this.targetEl, delay = true) {
          if (this.isToggled() && target && this.targetEl && target !== this.targetEl) {
            this.hide(false, false);
          }
          this.targetEl = target;
          this.clearTimers();
          if (this.isActive()) {
            return;
          }
          if (active) {
            if (delay && active.isDelaying()) {
              this.showTimer = setTimeout(() => matches(target, ":hover") && this.show(), 10);
              return;
            }
            let prev;
            while (active && prev !== active && !active.$el.contains(this.$el)) {
              prev = active;
              active.hide(false, false);
            }
          }
          if (this.container && parent(this.$el) !== this.container) {
            append(this.container, this.$el);
          }
          this.showTimer = setTimeout(
            () => this.toggleElement(this.$el, true),
            delay && this.delayShow || 0
          );
        },
        hide(delay = true, animate = true) {
          const hide = () => this.toggleElement(this.$el, false, this.animateOut && animate);
          this.clearTimers();
          this.isDelayedHide = delay;
          if (delay && this.isDelaying()) {
            this.hideTimer = setTimeout(this.hide, 50);
          } else if (delay && this.delayHide) {
            this.hideTimer = setTimeout(hide, this.delayHide);
          } else {
            hide();
          }
        },
        clearTimers() {
          clearTimeout(this.showTimer);
          clearTimeout(this.hideTimer);
          this.showTimer = null;
          this.hideTimer = null;
        },
        isActive() {
          return active === this;
        },
        isDelaying() {
          return [this.$el, ...$$(".uk-drop", this.$el)].some((el) => this.tracker.movesTo(el));
        },
        position() {
          const restoreScrollPosition = storeScrollPosition(this.$el);
          removeClass(this.$el, "uk-drop-stack");
          css(this.$el, this._style);
          this.$el.hidden = true;
          const viewports = this.target.map((target) => getViewport$1(this.$el, target));
          const viewportOffset = this.getViewportOffset(this.$el);
          const dirs = [
            [0, ["x", "width", "left", "right"]],
            [1, ["y", "height", "top", "bottom"]]
          ];
          for (const [i, [axis, prop]] of dirs) {
            if (this.axis !== axis && includes([axis, true], this.stretch)) {
              css(this.$el, {
                [prop]: Math.min(
                  offset(this.boundary[i])[prop],
                  viewports[i][prop] - 2 * viewportOffset
                ),
                [`overflow-${axis}`]: "auto"
              });
            }
          }
          const maxWidth = viewports[0].width - 2 * viewportOffset;
          this.$el.hidden = false;
          css(this.$el, "maxWidth", "");
          if (this.$el.offsetWidth > maxWidth) {
            addClass(this.$el, "uk-drop-stack");
          }
          css(this.$el, "maxWidth", maxWidth);
          this.positionAt(this.$el, this.target, this.boundary);
          for (const [i, [axis, prop, start, end]] of dirs) {
            if (this.axis === axis && includes([axis, true], this.stretch)) {
              const positionOffset = Math.abs(this.getPositionOffset());
              const targetOffset = offset(this.target[i]);
              const elOffset = offset(this.$el);
              css(this.$el, {
                [prop]: (targetOffset[start] > elOffset[start] ? targetOffset[this.inset ? end : start] - Math.max(
                  offset(this.boundary[i])[start],
                  viewports[i][start] + viewportOffset
                ) : Math.min(
                  offset(this.boundary[i])[end],
                  viewports[i][end] - viewportOffset
                ) - targetOffset[this.inset ? start : end]) - positionOffset,
                [`overflow-${axis}`]: "auto"
              });
              this.positionAt(this.$el, this.target, this.boundary);
            }
          }
          restoreScrollPosition();
        }
      }
    };
    function getViewport$1(el, target) {
      return offsetViewport(overflowParents(target).find((parent2) => parent2.contains(el)));
    }
    function createToggleComponent(drop) {
      const { $el } = drop.$create("toggle", query(drop.toggle, drop.$el), {
        target: drop.$el,
        mode: drop.mode
      });
      attr($el, "aria-haspopup", true);
      return $el;
    }
    function listenForResize(drop) {
      const update = () => drop.$emit();
      const off = [
        observeViewportResize(update),
        observeResize(overflowParents(drop.$el).concat(drop.target), update)
      ];
      return () => off.map((observer) => observer.disconnect());
    }
    function listenForScroll(drop, fn = () => drop.$emit()) {
      return on([document, ...overflowParents(drop.$el)], "scroll", fn, {
        passive: true
      });
    }
    function listenForEscClose(drop) {
      return on(document, "keydown", (e) => {
        if (e.keyCode === keyMap.ESC) {
          drop.hide(false);
        }
      });
    }
    function listenForScrollClose(drop) {
      return listenForScroll(drop, () => drop.hide(false));
    }
    function listenForBackgroundClose(drop) {
      return on(document, pointerDown$1, ({ target }) => {
        if (drop.$el.contains(target)) {
          return;
        }
        once(
          document,
          `${pointerUp$1} ${pointerCancel} scroll`,
          ({ defaultPrevented, type, target: newTarget }) => {
            var _a;
            if (!defaultPrevented && type === pointerUp$1 && target === newTarget && !((_a = drop.targetEl) == null ? void 0 : _a.contains(target))) {
              drop.hide(false);
            }
          },
          true
        );
      });
    }

    var Dropnav = {
      mixins: [Class, Container],
      props: {
        align: String,
        clsDrop: String,
        boundary: Boolean,
        dropbar: Boolean,
        dropbarAnchor: Boolean,
        duration: Number,
        mode: Boolean,
        offset: Boolean,
        stretch: Boolean,
        delayShow: Boolean,
        delayHide: Boolean,
        target: Boolean,
        targetX: Boolean,
        targetY: Boolean,
        animation: Boolean,
        animateOut: Boolean,
        closeOnScroll: Boolean
      },
      data: {
        align: isRtl ? "right" : "left",
        clsDrop: "uk-dropdown",
        clsDropbar: "uk-dropnav-dropbar",
        boundary: true,
        dropbar: false,
        dropbarAnchor: false,
        duration: 200,
        container: false,
        selNavItem: "> li > a, > ul > li > a"
      },
      computed: {
        dropbarAnchor: ({ dropbarAnchor }, $el) => query(dropbarAnchor, $el) || $el,
        dropbar({ dropbar }) {
          if (!dropbar) {
            return null;
          }
          dropbar = this._dropbar || query(dropbar, this.$el) || $(`+ .${this.clsDropbar}`, this.$el);
          return dropbar ? dropbar : this._dropbar = $("<div></div>");
        },
        dropContainer(_, $el) {
          return this.container || $el;
        },
        dropdowns({ clsDrop }, $el) {
          var _a;
          const dropdowns = $$(`.${clsDrop}`, $el);
          if (this.dropContainer !== $el) {
            for (const el of $$(`.${clsDrop}`, this.dropContainer)) {
              const target = (_a = this.getDropdown(el)) == null ? void 0 : _a.targetEl;
              if (!includes(dropdowns, el) && target && this.$el.contains(target)) {
                dropdowns.push(el);
              }
            }
          }
          return dropdowns;
        },
        items({ selNavItem }, $el) {
          return $$(selNavItem, $el);
        }
      },
      watch: {
        dropbar(dropbar) {
          addClass(
            dropbar,
            "uk-dropbar",
            "uk-dropbar-top",
            this.clsDropbar,
            `uk-${this.$options.name}-dropbar`
          );
        },
        dropdowns() {
          this.initializeDropdowns();
        }
      },
      connected() {
        this.initializeDropdowns();
      },
      disconnected() {
        remove$1(this._dropbar);
        delete this._dropbar;
      },
      events: [
        {
          name: "mouseover focusin",
          delegate: ({ selNavItem }) => selNavItem,
          handler({ current }) {
            const active2 = this.getActive();
            if (active2 && includes(active2.mode, "hover") && active2.targetEl && !current.contains(active2.targetEl) && !active2.isDelaying()) {
              active2.hide(false);
            }
          }
        },
        {
          name: "keydown",
          self: true,
          delegate: ({ selNavItem }) => selNavItem,
          handler(e) {
            var _a;
            const { current, keyCode } = e;
            const active2 = this.getActive();
            if (keyCode === keyMap.DOWN && (active2 == null ? void 0 : active2.targetEl) === current) {
              e.preventDefault();
              (_a = $(selFocusable, active2.$el)) == null ? void 0 : _a.focus();
            }
            handleNavItemNavigation(e, this.items, active2);
          }
        },
        {
          name: "keydown",
          el: ({ dropContainer }) => dropContainer,
          delegate: ({ clsDrop }) => `.${clsDrop}`,
          handler(e) {
            var _a;
            const { current, keyCode, target } = e;
            if (isInput(target) || !includes(this.dropdowns, current)) {
              return;
            }
            const active2 = this.getActive();
            let next = -1;
            if (keyCode === keyMap.HOME) {
              next = 0;
            } else if (keyCode === keyMap.END) {
              next = "last";
            } else if (keyCode === keyMap.UP) {
              next = "previous";
            } else if (keyCode === keyMap.DOWN) {
              next = "next";
            } else if (keyCode === keyMap.ESC) {
              (_a = active2.targetEl) == null ? void 0 : _a.focus();
            }
            if (~next) {
              e.preventDefault();
              const elements = $$(selFocusable, current);
              elements[getIndex(
                next,
                elements,
                findIndex(elements, (el) => matches(el, ":focus"))
              )].focus();
            }
            handleNavItemNavigation(e, this.items, active2);
          }
        },
        {
          name: "mouseleave",
          el: ({ dropbar }) => dropbar,
          filter: ({ dropbar }) => dropbar,
          handler() {
            const active2 = this.getActive();
            if (active2 && includes(active2.mode, "hover") && !this.dropdowns.some((el) => matches(el, ":hover"))) {
              active2.hide();
            }
          }
        },
        {
          name: "beforeshow",
          el: ({ dropContainer }) => dropContainer,
          filter: ({ dropbar }) => dropbar,
          handler({ target }) {
            if (!this.isDropbarDrop(target)) {
              return;
            }
            if (this.dropbar.previousElementSibling !== this.dropbarAnchor) {
              after(this.dropbarAnchor, this.dropbar);
            }
            addClass(target, `${this.clsDrop}-dropbar`);
          }
        },
        {
          name: "show",
          el: ({ dropContainer }) => dropContainer,
          filter: ({ dropbar }) => dropbar,
          handler({ target }) {
            if (!this.isDropbarDrop(target)) {
              return;
            }
            const drop = this.getDropdown(target);
            const adjustHeight = () => {
              const maxBottom = Math.max(
                ...parents(target, `.${this.clsDrop}`).concat(target).map((el) => offset(el).bottom)
              );
              offset(this.dropbar, {
                left: offset(this.dropbar).left,
                top: this.getDropbarOffset(drop.getPositionOffset())
              });
              this.transitionTo(
                maxBottom - offset(this.dropbar).top + toFloat(css(target, "marginBottom")),
                target
              );
            };
            this._observer = observeResize([drop.$el, ...drop.target], adjustHeight);
            adjustHeight();
          }
        },
        {
          name: "beforehide",
          el: ({ dropContainer }) => dropContainer,
          filter: ({ dropbar }) => dropbar,
          handler(e) {
            const active2 = this.getActive();
            if (matches(this.dropbar, ":hover") && active2.$el === e.target && this.isDropbarDrop(active2.$el) && includes(active2.mode, "hover") && active2.isDelayedHide && !this.items.some((el) => active2.targetEl !== el && matches(el, ":focus"))) {
              e.preventDefault();
            }
          }
        },
        {
          name: "hide",
          el: ({ dropContainer }) => dropContainer,
          filter: ({ dropbar }) => dropbar,
          handler({ target }) {
            var _a;
            if (!this.isDropbarDrop(target)) {
              return;
            }
            (_a = this._observer) == null ? void 0 : _a.disconnect();
            const active2 = this.getActive();
            if (!active2 || active2.$el === target) {
              this.transitionTo(0);
            }
          }
        }
      ],
      methods: {
        getActive() {
          var _a;
          return includes(this.dropdowns, (_a = active) == null ? void 0 : _a.$el) && active;
        },
        async transitionTo(newHeight, el) {
          const { dropbar } = this;
          const oldHeight = height(dropbar);
          el = oldHeight < newHeight && el;
          await Transition.cancel([el, dropbar]);
          if (el) {
            const diff = offset(el).top - offset(dropbar).top - oldHeight;
            if (diff > 0) {
              css(el, "transitionDelay", `${diff / newHeight * this.duration}ms`);
            }
          }
          css(el, "clipPath", `polygon(0 0,100% 0,100% ${oldHeight}px,0 ${oldHeight}px)`);
          height(dropbar, oldHeight);
          await Promise.all([
            Transition.start(dropbar, { height: newHeight }, this.duration),
            Transition.start(
              el,
              { clipPath: `polygon(0 0,100% 0,100% ${newHeight}px,0 ${newHeight}px)` },
              this.duration
            ).finally(() => css(el, { clipPath: "", transitionDelay: "" }))
          ]).catch(noop);
        },
        getDropdown(el) {
          return this.$getComponent(el, "drop") || this.$getComponent(el, "dropdown");
        },
        isDropbarDrop(el) {
          return includes(this.dropdowns, el) && hasClass(el, this.clsDrop);
        },
        getDropbarOffset(offsetTop) {
          const { $el, target, targetY } = this;
          const { top, height: height2 } = offset(query(targetY || target || $el, $el));
          return top + height2 + offsetTop;
        },
        initializeDropdowns() {
          this.$create(
            "drop",
            this.dropdowns.filter((el) => !this.getDropdown(el)),
            {
              ...this.$props,
              flip: false,
              shift: true,
              pos: `bottom-${this.align}`,
              boundary: this.boundary === true ? this.$el : this.boundary
            }
          );
        }
      }
    };
    function handleNavItemNavigation(e, toggles, active2) {
      var _a, _b, _c;
      const { current, keyCode } = e;
      let next = -1;
      if (keyCode === keyMap.HOME) {
        next = 0;
      } else if (keyCode === keyMap.END) {
        next = "last";
      } else if (keyCode === keyMap.LEFT) {
        next = "previous";
      } else if (keyCode === keyMap.RIGHT) {
        next = "next";
      } else if (keyCode === keyMap.TAB) {
        (_a = active2.targetEl) == null ? void 0 : _a.focus();
        (_b = active2.hide) == null ? void 0 : _b.call(active2, false);
      }
      if (~next) {
        e.preventDefault();
        (_c = active2.hide) == null ? void 0 : _c.call(active2, false);
        toggles[getIndex(next, toggles, toggles.indexOf(active2.targetEl || current))].focus();
      }
    }

    var formCustom = {
      mixins: [Class],
      args: "target",
      props: {
        target: Boolean
      },
      data: {
        target: false
      },
      computed: {
        input: (_, $el) => $(selInput, $el),
        state() {
          return this.input.nextElementSibling;
        },
        target({ target }, $el) {
          return target && (target === true && parent(this.input) === $el && this.input.nextElementSibling || $(target, $el));
        }
      },
      update() {
        var _a;
        const { target, input } = this;
        if (!target) {
          return;
        }
        let option;
        const prop = isInput(target) ? "value" : "textContent";
        const prev = target[prop];
        const value = ((_a = input.files) == null ? void 0 : _a[0]) ? input.files[0].name : matches(input, "select") && (option = $$("option", input).filter((el) => el.selected)[0]) ? option.textContent : input.value;
        if (prev !== value) {
          target[prop] = value;
        }
      },
      events: [
        {
          name: "change",
          handler() {
            this.$emit();
          }
        },
        {
          name: "reset",
          el: ({ $el }) => $el.closest("form"),
          handler() {
            this.$emit();
          }
        }
      ]
    };

    var grid = {
      extends: Margin,
      mixins: [Class],
      name: "grid",
      props: {
        masonry: Boolean,
        parallax: String,
        parallaxStart: String,
        parallaxEnd: String,
        parallaxJustify: Boolean
      },
      data: {
        margin: "uk-grid-margin",
        clsStack: "uk-grid-stack",
        masonry: false,
        parallax: 0,
        parallaxStart: 0,
        parallaxEnd: 0,
        parallaxJustify: false
      },
      connected() {
        this.masonry && addClass(this.$el, "uk-flex-top", "uk-flex-wrap-top");
      },
      observe: scroll$1({ filter: ({ parallax, parallaxJustify }) => parallax || parallaxJustify }),
      update: [
        {
          write({ rows }) {
            toggleClass(this.$el, this.clsStack, !rows.some((row) => row.length > 1));
          },
          events: ["resize"]
        },
        {
          read(data) {
            const { rows } = data;
            let { masonry, parallax, parallaxJustify, margin } = this;
            parallax = Math.max(0, toPx(parallax));
            if (!(masonry || parallax || parallaxJustify) || positionedAbsolute(rows) || rows[0].some(
              (el, i) => rows.some((row) => row[i] && row[i].offsetWidth !== el.offsetWidth)
            )) {
              return data.translates = data.scrollColumns = false;
            }
            let gutter = getGutter(rows, margin);
            let columns;
            let translates;
            if (masonry) {
              [columns, translates] = applyMasonry(rows, gutter, masonry === "next");
            } else {
              columns = transpose(rows);
            }
            const columnHeights = columns.map(
              (column) => sumBy(column, "offsetHeight") + gutter * (column.length - 1)
            );
            const height = Math.max(0, ...columnHeights);
            let scrollColumns;
            let parallaxStart;
            let parallaxEnd;
            if (parallax || parallaxJustify) {
              scrollColumns = columnHeights.map(
                (hgt, i) => parallaxJustify ? height - hgt + parallax : parallax / (i % 2 || 8)
              );
              if (!parallaxJustify) {
                parallax = Math.max(
                  ...columnHeights.map((hgt, i) => hgt + scrollColumns[i] - height)
                );
              }
              parallaxStart = toPx(this.parallaxStart, "height", this.$el, true);
              parallaxEnd = toPx(this.parallaxEnd, "height", this.$el, true);
            }
            return {
              columns,
              translates,
              scrollColumns,
              parallaxStart,
              parallaxEnd,
              padding: parallax,
              height: translates ? height : ""
            };
          },
          write({ height, padding }) {
            css(this.$el, "paddingBottom", padding || "");
            height !== false && css(this.$el, "height", height);
          },
          events: ["resize"]
        },
        {
          read({ rows, scrollColumns, parallaxStart, parallaxEnd }) {
            return {
              scrolled: scrollColumns && !positionedAbsolute(rows) ? scrolledOver(this.$el, parallaxStart, parallaxEnd) : false
            };
          },
          write({ columns, scrolled, scrollColumns, translates }) {
            if (!scrolled && !translates) {
              return;
            }
            columns.forEach(
              (column, i) => column.forEach((el, j) => {
                let [x, y] = translates && translates[i][j] || [0, 0];
                if (scrolled) {
                  y += scrolled * scrollColumns[i];
                }
                css(el, "transform", `translate(${x}px, ${y}px)`);
              })
            );
          },
          events: ["scroll", "resize"]
        }
      ]
    };
    function positionedAbsolute(rows) {
      return rows.flat().some((el) => css(el, "position") === "absolute");
    }
    function applyMasonry(rows, gutter, next) {
      const columns = [];
      const translates = [];
      const columnHeights = Array(rows[0].length).fill(0);
      let rowHeights = 0;
      for (let row of rows) {
        if (isRtl) {
          row.reverse();
        }
        let height = 0;
        for (const j in row) {
          const { offsetWidth, offsetHeight } = row[j];
          const index = next ? j : columnHeights.indexOf(Math.min(...columnHeights));
          push(columns, index, row[j]);
          push(translates, index, [
            (index - j) * offsetWidth * (isRtl ? -1 : 1),
            columnHeights[index] - rowHeights
          ]);
          columnHeights[index] += offsetHeight + gutter;
          height = Math.max(height, offsetHeight);
        }
        rowHeights += height + gutter;
      }
      return [columns, translates];
    }
    function getGutter(rows, cls) {
      const node = rows.flat().find((el) => hasClass(el, cls));
      return toFloat(node ? css(node, "marginTop") : css(rows[0][0], "paddingLeft"));
    }
    function transpose(rows) {
      const columns = [];
      for (const row of rows) {
        for (const i in row) {
          push(columns, i, row[i]);
        }
      }
      return columns;
    }
    function push(array, index, value) {
      if (!array[index]) {
        array[index] = [];
      }
      array[index].push(value);
    }

    var heightMatch = {
      args: "target",
      props: {
        target: String,
        row: Boolean
      },
      data: {
        target: "> *",
        row: true
      },
      computed: {
        elements: ({ target }, $el) => $$(target, $el)
      },
      observe: resize({
        target: ({ $el, elements }) => elements.reduce((elements2, el) => elements2.concat(el, ...el.children), [$el])
      }),
      events: {
        // Hidden elements may change height when fonts load
        name: "loadingdone",
        el: () => document.fonts,
        handler() {
          this.$emit("resize");
        }
      },
      update: {
        read() {
          return {
            rows: (this.row ? getRows(this.elements) : [this.elements]).map(match)
          };
        },
        write({ rows }) {
          for (const { heights, elements } of rows) {
            elements.forEach((el, i) => css(el, "minHeight", heights[i]));
          }
        },
        events: ["resize"]
      }
    };
    function match(elements) {
      if (elements.length < 2) {
        return { heights: [""], elements };
      }
      let heights = elements.map(getHeight);
      const max = Math.max(...heights);
      return {
        heights: elements.map((el, i) => heights[i].toFixed(2) === max.toFixed(2) ? "" : max),
        elements
      };
    }
    function getHeight(element) {
      const style = pick(element.style, ["display", "minHeight"]);
      if (!isVisible(element)) {
        css(element, "display", "block", "important");
      }
      css(element, "minHeight", "");
      const height = dimensions$1(element).height - boxModelAdjust(element, "height", "content-box");
      css(element, style);
      return height;
    }

    var heightPlaceholder = {
      args: "target",
      props: {
        target: String
      },
      data: {
        target: ""
      },
      computed: {
        target: {
          get: ({ target }, $el) => query(target, $el),
          observe: ({ target }) => target
        }
      },
      observe: resize({ target: ({ target }) => target }),
      update: {
        read() {
          return this.target ? { height: this.target.offsetHeight } : false;
        },
        write({ height }) {
          css(this.$el, "minHeight", height);
        },
        events: ["resize"]
      }
    };

    var heightViewport = {
      props: {
        expand: Boolean,
        offsetTop: Boolean,
        offsetBottom: Boolean,
        minHeight: Number
      },
      data: {
        expand: false,
        offsetTop: false,
        offsetBottom: false,
        minHeight: 0
      },
      // check for offsetTop change
      observe: [
        viewport({ filter: ({ expand }) => expand }),
        resize({ target: ({ $el }) => scrollParents($el) })
      ],
      update: {
        read() {
          if (!isVisible(this.$el)) {
            return false;
          }
          let minHeight = "";
          const box = boxModelAdjust(this.$el, "height", "content-box");
          const { body, scrollingElement } = document;
          const scrollElement = scrollParent(this.$el);
          const { height: viewportHeight } = offsetViewport(
            scrollElement === body ? scrollingElement : scrollElement
          );
          const isScrollingElement = scrollingElement === scrollElement || body === scrollElement;
          minHeight = `calc(${isScrollingElement ? "100vh" : `${viewportHeight}px`}`;
          if (this.expand) {
            const diff = dimensions$1(scrollElement).height - dimensions$1(this.$el).height;
            minHeight += ` - ${diff}px`;
          } else {
            if (this.offsetTop) {
              if (isScrollingElement) {
                const offsetTopEl = this.offsetTop === true ? this.$el : query(this.offsetTop, this.$el);
                const { top } = offset(offsetTopEl);
                minHeight += top > 0 && top < viewportHeight / 2 ? ` - ${top}px` : "";
              } else {
                minHeight += ` - ${boxModelAdjust(scrollElement, "height", css(scrollElement, "boxSizing"))}px`;
              }
            }
            if (this.offsetBottom === true) {
              minHeight += ` - ${dimensions$1(this.$el.nextElementSibling).height}px`;
            } else if (isNumeric(this.offsetBottom)) {
              minHeight += ` - ${this.offsetBottom}vh`;
            } else if (this.offsetBottom && endsWith(this.offsetBottom, "px")) {
              minHeight += ` - ${toFloat(this.offsetBottom)}px`;
            } else if (isString(this.offsetBottom)) {
              minHeight += ` - ${dimensions$1(query(this.offsetBottom, this.$el)).height}px`;
            }
          }
          minHeight += `${box ? ` - ${box}px` : ""})`;
          return { minHeight };
        },
        write({ minHeight }) {
          css(this.$el, "minHeight", `max(${this.minHeight || 0}px, ${minHeight})`);
        },
        events: ["resize"]
      }
    };

    var closeIcon = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"1\" y1=\"1\" x2=\"13\" y2=\"13\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13\" y1=\"1\" x2=\"1\" y2=\"13\"/></svg>";

    var closeLarge = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"1\" y1=\"1\" x2=\"19\" y2=\"19\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"19\" y1=\"1\" x2=\"1\" y2=\"19\"/></svg>";

    var dropParentIcon = "<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 3.5 6 8.5 11 3.5\"/></svg>";

    var marker = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><rect width=\"1\" height=\"11\" x=\"9\" y=\"4\"/><rect width=\"11\" height=\"1\" x=\"4\" y=\"9\"/></svg>";

    var navParentIconLarge = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 4 7 10 13 4\"/></svg>";

    var navParentIcon = "<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 3.5 6 8.5 11 3.5\"/></svg>";

    var navbarParentIcon = "<svg width=\"12\" height=\"12\" viewBox=\"0 0 12 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"1 3.5 6 8.5 11 3.5\"/></svg>";

    var navbarToggleIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><style>.uk-navbar-toggle-icon svg&gt;[class*=&quot;line-&quot;]{transition:0.2s ease-in-out;transition-property:transform, opacity;transform-origin:center;opacity:1}.uk-navbar-toggle-icon svg&gt;.line-3{opacity:0}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-3{opacity:1}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-2{transform:rotate(45deg)}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-3{transform:rotate(-45deg)}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-1,.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-4{opacity:0}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-1{transform:translateY(6px) scaleX(0)}.uk-navbar-toggle-animate[aria-expanded=&quot;true&quot;] svg&gt;.line-4{transform:translateY(-6px) scaleX(0)}</style><rect width=\"20\" height=\"2\" y=\"3\" class=\"line-1\"/><rect width=\"20\" height=\"2\" y=\"9\" class=\"line-2\"/><rect width=\"20\" height=\"2\" y=\"9\" class=\"line-3\"/><rect width=\"20\" height=\"2\" y=\"15\" class=\"line-4\"/></svg>";

    var overlayIcon = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><rect width=\"1\" height=\"40\" x=\"19\" y=\"0\"/><rect width=\"40\" height=\"1\" x=\"0\" y=\"19\"/></svg>";

    var paginationNext = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 1 6 6 1 11\"/></svg>";

    var paginationPrevious = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"6 1 1 6 6 11\"/></svg>";

    var searchIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>";

    var searchLarge = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" cx=\"17.5\" cy=\"17.5\" r=\"16.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" x1=\"38\" y1=\"39\" x2=\"29\" y2=\"30\"/></svg>";

    var searchMedium = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10.5\" cy=\"10.5\" r=\"9.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"23\" y1=\"23\" x2=\"17\" y2=\"17\"/></svg>";

    var slidenavNextLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"4.002,38.547 22.527,20.024 4,1.5\"/></svg>";

    var slidenavNext = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"1.225,23 12.775,12 1.225,1\"/></svg>";

    var slidenavPreviousLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"20.527,1.5 2,20.024 20.525,38.547\"/></svg>";

    var slidenavPrevious = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"12.775,1 1.225,12 12.775,23\"/></svg>";

    var spinner = "<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\"><circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/></svg>";

    var totop = "<svg width=\"18\" height=\"10\" viewBox=\"0 0 18 10\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 9 9 1 17 9\"/></svg>";

    var Svg = {
      args: "src",
      props: {
        width: Number,
        height: Number,
        ratio: Number
      },
      data: {
        ratio: 1
      },
      connected() {
        this.svg = this.getSvg().then((el) => {
          if (!this._connected) {
            return;
          }
          const svg = insertSVG(el, this.$el);
          if (this.svgEl && svg !== this.svgEl) {
            remove$1(this.svgEl);
          }
          applyWidthAndHeight.call(this, svg, el);
          return this.svgEl = svg;
        }, noop);
      },
      disconnected() {
        this.svg.then((svg) => {
          if (this._connected) {
            return;
          }
          if (isVoidElement(this.$el)) {
            this.$el.hidden = false;
          }
          remove$1(svg);
          this.svgEl = null;
        });
        this.svg = null;
      },
      methods: {
        async getSvg() {
        }
      }
    };
    function insertSVG(el, root) {
      if (isVoidElement(root) || isTag(root, "canvas")) {
        root.hidden = true;
        const next = root.nextElementSibling;
        return equals(el, next) ? next : after(root, el);
      }
      const last = root.lastElementChild;
      return equals(el, last) ? last : append(root, el);
    }
    function equals(el, other) {
      return isTag(el, "svg") && isTag(other, "svg") && el.innerHTML === other.innerHTML;
    }
    function applyWidthAndHeight(el, ref) {
      const props = ["width", "height"];
      let dimensions = props.map((prop) => this[prop]);
      if (!dimensions.some((val) => val)) {
        dimensions = props.map((prop) => attr(ref, prop));
      }
      const viewBox = attr(ref, "viewBox");
      if (viewBox && !dimensions.some((val) => val)) {
        dimensions = viewBox.split(" ").slice(2);
      }
      dimensions.forEach((val, i) => attr(el, props[i], toFloat(val) * this.ratio || null));
    }
    function parseSVG(svg, icon) {
      if (icon && includes(svg, "<symbol")) {
        svg = parseSymbols(svg)[icon] || svg;
      }
      return toNodes(fragment(svg)).filter(isElement)[0];
    }
    const symbolRe = /<symbol([^]*?id=(['"])(.+?)\2[^]*?<\/)symbol>/g;
    const parseSymbols = memoize(function(svg) {
      const symbols = {};
      symbolRe.lastIndex = 0;
      let match;
      while (match = symbolRe.exec(svg)) {
        symbols[match[3]] = `<svg ${match[1]}svg>`;
      }
      return symbols;
    });

    const icons = {
      spinner,
      totop,
      marker,
      "close-icon": closeIcon,
      "close-large": closeLarge,
      "drop-parent-icon": dropParentIcon,
      "nav-parent-icon": navParentIcon,
      "nav-parent-icon-large": navParentIconLarge,
      "navbar-parent-icon": navbarParentIcon,
      "navbar-toggle-icon": navbarToggleIcon,
      "overlay-icon": overlayIcon,
      "pagination-next": paginationNext,
      "pagination-previous": paginationPrevious,
      "search-icon": searchIcon,
      "search-medium": searchMedium,
      "search-large": searchLarge,
      "search-toggle-icon": searchIcon,
      "slidenav-next": slidenavNext,
      "slidenav-next-large": slidenavNextLarge,
      "slidenav-previous": slidenavPrevious,
      "slidenav-previous-large": slidenavPreviousLarge
    };
    const Icon = {
      install: install$1,
      mixins: [Svg],
      args: "icon",
      props: { icon: String },
      isIcon: true,
      beforeConnect() {
        addClass(this.$el, "uk-icon");
      },
      methods: {
        async getSvg() {
          const icon = getIcon(this.icon);
          if (!icon) {
            throw "Icon not found.";
          }
          return icon;
        }
      }
    };
    const IconComponent = {
      args: false,
      extends: Icon,
      data: (vm) => ({
        icon: hyphenate(vm.constructor.options.name)
      }),
      beforeConnect() {
        addClass(this.$el, this.$options.id);
      }
    };
    const NavParentIcon = {
      extends: IconComponent,
      beforeConnect() {
        const icon = this.$props.icon;
        this.icon = this.$el.closest(".uk-nav-primary") ? `${icon}-large` : icon;
      }
    };
    const Search = {
      extends: IconComponent,
      mixins: [I18n],
      i18n: { toggle: "Open Search", submit: "Submit Search" },
      beforeConnect() {
        const isToggle = hasClass(this.$el, "uk-search-toggle") || hasClass(this.$el, "uk-navbar-toggle");
        this.icon = isToggle ? "search-toggle-icon" : hasClass(this.$el, "uk-search-icon") && this.$el.closest(".uk-search-large") ? "search-large" : this.$el.closest(".uk-search-medium") ? "search-medium" : this.$props.icon;
        if (hasAttr(this.$el, "aria-label")) {
          return;
        }
        if (isToggle) {
          const label = this.t("toggle");
          attr(this.$el, "aria-label", label);
        } else {
          const button = this.$el.closest("a,button");
          if (button) {
            const label = this.t("submit");
            attr(button, "aria-label", label);
          }
        }
      }
    };
    const Spinner = {
      extends: IconComponent,
      beforeConnect() {
        attr(this.$el, "role", "status");
      },
      methods: {
        async getSvg() {
          const icon = await Icon.methods.getSvg.call(this);
          if (this.ratio !== 1) {
            css($("circle", icon), "strokeWidth", 1 / this.ratio);
          }
          return icon;
        }
      }
    };
    const ButtonComponent = {
      extends: IconComponent,
      mixins: [I18n],
      beforeConnect() {
        const button = this.$el.closest("a,button");
        attr(button, "role", this.role !== null && isTag(button, "a") ? "button" : this.role);
        const label = this.t("label");
        if (label && !hasAttr(button, "aria-label")) {
          attr(button, "aria-label", label);
        }
      }
    };
    const Slidenav = {
      extends: ButtonComponent,
      beforeConnect() {
        addClass(this.$el, "uk-slidenav");
        const icon = this.$props.icon;
        this.icon = hasClass(this.$el, "uk-slidenav-large") ? `${icon}-large` : icon;
      }
    };
    const NavbarToggleIcon = {
      extends: ButtonComponent,
      i18n: { label: "Open menu" }
    };
    const Close = {
      extends: ButtonComponent,
      i18n: { label: "Close" },
      beforeConnect() {
        this.icon = `close-${hasClass(this.$el, "uk-close-large") ? "large" : "icon"}`;
      }
    };
    const Marker = {
      extends: ButtonComponent,
      i18n: { label: "Open" }
    };
    const Totop = {
      extends: ButtonComponent,
      i18n: { label: "Back to top" }
    };
    const PaginationNext = {
      extends: ButtonComponent,
      i18n: { label: "Next page" },
      data: { role: null }
    };
    const PaginationPrevious = {
      extends: ButtonComponent,
      i18n: { label: "Previous page" },
      data: { role: null }
    };
    const parsed = {};
    function install$1(UIkit) {
      UIkit.icon.add = (name, svg) => {
        const added = isString(name) ? { [name]: svg } : name;
        each(added, (svg2, name2) => {
          icons[name2] = svg2;
          delete parsed[name2];
        });
        if (UIkit._initialized) {
          apply(
            document.body,
            (el) => each(UIkit.getComponents(el), (cmp) => {
              cmp.$options.isIcon && cmp.icon in added && cmp.$reset();
            })
          );
        }
      };
    }
    const aliases = { twitter: "x" };
    function getIcon(icon) {
      icon = aliases[icon] || icon;
      if (!icons[icon]) {
        return null;
      }
      if (!parsed[icon]) {
        parsed[icon] = parseSVG(icons[applyRtl(icon)] || icons[icon]);
      }
      return parsed[icon].cloneNode(true);
    }
    function applyRtl(icon) {
      return isRtl ? swap(swap(icon, "left", "right"), "previous", "next") : icon;
    }

    var inverse = {
      props: {
        target: String,
        selActive: String
      },
      data: {
        target: false,
        selActive: false
      },
      computed: {
        target: ({ target }, $el) => target ? $$(target, $el) : $el
      },
      observe: [
        intersection({
          handler(entries) {
            this.isIntersecting = entries.some(({ isIntersecting }) => isIntersecting);
            this.$emit();
          },
          target: ({ target }) => target,
          args: { intersecting: false }
        }),
        mutation({
          target: ({ target }) => target,
          options: { attributes: true, attributeFilter: ["class"], attributeOldValue: true }
        }),
        {
          target: ({ target }) => target,
          observe: (target, handler) => {
            const observer = observeResize(
              [...toNodes(target), document.documentElement],
              handler
            );
            const listener = [
              on(document, "scroll itemshown itemhidden", handler, {
                passive: true,
                capture: true
              }),
              on(document, "show hide transitionstart", (e) => {
                handler();
                return observer.observe(e.target);
              }),
              on(document, "shown hidden transitionend transitioncancel", (e) => {
                handler();
                return observer.unobserve(e.target);
              })
            ];
            return {
              observe: observer.observe.bind(observer),
              unobserve: observer.unobserve.bind(observer),
              disconnect() {
                observer.disconnect();
                listener.map((off) => off());
              }
            };
          },
          handler() {
            this.$emit();
          }
        }
      ],
      update: {
        read() {
          if (!this.isIntersecting) {
            return false;
          }
          for (const target of toNodes(this.target)) {
            let color = !this.selActive || matches(target, this.selActive) ? findTargetColor(target) : "";
            if (color !== false) {
              replaceClass(target, "uk-light uk-dark", color);
            }
          }
        }
      }
    };
    function findTargetColor(target) {
      const dim = dimensions$1(target);
      const viewport = dimensions$1(window);
      if (!intersectRect(dim, viewport)) {
        return false;
      }
      const { left, top, height, width } = dim;
      let last;
      for (const percent of [0.25, 0.5, 0.75]) {
        const elements = target.ownerDocument.elementsFromPoint(
          Math.max(0, Math.min(left + width * percent, viewport.width - 1)),
          Math.max(0, Math.min(top + height / 2, viewport.height - 1))
        );
        for (const element of elements) {
          if (target.contains(element) || !checkVisibility(element) || element.closest('[class*="-leave"]') && elements.some((el) => element !== el && matches(el, '[class*="-enter"]'))) {
            continue;
          }
          const color = css(element, "--uk-inverse");
          if (color) {
            if (color === last) {
              return `uk-${color}`;
            }
            last = color;
            break;
          }
        }
      }
      return last ? `uk-${last}` : "";
    }
    function checkVisibility(element) {
      if (css(element, "visibility") !== "visible") {
        return false;
      }
      while (element) {
        if (css(element, "opacity") === "0") {
          return false;
        }
        element = parent(element);
      }
      return true;
    }

    var leader = {
      mixins: [Class, Media],
      props: {
        fill: String
      },
      data: {
        fill: "",
        clsWrapper: "uk-leader-fill",
        clsHide: "uk-leader-hide",
        attrFill: "data-fill"
      },
      computed: {
        fill: ({ fill }, $el) => fill || css($el, "--uk-leader-fill-content")
      },
      connected() {
        [this.wrapper] = wrapInner(this.$el, `<span class="${this.clsWrapper}">`);
      },
      disconnected() {
        unwrap(this.wrapper.childNodes);
      },
      observe: resize(),
      update: {
        read() {
          const width = Math.trunc(this.$el.offsetWidth / 2);
          return {
            width,
            fill: this.fill,
            hide: !this.matchMedia
          };
        },
        write({ width, fill, hide }) {
          toggleClass(this.wrapper, this.clsHide, hide);
          attr(this.wrapper, this.attrFill, new Array(width).join(fill));
        },
        events: ["resize"]
      }
    };

    var modal = {
      install,
      mixins: [Modal],
      data: {
        clsPage: "uk-modal-page",
        selPanel: ".uk-modal-dialog",
        selClose: '[class*="uk-modal-close"]'
      },
      events: [
        {
          name: "fullscreenchange webkitendfullscreen",
          capture: true,
          handler(e) {
            if (isTag(e.target, "video") && this.isToggled() && !document.fullscreenElement) {
              this.hide();
            }
          }
        },
        {
          name: "show",
          self: true,
          handler() {
            if (hasClass(this.panel, "uk-margin-auto-vertical")) {
              addClass(this.$el, "uk-flex");
            } else {
              css(this.$el, "display", "block");
            }
            height(this.$el);
          }
        },
        {
          name: "hidden",
          self: true,
          handler() {
            css(this.$el, "display", "");
            removeClass(this.$el, "uk-flex");
          }
        }
      ]
    };
    function install({ modal }) {
      modal.dialog = function(content, options) {
        const dialog = modal($(`<div><div class="uk-modal-dialog">${content}</div></div>`), {
          stack: true,
          role: "alertdialog",
          ...options
        });
        dialog.show();
        on(
          dialog.$el,
          "hidden",
          async () => {
            await Promise.resolve();
            dialog.$destroy(true);
          },
          { self: true }
        );
        return dialog;
      };
      modal.alert = function(message, options) {
        return openDialog(
          ({ i18n }) => `<div class="uk-modal-body">${isString(message) ? message : html(message)}</div> <div class="uk-modal-footer uk-text-right"> <button class="uk-button uk-button-primary uk-modal-close" autofocus>${i18n.ok}</button> </div>`,
          options
        );
      };
      modal.confirm = function(message, options) {
        return openDialog(
          ({ i18n }) => `<form> <div class="uk-modal-body">${isString(message) ? message : html(message)}</div> <div class="uk-modal-footer uk-text-right"> <button class="uk-button uk-button-default uk-modal-close" type="button">${i18n.cancel}</button> <button class="uk-button uk-button-primary" autofocus>${i18n.ok}</button> </div> </form>`,
          options,
          () => Promise.reject()
        );
      };
      modal.prompt = function(message, value, options) {
        const promise = openDialog(
          ({ i18n }) => `<form class="uk-form-stacked"> <div class="uk-modal-body"> <label>${isString(message) ? message : html(message)}</label> <input class="uk-input" autofocus> </div> <div class="uk-modal-footer uk-text-right"> <button class="uk-button uk-button-default uk-modal-close" type="button">${i18n.cancel}</button> <button class="uk-button uk-button-primary">${i18n.ok}</button> </div> </form>`,
          options,
          () => null,
          () => input.value
        );
        const { $el } = promise.dialog;
        const input = $("input", $el);
        input.value = value || "";
        on($el, "show", () => input.select());
        return promise;
      };
      modal.i18n = {
        ok: "Ok",
        cancel: "Cancel"
      };
      function openDialog(tmpl, options, hideFn = noop, submitFn = noop) {
        options = {
          bgClose: false,
          escClose: true,
          ...options,
          i18n: { ...modal.i18n, ...options == null ? void 0 : options.i18n }
        };
        const dialog = modal.dialog(tmpl(options), options);
        return assign(
          new Promise((resolve) => {
            const off = on(dialog.$el, "hide", () => resolve(hideFn()));
            on(dialog.$el, "submit", "form", (e) => {
              e.preventDefault();
              resolve(submitFn(dialog));
              off();
              dialog.hide();
            });
          }),
          { dialog }
        );
      }
    }

    var nav = {
      extends: Accordion,
      data: {
        targets: "> .uk-parent",
        toggle: "> a",
        content: "> ul"
      }
    };

    const clsNavbarTransparent = "uk-navbar-transparent";
    var navbar = {
      extends: Dropnav,
      props: {
        dropbarTransparentMode: Boolean
      },
      data: {
        clsDrop: "uk-navbar-dropdown",
        selNavItem: ".uk-navbar-nav > li > a,a.uk-navbar-item,button.uk-navbar-item,.uk-navbar-item a,.uk-navbar-item button,.uk-navbar-toggle",
        // Simplify with :where() selector once browser target is Safari 14+
        dropbarTransparentMode: false
      },
      computed: {
        navbarContainer: (_, $el) => $el.closest(".uk-navbar-container")
      },
      watch: {
        items() {
          const justify = hasClass(this.$el, "uk-navbar-justify");
          const containers = $$(".uk-navbar-nav, .uk-navbar-left, .uk-navbar-right", this.$el);
          for (const container of containers) {
            const items = justify ? $$(".uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle", container).length : "";
            css(container, "flexGrow", items);
          }
        }
      },
      events: [
        {
          name: "show",
          el: ({ dropContainer }) => dropContainer,
          handler({ target }) {
            if (this.getTransparentMode(target) === "remove" && hasClass(this.navbarContainer, clsNavbarTransparent)) {
              removeClass(this.navbarContainer, clsNavbarTransparent);
              this._transparent = true;
            }
          }
        },
        {
          name: "hide",
          el: ({ dropContainer }) => dropContainer,
          async handler() {
            await awaitMacroTask();
            if (this._transparent && (!active || !this.dropContainer.contains(active.$el))) {
              addClass(this.navbarContainer, clsNavbarTransparent);
              this._transparent = null;
            }
          }
        }
      ],
      methods: {
        getTransparentMode(el) {
          if (!this.navbarContainer) {
            return;
          }
          if (this.dropbar && this.isDropbarDrop(el)) {
            return this.dropbarTransparentMode;
          }
          const drop = this.getDropdown(el);
          if (drop && hasClass(el, "uk-dropbar")) {
            return drop.inset ? "behind" : "remove";
          }
        },
        getDropbarOffset(offsetTop) {
          const { top, height } = offset(this.navbarContainer);
          return top + (this.dropbarTransparentMode === "behind" ? 0 : height + offsetTop);
        }
      }
    };
    function awaitMacroTask() {
      return new Promise((resolve) => setTimeout(resolve));
    }

    var offcanvas = {
      mixins: [Modal],
      args: "mode",
      props: {
        mode: String,
        flip: Boolean,
        overlay: Boolean,
        swiping: Boolean
      },
      data: {
        mode: "slide",
        flip: false,
        overlay: false,
        clsPage: "uk-offcanvas-page",
        clsContainer: "uk-offcanvas-container",
        selPanel: ".uk-offcanvas-bar",
        clsFlip: "uk-offcanvas-flip",
        clsContainerAnimation: "uk-offcanvas-container-animation",
        clsSidebarAnimation: "uk-offcanvas-bar-animation",
        clsMode: "uk-offcanvas",
        clsOverlay: "uk-offcanvas-overlay",
        selClose: ".uk-offcanvas-close",
        container: false,
        swiping: true
      },
      computed: {
        clsFlip: ({ flip, clsFlip }) => flip ? clsFlip : "",
        clsOverlay: ({ overlay, clsOverlay }) => overlay ? clsOverlay : "",
        clsMode: ({ mode, clsMode }) => `${clsMode}-${mode}`,
        clsSidebarAnimation: ({ mode, clsSidebarAnimation }) => mode === "none" || mode === "reveal" ? "" : clsSidebarAnimation,
        clsContainerAnimation: ({ mode, clsContainerAnimation }) => mode !== "push" && mode !== "reveal" ? "" : clsContainerAnimation,
        transitionElement({ mode }) {
          return mode === "reveal" ? parent(this.panel) : this.panel;
        }
      },
      observe: swipe({ filter: ({ swiping }) => swiping }),
      update: {
        read() {
          if (this.isToggled() && !isVisible(this.$el)) {
            this.hide();
          }
        },
        events: ["resize"]
      },
      events: [
        {
          name: "touchmove",
          self: true,
          passive: false,
          filter: ({ overlay }) => overlay,
          handler(e) {
            e.cancelable && e.preventDefault();
          }
        },
        {
          name: "show",
          self: true,
          handler() {
            if (this.mode === "reveal" && !hasClass(parent(this.panel), this.clsMode)) {
              addClass(wrapAll(this.panel, "<div>"), this.clsMode);
            }
            const { body, scrollingElement } = document;
            addClass(body, this.clsContainer, this.clsFlip);
            css(body, "touchAction", "pan-y pinch-zoom");
            css(this.$el, "display", "block");
            css(this.panel, "maxWidth", scrollingElement.clientWidth);
            addClass(this.$el, this.clsOverlay);
            addClass(
              this.panel,
              this.clsSidebarAnimation,
              this.mode === "reveal" ? "" : this.clsMode
            );
            height(body);
            addClass(body, this.clsContainerAnimation);
            this.clsContainerAnimation && suppressUserScale();
          }
        },
        {
          name: "hide",
          self: true,
          handler() {
            removeClass(document.body, this.clsContainerAnimation);
            css(document.body, "touchAction", "");
          }
        },
        {
          name: "hidden",
          self: true,
          handler() {
            this.clsContainerAnimation && resumeUserScale();
            if (this.mode === "reveal" && hasClass(parent(this.panel), this.clsMode)) {
              unwrap(this.panel);
            }
            removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);
            removeClass(this.$el, this.clsOverlay);
            css(this.$el, "display", "");
            css(this.panel, "maxWidth", "");
            removeClass(document.body, this.clsContainer, this.clsFlip);
          }
        },
        {
          name: "swipeLeft swipeRight",
          handler(e) {
            if (this.isToggled() && endsWith(e.type, "Left") ^ this.flip) {
              this.hide();
            }
          }
        }
      ]
    };
    function suppressUserScale() {
      getViewport().content += ",user-scalable=0";
    }
    function resumeUserScale() {
      const viewport = getViewport();
      viewport.content = viewport.content.replace(/,user-scalable=0$/, "");
    }
    function getViewport() {
      return $('meta[name="viewport"]', document.head) || append(document.head, '<meta name="viewport">');
    }

    var overflowAuto = {
      mixins: [Class],
      props: {
        selContainer: String,
        selContent: String,
        minHeight: Number
      },
      data: {
        selContainer: ".uk-modal",
        selContent: ".uk-modal-dialog",
        minHeight: 150
      },
      computed: {
        container: ({ selContainer }, $el) => $el.closest(selContainer),
        content: ({ selContent }, $el) => $el.closest(selContent)
      },
      observe: resize({
        target: ({ container, content }) => [container, content]
      }),
      update: {
        read() {
          if (!this.content || !this.container || !isVisible(this.$el)) {
            return false;
          }
          return {
            max: Math.max(
              this.minHeight,
              height(this.container) - (dimensions$1(this.content).height - height(this.$el))
            )
          };
        },
        write({ max }) {
          css(this.$el, { minHeight: this.minHeight, maxHeight: max });
        },
        events: ["resize"]
      }
    };

    var responsive = {
      props: ["width", "height"],
      connected() {
        addClass(this.$el, "uk-responsive-width");
        css(this.$el, "aspectRatio", `${this.width}/${this.height}`);
      }
    };

    var scroll = {
      props: {
        offset: Number
      },
      data: {
        offset: 0
      },
      connected() {
        registerClick(this);
      },
      disconnected() {
        unregisterClick(this);
      },
      methods: {
        async scrollTo(el) {
          el = el && $(el) || document.body;
          if (trigger(this.$el, "beforescroll", [this, el])) {
            await scrollIntoView(el, { offset: this.offset });
            trigger(this.$el, "scrolled", [this, el]);
          }
        }
      }
    };
    const instances = /* @__PURE__ */ new Set();
    function registerClick(cmp) {
      if (!instances.size) {
        on(document, "click", clickHandler);
      }
      instances.add(cmp);
    }
    function unregisterClick(cmp) {
      instances.delete(cmp);
      if (!instances.size) {
        off(document, "click", clickHandler);
      }
    }
    function clickHandler(e) {
      if (e.defaultPrevented) {
        return;
      }
      for (const instance of instances) {
        if (instance.$el.contains(e.target) && isSameSiteAnchor(instance.$el)) {
          e.preventDefault();
          if (window.location.href !== instance.$el.href) {
            window.history.pushState({}, "", instance.$el.href);
          }
          instance.scrollTo(getTargetedElement(instance.$el));
        }
      }
    }

    const clsInView = "uk-scrollspy-inview";
    var scrollspy = {
      args: "cls",
      props: {
        cls: String,
        target: String,
        hidden: Boolean,
        margin: String,
        repeat: Boolean,
        delay: Number
      },
      data: () => ({
        cls: "",
        target: false,
        hidden: true,
        margin: "-1px",
        repeat: false,
        delay: 0
      }),
      computed: {
        elements: ({ target }, $el) => target ? $$(target, $el) : [$el]
      },
      watch: {
        elements(elements) {
          if (this.hidden) {
            css(filter$1(elements, `:not(.${clsInView})`), "opacity", 0);
          }
        }
      },
      connected() {
        this.elementData = /* @__PURE__ */ new Map();
      },
      disconnected() {
        for (const [el, state] of this.elementData.entries()) {
          removeClass(el, clsInView, (state == null ? void 0 : state.cls) || "");
        }
        delete this.elementData;
      },
      observe: intersection({
        target: ({ elements }) => elements,
        handler(records) {
          const elements = this.elementData;
          for (const { target: el, isIntersecting } of records) {
            if (!elements.has(el)) {
              elements.set(el, {
                cls: data(el, "uk-scrollspy-class") || this.cls
              });
            }
            const state = elements.get(el);
            if (!this.repeat && state.show) {
              continue;
            }
            state.show = isIntersecting;
          }
          this.$emit();
        },
        options: ({ margin }) => ({ rootMargin: margin }),
        args: { intersecting: false }
      }),
      update: [
        {
          write(data) {
            for (const [el, state] of this.elementData.entries()) {
              if (state.show && !state.inview && !state.queued) {
                state.queued = true;
                data.promise = (data.promise || Promise.resolve()).then(() => new Promise((resolve) => setTimeout(resolve, this.delay))).then(() => {
                  this.toggle(el, true);
                  setTimeout(() => {
                    state.queued = false;
                    this.$emit();
                  }, 300);
                });
              } else if (!state.show && state.inview && !state.queued && this.repeat) {
                this.toggle(el, false);
              }
            }
          }
        }
      ],
      methods: {
        toggle(el, inview) {
          var _a, _b;
          const state = (_a = this.elementData) == null ? void 0 : _a.get(el);
          if (!state) {
            return;
          }
          (_b = state.off) == null ? void 0 : _b.call(state);
          css(el, "opacity", !inview && this.hidden ? 0 : "");
          toggleClass(el, clsInView, inview);
          toggleClass(el, state.cls);
          let match;
          if (match = state.cls.match(/\buk-animation-[\w-]+/g)) {
            const removeAnimationClasses = () => removeClass(el, match);
            if (inview) {
              state.off = once(el, "animationcancel animationend", removeAnimationClasses, {
                self: true
              });
            } else {
              removeAnimationClasses();
            }
          }
          trigger(el, inview ? "inview" : "outview");
          state.inview = inview;
        }
      }
    };

    var scrollspyNav = {
      props: {
        cls: String,
        closest: Boolean,
        scroll: Boolean,
        target: String,
        offset: Number
      },
      data: {
        cls: "uk-active",
        closest: false,
        scroll: false,
        target: 'a[href]:not([role="button"])',
        offset: 0
      },
      computed: {
        links: ({ target }, $el) => $$(target, $el).filter((el) => isSameSiteAnchor(el)),
        elements({ closest }) {
          return this.links.map((el) => el.closest(closest || "*"));
        }
      },
      watch: {
        links(links) {
          if (this.scroll) {
            this.$create("scroll", links, { offset: this.offset });
          }
        }
      },
      observe: [intersection(), scroll$1()],
      update: [
        {
          read() {
            const targets = this.links.map((el) => getTargetedElement(el)).filter(Boolean);
            const { length } = targets;
            if (!length || !isVisible(this.$el)) {
              return false;
            }
            const scrollElement = scrollParent(targets, true);
            const { scrollTop, scrollHeight } = scrollElement;
            const viewport = offsetViewport(scrollElement);
            const max = scrollHeight - viewport.height;
            let active = false;
            if (scrollTop >= max) {
              active = length - 1;
            } else {
              const offsetBy = this.offset + dimensions$1(getCoveringElement()).height + viewport.height * 0.1;
              for (let i = 0; i < targets.length; i++) {
                if (offset(targets[i]).top - viewport.top - offsetBy > 0) {
                  break;
                }
                active = +i;
              }
            }
            return { active };
          },
          write({ active }) {
            const changed = active !== false && !hasClass(this.elements[active], this.cls);
            this.links.forEach((el) => el.blur());
            for (let i = 0; i < this.elements.length; i++) {
              toggleClass(this.elements[i], this.cls, +i === active);
            }
            if (changed) {
              trigger(this.$el, "active", [active, this.elements[active]]);
            }
          },
          events: ["scroll", "resize"]
        }
      ]
    };

    var sticky = {
      mixins: [Class, Media],
      props: {
        position: String,
        top: null,
        bottom: null,
        start: null,
        end: null,
        offset: String,
        offsetEnd: String,
        overflowFlip: Boolean,
        animation: String,
        clsActive: String,
        clsInactive: String,
        clsFixed: String,
        clsBelow: String,
        selTarget: String,
        showOnUp: Boolean,
        targetOffset: Number
      },
      data: {
        position: "top",
        top: false,
        bottom: false,
        start: false,
        end: false,
        offset: 0,
        offsetEnd: 0,
        overflowFlip: false,
        animation: "",
        clsActive: "uk-active",
        clsInactive: "",
        clsFixed: "uk-sticky-fixed",
        clsBelow: "uk-sticky-below",
        selTarget: "",
        showOnUp: false,
        targetOffset: false
      },
      computed: {
        target: ({ selTarget }, $el) => selTarget && $(selTarget, $el) || $el
      },
      connected() {
        this.start = coerce(this.start || this.top);
        this.end = coerce(this.end || this.bottom);
        this.placeholder = $("+ .uk-sticky-placeholder", this.$el) || $('<div class="uk-sticky-placeholder"></div>');
        this.isFixed = false;
        this.setActive(false);
      },
      beforeDisconnect() {
        if (this.isFixed) {
          this.hide();
          removeClass(this.target, this.clsInactive);
        }
        reset(this.$el);
        remove$1(this.placeholder);
        this.placeholder = null;
      },
      observe: [
        viewport(),
        scroll$1({ target: () => document.scrollingElement }),
        resize({
          target: ({ $el }) => [$el, getVisibleParent($el), document.scrollingElement],
          handler(entries) {
            this.$emit(
              this._data.resized && entries.some(({ target }) => target === getVisibleParent(this.$el)) ? "update" : "resize"
            );
            this._data.resized = true;
          }
        })
      ],
      events: [
        {
          name: "load hashchange popstate",
          el: () => window,
          filter: ({ targetOffset }) => targetOffset !== false,
          handler() {
            const { scrollingElement } = document;
            if (!location.hash || scrollingElement.scrollTop === 0) {
              return;
            }
            setTimeout(() => {
              const targetOffset = offset($(location.hash));
              const elOffset = offset(this.$el);
              if (this.isFixed && intersectRect(targetOffset, elOffset)) {
                scrollingElement.scrollTop = Math.ceil(
                  targetOffset.top - elOffset.height - toPx(this.targetOffset, "height", this.placeholder) - toPx(this.offset, "height", this.placeholder)
                );
              }
            });
          }
        }
      ],
      update: [
        {
          read({ height: height$1, width, margin, sticky }, types) {
            this.inactive = !this.matchMedia || !isVisible(this.$el) || !this.$el.offsetHeight;
            if (this.inactive) {
              return;
            }
            const dynamicViewport = height(window);
            const maxScrollHeight = Math.max(
              0,
              document.scrollingElement.scrollHeight - dynamicViewport
            );
            if (!maxScrollHeight) {
              this.inactive = true;
              return;
            }
            const hide = this.isFixed && types.has("update");
            if (hide) {
              preventTransition(this.target);
              this.hide();
            }
            if (!this.active) {
              ({ height: height$1, width } = dimensions$1(this.$el));
              margin = css(this.$el, "margin");
            }
            if (hide) {
              this.show();
            }
            const viewport2 = toPx("100vh", "height");
            let position = this.position;
            if (this.overflowFlip && height$1 > viewport2) {
              position = position === "top" ? "bottom" : "top";
            }
            const referenceElement = this.isFixed ? this.placeholder : this.$el;
            let [offset$1, offsetEnd] = [this.offset, this.offsetEnd].map(
              (value) => toPx(value, "height", sticky ? this.$el : referenceElement)
            );
            if (position === "bottom" && (height$1 < dynamicViewport || this.overflowFlip)) {
              offset$1 += dynamicViewport - height$1;
            }
            const elementBox = height$1 + offset$1 + offsetEnd;
            const overflow = this.overflowFlip ? 0 : Math.max(0, elementBox - viewport2);
            const topOffset = offset(referenceElement).top - // offset possible `transform: translateY` animation 'uk-animation-slide-top' while hiding
            new DOMMatrix(css(referenceElement, "transform")).m42;
            const elHeight = dimensions$1(this.$el).height;
            const start = (this.start === false ? topOffset : parseProp(this.start, this.$el, topOffset)) - offset$1;
            const end = this.end === false ? maxScrollHeight : Math.min(
              maxScrollHeight,
              parseProp(this.end, this.$el, topOffset + height$1, true) - elHeight - offset$1 + overflow
            );
            sticky = !this.showOnUp && start + offset$1 === topOffset && end === Math.min(
              maxScrollHeight,
              parseProp(true, this.$el, 0, true) - elHeight - offset$1 + overflow
            ) && css(getVisibleParent(this.$el), "overflowY") !== "hidden";
            return {
              start,
              end,
              offset: offset$1,
              overflow,
              height: height$1,
              elHeight,
              width,
              margin,
              top: offsetPosition(referenceElement)[0],
              sticky,
              viewport: viewport2,
              maxScrollHeight
            };
          },
          write({ height, width, margin, offset, sticky }) {
            if (this.inactive || sticky || !this.isFixed) {
              reset(this.$el);
            }
            if (this.inactive) {
              return;
            }
            if (sticky) {
              height = width = margin = 0;
              css(this.$el, { position: "sticky", top: offset });
            }
            const { placeholder } = this;
            css(placeholder, { height, width, margin });
            if (parent(placeholder) !== parent(this.$el) || sticky ^ index(placeholder) < index(this.$el)) {
              (sticky ? before : after)(this.$el, placeholder);
              placeholder.hidden = true;
            }
          },
          events: ["resize"]
        },
        {
          read({
            scroll: prevScroll = 0,
            dir: prevDir = "down",
            overflow,
            overflowScroll = 0,
            start,
            end,
            elHeight,
            height,
            sticky,
            maxScrollHeight
          }) {
            const scroll2 = Math.min(document.scrollingElement.scrollTop, maxScrollHeight);
            const dir = prevScroll <= scroll2 ? "down" : "up";
            const referenceElement = this.isFixed ? this.placeholder : this.$el;
            return {
              dir,
              prevDir,
              scroll: scroll2,
              prevScroll,
              below: scroll2 > offset(referenceElement).top + (sticky ? Math.min(height, elHeight) : height),
              offsetParentTop: offset(referenceElement.offsetParent).top,
              overflowScroll: clamp(
                overflowScroll + clamp(scroll2, start, end) - clamp(prevScroll, start, end),
                0,
                overflow
              )
            };
          },
          write(data, types) {
            const isScrollUpdate = types.has("scroll");
            const {
              initTimestamp = 0,
              dir,
              prevDir,
              scroll: scroll2,
              prevScroll = 0,
              top,
              start,
              below
            } = data;
            if (scroll2 < 0 || scroll2 === prevScroll && isScrollUpdate || this.showOnUp && !isScrollUpdate && !this.isFixed) {
              return;
            }
            const now = Date.now();
            if (now - initTimestamp > 300 || dir !== prevDir) {
              data.initScroll = scroll2;
              data.initTimestamp = now;
            }
            if (this.showOnUp && !this.isFixed && Math.abs(data.initScroll - scroll2) <= 30 && Math.abs(prevScroll - scroll2) <= 10) {
              return;
            }
            if (this.inactive || scroll2 < start || this.showOnUp && (scroll2 <= start || dir === "down" && isScrollUpdate || dir === "up" && !this.isFixed && !below)) {
              if (!this.isFixed) {
                if (Animation.inProgress(this.$el) && top > scroll2) {
                  Animation.cancel(this.$el);
                  this.hide();
                }
                return;
              }
              if (this.animation && below) {
                if (hasClass(this.$el, "uk-animation-leave")) {
                  return;
                }
                Animation.out(this.$el, this.animation).then(() => this.hide(), noop);
              } else {
                this.hide();
              }
            } else if (this.isFixed) {
              this.update();
            } else if (this.animation && below) {
              this.show();
              Animation.in(this.$el, this.animation).catch(noop);
            } else {
              preventTransition(this.target);
              this.show();
            }
          },
          events: ["resize", "resizeViewport", "scroll"]
        }
      ],
      methods: {
        show() {
          this.isFixed = true;
          this.update();
          this.placeholder.hidden = false;
        },
        hide() {
          const { offset, sticky } = this._data;
          this.setActive(false);
          removeClass(this.$el, this.clsFixed, this.clsBelow);
          if (sticky) {
            css(this.$el, "top", offset);
          } else {
            css(this.$el, {
              position: "",
              top: "",
              width: "",
              marginTop: ""
            });
          }
          this.placeholder.hidden = true;
          this.isFixed = false;
        },
        update() {
          let {
            width,
            scroll: scroll2 = 0,
            overflow,
            overflowScroll = 0,
            start,
            end,
            offset,
            offsetParentTop,
            sticky,
            below
          } = this._data;
          const active = start !== 0 || scroll2 > start;
          if (!sticky) {
            let position = "fixed";
            if (scroll2 > end) {
              offset += end - offsetParentTop + overflowScroll - overflow;
              position = "absolute";
            }
            css(this.$el, { position, width, marginTop: 0 }, "important");
          }
          css(this.$el, "top", offset - overflowScroll);
          this.setActive(active);
          toggleClass(this.$el, this.clsBelow, below);
          addClass(this.$el, this.clsFixed);
        },
        setActive(active) {
          const prev = this.active;
          this.active = active;
          if (active) {
            replaceClass(this.target, this.clsInactive, this.clsActive);
            prev !== active && trigger(this.$el, "active");
          } else {
            replaceClass(this.target, this.clsActive, this.clsInactive);
            if (prev !== active) {
              preventTransition(this.target);
              trigger(this.$el, "inactive");
            }
          }
        }
      }
    };
    function parseProp(value, el, propOffset, padding) {
      if (!value) {
        return 0;
      }
      if (isNumeric(value) || isString(value) && value.match(/^-?\d/)) {
        return propOffset + toPx(value, "height", el, true);
      } else {
        const refElement = value === true ? getVisibleParent(el) : query(value, el);
        return offset(refElement).bottom - (padding && (refElement == null ? void 0 : refElement.contains(el)) ? toFloat(css(refElement, "paddingBottom")) + toFloat(css(refElement, "borderBottomWidth")) : 0);
      }
    }
    function coerce(value) {
      if (value === "true") {
        return true;
      } else if (value === "false") {
        return false;
      }
      return value;
    }
    function reset(el) {
      css(el, { position: "", top: "", marginTop: "", width: "" });
    }
    const clsTransitionDisable = "uk-transition-disable";
    function preventTransition(element) {
      if (!hasClass(element, clsTransitionDisable)) {
        addClass(element, clsTransitionDisable);
        requestAnimationFrame(() => removeClass(element, clsTransitionDisable));
      }
    }
    function getVisibleParent(element) {
      while (element = parent(element)) {
        if (isVisible(element)) {
          return element;
        }
      }
    }

    var svg = {
      mixins: [Svg],
      args: "src",
      props: {
        src: String,
        icon: String,
        attributes: "list",
        strokeAnimation: Boolean
      },
      data: {
        strokeAnimation: false
      },
      observe: [
        mutation({
          async handler() {
            const svg = await this.svg;
            if (svg) {
              applyAttributes.call(this, svg);
            }
          },
          options: {
            attributes: true,
            attributeFilter: ["id", "class", "style"]
          }
        })
      ],
      async connected() {
        if (includes(this.src, "#")) {
          [this.src, this.icon] = this.src.split("#", 2);
        }
        const svg = await this.svg;
        if (svg) {
          applyAttributes.call(this, svg);
          if (this.strokeAnimation) {
            applyAnimation(svg);
          }
        }
      },
      methods: {
        async getSvg() {
          if (isTag(this.$el, "img") && !this.$el.complete && this.$el.loading === "lazy") {
            await new Promise((resolve) => once(this.$el, "load", resolve));
          }
          return parseSVG(await loadSVG(this.src), this.icon) || Promise.reject("SVG not found.");
        }
      }
    };
    function applyAttributes(el) {
      const { $el } = this;
      addClass(el, attr($el, "class"), "uk-svg");
      for (let i = 0; i < $el.style.length; i++) {
        const prop = $el.style[i];
        css(el, prop, css($el, prop));
      }
      for (const attribute in this.attributes) {
        const [prop, value] = this.attributes[attribute].split(":", 2);
        attr(el, prop, value);
      }
      if (!this.$el.id) {
        removeAttr(el, "id");
      }
    }
    const loadSVG = memoize(async (src) => {
      if (src) {
        if (startsWith(src, "data:")) {
          return decodeURIComponent(src.split(",", 2)[1]);
        } else {
          const response = await fetch(src);
          if (response.headers.get("Content-Type") === "image/svg+xml") {
            return response.text();
          }
        }
      }
      return Promise.reject();
    });
    function applyAnimation(el) {
      const length = getMaxPathLength(el);
      if (length) {
        css(el, "--uk-animation-stroke", length);
      }
    }

    const selDisabled = ".uk-disabled *, .uk-disabled, [disabled]";
    var Switcher = {
      mixins: [Togglable],
      args: "connect",
      props: {
        connect: String,
        toggle: String,
        itemNav: String,
        active: Number,
        followFocus: Boolean,
        swiping: Boolean
      },
      data: {
        connect: "~.uk-switcher",
        toggle: "> * > :first-child",
        itemNav: false,
        active: 0,
        cls: "uk-active",
        attrItem: "uk-switcher-item",
        selVertical: ".uk-nav",
        followFocus: false,
        swiping: true
      },
      computed: {
        connects: {
          get: ({ connect }, $el) => queryAll(connect, $el),
          observe: ({ connect }) => connect
        },
        connectChildren() {
          return this.connects.map((el) => children(el)).flat();
        },
        toggles: ({ toggle }, $el) => $$(toggle, $el),
        children(_, $el) {
          return children($el).filter(
            (child) => this.toggles.some((toggle) => child.contains(toggle))
          );
        }
      },
      watch: {
        connects(connects) {
          if (this.swiping) {
            css(connects, "touchAction", "pan-y pinch-zoom");
          }
          this.$emit();
        },
        connectChildren() {
          let index = Math.max(0, this.index());
          for (const el of this.connects) {
            children(el).forEach((child, i) => toggleClass(child, this.cls, i === index));
          }
          this.$emit();
        },
        toggles(toggles) {
          this.$emit();
          const active = this.index();
          this.show(~active ? active : toggles[this.active] || toggles[0]);
        }
      },
      connected() {
        attr(this.$el, "role", "tablist");
      },
      observe: [
        lazyload({ targets: ({ connectChildren }) => connectChildren }),
        swipe({ target: ({ connects }) => connects, filter: ({ swiping }) => swiping })
      ],
      events: [
        {
          name: "click keydown",
          delegate: ({ toggle }) => toggle,
          handler(e) {
            if (!matches(e.current, selDisabled) && (e.type === "click" || e.keyCode === keyMap.SPACE)) {
              e.preventDefault();
              this.show(e.current);
            }
          }
        },
        {
          name: "keydown",
          delegate: ({ toggle }) => toggle,
          handler(e) {
            const { current, keyCode } = e;
            const isVertical = matches(this.$el, this.selVertical);
            let i = keyCode === keyMap.HOME ? 0 : keyCode === keyMap.END ? "last" : keyCode === keyMap.LEFT && !isVertical || keyCode === keyMap.UP && isVertical ? "previous" : keyCode === keyMap.RIGHT && !isVertical || keyCode === keyMap.DOWN && isVertical ? "next" : -1;
            if (~i) {
              e.preventDefault();
              const toggles = this.toggles.filter((el) => !matches(el, selDisabled));
              const next = toggles[getIndex(i, toggles, toggles.indexOf(current))];
              next.focus();
              if (this.followFocus) {
                this.show(next);
              }
            }
          }
        },
        {
          name: "click",
          el: ({ $el, connects, itemNav }) => connects.concat(itemNav ? queryAll(itemNav, $el) : []),
          delegate: ({ attrItem }) => `[${attrItem}],[data-${attrItem}]`,
          handler(e) {
            if (e.target.closest("a,button")) {
              e.preventDefault();
              this.show(data(e.current, this.attrItem));
            }
          }
        },
        {
          name: "swipeRight swipeLeft",
          filter: ({ swiping }) => swiping,
          el: ({ connects }) => connects,
          handler({ type }) {
            this.show(endsWith(type, "Left") ? "next" : "previous");
          }
        }
      ],
      update() {
        var _a;
        for (const el of this.connects) {
          if (isTag(el, "ul")) {
            attr(el, "role", "presentation");
          }
        }
        attr(children(this.$el), "role", "presentation");
        for (const index in this.toggles) {
          const toggle = this.toggles[index];
          const item = (_a = this.connects[0]) == null ? void 0 : _a.children[index];
          attr(toggle, "role", "tab");
          if (!item) {
            continue;
          }
          toggle.id = generateId(this, toggle);
          item.id = generateId(this, item);
          attr(toggle, "aria-controls", item.id);
          attr(item, { role: "tabpanel", "aria-labelledby": toggle.id });
        }
        attr(this.$el, "aria-orientation", matches(this.$el, this.selVertical) ? "vertical" : null);
      },
      methods: {
        index() {
          return findIndex(this.children, (el) => hasClass(el, this.cls));
        },
        show(item) {
          const toggles = this.toggles.filter((el) => !matches(el, selDisabled));
          const prev = this.index();
          const next = getIndex(
            !isNode(item) || includes(toggles, item) ? item : 0,
            toggles,
            getIndex(this.toggles[prev], toggles)
          );
          const active = getIndex(toggles[next], this.toggles);
          this.children.forEach((child, i) => {
            toggleClass(child, this.cls, active === i);
            attr(this.toggles[i], {
              "aria-selected": active === i,
              tabindex: active === i ? null : -1
            });
          });
          const animate = prev >= 0 && prev !== next;
          this.connects.forEach(async ({ children: children2 }) => {
            const actives = toArray(children2).filter(
              (child, i) => i !== active && hasClass(child, this.cls)
            );
            if (await this.toggleElement(actives, false, animate)) {
              await this.toggleElement(children2[active], true, animate);
            }
          });
        }
      }
    };

    var tab = {
      mixins: [Class],
      extends: Switcher,
      props: {
        media: Boolean
      },
      data: {
        media: 960,
        attrItem: "uk-tab-item",
        selVertical: ".uk-tab-left,.uk-tab-right"
      },
      connected() {
        const cls = hasClass(this.$el, "uk-tab-left") ? "uk-tab-left" : hasClass(this.$el, "uk-tab-right") ? "uk-tab-right" : false;
        if (cls) {
          this.$create("toggle", this.$el, { cls, mode: "media", media: this.media });
        }
      }
    };

    const KEY_SPACE = 32;
    var toggle = {
      mixins: [Media, Togglable],
      args: "target",
      props: {
        href: String,
        target: null,
        mode: "list",
        queued: Boolean
      },
      data: {
        href: false,
        target: false,
        mode: "click",
        queued: true
      },
      computed: {
        target: {
          get: ({ target }, $el) => {
            target = queryAll(target || $el.hash, $el);
            return target.length ? target : [$el];
          },
          observe: ({ target }) => target
        }
      },
      connected() {
        if (!includes(this.mode, "media")) {
          if (!isFocusable(this.$el)) {
            attr(this.$el, "tabindex", "0");
          }
          if (!this.cls && isTag(this.$el, "a")) {
            attr(this.$el, "role", "button");
          }
        }
      },
      observe: lazyload({ targets: ({ target }) => target }),
      events: [
        {
          name: pointerDown$1,
          filter: ({ mode }) => includes(mode, "hover"),
          handler(e) {
            this._preventClick = null;
            if (!isTouch(e) || isBoolean(this._showState) || this.$el.disabled) {
              return;
            }
            trigger(this.$el, "focus");
            once(
              document,
              pointerDown$1,
              () => trigger(this.$el, "blur"),
              true,
              (e2) => !this.$el.contains(e2.target)
            );
            if (includes(this.mode, "click")) {
              this._preventClick = true;
            }
          }
        },
        {
          // mouseenter mouseleave are added because of Firefox bug,
          // where pointerleave is triggered immediately after pointerenter on scroll
          name: `mouseenter mouseleave ${pointerEnter} ${pointerLeave} focus blur`,
          filter: ({ mode }) => includes(mode, "hover"),
          handler(e) {
            if (isTouch(e) || this.$el.disabled || document.readyState === "loading") {
              return;
            }
            const show = includes(["mouseenter", pointerEnter, "focus"], e.type);
            const expanded = this.isToggled(this.target);
            if (!show && (!isBoolean(this._showState) || e.type !== "blur" && matches(this.$el, ":focus") || e.type === "blur" && matches(this.$el, ":hover"))) {
              if (expanded === this._showState) {
                this._showState = null;
              }
              return;
            }
            if (show && isBoolean(this._showState) && expanded !== this._showState) {
              return;
            }
            this._showState = show ? expanded : null;
            this.toggle(`toggle${show ? "show" : "hide"}`);
          }
        },
        {
          name: "keydown",
          filter: ({ $el, mode }) => includes(mode, "click") && !isTag($el, "input"),
          handler(e) {
            if (e.keyCode === KEY_SPACE) {
              e.preventDefault();
              this.$el.click();
            }
          }
        },
        {
          name: "click",
          filter: ({ mode }) => ["click", "hover"].some((m) => includes(mode, m)),
          handler(e) {
            let link;
            if (this._preventClick || e.target.closest('a[href="#"], a[href=""]') || (link = e.target.closest("a[href]")) && (!this.isToggled(this.target) || link.hash && matches(this.target, link.hash))) {
              e.preventDefault();
            }
            if (!this._preventClick && includes(this.mode, "click")) {
              this.toggle();
            }
          }
        },
        {
          name: "mediachange",
          filter: ({ mode }) => includes(mode, "media"),
          el: ({ target }) => target,
          handler(e, mediaObj) {
            if (mediaObj.matches ^ this.isToggled(this.target)) {
              this.toggle();
            }
          }
        }
      ],
      methods: {
        async toggle(type) {
          if (!trigger(this.target, type || "toggle", [this])) {
            return;
          }
          if (hasAttr(this.$el, "aria-expanded")) {
            attr(this.$el, "aria-expanded", !this.isToggled(this.target));
          }
          if (!this.queued) {
            return this.toggleElement(this.target);
          }
          const leaving = this.target.filter((el) => hasClass(el, this.clsLeave));
          if (leaving.length) {
            for (const el of this.target) {
              const isLeaving = includes(leaving, el);
              this.toggleElement(el, isLeaving, isLeaving);
            }
            return;
          }
          const toggled = this.target.filter(this.isToggled);
          if (await this.toggleElement(toggled, false)) {
            await this.toggleElement(
              this.target.filter((el) => !includes(toggled, el)),
              true
            );
          }
        }
      }
    };

    var components = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Accordion: Accordion,
        Alert: alert,
        Close: Close,
        Cover: cover,
        Drop: drop,
        DropParentIcon: IconComponent,
        Dropdown: drop,
        Dropnav: Dropnav,
        FormCustom: formCustom,
        Grid: grid,
        HeightMatch: heightMatch,
        HeightPlaceholder: heightPlaceholder,
        HeightViewport: heightViewport,
        Icon: Icon,
        Img: img,
        Inverse: inverse,
        Leader: leader,
        Margin: Margin,
        Marker: Marker,
        Modal: modal,
        Nav: nav,
        NavParentIcon: NavParentIcon,
        Navbar: navbar,
        NavbarParentIcon: IconComponent,
        NavbarToggleIcon: NavbarToggleIcon,
        Offcanvas: offcanvas,
        OverflowAuto: overflowAuto,
        OverlayIcon: IconComponent,
        PaginationNext: PaginationNext,
        PaginationPrevious: PaginationPrevious,
        Responsive: responsive,
        Scroll: scroll,
        Scrollspy: scrollspy,
        ScrollspyNav: scrollspyNav,
        SearchIcon: Search,
        SlidenavNext: Slidenav,
        SlidenavPrevious: Slidenav,
        Spinner: Spinner,
        Sticky: sticky,
        Svg: svg,
        Switcher: Switcher,
        Tab: tab,
        Toggle: toggle,
        Totop: Totop,
        Video: Video
    });

    each(components, (component, name) => App.component(name, component));
    boot(App);

    each(components$1, (component, name) => App.component(name, component));

    return App;

}));

},{}],40:[function(require,module,exports){
(function (global,setImmediate){(function (){
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
'use strict';

const emptyObject = Object.freeze({});
const isArray = Array.isArray;
// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef(v) {
    return v === undefined || v === null;
}
function isDef(v) {
    return v !== undefined && v !== null;
}
function isTrue(v) {
    return v === true;
}
function isFalse(v) {
    return v === false;
}
/**
 * Check if value is primitive.
 */
function isPrimitive(value) {
    return (typeof value === 'string' ||
        typeof value === 'number' ||
        // $flow-disable-line
        typeof value === 'symbol' ||
        typeof value === 'boolean');
}
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * Quick object check - this is primarily used to tell
 * objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
    return obj !== null && typeof obj === 'object';
}
/**
 * Get the raw type string of a value, e.g., [object Object].
 */
const _toString = Object.prototype.toString;
function toRawType(value) {
    return _toString.call(value).slice(8, -1);
}
/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
    return _toString.call(obj) === '[object Object]';
}
function isRegExp(v) {
    return _toString.call(v) === '[object RegExp]';
}
/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
    const n = parseFloat(String(val));
    return n >= 0 && Math.floor(n) === n && isFinite(val);
}
function isPromise(val) {
    return (isDef(val) &&
        typeof val.then === 'function' &&
        typeof val.catch === 'function');
}
/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
    return val == null
        ? ''
        : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
            ? JSON.stringify(val, replacer, 2)
            : String(val);
}
function replacer(_key, val) {
    // avoid circular deps from v3
    if (val && val.__v_isRef) {
        return val.value;
    }
    return val;
}
/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
}
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
    const map = Object.create(null);
    const list = str.split(',');
    for (let i = 0; i < list.length; i++) {
        map[list[i]] = true;
    }
    return expectsLowerCase ? val => map[val.toLowerCase()] : val => map[val];
}
/**
 * Check if a tag is a built-in tag.
 */
const isBuiltInTag = makeMap('slot,component', true);
/**
 * Check if an attribute is a reserved attribute.
 */
const isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');
/**
 * Remove an item from an array.
 */
function remove$2(arr, item) {
    const len = arr.length;
    if (len) {
        // fast path for the only / last item
        if (item === arr[len - 1]) {
            arr.length = len - 1;
            return;
        }
        const index = arr.indexOf(item);
        if (index > -1) {
            return arr.splice(index, 1);
        }
    }
}
/**
 * Check whether an object has the property.
 */
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
    return hasOwnProperty.call(obj, key);
}
/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
    const cache = Object.create(null);
    return function cachedFn(str) {
        const hit = cache[str];
        return hit || (cache[str] = fn(str));
    };
}
/**
 * Camelize a hyphen-delimited string.
 */
const camelizeRE = /-(\w)/g;
const camelize = cached((str) => {
    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));
});
/**
 * Capitalize a string.
 */
const capitalize = cached((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
});
/**
 * Hyphenate a camelCase string.
 */
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cached((str) => {
    return str.replace(hyphenateRE, '-$1').toLowerCase();
});
/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */
/* istanbul ignore next */
function polyfillBind(fn, ctx) {
    function boundFn(a) {
        const l = arguments.length;
        return l
            ? l > 1
                ? fn.apply(ctx, arguments)
                : fn.call(ctx, a)
            : fn.call(ctx);
    }
    boundFn._length = fn.length;
    return boundFn;
}
function nativeBind(fn, ctx) {
    return fn.bind(ctx);
}
// @ts-expect-error bind cannot be `undefined`
const bind$1 = Function.prototype.bind ? nativeBind : polyfillBind;
/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
    start = start || 0;
    let i = list.length - start;
    const ret = new Array(i);
    while (i--) {
        ret[i] = list[i + start];
    }
    return ret;
}
/**
 * Mix properties into target object.
 */
function extend(to, _from) {
    for (const key in _from) {
        to[key] = _from[key];
    }
    return to;
}
/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
    const res = {};
    for (let i = 0; i < arr.length; i++) {
        if (arr[i]) {
            extend(res, arr[i]);
        }
    }
    return res;
}
/* eslint-disable no-unused-vars */
/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop(a, b, c) { }
/**
 * Always return false.
 */
const no = (a, b, c) => false;
/* eslint-enable no-unused-vars */
/**
 * Return the same value.
 */
const identity = (_) => _;
/**
 * Generate a string containing static keys from compiler modules.
 */
function genStaticKeys$1(modules) {
    return modules
        .reduce((keys, m) => keys.concat(m.staticKeys || []), [])
        .join(',');
}
/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
    if (a === b)
        return true;
    const isObjectA = isObject(a);
    const isObjectB = isObject(b);
    if (isObjectA && isObjectB) {
        try {
            const isArrayA = Array.isArray(a);
            const isArrayB = Array.isArray(b);
            if (isArrayA && isArrayB) {
                return (a.length === b.length &&
                    a.every((e, i) => {
                        return looseEqual(e, b[i]);
                    }));
            }
            else if (a instanceof Date && b instanceof Date) {
                return a.getTime() === b.getTime();
            }
            else if (!isArrayA && !isArrayB) {
                const keysA = Object.keys(a);
                const keysB = Object.keys(b);
                return (keysA.length === keysB.length &&
                    keysA.every(key => {
                        return looseEqual(a[key], b[key]);
                    }));
            }
            else {
                /* istanbul ignore next */
                return false;
            }
        }
        catch (e) {
            /* istanbul ignore next */
            return false;
        }
    }
    else if (!isObjectA && !isObjectB) {
        return String(a) === String(b);
    }
    else {
        return false;
    }
}
/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf(arr, val) {
    for (let i = 0; i < arr.length; i++) {
        if (looseEqual(arr[i], val))
            return i;
    }
    return -1;
}
/**
 * Ensure a function is called only once.
 */
function once(fn) {
    let called = false;
    return function () {
        if (!called) {
            called = true;
            fn.apply(this, arguments);
        }
    };
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#polyfill
function hasChanged(x, y) {
    if (x === y) {
        return x === 0 && 1 / x !== 1 / y;
    }
    else {
        return x === x || y === y;
    }
}

const SSR_ATTR = 'data-server-rendered';
const ASSET_TYPES = ['component', 'directive', 'filter'];
const LIFECYCLE_HOOKS = [
    'beforeCreate',
    'created',
    'beforeMount',
    'mounted',
    'beforeUpdate',
    'updated',
    'beforeDestroy',
    'destroyed',
    'activated',
    'deactivated',
    'errorCaptured',
    'serverPrefetch',
    'renderTracked',
    'renderTriggered'
];

var config = {
    /**
     * Option merge strategies (used in core/util/options)
     */
    // $flow-disable-line
    optionMergeStrategies: Object.create(null),
    /**
     * Whether to suppress warnings.
     */
    silent: false,
    /**
     * Show production mode tip message on boot?
     */
    productionTip: true,
    /**
     * Whether to enable devtools
     */
    devtools: true,
    /**
     * Whether to record perf
     */
    performance: false,
    /**
     * Error handler for watcher errors
     */
    errorHandler: null,
    /**
     * Warn handler for watcher warns
     */
    warnHandler: null,
    /**
     * Ignore certain custom elements
     */
    ignoredElements: [],
    /**
     * Custom user key aliases for v-on
     */
    // $flow-disable-line
    keyCodes: Object.create(null),
    /**
     * Check if a tag is reserved so that it cannot be registered as a
     * component. This is platform-dependent and may be overwritten.
     */
    isReservedTag: no,
    /**
     * Check if an attribute is reserved so that it cannot be used as a component
     * prop. This is platform-dependent and may be overwritten.
     */
    isReservedAttr: no,
    /**
     * Check if a tag is an unknown element.
     * Platform-dependent.
     */
    isUnknownElement: no,
    /**
     * Get the namespace of an element
     */
    getTagNamespace: noop,
    /**
     * Parse the real tag name for the specific platform.
     */
    parsePlatformTagName: identity,
    /**
     * Check if an attribute must be bound using property, e.g. value
     * Platform-dependent.
     */
    mustUseProp: no,
    /**
     * Perform updates asynchronously. Intended to be used by Vue Test Utils
     * This will significantly reduce performance if set to false.
     */
    async: true,
    /**
     * Exposed for legacy reasons
     */
    _lifecycleHooks: LIFECYCLE_HOOKS
};

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
const unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
    const c = (str + '').charCodeAt(0);
    return c === 0x24 || c === 0x5f;
}
/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
    });
}
/**
 * Parse simple path.
 */
const bailRE = new RegExp(`[^${unicodeRegExp.source}.$_\\d]`);
function parsePath(path) {
    if (bailRE.test(path)) {
        return;
    }
    const segments = path.split('.');
    return function (obj) {
        for (let i = 0; i < segments.length; i++) {
            if (!obj)
                return;
            obj = obj[segments[i]];
        }
        return obj;
    };
}

// can we use __proto__?
const hasProto = '__proto__' in {};
// Browser environment sniffing
const inBrowser = typeof window !== 'undefined';
const UA = inBrowser && window.navigator.userAgent.toLowerCase();
const isIE = UA && /msie|trident/.test(UA);
const isIE9 = UA && UA.indexOf('msie 9.0') > 0;
const isEdge = UA && UA.indexOf('edge/') > 0;
UA && UA.indexOf('android') > 0;
const isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
UA && /chrome\/\d+/.test(UA) && !isEdge;
UA && /phantomjs/.test(UA);
const isFF = UA && UA.match(/firefox\/(\d+)/);
// Firefox has a "watch" function on Object.prototype...
// @ts-expect-error firebox support
const nativeWatch = {}.watch;
let supportsPassive = false;
if (inBrowser) {
    try {
        const opts = {};
        Object.defineProperty(opts, 'passive', {
            get() {
                /* istanbul ignore next */
                supportsPassive = true;
            }
        }); // https://github.com/facebook/flow/issues/285
        window.addEventListener('test-passive', null, opts);
    }
    catch (e) { }
}
// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
let _isServer;
const isServerRendering = () => {
    if (_isServer === undefined) {
        /* istanbul ignore if */
        if (!inBrowser && typeof global !== 'undefined') {
            // detect presence of vue-server-renderer and avoid
            // Webpack shimming the process
            _isServer =
                global['process'] && global['process'].env.VUE_ENV === 'server';
        }
        else {
            _isServer = false;
        }
    }
    return _isServer;
};
// detect devtools
const devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
/* istanbul ignore next */
function isNative(Ctor) {
    return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}
const hasSymbol = typeof Symbol !== 'undefined' &&
    isNative(Symbol) &&
    typeof Reflect !== 'undefined' &&
    isNative(Reflect.ownKeys);
let _Set; // $flow-disable-line
/* istanbul ignore if */ if (typeof Set !== 'undefined' && isNative(Set)) {
    // use native Set when available.
    _Set = Set;
}
else {
    // a non-standard Set polyfill that only works with primitive keys.
    _Set = class Set {
        constructor() {
            this.set = Object.create(null);
        }
        has(key) {
            return this.set[key] === true;
        }
        add(key) {
            this.set[key] = true;
        }
        clear() {
            this.set = Object.create(null);
        }
    };
}

let currentInstance = null;
/**
 * This is exposed for compatibility with v3 (e.g. some functions in VueUse
 * relies on it). Do not use this internally, just use `currentInstance`.
 *
 * @internal this function needs manual type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function getCurrentInstance() {
    return currentInstance && { proxy: currentInstance };
}
/**
 * @internal
 */
function setCurrentInstance(vm = null) {
    if (!vm)
        currentInstance && currentInstance._scope.off();
    currentInstance = vm;
    vm && vm._scope.on();
}

/**
 * @internal
 */
class VNode {
    constructor(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = undefined;
        this.context = context;
        this.fnContext = undefined;
        this.fnOptions = undefined;
        this.fnScopeId = undefined;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = undefined;
        this.parent = undefined;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = undefined;
        this.isAsyncPlaceholder = false;
    }
    // DEPRECATED: alias for componentInstance for backwards compat.
    /* istanbul ignore next */
    get child() {
        return this.componentInstance;
    }
}
const createEmptyVNode = (text = '') => {
    const node = new VNode();
    node.text = text;
    node.isComment = true;
    return node;
};
function createTextVNode(val) {
    return new VNode(undefined, undefined, undefined, String(val));
}
// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode) {
    const cloned = new VNode(vnode.tag, vnode.data, 
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(), vnode.text, vnode.elm, vnode.context, vnode.componentOptions, vnode.asyncFactory);
    cloned.ns = vnode.ns;
    cloned.isStatic = vnode.isStatic;
    cloned.key = vnode.key;
    cloned.isComment = vnode.isComment;
    cloned.fnContext = vnode.fnContext;
    cloned.fnOptions = vnode.fnOptions;
    cloned.fnScopeId = vnode.fnScopeId;
    cloned.asyncMeta = vnode.asyncMeta;
    cloned.isCloned = true;
    return cloned;
}

/* not type checking this file because flow doesn't play well with Proxy */
let initProxy;
{
    const allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' +
        'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
        'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,' +
        'require' // for Webpack/Browserify
    );
    const warnNonPresent = (target, key) => {
        warn$2(`Property or method "${key}" is not defined on the instance but ` +
            'referenced during render. Make sure that this property is reactive, ' +
            'either in the data option, or for class-based components, by ' +
            'initializing the property. ' +
            'See: https://v2.vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
    };
    const warnReservedPrefix = (target, key) => {
        warn$2(`Property "${key}" must be accessed with "$data.${key}" because ` +
            'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
            'prevent conflicts with Vue internals. ' +
            'See: https://v2.vuejs.org/v2/api/#data', target);
    };
    const hasProxy = typeof Proxy !== 'undefined' && isNative(Proxy);
    if (hasProxy) {
        const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
        config.keyCodes = new Proxy(config.keyCodes, {
            set(target, key, value) {
                if (isBuiltInModifier(key)) {
                    warn$2(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`);
                    return false;
                }
                else {
                    target[key] = value;
                    return true;
                }
            }
        });
    }
    const hasHandler = {
        has(target, key) {
            const has = key in target;
            const isAllowed = allowedGlobals(key) ||
                (typeof key === 'string' &&
                    key.charAt(0) === '_' &&
                    !(key in target.$data));
            if (!has && !isAllowed) {
                if (key in target.$data)
                    warnReservedPrefix(target, key);
                else
                    warnNonPresent(target, key);
            }
            return has || !isAllowed;
        }
    };
    const getHandler = {
        get(target, key) {
            if (typeof key === 'string' && !(key in target)) {
                if (key in target.$data)
                    warnReservedPrefix(target, key);
                else
                    warnNonPresent(target, key);
            }
            return target[key];
        }
    };
    initProxy = function initProxy(vm) {
        if (hasProxy) {
            // determine which proxy handler to use
            const options = vm.$options;
            const handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
            vm._renderProxy = new Proxy(vm, handlers);
        }
        else {
            vm._renderProxy = vm;
        }
    };
}

let uid$2 = 0;
const pendingCleanupDeps = [];
const cleanupDeps = () => {
    for (let i = 0; i < pendingCleanupDeps.length; i++) {
        const dep = pendingCleanupDeps[i];
        dep.subs = dep.subs.filter(s => s);
        dep._pending = false;
    }
    pendingCleanupDeps.length = 0;
};
/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 * @internal
 */
class Dep {
    constructor() {
        // pending subs cleanup
        this._pending = false;
        this.id = uid$2++;
        this.subs = [];
    }
    addSub(sub) {
        this.subs.push(sub);
    }
    removeSub(sub) {
        // #12696 deps with massive amount of subscribers are extremely slow to
        // clean up in Chromium
        // to workaround this, we unset the sub for now, and clear them on
        // next scheduler flush.
        this.subs[this.subs.indexOf(sub)] = null;
        if (!this._pending) {
            this._pending = true;
            pendingCleanupDeps.push(this);
        }
    }
    depend(info) {
        if (Dep.target) {
            Dep.target.addDep(this);
            if (info && Dep.target.onTrack) {
                Dep.target.onTrack(Object.assign({ effect: Dep.target }, info));
            }
        }
    }
    notify(info) {
        // stabilize the subscriber list first
        const subs = this.subs.filter(s => s);
        if (!config.async) {
            // subs aren't sorted in scheduler if not running async
            // we need to sort them now to make sure they fire in correct
            // order
            subs.sort((a, b) => a.id - b.id);
        }
        for (let i = 0, l = subs.length; i < l; i++) {
            const sub = subs[i];
            if (info) {
                sub.onTrigger &&
                    sub.onTrigger(Object.assign({ effect: subs[i] }, info));
            }
            sub.update();
        }
    }
}
// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
const targetStack = [];
function pushTarget(target) {
    targetStack.push(target);
    Dep.target = target;
}
function popTarget() {
    targetStack.pop();
    Dep.target = targetStack[targetStack.length - 1];
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */
const arrayProto = Array.prototype;
const arrayMethods = Object.create(arrayProto);
const methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
    // cache original method
    const original = arrayProto[method];
    def(arrayMethods, method, function mutator(...args) {
        const result = original.apply(this, args);
        const ob = this.__ob__;
        let inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                inserted = args;
                break;
            case 'splice':
                inserted = args.slice(2);
                break;
        }
        if (inserted)
            ob.observeArray(inserted);
        // notify change
        {
            ob.dep.notify({
                type: "array mutation" /* TriggerOpTypes.ARRAY_MUTATION */,
                target: this,
                key: method
            });
        }
        return result;
    });
});

const arrayKeys = Object.getOwnPropertyNames(arrayMethods);
const NO_INITIAL_VALUE = {};
/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
let shouldObserve = true;
function toggleObserving(value) {
    shouldObserve = value;
}
// ssr mock dep
const mockDep = {
    notify: noop,
    depend: noop,
    addSub: noop,
    removeSub: noop
};
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
class Observer {
    constructor(value, shallow = false, mock = false) {
        this.value = value;
        this.shallow = shallow;
        this.mock = mock;
        // this.value = value
        this.dep = mock ? mockDep : new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this);
        if (isArray(value)) {
            if (!mock) {
                if (hasProto) {
                    value.__proto__ = arrayMethods;
                    /* eslint-enable no-proto */
                }
                else {
                    for (let i = 0, l = arrayKeys.length; i < l; i++) {
                        const key = arrayKeys[i];
                        def(value, key, arrayMethods[key]);
                    }
                }
            }
            if (!shallow) {
                this.observeArray(value);
            }
        }
        else {
            /**
             * Walk through all properties and convert them into
             * getter/setters. This method should only be called when
             * value type is Object.
             */
            const keys = Object.keys(value);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock);
            }
        }
    }
    /**
     * Observe a list of Array items.
     */
    observeArray(value) {
        for (let i = 0, l = value.length; i < l; i++) {
            observe(value[i], false, this.mock);
        }
    }
}
// helpers
/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, shallow, ssrMockReactivity) {
    if (value && hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        return value.__ob__;
    }
    if (shouldObserve &&
        (ssrMockReactivity || !isServerRendering()) &&
        (isArray(value) || isPlainObject(value)) &&
        Object.isExtensible(value) &&
        !value.__v_skip /* ReactiveFlags.SKIP */ &&
        !isRef(value) &&
        !(value instanceof VNode)) {
        return new Observer(value, shallow, ssrMockReactivity);
    }
}
/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow, mock, observeEvenIfShallow = false) {
    const dep = new Dep();
    const property = Object.getOwnPropertyDescriptor(obj, key);
    if (property && property.configurable === false) {
        return;
    }
    // cater for pre-defined getter/setters
    const getter = property && property.get;
    const setter = property && property.set;
    if ((!getter || setter) &&
        (val === NO_INITIAL_VALUE || arguments.length === 2)) {
        val = obj[key];
    }
    let childOb = shallow ? val && val.__ob__ : observe(val, false, mock);
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            const value = getter ? getter.call(obj) : val;
            if (Dep.target) {
                {
                    dep.depend({
                        target: obj,
                        type: "get" /* TrackOpTypes.GET */,
                        key
                    });
                }
                if (childOb) {
                    childOb.dep.depend();
                    if (isArray(value)) {
                        dependArray(value);
                    }
                }
            }
            return isRef(value) && !shallow ? value.value : value;
        },
        set: function reactiveSetter(newVal) {
            const value = getter ? getter.call(obj) : val;
            if (!hasChanged(value, newVal)) {
                return;
            }
            if (customSetter) {
                customSetter();
            }
            if (setter) {
                setter.call(obj, newVal);
            }
            else if (getter) {
                // #7981: for accessor properties without setter
                return;
            }
            else if (!shallow && isRef(value) && !isRef(newVal)) {
                value.value = newVal;
                return;
            }
            else {
                val = newVal;
            }
            childOb = shallow ? newVal && newVal.__ob__ : observe(newVal, false, mock);
            {
                dep.notify({
                    type: "set" /* TriggerOpTypes.SET */,
                    target: obj,
                    key,
                    newValue: newVal,
                    oldValue: value
                });
            }
        }
    });
    return dep;
}
function set(target, key, val) {
    if ((isUndef(target) || isPrimitive(target))) {
        warn$2(`Cannot set reactive property on undefined, null, or primitive value: ${target}`);
    }
    if (isReadonly(target)) {
        warn$2(`Set operation on key "${key}" failed: target is readonly.`);
        return;
    }
    const ob = target.__ob__;
    if (isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        // when mocking for SSR, array methods are not hijacked
        if (ob && !ob.shallow && ob.mock) {
            observe(val, false, true);
        }
        return val;
    }
    if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val;
    }
    if (target._isVue || (ob && ob.vmCount)) {
        warn$2('Avoid adding reactive properties to a Vue instance or its root $data ' +
                'at runtime - declare it upfront in the data option.');
        return val;
    }
    if (!ob) {
        target[key] = val;
        return val;
    }
    defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock);
    {
        ob.dep.notify({
            type: "add" /* TriggerOpTypes.ADD */,
            target: target,
            key,
            newValue: val,
            oldValue: undefined
        });
    }
    return val;
}
function del(target, key) {
    if ((isUndef(target) || isPrimitive(target))) {
        warn$2(`Cannot delete reactive property on undefined, null, or primitive value: ${target}`);
    }
    if (isArray(target) && isValidArrayIndex(key)) {
        target.splice(key, 1);
        return;
    }
    const ob = target.__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
        warn$2('Avoid deleting properties on a Vue instance or its root $data ' +
                '- just set it to null.');
        return;
    }
    if (isReadonly(target)) {
        warn$2(`Delete operation on key "${key}" failed: target is readonly.`);
        return;
    }
    if (!hasOwn(target, key)) {
        return;
    }
    delete target[key];
    if (!ob) {
        return;
    }
    {
        ob.dep.notify({
            type: "delete" /* TriggerOpTypes.DELETE */,
            target: target,
            key
        });
    }
}
/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
    for (let e, i = 0, l = value.length; i < l; i++) {
        e = value[i];
        if (e && e.__ob__) {
            e.__ob__.dep.depend();
        }
        if (isArray(e)) {
            dependArray(e);
        }
    }
}

function reactive(target) {
    makeReactive(target, false);
    return target;
}
/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */
function shallowReactive(target) {
    makeReactive(target, true);
    def(target, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    return target;
}
function makeReactive(target, shallow) {
    // if trying to observe a readonly proxy, return the readonly version.
    if (!isReadonly(target)) {
        {
            if (isArray(target)) {
                warn$2(`Avoid using Array as root value for ${shallow ? `shallowReactive()` : `reactive()`} as it cannot be tracked in watch() or watchEffect(). Use ${shallow ? `shallowRef()` : `ref()`} instead. This is a Vue-2-only limitation.`);
            }
            const existingOb = target && target.__ob__;
            if (existingOb && existingOb.shallow !== shallow) {
                warn$2(`Target is already a ${existingOb.shallow ? `` : `non-`}shallow reactive object, and cannot be converted to ${shallow ? `` : `non-`}shallow.`);
            }
        }
        const ob = observe(target, shallow, isServerRendering() /* ssr mock reactivity */);
        if (!ob) {
            if (target == null || isPrimitive(target)) {
                warn$2(`value cannot be made reactive: ${String(target)}`);
            }
            if (isCollectionType(target)) {
                warn$2(`Vue 2 does not support reactive collection types such as Map or Set.`);
            }
        }
    }
}
function isReactive(value) {
    if (isReadonly(value)) {
        return isReactive(value["__v_raw" /* ReactiveFlags.RAW */]);
    }
    return !!(value && value.__ob__);
}
function isShallow(value) {
    return !!(value && value.__v_isShallow);
}
function isReadonly(value) {
    return !!(value && value.__v_isReadonly);
}
function isProxy(value) {
    return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
    const raw = observed && observed["__v_raw" /* ReactiveFlags.RAW */];
    return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
    // non-extensible objects won't be observed anyway
    if (Object.isExtensible(value)) {
        def(value, "__v_skip" /* ReactiveFlags.SKIP */, true);
    }
    return value;
}
/**
 * @internal
 */
function isCollectionType(value) {
    const type = toRawType(value);
    return (type === 'Map' || type === 'WeakMap' || type === 'Set' || type === 'WeakSet');
}

/**
 * @internal
 */
const RefFlag = `__v_isRef`;
function isRef(r) {
    return !!(r && r.__v_isRef === true);
}
function ref$1(value) {
    return createRef(value, false);
}
function shallowRef(value) {
    return createRef(value, true);
}
function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
        return rawValue;
    }
    const ref = {};
    def(ref, RefFlag, true);
    def(ref, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, shallow);
    def(ref, 'dep', defineReactive(ref, 'value', rawValue, null, shallow, isServerRendering()));
    return ref;
}
function triggerRef(ref) {
    if (!ref.dep) {
        warn$2(`received object is not a triggerable ref.`);
    }
    {
        ref.dep &&
            ref.dep.notify({
                type: "set" /* TriggerOpTypes.SET */,
                target: ref,
                key: 'value'
            });
    }
}
function unref(ref) {
    return isRef(ref) ? ref.value : ref;
}
function proxyRefs(objectWithRefs) {
    if (isReactive(objectWithRefs)) {
        return objectWithRefs;
    }
    const proxy = {};
    const keys = Object.keys(objectWithRefs);
    for (let i = 0; i < keys.length; i++) {
        proxyWithRefUnwrap(proxy, objectWithRefs, keys[i]);
    }
    return proxy;
}
function proxyWithRefUnwrap(target, source, key) {
    Object.defineProperty(target, key, {
        enumerable: true,
        configurable: true,
        get: () => {
            const val = source[key];
            if (isRef(val)) {
                return val.value;
            }
            else {
                const ob = val && val.__ob__;
                if (ob)
                    ob.dep.depend();
                return val;
            }
        },
        set: value => {
            const oldValue = source[key];
            if (isRef(oldValue) && !isRef(value)) {
                oldValue.value = value;
            }
            else {
                source[key] = value;
            }
        }
    });
}
function customRef(factory) {
    const dep = new Dep();
    const { get, set } = factory(() => {
        {
            dep.depend({
                target: ref,
                type: "get" /* TrackOpTypes.GET */,
                key: 'value'
            });
        }
    }, () => {
        {
            dep.notify({
                target: ref,
                type: "set" /* TriggerOpTypes.SET */,
                key: 'value'
            });
        }
    });
    const ref = {
        get value() {
            return get();
        },
        set value(newVal) {
            set(newVal);
        }
    };
    def(ref, RefFlag, true);
    return ref;
}
function toRefs(object) {
    if (!isReactive(object)) {
        warn$2(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray(object) ? new Array(object.length) : {};
    for (const key in object) {
        ret[key] = toRef(object, key);
    }
    return ret;
}
function toRef(object, key, defaultValue) {
    const val = object[key];
    if (isRef(val)) {
        return val;
    }
    const ref = {
        get value() {
            const val = object[key];
            return val === undefined ? defaultValue : val;
        },
        set value(newVal) {
            object[key] = newVal;
        }
    };
    def(ref, RefFlag, true);
    return ref;
}

const rawToReadonlyFlag = `__v_rawToReadonly`;
const rawToShallowReadonlyFlag = `__v_rawToShallowReadonly`;
function readonly(target) {
    return createReadonly(target, false);
}
function createReadonly(target, shallow) {
    if (!isPlainObject(target)) {
        {
            if (isArray(target)) {
                warn$2(`Vue 2 does not support readonly arrays.`);
            }
            else if (isCollectionType(target)) {
                warn$2(`Vue 2 does not support readonly collection types such as Map or Set.`);
            }
            else {
                warn$2(`value cannot be made readonly: ${typeof target}`);
            }
        }
        return target;
    }
    if (!Object.isExtensible(target)) {
        warn$2(`Vue 2 does not support creating readonly proxy for non-extensible object.`);
    }
    // already a readonly object
    if (isReadonly(target)) {
        return target;
    }
    // already has a readonly proxy
    const existingFlag = shallow ? rawToShallowReadonlyFlag : rawToReadonlyFlag;
    const existingProxy = target[existingFlag];
    if (existingProxy) {
        return existingProxy;
    }
    const proxy = Object.create(Object.getPrototypeOf(target));
    def(target, existingFlag, proxy);
    def(proxy, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, true);
    def(proxy, "__v_raw" /* ReactiveFlags.RAW */, target);
    if (isRef(target)) {
        def(proxy, RefFlag, true);
    }
    if (shallow || isShallow(target)) {
        def(proxy, "__v_isShallow" /* ReactiveFlags.IS_SHALLOW */, true);
    }
    const keys = Object.keys(target);
    for (let i = 0; i < keys.length; i++) {
        defineReadonlyProperty(proxy, target, keys[i], shallow);
    }
    return proxy;
}
function defineReadonlyProperty(proxy, target, key, shallow) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get() {
            const val = target[key];
            return shallow || !isPlainObject(val) ? val : readonly(val);
        },
        set() {
            warn$2(`Set operation on key "${key}" failed: target is readonly.`);
        }
    });
}
/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */
function shallowReadonly(target) {
    return createReadonly(target, true);
}

function computed(getterOrOptions, debugOptions) {
    let getter;
    let setter;
    const onlyGetter = isFunction(getterOrOptions);
    if (onlyGetter) {
        getter = getterOrOptions;
        setter = () => {
                warn$2('Write operation failed: computed value is readonly');
            }
            ;
    }
    else {
        getter = getterOrOptions.get;
        setter = getterOrOptions.set;
    }
    const watcher = isServerRendering()
        ? null
        : new Watcher(currentInstance, getter, noop, { lazy: true });
    if (watcher && debugOptions) {
        watcher.onTrack = debugOptions.onTrack;
        watcher.onTrigger = debugOptions.onTrigger;
    }
    const ref = {
        // some libs rely on the presence effect for checking computed refs
        // from normal refs, but the implementation doesn't matter
        effect: watcher,
        get value() {
            if (watcher) {
                if (watcher.dirty) {
                    watcher.evaluate();
                }
                if (Dep.target) {
                    if (Dep.target.onTrack) {
                        Dep.target.onTrack({
                            effect: Dep.target,
                            target: ref,
                            type: "get" /* TrackOpTypes.GET */,
                            key: 'value'
                        });
                    }
                    watcher.depend();
                }
                return watcher.value;
            }
            else {
                return getter();
            }
        },
        set value(newVal) {
            setter(newVal);
        }
    };
    def(ref, RefFlag, true);
    def(ref, "__v_isReadonly" /* ReactiveFlags.IS_READONLY */, onlyGetter);
    return ref;
}

let mark;
let measure;
{
    const perf = inBrowser && window.performance;
    /* istanbul ignore if */
    if (perf &&
        // @ts-ignore
        perf.mark &&
        // @ts-ignore
        perf.measure &&
        // @ts-ignore
        perf.clearMarks &&
        // @ts-ignore
        perf.clearMeasures) {
        mark = tag => perf.mark(tag);
        measure = (name, startTag, endTag) => {
            perf.measure(name, startTag, endTag);
            perf.clearMarks(startTag);
            perf.clearMarks(endTag);
            // perf.clearMeasures(name)
        };
    }
}

const normalizeEvent = cached((name) => {
    const passive = name.charAt(0) === '&';
    name = passive ? name.slice(1) : name;
    const once = name.charAt(0) === '~'; // Prefixed last, checked first
    name = once ? name.slice(1) : name;
    const capture = name.charAt(0) === '!';
    name = capture ? name.slice(1) : name;
    return {
        name,
        once,
        capture,
        passive
    };
});
function createFnInvoker(fns, vm) {
    function invoker() {
        const fns = invoker.fns;
        if (isArray(fns)) {
            const cloned = fns.slice();
            for (let i = 0; i < cloned.length; i++) {
                invokeWithErrorHandling(cloned[i], null, arguments, vm, `v-on handler`);
            }
        }
        else {
            // return handler return value for single handlers
            return invokeWithErrorHandling(fns, null, arguments, vm, `v-on handler`);
        }
    }
    invoker.fns = fns;
    return invoker;
}
function updateListeners(on, oldOn, add, remove, createOnceHandler, vm) {
    let name, cur, old, event;
    for (name in on) {
        cur = on[name];
        old = oldOn[name];
        event = normalizeEvent(name);
        if (isUndef(cur)) {
            warn$2(`Invalid handler for event "${event.name}": got ` + String(cur), vm);
        }
        else if (isUndef(old)) {
            if (isUndef(cur.fns)) {
                cur = on[name] = createFnInvoker(cur, vm);
            }
            if (isTrue(event.once)) {
                cur = on[name] = createOnceHandler(event.name, cur, event.capture);
            }
            add(event.name, cur, event.capture, event.passive, event.params);
        }
        else if (cur !== old) {
            old.fns = cur;
            on[name] = old;
        }
    }
    for (name in oldOn) {
        if (isUndef(on[name])) {
            event = normalizeEvent(name);
            remove(event.name, oldOn[name], event.capture);
        }
    }
}

function mergeVNodeHook(def, hookKey, hook) {
    if (def instanceof VNode) {
        def = def.data.hook || (def.data.hook = {});
    }
    let invoker;
    const oldHook = def[hookKey];
    function wrappedHook() {
        hook.apply(this, arguments);
        // important: remove merged hook to ensure it's called only once
        // and prevent memory leak
        remove$2(invoker.fns, wrappedHook);
    }
    if (isUndef(oldHook)) {
        // no existing hook
        invoker = createFnInvoker([wrappedHook]);
    }
    else {
        /* istanbul ignore if */
        if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
            // already a merged invoker
            invoker = oldHook;
            invoker.fns.push(wrappedHook);
        }
        else {
            // existing plain hook
            invoker = createFnInvoker([oldHook, wrappedHook]);
        }
    }
    invoker.merged = true;
    def[hookKey] = invoker;
}

function extractPropsFromVNodeData(data, Ctor, tag) {
    // we are only extracting raw values here.
    // validation and default values are handled in the child
    // component itself.
    const propOptions = Ctor.options.props;
    if (isUndef(propOptions)) {
        return;
    }
    const res = {};
    const { attrs, props } = data;
    if (isDef(attrs) || isDef(props)) {
        for (const key in propOptions) {
            const altKey = hyphenate(key);
            {
                const keyInLowerCase = key.toLowerCase();
                if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
                    tip(`Prop "${keyInLowerCase}" is passed to component ` +
                        `${formatComponentName(
                        // @ts-expect-error tag is string
                        tag || Ctor)}, but the declared prop name is` +
                        ` "${key}". ` +
                        `Note that HTML attributes are case-insensitive and camelCased ` +
                        `props need to use their kebab-case equivalents when using in-DOM ` +
                        `templates. You should probably use "${altKey}" instead of "${key}".`);
                }
            }
            checkProp(res, props, key, altKey, true) ||
                checkProp(res, attrs, key, altKey, false);
        }
    }
    return res;
}
function checkProp(res, hash, key, altKey, preserve) {
    if (isDef(hash)) {
        if (hasOwn(hash, key)) {
            res[key] = hash[key];
            if (!preserve) {
                delete hash[key];
            }
            return true;
        }
        else if (hasOwn(hash, altKey)) {
            res[key] = hash[altKey];
            if (!preserve) {
                delete hash[altKey];
            }
            return true;
        }
    }
    return false;
}

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:
// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
    for (let i = 0; i < children.length; i++) {
        if (isArray(children[i])) {
            return Array.prototype.concat.apply([], children);
        }
    }
    return children;
}
// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
    return isPrimitive(children)
        ? [createTextVNode(children)]
        : isArray(children)
            ? normalizeArrayChildren(children)
            : undefined;
}
function isTextNode(node) {
    return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}
function normalizeArrayChildren(children, nestedIndex) {
    const res = [];
    let i, c, lastIndex, last;
    for (i = 0; i < children.length; i++) {
        c = children[i];
        if (isUndef(c) || typeof c === 'boolean')
            continue;
        lastIndex = res.length - 1;
        last = res[lastIndex];
        //  nested
        if (isArray(c)) {
            if (c.length > 0) {
                c = normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`);
                // merge adjacent text nodes
                if (isTextNode(c[0]) && isTextNode(last)) {
                    res[lastIndex] = createTextVNode(last.text + c[0].text);
                    c.shift();
                }
                res.push.apply(res, c);
            }
        }
        else if (isPrimitive(c)) {
            if (isTextNode(last)) {
                // merge adjacent text nodes
                // this is necessary for SSR hydration because text nodes are
                // essentially merged when rendered to HTML strings
                res[lastIndex] = createTextVNode(last.text + c);
            }
            else if (c !== '') {
                // convert primitive to vnode
                res.push(createTextVNode(c));
            }
        }
        else {
            if (isTextNode(c) && isTextNode(last)) {
                // merge adjacent text nodes
                res[lastIndex] = createTextVNode(last.text + c.text);
            }
            else {
                // default key for nested array children (likely generated by v-for)
                if (isTrue(children._isVList) &&
                    isDef(c.tag) &&
                    isUndef(c.key) &&
                    isDef(nestedIndex)) {
                    c.key = `__vlist${nestedIndex}_${i}__`;
                }
                res.push(c);
            }
        }
    }
    return res;
}

const SIMPLE_NORMALIZE = 1;
const ALWAYS_NORMALIZE = 2;
// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement$1(context, tag, data, children, normalizationType, alwaysNormalize) {
    if (isArray(data) || isPrimitive(data)) {
        normalizationType = children;
        children = data;
        data = undefined;
    }
    if (isTrue(alwaysNormalize)) {
        normalizationType = ALWAYS_NORMALIZE;
    }
    return _createElement(context, tag, data, children, normalizationType);
}
function _createElement(context, tag, data, children, normalizationType) {
    if (isDef(data) && isDef(data.__ob__)) {
        warn$2(`Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` + 'Always create fresh vnode data objects in each render!', context);
        return createEmptyVNode();
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
        tag = data.is;
    }
    if (!tag) {
        // in case of component :is set to falsy value
        return createEmptyVNode();
    }
    // warn against non-primitive key
    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
        warn$2('Avoid using non-primitive value as key, ' +
            'use string/number value instead.', context);
    }
    // support single function children as default scoped slot
    if (isArray(children) && isFunction(children[0])) {
        data = data || {};
        data.scopedSlots = { default: children[0] };
        children.length = 0;
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children);
    }
    else if (normalizationType === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children);
    }
    let vnode, ns;
    if (typeof tag === 'string') {
        let Ctor;
        ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
        if (config.isReservedTag(tag)) {
            // platform built-in elements
            if (isDef(data) &&
                isDef(data.nativeOn) &&
                data.tag !== 'component') {
                warn$2(`The .native modifier for v-on is only valid on components but it was used on <${tag}>.`, context);
            }
            vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
        }
        else if ((!data || !data.pre) &&
            isDef((Ctor = resolveAsset(context.$options, 'components', tag)))) {
            // component
            vnode = createComponent(Ctor, data, context, children, tag);
        }
        else {
            // unknown or unlisted namespaced elements
            // check at runtime because it may get assigned a namespace when its
            // parent normalizes children
            vnode = new VNode(tag, data, children, undefined, undefined, context);
        }
    }
    else {
        // direct component options / constructor
        vnode = createComponent(tag, data, context, children);
    }
    if (isArray(vnode)) {
        return vnode;
    }
    else if (isDef(vnode)) {
        if (isDef(ns))
            applyNS(vnode, ns);
        if (isDef(data))
            registerDeepBindings(data);
        return vnode;
    }
    else {
        return createEmptyVNode();
    }
}
function applyNS(vnode, ns, force) {
    vnode.ns = ns;
    if (vnode.tag === 'foreignObject') {
        // use default namespace inside foreignObject
        ns = undefined;
        force = true;
    }
    if (isDef(vnode.children)) {
        for (let i = 0, l = vnode.children.length; i < l; i++) {
            const child = vnode.children[i];
            if (isDef(child.tag) &&
                (isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
                applyNS(child, ns, force);
            }
        }
    }
}
// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings(data) {
    if (isObject(data.style)) {
        traverse(data.style);
    }
    if (isObject(data.class)) {
        traverse(data.class);
    }
}

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
    let ret = null, i, l, keys, key;
    if (isArray(val) || typeof val === 'string') {
        ret = new Array(val.length);
        for (i = 0, l = val.length; i < l; i++) {
            ret[i] = render(val[i], i);
        }
    }
    else if (typeof val === 'number') {
        ret = new Array(val);
        for (i = 0; i < val; i++) {
            ret[i] = render(i + 1, i);
        }
    }
    else if (isObject(val)) {
        if (hasSymbol && val[Symbol.iterator]) {
            ret = [];
            const iterator = val[Symbol.iterator]();
            let result = iterator.next();
            while (!result.done) {
                ret.push(render(result.value, ret.length));
                result = iterator.next();
            }
        }
        else {
            keys = Object.keys(val);
            ret = new Array(keys.length);
            for (i = 0, l = keys.length; i < l; i++) {
                key = keys[i];
                ret[i] = render(val[key], key, i);
            }
        }
    }
    if (!isDef(ret)) {
        ret = [];
    }
    ret._isVList = true;
    return ret;
}

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallbackRender, props, bindObject) {
    const scopedSlotFn = this.$scopedSlots[name];
    let nodes;
    if (scopedSlotFn) {
        // scoped slot
        props = props || {};
        if (bindObject) {
            if (!isObject(bindObject)) {
                warn$2('slot v-bind without argument expects an Object', this);
            }
            props = extend(extend({}, bindObject), props);
        }
        nodes =
            scopedSlotFn(props) ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    else {
        nodes =
            this.$slots[name] ||
                (isFunction(fallbackRender) ? fallbackRender() : fallbackRender);
    }
    const target = props && props.slot;
    if (target) {
        return this.$createElement('template', { slot: target }, nodes);
    }
    else {
        return nodes;
    }
}

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
    return resolveAsset(this.$options, 'filters', id, true) || identity;
}

function isKeyNotMatch(expect, actual) {
    if (isArray(expect)) {
        return expect.indexOf(actual) === -1;
    }
    else {
        return expect !== actual;
    }
}
/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInKeyCode, eventKeyName, builtInKeyName) {
    const mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
        return isKeyNotMatch(builtInKeyName, eventKeyName);
    }
    else if (mappedKeyCode) {
        return isKeyNotMatch(mappedKeyCode, eventKeyCode);
    }
    else if (eventKeyName) {
        return hyphenate(eventKeyName) !== key;
    }
    return eventKeyCode === undefined;
}

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
    if (value) {
        if (!isObject(value)) {
            warn$2('v-bind without argument expects an Object or Array value', this);
        }
        else {
            if (isArray(value)) {
                value = toObject(value);
            }
            let hash;
            for (const key in value) {
                if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
                    hash = data;
                }
                else {
                    const type = data.attrs && data.attrs.type;
                    hash =
                        asProp || config.mustUseProp(tag, type, key)
                            ? data.domProps || (data.domProps = {})
                            : data.attrs || (data.attrs = {});
                }
                const camelizedKey = camelize(key);
                const hyphenatedKey = hyphenate(key);
                if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
                    hash[key] = value[key];
                    if (isSync) {
                        const on = data.on || (data.on = {});
                        on[`update:${key}`] = function ($event) {
                            value[key] = $event;
                        };
                    }
                }
            }
        }
    }
    return data;
}

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor) {
    const cached = this._staticTrees || (this._staticTrees = []);
    let tree = cached[index];
    // if has already-rendered static tree and not inside v-for,
    // we can reuse the same tree.
    if (tree && !isInFor) {
        return tree;
    }
    // otherwise, render a fresh tree.
    tree = cached[index] = this.$options.staticRenderFns[index].call(this._renderProxy, this._c, this // for render fns generated for functional component templates
    );
    markStatic$1(tree, `__static__${index}`, false);
    return tree;
}
/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
    markStatic$1(tree, `__once__${index}${key ? `_${key}` : ``}`, true);
    return tree;
}
function markStatic$1(tree, key, isOnce) {
    if (isArray(tree)) {
        for (let i = 0; i < tree.length; i++) {
            if (tree[i] && typeof tree[i] !== 'string') {
                markStaticNode(tree[i], `${key}_${i}`, isOnce);
            }
        }
    }
    else {
        markStaticNode(tree, key, isOnce);
    }
}
function markStaticNode(node, key, isOnce) {
    node.isStatic = true;
    node.key = key;
    node.isOnce = isOnce;
}

function bindObjectListeners(data, value) {
    if (value) {
        if (!isPlainObject(value)) {
            warn$2('v-on without argument expects an Object value', this);
        }
        else {
            const on = (data.on = data.on ? extend({}, data.on) : {});
            for (const key in value) {
                const existing = on[key];
                const ours = value[key];
                on[key] = existing ? [].concat(existing, ours) : ours;
            }
        }
    }
    return data;
}

function resolveScopedSlots(fns, res, 
// the following are added in 2.6
hasDynamicKeys, contentHashKey) {
    res = res || { $stable: !hasDynamicKeys };
    for (let i = 0; i < fns.length; i++) {
        const slot = fns[i];
        if (isArray(slot)) {
            resolveScopedSlots(slot, res, hasDynamicKeys);
        }
        else if (slot) {
            // marker for reverse proxying v-slot without scope on this.$slots
            // @ts-expect-error
            if (slot.proxy) {
                // @ts-expect-error
                slot.fn.proxy = true;
            }
            res[slot.key] = slot.fn;
        }
    }
    if (contentHashKey) {
        res.$key = contentHashKey;
    }
    return res;
}

// helper to process dynamic keys for dynamic arguments in v-bind and v-on.
function bindDynamicKeys(baseObj, values) {
    for (let i = 0; i < values.length; i += 2) {
        const key = values[i];
        if (typeof key === 'string' && key) {
            baseObj[values[i]] = values[i + 1];
        }
        else if (key !== '' && key !== null) {
            // null is a special value for explicitly removing a binding
            warn$2(`Invalid value for dynamic directive argument (expected string or null): ${key}`, this);
        }
    }
    return baseObj;
}
// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier(value, symbol) {
    return typeof value === 'string' ? symbol + value : value;
}

function installRenderHelpers(target) {
    target._o = markOnce;
    target._n = toNumber;
    target._s = toString;
    target._l = renderList;
    target._t = renderSlot;
    target._q = looseEqual;
    target._i = looseIndexOf;
    target._m = renderStatic;
    target._f = resolveFilter;
    target._k = checkKeyCodes;
    target._b = bindObjectProps;
    target._v = createTextVNode;
    target._e = createEmptyVNode;
    target._u = resolveScopedSlots;
    target._g = bindObjectListeners;
    target._d = bindDynamicKeys;
    target._p = prependModifier;
}

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
    if (!children || !children.length) {
        return {};
    }
    const slots = {};
    for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        const data = child.data;
        // remove slot attribute if the node is resolved as a Vue slot node
        if (data && data.attrs && data.attrs.slot) {
            delete data.attrs.slot;
        }
        // named slots should only be respected if the vnode was rendered in the
        // same context.
        if ((child.context === context || child.fnContext === context) &&
            data &&
            data.slot != null) {
            const name = data.slot;
            const slot = slots[name] || (slots[name] = []);
            if (child.tag === 'template') {
                slot.push.apply(slot, child.children || []);
            }
            else {
                slot.push(child);
            }
        }
        else {
            (slots.default || (slots.default = [])).push(child);
        }
    }
    // ignore slots that contains only whitespace
    for (const name in slots) {
        if (slots[name].every(isWhitespace)) {
            delete slots[name];
        }
    }
    return slots;
}
function isWhitespace(node) {
    return (node.isComment && !node.asyncFactory) || node.text === ' ';
}

function isAsyncPlaceholder(node) {
    // @ts-expect-error not really boolean type
    return node.isComment && node.asyncFactory;
}

function normalizeScopedSlots(ownerVm, scopedSlots, normalSlots, prevScopedSlots) {
    let res;
    const hasNormalSlots = Object.keys(normalSlots).length > 0;
    const isStable = scopedSlots ? !!scopedSlots.$stable : !hasNormalSlots;
    const key = scopedSlots && scopedSlots.$key;
    if (!scopedSlots) {
        res = {};
    }
    else if (scopedSlots._normalized) {
        // fast path 1: child component re-render only, parent did not change
        return scopedSlots._normalized;
    }
    else if (isStable &&
        prevScopedSlots &&
        prevScopedSlots !== emptyObject &&
        key === prevScopedSlots.$key &&
        !hasNormalSlots &&
        !prevScopedSlots.$hasNormal) {
        // fast path 2: stable scoped slots w/ no normal slots to proxy,
        // only need to normalize once
        return prevScopedSlots;
    }
    else {
        res = {};
        for (const key in scopedSlots) {
            if (scopedSlots[key] && key[0] !== '$') {
                res[key] = normalizeScopedSlot(ownerVm, normalSlots, key, scopedSlots[key]);
            }
        }
    }
    // expose normal slots on scopedSlots
    for (const key in normalSlots) {
        if (!(key in res)) {
            res[key] = proxyNormalSlot(normalSlots, key);
        }
    }
    // avoriaz seems to mock a non-extensible $scopedSlots object
    // and when that is passed down this would cause an error
    if (scopedSlots && Object.isExtensible(scopedSlots)) {
        scopedSlots._normalized = res;
    }
    def(res, '$stable', isStable);
    def(res, '$key', key);
    def(res, '$hasNormal', hasNormalSlots);
    return res;
}
function normalizeScopedSlot(vm, normalSlots, key, fn) {
    const normalized = function () {
        const cur = currentInstance;
        setCurrentInstance(vm);
        let res = arguments.length ? fn.apply(null, arguments) : fn({});
        res =
            res && typeof res === 'object' && !isArray(res)
                ? [res] // single vnode
                : normalizeChildren(res);
        const vnode = res && res[0];
        setCurrentInstance(cur);
        return res &&
            (!vnode ||
                (res.length === 1 && vnode.isComment && !isAsyncPlaceholder(vnode))) // #9658, #10391
            ? undefined
            : res;
    };
    // this is a slot using the new v-slot syntax without scope. although it is
    // compiled as a scoped slot, render fn users would expect it to be present
    // on this.$slots because the usage is semantically a normal slot.
    if (fn.proxy) {
        Object.defineProperty(normalSlots, key, {
            get: normalized,
            enumerable: true,
            configurable: true
        });
    }
    return normalized;
}
function proxyNormalSlot(slots, key) {
    return () => slots[key];
}

function initSetup(vm) {
    const options = vm.$options;
    const setup = options.setup;
    if (setup) {
        const ctx = (vm._setupContext = createSetupContext(vm));
        setCurrentInstance(vm);
        pushTarget();
        const setupResult = invokeWithErrorHandling(setup, null, [vm._props || shallowReactive({}), ctx], vm, `setup`);
        popTarget();
        setCurrentInstance();
        if (isFunction(setupResult)) {
            // render function
            // @ts-ignore
            options.render = setupResult;
        }
        else if (isObject(setupResult)) {
            // bindings
            if (setupResult instanceof VNode) {
                warn$2(`setup() should not return VNodes directly - ` +
                    `return a render function instead.`);
            }
            vm._setupState = setupResult;
            // __sfc indicates compiled bindings from <script setup>
            if (!setupResult.__sfc) {
                for (const key in setupResult) {
                    if (!isReserved(key)) {
                        proxyWithRefUnwrap(vm, setupResult, key);
                    }
                    else {
                        warn$2(`Avoid using variables that start with _ or $ in setup().`);
                    }
                }
            }
            else {
                // exposed for compiled render fn
                const proxy = (vm._setupProxy = {});
                for (const key in setupResult) {
                    if (key !== '__sfc') {
                        proxyWithRefUnwrap(proxy, setupResult, key);
                    }
                }
            }
        }
        else if (setupResult !== undefined) {
            warn$2(`setup() should return an object. Received: ${setupResult === null ? 'null' : typeof setupResult}`);
        }
    }
}
function createSetupContext(vm) {
    let exposeCalled = false;
    return {
        get attrs() {
            if (!vm._attrsProxy) {
                const proxy = (vm._attrsProxy = {});
                def(proxy, '_v_attr_proxy', true);
                syncSetupProxy(proxy, vm.$attrs, emptyObject, vm, '$attrs');
            }
            return vm._attrsProxy;
        },
        get listeners() {
            if (!vm._listenersProxy) {
                const proxy = (vm._listenersProxy = {});
                syncSetupProxy(proxy, vm.$listeners, emptyObject, vm, '$listeners');
            }
            return vm._listenersProxy;
        },
        get slots() {
            return initSlotsProxy(vm);
        },
        emit: bind$1(vm.$emit, vm),
        expose(exposed) {
            {
                if (exposeCalled) {
                    warn$2(`expose() should be called only once per setup().`, vm);
                }
                exposeCalled = true;
            }
            if (exposed) {
                Object.keys(exposed).forEach(key => proxyWithRefUnwrap(vm, exposed, key));
            }
        }
    };
}
function syncSetupProxy(to, from, prev, instance, type) {
    let changed = false;
    for (const key in from) {
        if (!(key in to)) {
            changed = true;
            defineProxyAttr(to, key, instance, type);
        }
        else if (from[key] !== prev[key]) {
            changed = true;
        }
    }
    for (const key in to) {
        if (!(key in from)) {
            changed = true;
            delete to[key];
        }
    }
    return changed;
}
function defineProxyAttr(proxy, key, instance, type) {
    Object.defineProperty(proxy, key, {
        enumerable: true,
        configurable: true,
        get() {
            return instance[type][key];
        }
    });
}
function initSlotsProxy(vm) {
    if (!vm._slotsProxy) {
        syncSetupSlots((vm._slotsProxy = {}), vm.$scopedSlots);
    }
    return vm._slotsProxy;
}
function syncSetupSlots(to, from) {
    for (const key in from) {
        to[key] = from[key];
    }
    for (const key in to) {
        if (!(key in from)) {
            delete to[key];
        }
    }
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useSlots() {
    return getContext().slots;
}
/**
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useAttrs() {
    return getContext().attrs;
}
/**
 * Vue 2 only
 * @internal use manual type def because public setup context type relies on
 * legacy VNode types
 */
function useListeners() {
    return getContext().listeners;
}
function getContext() {
    if (!currentInstance) {
        warn$2(`useContext() called without active instance.`);
    }
    const vm = currentInstance;
    return vm._setupContext || (vm._setupContext = createSetupContext(vm));
}
/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */
function mergeDefaults(raw, defaults) {
    const props = isArray(raw)
        ? raw.reduce((normalized, p) => ((normalized[p] = {}), normalized), {})
        : raw;
    for (const key in defaults) {
        const opt = props[key];
        if (opt) {
            if (isArray(opt) || isFunction(opt)) {
                props[key] = { type: opt, default: defaults[key] };
            }
            else {
                opt.default = defaults[key];
            }
        }
        else if (opt === null) {
            props[key] = { default: defaults[key] };
        }
        else {
            warn$2(`props default key "${key}" has no corresponding declaration.`);
        }
    }
    return props;
}

function initRender(vm) {
    vm._vnode = null; // the root of the child tree
    vm._staticTrees = null; // v-once cached trees
    const options = vm.$options;
    const parentVnode = (vm.$vnode = options._parentVnode); // the placeholder node in parent tree
    const renderContext = parentVnode && parentVnode.context;
    vm.$slots = resolveSlots(options._renderChildren, renderContext);
    vm.$scopedSlots = parentVnode
        ? normalizeScopedSlots(vm.$parent, parentVnode.data.scopedSlots, vm.$slots)
        : emptyObject;
    // bind the createElement fn to this instance
    // so that we get proper render context inside it.
    // args order: tag, data, children, normalizationType, alwaysNormalize
    // internal version is used by render functions compiled from templates
    // @ts-expect-error
    vm._c = (a, b, c, d) => createElement$1(vm, a, b, c, d, false);
    // normalization is always applied for the public version, used in
    // user-written render functions.
    // @ts-expect-error
    vm.$createElement = (a, b, c, d) => createElement$1(vm, a, b, c, d, true);
    // $attrs & $listeners are exposed for easier HOC creation.
    // they need to be reactive so that HOCs using them are always updated
    const parentData = parentVnode && parentVnode.data;
    /* istanbul ignore else */
    {
        defineReactive(vm, '$attrs', (parentData && parentData.attrs) || emptyObject, () => {
            !isUpdatingChildComponent && warn$2(`$attrs is readonly.`, vm);
        }, true);
        defineReactive(vm, '$listeners', options._parentListeners || emptyObject, () => {
            !isUpdatingChildComponent && warn$2(`$listeners is readonly.`, vm);
        }, true);
    }
}
let currentRenderingInstance = null;
function renderMixin(Vue) {
    // install runtime convenience helpers
    installRenderHelpers(Vue.prototype);
    Vue.prototype.$nextTick = function (fn) {
        return nextTick(fn, this);
    };
    Vue.prototype._render = function () {
        const vm = this;
        const { render, _parentVnode } = vm.$options;
        if (_parentVnode && vm._isMounted) {
            vm.$scopedSlots = normalizeScopedSlots(vm.$parent, _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);
            if (vm._slotsProxy) {
                syncSetupSlots(vm._slotsProxy, vm.$scopedSlots);
            }
        }
        // set parent vnode. this allows render functions to have access
        // to the data on the placeholder node.
        vm.$vnode = _parentVnode;
        // render self
        const prevInst = currentInstance;
        const prevRenderInst = currentRenderingInstance;
        let vnode;
        try {
            setCurrentInstance(vm);
            currentRenderingInstance = vm;
            vnode = render.call(vm._renderProxy, vm.$createElement);
        }
        catch (e) {
            handleError(e, vm, `render`);
            // return error render result,
            // or previous vnode to prevent render error causing blank component
            /* istanbul ignore else */
            if (vm.$options.renderError) {
                try {
                    vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
                }
                catch (e) {
                    handleError(e, vm, `renderError`);
                    vnode = vm._vnode;
                }
            }
            else {
                vnode = vm._vnode;
            }
        }
        finally {
            currentRenderingInstance = prevRenderInst;
            setCurrentInstance(prevInst);
        }
        // if the returned array contains only a single node, allow it
        if (isArray(vnode) && vnode.length === 1) {
            vnode = vnode[0];
        }
        // return empty vnode in case the render function errored out
        if (!(vnode instanceof VNode)) {
            if (isArray(vnode)) {
                warn$2('Multiple root nodes returned from render function. Render function ' +
                    'should return a single root node.', vm);
            }
            vnode = createEmptyVNode();
        }
        // set parent
        vnode.parent = _parentVnode;
        return vnode;
    };
}

function ensureCtor(comp, base) {
    if (comp.__esModule || (hasSymbol && comp[Symbol.toStringTag] === 'Module')) {
        comp = comp.default;
    }
    return isObject(comp) ? base.extend(comp) : comp;
}
function createAsyncPlaceholder(factory, data, context, children, tag) {
    const node = createEmptyVNode();
    node.asyncFactory = factory;
    node.asyncMeta = { data, context, children, tag };
    return node;
}
function resolveAsyncComponent(factory, baseCtor) {
    if (isTrue(factory.error) && isDef(factory.errorComp)) {
        return factory.errorComp;
    }
    if (isDef(factory.resolved)) {
        return factory.resolved;
    }
    const owner = currentRenderingInstance;
    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
        // already pending
        factory.owners.push(owner);
    }
    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
        return factory.loadingComp;
    }
    if (owner && !isDef(factory.owners)) {
        const owners = (factory.owners = [owner]);
        let sync = true;
        let timerLoading = null;
        let timerTimeout = null;
        owner.$on('hook:destroyed', () => remove$2(owners, owner));
        const forceRender = (renderCompleted) => {
            for (let i = 0, l = owners.length; i < l; i++) {
                owners[i].$forceUpdate();
            }
            if (renderCompleted) {
                owners.length = 0;
                if (timerLoading !== null) {
                    clearTimeout(timerLoading);
                    timerLoading = null;
                }
                if (timerTimeout !== null) {
                    clearTimeout(timerTimeout);
                    timerTimeout = null;
                }
            }
        };
        const resolve = once((res) => {
            // cache resolved
            factory.resolved = ensureCtor(res, baseCtor);
            // invoke callbacks only if this is not a synchronous resolve
            // (async resolves are shimmed as synchronous during SSR)
            if (!sync) {
                forceRender(true);
            }
            else {
                owners.length = 0;
            }
        });
        const reject = once(reason => {
            warn$2(`Failed to resolve async component: ${String(factory)}` +
                    (reason ? `\nReason: ${reason}` : ''));
            if (isDef(factory.errorComp)) {
                factory.error = true;
                forceRender(true);
            }
        });
        const res = factory(resolve, reject);
        if (isObject(res)) {
            if (isPromise(res)) {
                // () => Promise
                if (isUndef(factory.resolved)) {
                    res.then(resolve, reject);
                }
            }
            else if (isPromise(res.component)) {
                res.component.then(resolve, reject);
                if (isDef(res.error)) {
                    factory.errorComp = ensureCtor(res.error, baseCtor);
                }
                if (isDef(res.loading)) {
                    factory.loadingComp = ensureCtor(res.loading, baseCtor);
                    if (res.delay === 0) {
                        factory.loading = true;
                    }
                    else {
                        // @ts-expect-error NodeJS timeout type
                        timerLoading = setTimeout(() => {
                            timerLoading = null;
                            if (isUndef(factory.resolved) && isUndef(factory.error)) {
                                factory.loading = true;
                                forceRender(false);
                            }
                        }, res.delay || 200);
                    }
                }
                if (isDef(res.timeout)) {
                    // @ts-expect-error NodeJS timeout type
                    timerTimeout = setTimeout(() => {
                        timerTimeout = null;
                        if (isUndef(factory.resolved)) {
                            reject(`timeout (${res.timeout}ms)` );
                        }
                    }, res.timeout);
                }
            }
        }
        sync = false;
        // return in case resolved synchronously
        return factory.loading ? factory.loadingComp : factory.resolved;
    }
}

function getFirstComponentChild(children) {
    if (isArray(children)) {
        for (let i = 0; i < children.length; i++) {
            const c = children[i];
            if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
                return c;
            }
        }
    }
}

function initEvents(vm) {
    vm._events = Object.create(null);
    vm._hasHookEvent = false;
    // init parent attached events
    const listeners = vm.$options._parentListeners;
    if (listeners) {
        updateComponentListeners(vm, listeners);
    }
}
let target$1;
function add$1(event, fn) {
    target$1.$on(event, fn);
}
function remove$1(event, fn) {
    target$1.$off(event, fn);
}
function createOnceHandler$1(event, fn) {
    const _target = target$1;
    return function onceHandler() {
        const res = fn.apply(null, arguments);
        if (res !== null) {
            _target.$off(event, onceHandler);
        }
    };
}
function updateComponentListeners(vm, listeners, oldListeners) {
    target$1 = vm;
    updateListeners(listeners, oldListeners || {}, add$1, remove$1, createOnceHandler$1, vm);
    target$1 = undefined;
}
function eventsMixin(Vue) {
    const hookRE = /^hook:/;
    Vue.prototype.$on = function (event, fn) {
        const vm = this;
        if (isArray(event)) {
            for (let i = 0, l = event.length; i < l; i++) {
                vm.$on(event[i], fn);
            }
        }
        else {
            (vm._events[event] || (vm._events[event] = [])).push(fn);
            // optimize hook:event cost by using a boolean flag marked at registration
            // instead of a hash lookup
            if (hookRE.test(event)) {
                vm._hasHookEvent = true;
            }
        }
        return vm;
    };
    Vue.prototype.$once = function (event, fn) {
        const vm = this;
        function on() {
            vm.$off(event, on);
            fn.apply(vm, arguments);
        }
        on.fn = fn;
        vm.$on(event, on);
        return vm;
    };
    Vue.prototype.$off = function (event, fn) {
        const vm = this;
        // all
        if (!arguments.length) {
            vm._events = Object.create(null);
            return vm;
        }
        // array of events
        if (isArray(event)) {
            for (let i = 0, l = event.length; i < l; i++) {
                vm.$off(event[i], fn);
            }
            return vm;
        }
        // specific event
        const cbs = vm._events[event];
        if (!cbs) {
            return vm;
        }
        if (!fn) {
            vm._events[event] = null;
            return vm;
        }
        // specific handler
        let cb;
        let i = cbs.length;
        while (i--) {
            cb = cbs[i];
            if (cb === fn || cb.fn === fn) {
                cbs.splice(i, 1);
                break;
            }
        }
        return vm;
    };
    Vue.prototype.$emit = function (event) {
        const vm = this;
        {
            const lowerCaseEvent = event.toLowerCase();
            if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
                tip(`Event "${lowerCaseEvent}" is emitted in component ` +
                    `${formatComponentName(vm)} but the handler is registered for "${event}". ` +
                    `Note that HTML attributes are case-insensitive and you cannot use ` +
                    `v-on to listen to camelCase events when using in-DOM templates. ` +
                    `You should probably use "${hyphenate(event)}" instead of "${event}".`);
            }
        }
        let cbs = vm._events[event];
        if (cbs) {
            cbs = cbs.length > 1 ? toArray(cbs) : cbs;
            const args = toArray(arguments, 1);
            const info = `event handler for "${event}"`;
            for (let i = 0, l = cbs.length; i < l; i++) {
                invokeWithErrorHandling(cbs[i], vm, args, vm, info);
            }
        }
        return vm;
    };
}

let activeEffectScope;
class EffectScope {
    constructor(detached = false) {
        this.detached = detached;
        /**
         * @internal
         */
        this.active = true;
        /**
         * @internal
         */
        this.effects = [];
        /**
         * @internal
         */
        this.cleanups = [];
        this.parent = activeEffectScope;
        if (!detached && activeEffectScope) {
            this.index =
                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
        }
    }
    run(fn) {
        if (this.active) {
            const currentEffectScope = activeEffectScope;
            try {
                activeEffectScope = this;
                return fn();
            }
            finally {
                activeEffectScope = currentEffectScope;
            }
        }
        else {
            warn$2(`cannot run an inactive effect scope.`);
        }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
        activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
        activeEffectScope = this.parent;
    }
    stop(fromParent) {
        if (this.active) {
            let i, l;
            for (i = 0, l = this.effects.length; i < l; i++) {
                this.effects[i].teardown();
            }
            for (i = 0, l = this.cleanups.length; i < l; i++) {
                this.cleanups[i]();
            }
            if (this.scopes) {
                for (i = 0, l = this.scopes.length; i < l; i++) {
                    this.scopes[i].stop(true);
                }
            }
            // nested scope, dereference from parent to avoid memory leaks
            if (!this.detached && this.parent && !fromParent) {
                // optimized O(1) removal
                const last = this.parent.scopes.pop();
                if (last && last !== this) {
                    this.parent.scopes[this.index] = last;
                    last.index = this.index;
                }
            }
            this.parent = undefined;
            this.active = false;
        }
    }
}
function effectScope(detached) {
    return new EffectScope(detached);
}
/**
 * @internal
 */
function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
        scope.effects.push(effect);
    }
}
function getCurrentScope() {
    return activeEffectScope;
}
function onScopeDispose(fn) {
    if (activeEffectScope) {
        activeEffectScope.cleanups.push(fn);
    }
    else {
        warn$2(`onScopeDispose() is called when there is no active effect scope` +
            ` to be associated with.`);
    }
}

let activeInstance = null;
let isUpdatingChildComponent = false;
function setActiveInstance(vm) {
    const prevActiveInstance = activeInstance;
    activeInstance = vm;
    return () => {
        activeInstance = prevActiveInstance;
    };
}
function initLifecycle(vm) {
    const options = vm.$options;
    // locate first non-abstract parent
    let parent = options.parent;
    if (parent && !options.abstract) {
        while (parent.$options.abstract && parent.$parent) {
            parent = parent.$parent;
        }
        parent.$children.push(vm);
    }
    vm.$parent = parent;
    vm.$root = parent ? parent.$root : vm;
    vm.$children = [];
    vm.$refs = {};
    vm._provided = parent ? parent._provided : Object.create(null);
    vm._watcher = null;
    vm._inactive = null;
    vm._directInactive = false;
    vm._isMounted = false;
    vm._isDestroyed = false;
    vm._isBeingDestroyed = false;
}
function lifecycleMixin(Vue) {
    Vue.prototype._update = function (vnode, hydrating) {
        const vm = this;
        const prevEl = vm.$el;
        const prevVnode = vm._vnode;
        const restoreActiveInstance = setActiveInstance(vm);
        vm._vnode = vnode;
        // Vue.prototype.__patch__ is injected in entry points
        // based on the rendering backend used.
        if (!prevVnode) {
            // initial render
            vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
        }
        else {
            // updates
            vm.$el = vm.__patch__(prevVnode, vnode);
        }
        restoreActiveInstance();
        // update __vue__ reference
        if (prevEl) {
            prevEl.__vue__ = null;
        }
        if (vm.$el) {
            vm.$el.__vue__ = vm;
        }
        // if parent is an HOC, update its $el as well
        let wrapper = vm;
        while (wrapper &&
            wrapper.$vnode &&
            wrapper.$parent &&
            wrapper.$vnode === wrapper.$parent._vnode) {
            wrapper.$parent.$el = wrapper.$el;
            wrapper = wrapper.$parent;
        }
        // updated hook is called by the scheduler to ensure that children are
        // updated in a parent's updated hook.
    };
    Vue.prototype.$forceUpdate = function () {
        const vm = this;
        if (vm._watcher) {
            vm._watcher.update();
        }
    };
    Vue.prototype.$destroy = function () {
        const vm = this;
        if (vm._isBeingDestroyed) {
            return;
        }
        callHook$1(vm, 'beforeDestroy');
        vm._isBeingDestroyed = true;
        // remove self from parent
        const parent = vm.$parent;
        if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
            remove$2(parent.$children, vm);
        }
        // teardown scope. this includes both the render watcher and other
        // watchers created
        vm._scope.stop();
        // remove reference from data ob
        // frozen object may not have observer.
        if (vm._data.__ob__) {
            vm._data.__ob__.vmCount--;
        }
        // call the last hook...
        vm._isDestroyed = true;
        // invoke destroy hooks on current rendered tree
        vm.__patch__(vm._vnode, null);
        // fire destroyed hook
        callHook$1(vm, 'destroyed');
        // turn off all instance listeners.
        vm.$off();
        // remove __vue__ reference
        if (vm.$el) {
            vm.$el.__vue__ = null;
        }
        // release circular reference (#6759)
        if (vm.$vnode) {
            vm.$vnode.parent = null;
        }
    };
}
function mountComponent(vm, el, hydrating) {
    vm.$el = el;
    if (!vm.$options.render) {
        // @ts-expect-error invalid type
        vm.$options.render = createEmptyVNode;
        {
            /* istanbul ignore if */
            if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
                vm.$options.el ||
                el) {
                warn$2('You are using the runtime-only build of Vue where the template ' +
                    'compiler is not available. Either pre-compile the templates into ' +
                    'render functions, or use the compiler-included build.', vm);
            }
            else {
                warn$2('Failed to mount component: template or render function not defined.', vm);
            }
        }
    }
    callHook$1(vm, 'beforeMount');
    let updateComponent;
    /* istanbul ignore if */
    if (config.performance && mark) {
        updateComponent = () => {
            const name = vm._name;
            const id = vm._uid;
            const startTag = `vue-perf-start:${id}`;
            const endTag = `vue-perf-end:${id}`;
            mark(startTag);
            const vnode = vm._render();
            mark(endTag);
            measure(`vue ${name} render`, startTag, endTag);
            mark(startTag);
            vm._update(vnode, hydrating);
            mark(endTag);
            measure(`vue ${name} patch`, startTag, endTag);
        };
    }
    else {
        updateComponent = () => {
            vm._update(vm._render(), hydrating);
        };
    }
    const watcherOptions = {
        before() {
            if (vm._isMounted && !vm._isDestroyed) {
                callHook$1(vm, 'beforeUpdate');
            }
        }
    };
    {
        watcherOptions.onTrack = e => callHook$1(vm, 'renderTracked', [e]);
        watcherOptions.onTrigger = e => callHook$1(vm, 'renderTriggered', [e]);
    }
    // we set this to vm._watcher inside the watcher's constructor
    // since the watcher's initial patch may call $forceUpdate (e.g. inside child
    // component's mounted hook), which relies on vm._watcher being already defined
    new Watcher(vm, updateComponent, noop, watcherOptions, true /* isRenderWatcher */);
    hydrating = false;
    // flush buffer for flush: "pre" watchers queued in setup()
    const preWatchers = vm._preWatchers;
    if (preWatchers) {
        for (let i = 0; i < preWatchers.length; i++) {
            preWatchers[i].run();
        }
    }
    // manually mounted instance, call mounted on self
    // mounted is called for render-created child components in its inserted hook
    if (vm.$vnode == null) {
        vm._isMounted = true;
        callHook$1(vm, 'mounted');
    }
    return vm;
}
function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
    {
        isUpdatingChildComponent = true;
    }
    // determine whether component has slot children
    // we need to do this before overwriting $options._renderChildren.
    // check if there are dynamic scopedSlots (hand-written or compiled but with
    // dynamic slot names). Static scoped slots compiled from template has the
    // "$stable" marker.
    const newScopedSlots = parentVnode.data.scopedSlots;
    const oldScopedSlots = vm.$scopedSlots;
    const hasDynamicScopedSlot = !!((newScopedSlots && !newScopedSlots.$stable) ||
        (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
        (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key) ||
        (!newScopedSlots && vm.$scopedSlots.$key));
    // Any static slot children from the parent may have changed during parent's
    // update. Dynamic scoped slots may also have changed. In such cases, a forced
    // update is necessary to ensure correctness.
    let needsForceUpdate = !!(renderChildren || // has new static slots
        vm.$options._renderChildren || // has old static slots
        hasDynamicScopedSlot);
    const prevVNode = vm.$vnode;
    vm.$options._parentVnode = parentVnode;
    vm.$vnode = parentVnode; // update vm's placeholder node without re-render
    if (vm._vnode) {
        // update child tree's parent
        vm._vnode.parent = parentVnode;
    }
    vm.$options._renderChildren = renderChildren;
    // update $attrs and $listeners hash
    // these are also reactive so they may trigger child update if the child
    // used them during render
    const attrs = parentVnode.data.attrs || emptyObject;
    if (vm._attrsProxy) {
        // force update if attrs are accessed and has changed since it may be
        // passed to a child component.
        if (syncSetupProxy(vm._attrsProxy, attrs, (prevVNode.data && prevVNode.data.attrs) || emptyObject, vm, '$attrs')) {
            needsForceUpdate = true;
        }
    }
    vm.$attrs = attrs;
    // update listeners
    listeners = listeners || emptyObject;
    const prevListeners = vm.$options._parentListeners;
    if (vm._listenersProxy) {
        syncSetupProxy(vm._listenersProxy, listeners, prevListeners || emptyObject, vm, '$listeners');
    }
    vm.$listeners = vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, prevListeners);
    // update props
    if (propsData && vm.$options.props) {
        toggleObserving(false);
        const props = vm._props;
        const propKeys = vm.$options._propKeys || [];
        for (let i = 0; i < propKeys.length; i++) {
            const key = propKeys[i];
            const propOptions = vm.$options.props; // wtf flow?
            props[key] = validateProp(key, propOptions, propsData, vm);
        }
        toggleObserving(true);
        // keep a copy of raw propsData
        vm.$options.propsData = propsData;
    }
    // resolve slots + force update if has children
    if (needsForceUpdate) {
        vm.$slots = resolveSlots(renderChildren, parentVnode.context);
        vm.$forceUpdate();
    }
    {
        isUpdatingChildComponent = false;
    }
}
function isInInactiveTree(vm) {
    while (vm && (vm = vm.$parent)) {
        if (vm._inactive)
            return true;
    }
    return false;
}
function activateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = false;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    else if (vm._directInactive) {
        return;
    }
    if (vm._inactive || vm._inactive === null) {
        vm._inactive = false;
        for (let i = 0; i < vm.$children.length; i++) {
            activateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'activated');
    }
}
function deactivateChildComponent(vm, direct) {
    if (direct) {
        vm._directInactive = true;
        if (isInInactiveTree(vm)) {
            return;
        }
    }
    if (!vm._inactive) {
        vm._inactive = true;
        for (let i = 0; i < vm.$children.length; i++) {
            deactivateChildComponent(vm.$children[i]);
        }
        callHook$1(vm, 'deactivated');
    }
}
function callHook$1(vm, hook, args, setContext = true) {
    // #7573 disable dep collection when invoking lifecycle hooks
    pushTarget();
    const prevInst = currentInstance;
    const prevScope = getCurrentScope();
    setContext && setCurrentInstance(vm);
    const handlers = vm.$options[hook];
    const info = `${hook} hook`;
    if (handlers) {
        for (let i = 0, j = handlers.length; i < j; i++) {
            invokeWithErrorHandling(handlers[i], vm, args || null, vm, info);
        }
    }
    if (vm._hasHookEvent) {
        vm.$emit('hook:' + hook);
    }
    if (setContext) {
        setCurrentInstance(prevInst);
        prevScope && prevScope.on();
    }
    popTarget();
}

const MAX_UPDATE_COUNT = 100;
const queue = [];
const activatedChildren = [];
let has = {};
let circular = {};
let waiting = false;
let flushing = false;
let index$1 = 0;
/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
    index$1 = queue.length = activatedChildren.length = 0;
    has = {};
    {
        circular = {};
    }
    waiting = flushing = false;
}
// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
let currentFlushTimestamp = 0;
// Async edge case fix requires storing an event listener's attach timestamp.
let getNow = Date.now;
// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
    const performance = window.performance;
    if (performance &&
        typeof performance.now === 'function' &&
        getNow() > document.createEvent('Event').timeStamp) {
        // if the event timestamp, although evaluated AFTER the Date.now(), is
        // smaller than it, it means the event is using a hi-res timestamp,
        // and we need to use the hi-res version for event listener timestamps as
        // well.
        getNow = () => performance.now();
    }
}
const sortCompareFn = (a, b) => {
    if (a.post) {
        if (!b.post)
            return 1;
    }
    else if (b.post) {
        return -1;
    }
    return a.id - b.id;
};
/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
    currentFlushTimestamp = getNow();
    flushing = true;
    let watcher, id;
    // Sort queue before flush.
    // This ensures that:
    // 1. Components are updated from parent to child. (because parent is always
    //    created before the child)
    // 2. A component's user watchers are run before its render watcher (because
    //    user watchers are created before the render watcher)
    // 3. If a component is destroyed during a parent component's watcher run,
    //    its watchers can be skipped.
    queue.sort(sortCompareFn);
    // do not cache length because more watchers might be pushed
    // as we run existing watchers
    for (index$1 = 0; index$1 < queue.length; index$1++) {
        watcher = queue[index$1];
        if (watcher.before) {
            watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
        // in dev build, check and stop circular updates.
        if (has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
                warn$2('You may have an infinite update loop ' +
                    (watcher.user
                        ? `in watcher with expression "${watcher.expression}"`
                        : `in a component render function.`), watcher.vm);
                break;
            }
        }
    }
    // keep copies of post queues before resetting state
    const activatedQueue = activatedChildren.slice();
    const updatedQueue = queue.slice();
    resetSchedulerState();
    // call component updated and activated hooks
    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);
    cleanupDeps();
    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
        devtools.emit('flush');
    }
}
function callUpdatedHooks(queue) {
    let i = queue.length;
    while (i--) {
        const watcher = queue[i];
        const vm = watcher.vm;
        if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
            callHook$1(vm, 'updated');
        }
    }
}
/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
    // setting _inactive to false here so that a render function can
    // rely on checking whether it's in an inactive tree (e.g. router-view)
    vm._inactive = false;
    activatedChildren.push(vm);
}
function callActivatedHooks(queue) {
    for (let i = 0; i < queue.length; i++) {
        queue[i]._inactive = true;
        activateChildComponent(queue[i], true /* true */);
    }
}
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
    const id = watcher.id;
    if (has[id] != null) {
        return;
    }
    if (watcher === Dep.target && watcher.noRecurse) {
        return;
    }
    has[id] = true;
    if (!flushing) {
        queue.push(watcher);
    }
    else {
        // if already flushing, splice the watcher based on its id
        // if already past its id, it will be run next immediately.
        let i = queue.length - 1;
        while (i > index$1 && queue[i].id > watcher.id) {
            i--;
        }
        queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
        waiting = true;
        if (!config.async) {
            flushSchedulerQueue();
            return;
        }
        nextTick(flushSchedulerQueue);
    }
}

const WATCHER = `watcher`;
const WATCHER_CB = `${WATCHER} callback`;
const WATCHER_GETTER = `${WATCHER} getter`;
const WATCHER_CLEANUP = `${WATCHER} cleanup`;
// Simple effect.
function watchEffect(effect, options) {
    return doWatch(effect, null, options);
}
function watchPostEffect(effect, options) {
    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'post' }) ));
}
function watchSyncEffect(effect, options) {
    return doWatch(effect, null, (Object.assign(Object.assign({}, options), { flush: 'sync' }) ));
}
// initial value for watchers to trigger on undefined initial values
const INITIAL_WATCHER_VALUE = {};
// implementation
function watch(source, cb, options) {
    if (typeof cb !== 'function') {
        warn$2(`\`watch(fn, options?)\` signature has been moved to a separate API. ` +
            `Use \`watchEffect(fn, options?)\` instead. \`watch\` now only ` +
            `supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush = 'pre', onTrack, onTrigger } = emptyObject) {
    if (!cb) {
        if (immediate !== undefined) {
            warn$2(`watch() "immediate" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
        if (deep !== undefined) {
            warn$2(`watch() "deep" option is only respected when using the ` +
                `watch(source, callback, options?) signature.`);
        }
    }
    const warnInvalidSource = (s) => {
        warn$2(`Invalid watch source: ${s}. A watch source can only be a getter/effect ` +
            `function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    const call = (fn, type, args = null) => {
        const res = invokeWithErrorHandling(fn, null, args, instance, type);
        if (deep && res && res.__ob__)
            res.__ob__.dep.depend();
        return res;
    };
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
        getter = () => source.value;
        forceTrigger = isShallow(source);
    }
    else if (isReactive(source)) {
        getter = () => {
            source.__ob__.dep.depend();
            return source;
        };
        deep = true;
    }
    else if (isArray(source)) {
        isMultiSource = true;
        forceTrigger = source.some(s => isReactive(s) || isShallow(s));
        getter = () => source.map(s => {
            if (isRef(s)) {
                return s.value;
            }
            else if (isReactive(s)) {
                s.__ob__.dep.depend();
                return traverse(s);
            }
            else if (isFunction(s)) {
                return call(s, WATCHER_GETTER);
            }
            else {
                warnInvalidSource(s);
            }
        });
    }
    else if (isFunction(source)) {
        if (cb) {
            // getter with cb
            getter = () => call(source, WATCHER_GETTER);
        }
        else {
            // no cb -> simple effect
            getter = () => {
                if (instance && instance._isDestroyed) {
                    return;
                }
                if (cleanup) {
                    cleanup();
                }
                return call(source, WATCHER, [onCleanup]);
            };
        }
    }
    else {
        getter = noop;
        warnInvalidSource(source);
    }
    if (cb && deep) {
        const baseGetter = getter;
        getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
        cleanup = watcher.onStop = () => {
            call(fn, WATCHER_CLEANUP);
        };
    };
    // in SSR there is no need to setup an actual effect, and it should be noop
    // unless it's eager
    if (isServerRendering()) {
        // we will also not call the invalidate callback (+ runner is not set up)
        onCleanup = noop;
        if (!cb) {
            getter();
        }
        else if (immediate) {
            call(cb, WATCHER_CB, [
                getter(),
                isMultiSource ? [] : undefined,
                onCleanup
            ]);
        }
        return noop;
    }
    const watcher = new Watcher(currentInstance, getter, noop, {
        lazy: true
    });
    watcher.noRecurse = !cb;
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    // overwrite default run
    watcher.run = () => {
        if (!watcher.active) {
            return;
        }
        if (cb) {
            // watch(source, cb)
            const newValue = watcher.get();
            if (deep ||
                forceTrigger ||
                (isMultiSource
                    ? newValue.some((v, i) => hasChanged(v, oldValue[i]))
                    : hasChanged(newValue, oldValue))) {
                // cleanup before running cb again
                if (cleanup) {
                    cleanup();
                }
                call(cb, WATCHER_CB, [
                    newValue,
                    // pass undefined as the old value when it's changed for the first time
                    oldValue === INITIAL_WATCHER_VALUE ? undefined : oldValue,
                    onCleanup
                ]);
                oldValue = newValue;
            }
        }
        else {
            // watchEffect
            watcher.get();
        }
    };
    if (flush === 'sync') {
        watcher.update = watcher.run;
    }
    else if (flush === 'post') {
        watcher.post = true;
        watcher.update = () => queueWatcher(watcher);
    }
    else {
        // pre
        watcher.update = () => {
            if (instance && instance === currentInstance && !instance._isMounted) {
                // pre-watcher triggered before
                const buffer = instance._preWatchers || (instance._preWatchers = []);
                if (buffer.indexOf(watcher) < 0)
                    buffer.push(watcher);
            }
            else {
                queueWatcher(watcher);
            }
        };
    }
    {
        watcher.onTrack = onTrack;
        watcher.onTrigger = onTrigger;
    }
    // initial run
    if (cb) {
        if (immediate) {
            watcher.run();
        }
        else {
            oldValue = watcher.get();
        }
    }
    else if (flush === 'post' && instance) {
        instance.$once('hook:mounted', () => watcher.get());
    }
    else {
        watcher.get();
    }
    return () => {
        watcher.teardown();
    };
}

function provide(key, value) {
    if (!currentInstance) {
        {
            warn$2(`provide() can only be used inside setup().`);
        }
    }
    else {
        // TS doesn't allow symbol as index type
        resolveProvided(currentInstance)[key] = value;
    }
}
function resolveProvided(vm) {
    // by default an instance inherits its parent's provides object
    // but when it needs to provide values of its own, it creates its
    // own provides object using parent provides object as prototype.
    // this way in `inject` we can simply look up injections from direct
    // parent and let the prototype chain do the work.
    const existing = vm._provided;
    const parentProvides = vm.$parent && vm.$parent._provided;
    if (parentProvides === existing) {
        return (vm._provided = Object.create(parentProvides));
    }
    else {
        return existing;
    }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
    // fallback to `currentRenderingInstance` so that this can be called in
    // a functional component
    const instance = currentInstance;
    if (instance) {
        // #2400
        // to support `app.use` plugins,
        // fallback to appContext's `provides` if the instance is at root
        const provides = instance.$parent && instance.$parent._provided;
        if (provides && key in provides) {
            // TS doesn't allow symbol as index type
            return provides[key];
        }
        else if (arguments.length > 1) {
            return treatDefaultAsFactory && isFunction(defaultValue)
                ? defaultValue.call(instance)
                : defaultValue;
        }
        else {
            warn$2(`injection "${String(key)}" not found.`);
        }
    }
    else {
        warn$2(`inject() can only be used inside setup() or functional components.`);
    }
}

/**
 * @internal this function needs manual public type declaration because it relies
 * on previously manually authored types from Vue 2
 */
function h(type, props, children) {
    if (!currentInstance) {
        warn$2(`globally imported h() can only be invoked when there is an active ` +
                `component instance, e.g. synchronously in a component's render or setup function.`);
    }
    return createElement$1(currentInstance, type, props, children, 2, true);
}

function handleError(err, vm, info) {
    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
    // See: https://github.com/vuejs/vuex/issues/1505
    pushTarget();
    try {
        if (vm) {
            let cur = vm;
            while ((cur = cur.$parent)) {
                const hooks = cur.$options.errorCaptured;
                if (hooks) {
                    for (let i = 0; i < hooks.length; i++) {
                        try {
                            const capture = hooks[i].call(cur, err, vm, info) === false;
                            if (capture)
                                return;
                        }
                        catch (e) {
                            globalHandleError(e, cur, 'errorCaptured hook');
                        }
                    }
                }
            }
        }
        globalHandleError(err, vm, info);
    }
    finally {
        popTarget();
    }
}
function invokeWithErrorHandling(handler, context, args, vm, info) {
    let res;
    try {
        res = args ? handler.apply(context, args) : handler.call(context);
        if (res && !res._isVue && isPromise(res) && !res._handled) {
            res.catch(e => handleError(e, vm, info + ` (Promise/async)`));
            res._handled = true;
        }
    }
    catch (e) {
        handleError(e, vm, info);
    }
    return res;
}
function globalHandleError(err, vm, info) {
    if (config.errorHandler) {
        try {
            return config.errorHandler.call(null, err, vm, info);
        }
        catch (e) {
            // if the user intentionally throws the original error in the handler,
            // do not log it twice
            if (e !== err) {
                logError(e, null, 'config.errorHandler');
            }
        }
    }
    logError(err, vm, info);
}
function logError(err, vm, info) {
    {
        warn$2(`Error in ${info}: "${err.toString()}"`, vm);
    }
    /* istanbul ignore else */
    if (inBrowser && typeof console !== 'undefined') {
        console.error(err);
    }
    else {
        throw err;
    }
}

/* globals MutationObserver */
let isUsingMicroTask = false;
const callbacks = [];
let pending = false;
function flushCallbacks() {
    pending = false;
    const copies = callbacks.slice(0);
    callbacks.length = 0;
    for (let i = 0; i < copies.length; i++) {
        copies[i]();
    }
}
// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
let timerFunc;
// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
    const p = Promise.resolve();
    timerFunc = () => {
        p.then(flushCallbacks);
        // In problematic UIWebViews, Promise.then doesn't completely break, but
        // it can get stuck in a weird state where callbacks are pushed into the
        // microtask queue but the queue isn't being flushed, until the browser
        // needs to do some other work, e.g. handle a timer. Therefore we can
        // "force" the microtask queue to be flushed by adding an empty timer.
        if (isIOS)
            setTimeout(noop);
    };
    isUsingMicroTask = true;
}
else if (!isIE &&
    typeof MutationObserver !== 'undefined' &&
    (isNative(MutationObserver) ||
        // PhantomJS and iOS 7.x
        MutationObserver.toString() === '[object MutationObserverConstructor]')) {
    // Use MutationObserver where native Promise is not available,
    // e.g. PhantomJS, iOS7, Android 4.4
    // (#6466 MutationObserver is unreliable in IE11)
    let counter = 1;
    const observer = new MutationObserver(flushCallbacks);
    const textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
        characterData: true
    });
    timerFunc = () => {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
    };
    isUsingMicroTask = true;
}
else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Technically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = () => {
        setImmediate(flushCallbacks);
    };
}
else {
    // Fallback to setTimeout.
    timerFunc = () => {
        setTimeout(flushCallbacks, 0);
    };
}
/**
 * @internal
 */
function nextTick(cb, ctx) {
    let _resolve;
    callbacks.push(() => {
        if (cb) {
            try {
                cb.call(ctx);
            }
            catch (e) {
                handleError(e, ctx, 'nextTick');
            }
        }
        else if (_resolve) {
            _resolve(ctx);
        }
    });
    if (!pending) {
        pending = true;
        timerFunc();
    }
    // $flow-disable-line
    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(resolve => {
            _resolve = resolve;
        });
    }
}

function useCssModule(name = '$style') {
    /* istanbul ignore else */
    {
        if (!currentInstance) {
            warn$2(`useCssModule must be called inside setup()`);
            return emptyObject;
        }
        const mod = currentInstance[name];
        if (!mod) {
            warn$2(`Current instance does not have CSS module named "${name}".`);
            return emptyObject;
        }
        return mod;
    }
}

/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */
function useCssVars(getter) {
    if (!inBrowser && !false)
        return;
    const instance = currentInstance;
    if (!instance) {
        warn$2(`useCssVars is called without current active component instance.`);
        return;
    }
    watchPostEffect(() => {
        const el = instance.$el;
        const vars = getter(instance, instance._setupProxy);
        if (el && el.nodeType === 1) {
            const style = el.style;
            for (const key in vars) {
                style.setProperty(`--${key}`, vars[key]);
            }
        }
    });
}

/**
 * v3-compatible async component API.
 * @internal the type is manually declared in <root>/types/v3-define-async-component.d.ts
 * because it relies on existing manual types
 */
function defineAsyncComponent(source) {
    if (isFunction(source)) {
        source = { loader: source };
    }
    const { loader, loadingComponent, errorComponent, delay = 200, timeout, // undefined = never times out
    suspensible = false, // in Vue 3 default is true
    onError: userOnError } = source;
    if (suspensible) {
        warn$2(`The suspensible option for async components is not supported in Vue2. It is ignored.`);
    }
    let pendingRequest = null;
    let retries = 0;
    const retry = () => {
        retries++;
        pendingRequest = null;
        return load();
    };
    const load = () => {
        let thisRequest;
        return (pendingRequest ||
            (thisRequest = pendingRequest =
                loader()
                    .catch(err => {
                    err = err instanceof Error ? err : new Error(String(err));
                    if (userOnError) {
                        return new Promise((resolve, reject) => {
                            const userRetry = () => resolve(retry());
                            const userFail = () => reject(err);
                            userOnError(err, userRetry, userFail, retries + 1);
                        });
                    }
                    else {
                        throw err;
                    }
                })
                    .then((comp) => {
                    if (thisRequest !== pendingRequest && pendingRequest) {
                        return pendingRequest;
                    }
                    if (!comp) {
                        warn$2(`Async component loader resolved to undefined. ` +
                            `If you are using retry(), make sure to return its return value.`);
                    }
                    // interop module default
                    if (comp &&
                        (comp.__esModule || comp[Symbol.toStringTag] === 'Module')) {
                        comp = comp.default;
                    }
                    if (comp && !isObject(comp) && !isFunction(comp)) {
                        throw new Error(`Invalid async component load result: ${comp}`);
                    }
                    return comp;
                })));
    };
    return () => {
        const component = load();
        return {
            component,
            delay,
            timeout,
            error: errorComponent,
            loading: loadingComponent
        };
    };
}

function createLifeCycle(hookName) {
    return (fn, target = currentInstance) => {
        if (!target) {
            warn$2(`${formatName(hookName)} is called when there is no active component instance to be ` +
                    `associated with. ` +
                    `Lifecycle injection APIs can only be used during execution of setup().`);
            return;
        }
        return injectHook(target, hookName, fn);
    };
}
function formatName(name) {
    if (name === 'beforeDestroy') {
        name = 'beforeUnmount';
    }
    else if (name === 'destroyed') {
        name = 'unmounted';
    }
    return `on${name[0].toUpperCase() + name.slice(1)}`;
}
function injectHook(instance, hookName, fn) {
    const options = instance.$options;
    options[hookName] = mergeLifecycleHook(options[hookName], fn);
}
const onBeforeMount = createLifeCycle('beforeMount');
const onMounted = createLifeCycle('mounted');
const onBeforeUpdate = createLifeCycle('beforeUpdate');
const onUpdated = createLifeCycle('updated');
const onBeforeUnmount = createLifeCycle('beforeDestroy');
const onUnmounted = createLifeCycle('destroyed');
const onActivated = createLifeCycle('activated');
const onDeactivated = createLifeCycle('deactivated');
const onServerPrefetch = createLifeCycle('serverPrefetch');
const onRenderTracked = createLifeCycle('renderTracked');
const onRenderTriggered = createLifeCycle('renderTriggered');
const injectErrorCapturedHook = createLifeCycle('errorCaptured');
function onErrorCaptured(hook, target = currentInstance) {
    injectErrorCapturedHook(hook, target);
}

/**
 * Note: also update dist/vue.runtime.mjs when adding new exports to this file.
 */
const version = '2.7.16';
/**
 * @internal type is manually declared in <root>/types/v3-define-component.d.ts
 */
function defineComponent(options) {
    return options;
}

var vca = /*#__PURE__*/Object.freeze({
  __proto__: null,
  version: version,
  defineComponent: defineComponent,
  ref: ref$1,
  shallowRef: shallowRef,
  isRef: isRef,
  toRef: toRef,
  toRefs: toRefs,
  unref: unref,
  proxyRefs: proxyRefs,
  customRef: customRef,
  triggerRef: triggerRef,
  reactive: reactive,
  isReactive: isReactive,
  isReadonly: isReadonly,
  isShallow: isShallow,
  isProxy: isProxy,
  shallowReactive: shallowReactive,
  markRaw: markRaw,
  toRaw: toRaw,
  readonly: readonly,
  shallowReadonly: shallowReadonly,
  computed: computed,
  watch: watch,
  watchEffect: watchEffect,
  watchPostEffect: watchPostEffect,
  watchSyncEffect: watchSyncEffect,
  EffectScope: EffectScope,
  effectScope: effectScope,
  onScopeDispose: onScopeDispose,
  getCurrentScope: getCurrentScope,
  provide: provide,
  inject: inject,
  h: h,
  getCurrentInstance: getCurrentInstance,
  useSlots: useSlots,
  useAttrs: useAttrs,
  useListeners: useListeners,
  mergeDefaults: mergeDefaults,
  nextTick: nextTick,
  set: set,
  del: del,
  useCssModule: useCssModule,
  useCssVars: useCssVars,
  defineAsyncComponent: defineAsyncComponent,
  onBeforeMount: onBeforeMount,
  onMounted: onMounted,
  onBeforeUpdate: onBeforeUpdate,
  onUpdated: onUpdated,
  onBeforeUnmount: onBeforeUnmount,
  onUnmounted: onUnmounted,
  onActivated: onActivated,
  onDeactivated: onDeactivated,
  onServerPrefetch: onServerPrefetch,
  onRenderTracked: onRenderTracked,
  onRenderTriggered: onRenderTriggered,
  onErrorCaptured: onErrorCaptured
});

const seenObjects = new _Set();
/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
    _traverse(val, seenObjects);
    seenObjects.clear();
    return val;
}
function _traverse(val, seen) {
    let i, keys;
    const isA = isArray(val);
    if ((!isA && !isObject(val)) ||
        val.__v_skip /* ReactiveFlags.SKIP */ ||
        Object.isFrozen(val) ||
        val instanceof VNode) {
        return;
    }
    if (val.__ob__) {
        const depId = val.__ob__.dep.id;
        if (seen.has(depId)) {
            return;
        }
        seen.add(depId);
    }
    if (isA) {
        i = val.length;
        while (i--)
            _traverse(val[i], seen);
    }
    else if (isRef(val)) {
        _traverse(val.value, seen);
    }
    else {
        keys = Object.keys(val);
        i = keys.length;
        while (i--)
            _traverse(val[keys[i]], seen);
    }
}

let uid$1 = 0;
/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 * @internal
 */
class Watcher {
    constructor(vm, expOrFn, cb, options, isRenderWatcher) {
        recordEffectScope(this, 
        // if the active effect scope is manually created (not a component scope),
        // prioritize it
        activeEffectScope && !activeEffectScope._vm
            ? activeEffectScope
            : vm
                ? vm._scope
                : undefined);
        if ((this.vm = vm) && isRenderWatcher) {
            vm._watcher = this;
        }
        // options
        if (options) {
            this.deep = !!options.deep;
            this.user = !!options.user;
            this.lazy = !!options.lazy;
            this.sync = !!options.sync;
            this.before = options.before;
            {
                this.onTrack = options.onTrack;
                this.onTrigger = options.onTrigger;
            }
        }
        else {
            this.deep = this.user = this.lazy = this.sync = false;
        }
        this.cb = cb;
        this.id = ++uid$1; // uid for batching
        this.active = true;
        this.post = false;
        this.dirty = this.lazy; // for lazy watchers
        this.deps = [];
        this.newDeps = [];
        this.depIds = new _Set();
        this.newDepIds = new _Set();
        this.expression = expOrFn.toString() ;
        // parse expression for getter
        if (isFunction(expOrFn)) {
            this.getter = expOrFn;
        }
        else {
            this.getter = parsePath(expOrFn);
            if (!this.getter) {
                this.getter = noop;
                warn$2(`Failed watching path: "${expOrFn}" ` +
                        'Watcher only accepts simple dot-delimited paths. ' +
                        'For full control, use a function instead.', vm);
            }
        }
        this.value = this.lazy ? undefined : this.get();
    }
    /**
     * Evaluate the getter, and re-collect dependencies.
     */
    get() {
        pushTarget(this);
        let value;
        const vm = this.vm;
        try {
            value = this.getter.call(vm, vm);
        }
        catch (e) {
            if (this.user) {
                handleError(e, vm, `getter for watcher "${this.expression}"`);
            }
            else {
                throw e;
            }
        }
        finally {
            // "touch" every property so they are all tracked as
            // dependencies for deep watching
            if (this.deep) {
                traverse(value);
            }
            popTarget();
            this.cleanupDeps();
        }
        return value;
    }
    /**
     * Add a dependency to this directive.
     */
    addDep(dep) {
        const id = dep.id;
        if (!this.newDepIds.has(id)) {
            this.newDepIds.add(id);
            this.newDeps.push(dep);
            if (!this.depIds.has(id)) {
                dep.addSub(this);
            }
        }
    }
    /**
     * Clean up for dependency collection.
     */
    cleanupDeps() {
        let i = this.deps.length;
        while (i--) {
            const dep = this.deps[i];
            if (!this.newDepIds.has(dep.id)) {
                dep.removeSub(this);
            }
        }
        let tmp = this.depIds;
        this.depIds = this.newDepIds;
        this.newDepIds = tmp;
        this.newDepIds.clear();
        tmp = this.deps;
        this.deps = this.newDeps;
        this.newDeps = tmp;
        this.newDeps.length = 0;
    }
    /**
     * Subscriber interface.
     * Will be called when a dependency changes.
     */
    update() {
        /* istanbul ignore else */
        if (this.lazy) {
            this.dirty = true;
        }
        else if (this.sync) {
            this.run();
        }
        else {
            queueWatcher(this);
        }
    }
    /**
     * Scheduler job interface.
     * Will be called by the scheduler.
     */
    run() {
        if (this.active) {
            const value = this.get();
            if (value !== this.value ||
                // Deep watchers and watchers on Object/Arrays should fire even
                // when the value is the same, because the value may
                // have mutated.
                isObject(value) ||
                this.deep) {
                // set new value
                const oldValue = this.value;
                this.value = value;
                if (this.user) {
                    const info = `callback for watcher "${this.expression}"`;
                    invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info);
                }
                else {
                    this.cb.call(this.vm, value, oldValue);
                }
            }
        }
    }
    /**
     * Evaluate the value of the watcher.
     * This only gets called for lazy watchers.
     */
    evaluate() {
        this.value = this.get();
        this.dirty = false;
    }
    /**
     * Depend on all deps collected by this watcher.
     */
    depend() {
        let i = this.deps.length;
        while (i--) {
            this.deps[i].depend();
        }
    }
    /**
     * Remove self from all dependencies' subscriber list.
     */
    teardown() {
        if (this.vm && !this.vm._isBeingDestroyed) {
            remove$2(this.vm._scope.effects, this);
        }
        if (this.active) {
            let i = this.deps.length;
            while (i--) {
                this.deps[i].removeSub(this);
            }
            this.active = false;
            if (this.onStop) {
                this.onStop();
            }
        }
    }
}

const sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: noop,
    set: noop
};
function proxy(target, sourceKey, key) {
    sharedPropertyDefinition.get = function proxyGetter() {
        return this[sourceKey][key];
    };
    sharedPropertyDefinition.set = function proxySetter(val) {
        this[sourceKey][key] = val;
    };
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function initState(vm) {
    const opts = vm.$options;
    if (opts.props)
        initProps$1(vm, opts.props);
    // Composition API
    initSetup(vm);
    if (opts.methods)
        initMethods(vm, opts.methods);
    if (opts.data) {
        initData(vm);
    }
    else {
        const ob = observe((vm._data = {}));
        ob && ob.vmCount++;
    }
    if (opts.computed)
        initComputed$1(vm, opts.computed);
    if (opts.watch && opts.watch !== nativeWatch) {
        initWatch(vm, opts.watch);
    }
}
function initProps$1(vm, propsOptions) {
    const propsData = vm.$options.propsData || {};
    const props = (vm._props = shallowReactive({}));
    // cache prop keys so that future props updates can iterate using Array
    // instead of dynamic object key enumeration.
    const keys = (vm.$options._propKeys = []);
    const isRoot = !vm.$parent;
    // root instance props should be converted
    if (!isRoot) {
        toggleObserving(false);
    }
    for (const key in propsOptions) {
        keys.push(key);
        const value = validateProp(key, propsOptions, propsData, vm);
        /* istanbul ignore else */
        {
            const hyphenatedKey = hyphenate(key);
            if (isReservedAttribute(hyphenatedKey) ||
                config.isReservedAttr(hyphenatedKey)) {
                warn$2(`"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`, vm);
            }
            defineReactive(props, key, value, () => {
                if (!isRoot && !isUpdatingChildComponent) {
                    warn$2(`Avoid mutating a prop directly since the value will be ` +
                        `overwritten whenever the parent component re-renders. ` +
                        `Instead, use a data or computed property based on the prop's ` +
                        `value. Prop being mutated: "${key}"`, vm);
                }
            }, true /* shallow */);
        }
        // static props are already proxied on the component's prototype
        // during Vue.extend(). We only need to proxy props defined at
        // instantiation here.
        if (!(key in vm)) {
            proxy(vm, `_props`, key);
        }
    }
    toggleObserving(true);
}
function initData(vm) {
    let data = vm.$options.data;
    data = vm._data = isFunction(data) ? getData(data, vm) : data || {};
    if (!isPlainObject(data)) {
        data = {};
        warn$2('data functions should return an object:\n' +
                'https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
    }
    // proxy data on instance
    const keys = Object.keys(data);
    const props = vm.$options.props;
    const methods = vm.$options.methods;
    let i = keys.length;
    while (i--) {
        const key = keys[i];
        {
            if (methods && hasOwn(methods, key)) {
                warn$2(`Method "${key}" has already been defined as a data property.`, vm);
            }
        }
        if (props && hasOwn(props, key)) {
            warn$2(`The data property "${key}" is already declared as a prop. ` +
                    `Use prop default value instead.`, vm);
        }
        else if (!isReserved(key)) {
            proxy(vm, `_data`, key);
        }
    }
    // observe data
    const ob = observe(data);
    ob && ob.vmCount++;
}
function getData(data, vm) {
    // #7573 disable dep collection when invoking data getters
    pushTarget();
    try {
        return data.call(vm, vm);
    }
    catch (e) {
        handleError(e, vm, `data()`);
        return {};
    }
    finally {
        popTarget();
    }
}
const computedWatcherOptions = { lazy: true };
function initComputed$1(vm, computed) {
    // $flow-disable-line
    const watchers = (vm._computedWatchers = Object.create(null));
    // computed properties are just getters during SSR
    const isSSR = isServerRendering();
    for (const key in computed) {
        const userDef = computed[key];
        const getter = isFunction(userDef) ? userDef : userDef.get;
        if (getter == null) {
            warn$2(`Getter is missing for computed property "${key}".`, vm);
        }
        if (!isSSR) {
            // create internal watcher for the computed property.
            watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
        }
        // component-defined computed properties are already defined on the
        // component prototype. We only need to define computed properties defined
        // at instantiation here.
        if (!(key in vm)) {
            defineComputed(vm, key, userDef);
        }
        else {
            if (key in vm.$data) {
                warn$2(`The computed property "${key}" is already defined in data.`, vm);
            }
            else if (vm.$options.props && key in vm.$options.props) {
                warn$2(`The computed property "${key}" is already defined as a prop.`, vm);
            }
            else if (vm.$options.methods && key in vm.$options.methods) {
                warn$2(`The computed property "${key}" is already defined as a method.`, vm);
            }
        }
    }
}
function defineComputed(target, key, userDef) {
    const shouldCache = !isServerRendering();
    if (isFunction(userDef)) {
        sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
        sharedPropertyDefinition.set = noop;
    }
    else {
        sharedPropertyDefinition.get = userDef.get
            ? shouldCache && userDef.cache !== false
                ? createComputedGetter(key)
                : createGetterInvoker(userDef.get)
            : noop;
        sharedPropertyDefinition.set = userDef.set || noop;
    }
    if (sharedPropertyDefinition.set === noop) {
        sharedPropertyDefinition.set = function () {
            warn$2(`Computed property "${key}" was assigned to but it has no setter.`, this);
        };
    }
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
function createComputedGetter(key) {
    return function computedGetter() {
        const watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
            if (watcher.dirty) {
                watcher.evaluate();
            }
            if (Dep.target) {
                if (Dep.target.onTrack) {
                    Dep.target.onTrack({
                        effect: Dep.target,
                        target: this,
                        type: "get" /* TrackOpTypes.GET */,
                        key
                    });
                }
                watcher.depend();
            }
            return watcher.value;
        }
    };
}
function createGetterInvoker(fn) {
    return function computedGetter() {
        return fn.call(this, this);
    };
}
function initMethods(vm, methods) {
    const props = vm.$options.props;
    for (const key in methods) {
        {
            if (typeof methods[key] !== 'function') {
                warn$2(`Method "${key}" has type "${typeof methods[key]}" in the component definition. ` +
                    `Did you reference the function correctly?`, vm);
            }
            if (props && hasOwn(props, key)) {
                warn$2(`Method "${key}" has already been defined as a prop.`, vm);
            }
            if (key in vm && isReserved(key)) {
                warn$2(`Method "${key}" conflicts with an existing Vue instance method. ` +
                    `Avoid defining component methods that start with _ or $.`);
            }
        }
        vm[key] = typeof methods[key] !== 'function' ? noop : bind$1(methods[key], vm);
    }
}
function initWatch(vm, watch) {
    for (const key in watch) {
        const handler = watch[key];
        if (isArray(handler)) {
            for (let i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i]);
            }
        }
        else {
            createWatcher(vm, key, handler);
        }
    }
}
function createWatcher(vm, expOrFn, handler, options) {
    if (isPlainObject(handler)) {
        options = handler;
        handler = handler.handler;
    }
    if (typeof handler === 'string') {
        handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options);
}
function stateMixin(Vue) {
    // flow somehow has problems with directly declared definition object
    // when using Object.defineProperty, so we have to procedurally build up
    // the object here.
    const dataDef = {};
    dataDef.get = function () {
        return this._data;
    };
    const propsDef = {};
    propsDef.get = function () {
        return this._props;
    };
    {
        dataDef.set = function () {
            warn$2('Avoid replacing instance root $data. ' +
                'Use nested data properties instead.', this);
        };
        propsDef.set = function () {
            warn$2(`$props is readonly.`, this);
        };
    }
    Object.defineProperty(Vue.prototype, '$data', dataDef);
    Object.defineProperty(Vue.prototype, '$props', propsDef);
    Vue.prototype.$set = set;
    Vue.prototype.$delete = del;
    Vue.prototype.$watch = function (expOrFn, cb, options) {
        const vm = this;
        if (isPlainObject(cb)) {
            return createWatcher(vm, expOrFn, cb, options);
        }
        options = options || {};
        options.user = true;
        const watcher = new Watcher(vm, expOrFn, cb, options);
        if (options.immediate) {
            const info = `callback for immediate watcher "${watcher.expression}"`;
            pushTarget();
            invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);
            popTarget();
        }
        return function unwatchFn() {
            watcher.teardown();
        };
    };
}

function initProvide(vm) {
    const provideOption = vm.$options.provide;
    if (provideOption) {
        const provided = isFunction(provideOption)
            ? provideOption.call(vm)
            : provideOption;
        if (!isObject(provided)) {
            return;
        }
        const source = resolveProvided(vm);
        // IE9 doesn't support Object.getOwnPropertyDescriptors so we have to
        // iterate the keys ourselves.
        const keys = hasSymbol ? Reflect.ownKeys(provided) : Object.keys(provided);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            Object.defineProperty(source, key, Object.getOwnPropertyDescriptor(provided, key));
        }
    }
}
function initInjections(vm) {
    const result = resolveInject(vm.$options.inject, vm);
    if (result) {
        toggleObserving(false);
        Object.keys(result).forEach(key => {
            /* istanbul ignore else */
            {
                defineReactive(vm, key, result[key], () => {
                    warn$2(`Avoid mutating an injected value directly since the changes will be ` +
                        `overwritten whenever the provided component re-renders. ` +
                        `injection being mutated: "${key}"`, vm);
                });
            }
        });
        toggleObserving(true);
    }
}
function resolveInject(inject, vm) {
    if (inject) {
        // inject is :any because flow is not smart enough to figure out cached
        const result = Object.create(null);
        const keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            // #6574 in case the inject object is observed...
            if (key === '__ob__')
                continue;
            const provideKey = inject[key].from;
            if (provideKey in vm._provided) {
                result[key] = vm._provided[provideKey];
            }
            else if ('default' in inject[key]) {
                const provideDefault = inject[key].default;
                result[key] = isFunction(provideDefault)
                    ? provideDefault.call(vm)
                    : provideDefault;
            }
            else {
                warn$2(`Injection "${key}" not found`, vm);
            }
        }
        return result;
    }
}

let uid = 0;
function initMixin$1(Vue) {
    Vue.prototype._init = function (options) {
        const vm = this;
        // a uid
        vm._uid = uid++;
        let startTag, endTag;
        /* istanbul ignore if */
        if (config.performance && mark) {
            startTag = `vue-perf-start:${vm._uid}`;
            endTag = `vue-perf-end:${vm._uid}`;
            mark(startTag);
        }
        // a flag to mark this as a Vue instance without having to do instanceof
        // check
        vm._isVue = true;
        // avoid instances from being observed
        vm.__v_skip = true;
        // effect scope
        vm._scope = new EffectScope(true /* detached */);
        // #13134 edge case where a child component is manually created during the
        // render of a parent component
        vm._scope.parent = undefined;
        vm._scope._vm = true;
        // merge options
        if (options && options._isComponent) {
            // optimize internal component instantiation
            // since dynamic options merging is pretty slow, and none of the
            // internal component options needs special treatment.
            initInternalComponent(vm, options);
        }
        else {
            vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
        }
        /* istanbul ignore else */
        {
            initProxy(vm);
        }
        // expose real self
        vm._self = vm;
        initLifecycle(vm);
        initEvents(vm);
        initRender(vm);
        callHook$1(vm, 'beforeCreate', undefined, false /* setContext */);
        initInjections(vm); // resolve injections before data/props
        initState(vm);
        initProvide(vm); // resolve provide after data/props
        callHook$1(vm, 'created');
        /* istanbul ignore if */
        if (config.performance && mark) {
            vm._name = formatComponentName(vm, false);
            mark(endTag);
            measure(`vue ${vm._name} init`, startTag, endTag);
        }
        if (vm.$options.el) {
            vm.$mount(vm.$options.el);
        }
    };
}
function initInternalComponent(vm, options) {
    const opts = (vm.$options = Object.create(vm.constructor.options));
    // doing this because it's faster than dynamic enumeration.
    const parentVnode = options._parentVnode;
    opts.parent = options.parent;
    opts._parentVnode = parentVnode;
    const vnodeComponentOptions = parentVnode.componentOptions;
    opts.propsData = vnodeComponentOptions.propsData;
    opts._parentListeners = vnodeComponentOptions.listeners;
    opts._renderChildren = vnodeComponentOptions.children;
    opts._componentTag = vnodeComponentOptions.tag;
    if (options.render) {
        opts.render = options.render;
        opts.staticRenderFns = options.staticRenderFns;
    }
}
function resolveConstructorOptions(Ctor) {
    let options = Ctor.options;
    if (Ctor.super) {
        const superOptions = resolveConstructorOptions(Ctor.super);
        const cachedSuperOptions = Ctor.superOptions;
        if (superOptions !== cachedSuperOptions) {
            // super option changed,
            // need to resolve new options.
            Ctor.superOptions = superOptions;
            // check if there are any late-modified/attached options (#4976)
            const modifiedOptions = resolveModifiedOptions(Ctor);
            // update base extend options
            if (modifiedOptions) {
                extend(Ctor.extendOptions, modifiedOptions);
            }
            options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
            if (options.name) {
                options.components[options.name] = Ctor;
            }
        }
    }
    return options;
}
function resolveModifiedOptions(Ctor) {
    let modified;
    const latest = Ctor.options;
    const sealed = Ctor.sealedOptions;
    for (const key in latest) {
        if (latest[key] !== sealed[key]) {
            if (!modified)
                modified = {};
            modified[key] = latest[key];
        }
    }
    return modified;
}

function FunctionalRenderContext(data, props, children, parent, Ctor) {
    const options = Ctor.options;
    // ensure the createElement function in functional components
    // gets a unique context - this is necessary for correct named slot check
    let contextVm;
    if (hasOwn(parent, '_uid')) {
        contextVm = Object.create(parent);
        contextVm._original = parent;
    }
    else {
        // the context vm passed in is a functional context as well.
        // in this case we want to make sure we are able to get a hold to the
        // real context instance.
        contextVm = parent;
        // @ts-ignore
        parent = parent._original;
    }
    const isCompiled = isTrue(options._compiled);
    const needNormalization = !isCompiled;
    this.data = data;
    this.props = props;
    this.children = children;
    this.parent = parent;
    this.listeners = data.on || emptyObject;
    this.injections = resolveInject(options.inject, parent);
    this.slots = () => {
        if (!this.$slots) {
            normalizeScopedSlots(parent, data.scopedSlots, (this.$slots = resolveSlots(children, parent)));
        }
        return this.$slots;
    };
    Object.defineProperty(this, 'scopedSlots', {
        enumerable: true,
        get() {
            return normalizeScopedSlots(parent, data.scopedSlots, this.slots());
        }
    });
    // support for compiled functional template
    if (isCompiled) {
        // exposing $options for renderStatic()
        this.$options = options;
        // pre-resolve slots for renderSlot()
        this.$slots = this.slots();
        this.$scopedSlots = normalizeScopedSlots(parent, data.scopedSlots, this.$slots);
    }
    if (options._scopeId) {
        this._c = (a, b, c, d) => {
            const vnode = createElement$1(contextVm, a, b, c, d, needNormalization);
            if (vnode && !isArray(vnode)) {
                vnode.fnScopeId = options._scopeId;
                vnode.fnContext = parent;
            }
            return vnode;
        };
    }
    else {
        this._c = (a, b, c, d) => createElement$1(contextVm, a, b, c, d, needNormalization);
    }
}
installRenderHelpers(FunctionalRenderContext.prototype);
function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
    const options = Ctor.options;
    const props = {};
    const propOptions = options.props;
    if (isDef(propOptions)) {
        for (const key in propOptions) {
            props[key] = validateProp(key, propOptions, propsData || emptyObject);
        }
    }
    else {
        if (isDef(data.attrs))
            mergeProps(props, data.attrs);
        if (isDef(data.props))
            mergeProps(props, data.props);
    }
    const renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);
    const vnode = options.render.call(null, renderContext._c, renderContext);
    if (vnode instanceof VNode) {
        return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext);
    }
    else if (isArray(vnode)) {
        const vnodes = normalizeChildren(vnode) || [];
        const res = new Array(vnodes.length);
        for (let i = 0; i < vnodes.length; i++) {
            res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
        }
        return res;
    }
}
function cloneAndMarkFunctionalResult(vnode, data, contextVm, options, renderContext) {
    // #7817 clone node before setting fnContext, otherwise if the node is reused
    // (e.g. it was from a cached normal slot) the fnContext causes named slots
    // that should not be matched to match.
    const clone = cloneVNode(vnode);
    clone.fnContext = contextVm;
    clone.fnOptions = options;
    {
        (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext =
            renderContext;
    }
    if (data.slot) {
        (clone.data || (clone.data = {})).slot = data.slot;
    }
    return clone;
}
function mergeProps(to, from) {
    for (const key in from) {
        to[camelize(key)] = from[key];
    }
}

function getComponentName(options) {
    return options.name || options.__name || options._componentTag;
}
// inline hooks to be invoked on component VNodes during patch
const componentVNodeHooks = {
    init(vnode, hydrating) {
        if (vnode.componentInstance &&
            !vnode.componentInstance._isDestroyed &&
            vnode.data.keepAlive) {
            // kept-alive components, treat as a patch
            const mountedNode = vnode; // work around flow
            componentVNodeHooks.prepatch(mountedNode, mountedNode);
        }
        else {
            const child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));
            child.$mount(hydrating ? vnode.elm : undefined, hydrating);
        }
    },
    prepatch(oldVnode, vnode) {
        const options = vnode.componentOptions;
        const child = (vnode.componentInstance = oldVnode.componentInstance);
        updateChildComponent(child, options.propsData, // updated props
        options.listeners, // updated listeners
        vnode, // new parent vnode
        options.children // new children
        );
    },
    insert(vnode) {
        const { context, componentInstance } = vnode;
        if (!componentInstance._isMounted) {
            componentInstance._isMounted = true;
            callHook$1(componentInstance, 'mounted');
        }
        if (vnode.data.keepAlive) {
            if (context._isMounted) {
                // vue-router#1212
                // During updates, a kept-alive component's child components may
                // change, so directly walking the tree here may call activated hooks
                // on incorrect children. Instead we push them into a queue which will
                // be processed after the whole patch process ended.
                queueActivatedComponent(componentInstance);
            }
            else {
                activateChildComponent(componentInstance, true /* direct */);
            }
        }
    },
    destroy(vnode) {
        const { componentInstance } = vnode;
        if (!componentInstance._isDestroyed) {
            if (!vnode.data.keepAlive) {
                componentInstance.$destroy();
            }
            else {
                deactivateChildComponent(componentInstance, true /* direct */);
            }
        }
    }
};
const hooksToMerge = Object.keys(componentVNodeHooks);
function createComponent(Ctor, data, context, children, tag) {
    if (isUndef(Ctor)) {
        return;
    }
    const baseCtor = context.$options._base;
    // plain options object: turn it into a constructor
    if (isObject(Ctor)) {
        Ctor = baseCtor.extend(Ctor);
    }
    // if at this stage it's not a constructor or an async component factory,
    // reject.
    if (typeof Ctor !== 'function') {
        {
            warn$2(`Invalid Component definition: ${String(Ctor)}`, context);
        }
        return;
    }
    // async component
    let asyncFactory;
    // @ts-expect-error
    if (isUndef(Ctor.cid)) {
        asyncFactory = Ctor;
        Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
        if (Ctor === undefined) {
            // return a placeholder node for async component, which is rendered
            // as a comment node but preserves all the raw information for the node.
            // the information will be used for async server-rendering and hydration.
            return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
        }
    }
    data = data || {};
    // resolve constructor options in case global mixins are applied after
    // component constructor creation
    resolveConstructorOptions(Ctor);
    // transform component v-model data into props & events
    if (isDef(data.model)) {
        // @ts-expect-error
        transformModel(Ctor.options, data);
    }
    // extract props
    // @ts-expect-error
    const propsData = extractPropsFromVNodeData(data, Ctor, tag);
    // functional component
    // @ts-expect-error
    if (isTrue(Ctor.options.functional)) {
        return createFunctionalComponent(Ctor, propsData, data, context, children);
    }
    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    const listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;
    // @ts-expect-error
    if (isTrue(Ctor.options.abstract)) {
        // abstract components do not keep anything
        // other than props & listeners & slot
        // work around flow
        const slot = data.slot;
        data = {};
        if (slot) {
            data.slot = slot;
        }
    }
    // install component management hooks onto the placeholder node
    installComponentHooks(data);
    // return a placeholder vnode
    // @ts-expect-error
    const name = getComponentName(Ctor.options) || tag;
    const vnode = new VNode(
    // @ts-expect-error
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`, data, undefined, undefined, undefined, context, 
    // @ts-expect-error
    { Ctor, propsData, listeners, tag, children }, asyncFactory);
    return vnode;
}
function createComponentInstanceForVnode(
// we know it's MountedComponentVNode but flow doesn't
vnode, 
// activeInstance in lifecycle state
parent) {
    const options = {
        _isComponent: true,
        _parentVnode: vnode,
        parent
    };
    // check inline-template render functions
    const inlineTemplate = vnode.data.inlineTemplate;
    if (isDef(inlineTemplate)) {
        options.render = inlineTemplate.render;
        options.staticRenderFns = inlineTemplate.staticRenderFns;
    }
    return new vnode.componentOptions.Ctor(options);
}
function installComponentHooks(data) {
    const hooks = data.hook || (data.hook = {});
    for (let i = 0; i < hooksToMerge.length; i++) {
        const key = hooksToMerge[i];
        const existing = hooks[key];
        const toMerge = componentVNodeHooks[key];
        // @ts-expect-error
        if (existing !== toMerge && !(existing && existing._merged)) {
            hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge;
        }
    }
}
function mergeHook(f1, f2) {
    const merged = (a, b) => {
        // flow complains about extra args which is why we use any
        f1(a, b);
        f2(a, b);
    };
    merged._merged = true;
    return merged;
}
// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
    const prop = (options.model && options.model.prop) || 'value';
    const event = (options.model && options.model.event) || 'input';
    (data.attrs || (data.attrs = {}))[prop] = data.model.value;
    const on = data.on || (data.on = {});
    const existing = on[event];
    const callback = data.model.callback;
    if (isDef(existing)) {
        if (isArray(existing)
            ? existing.indexOf(callback) === -1
            : existing !== callback) {
            on[event] = [callback].concat(existing);
        }
    }
    else {
        on[event] = callback;
    }
}

let warn$2 = noop;
let tip = noop;
let generateComponentTrace; // work around flow check
let formatComponentName;
{
    const hasConsole = typeof console !== 'undefined';
    const classifyRE = /(?:^|[-_])(\w)/g;
    const classify = str => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');
    warn$2 = (msg, vm = currentInstance) => {
        const trace = vm ? generateComponentTrace(vm) : '';
        if (config.warnHandler) {
            config.warnHandler.call(null, msg, vm, trace);
        }
        else if (hasConsole && !config.silent) {
            console.error(`[Vue warn]: ${msg}${trace}`);
        }
    };
    tip = (msg, vm) => {
        if (hasConsole && !config.silent) {
            console.warn(`[Vue tip]: ${msg}` + (vm ? generateComponentTrace(vm) : ''));
        }
    };
    formatComponentName = (vm, includeFile) => {
        if (vm.$root === vm) {
            return '<Root>';
        }
        const options = isFunction(vm) && vm.cid != null
            ? vm.options
            : vm._isVue
                ? vm.$options || vm.constructor.options
                : vm;
        let name = getComponentName(options);
        const file = options.__file;
        if (!name && file) {
            const match = file.match(/([^/\\]+)\.vue$/);
            name = match && match[1];
        }
        return ((name ? `<${classify(name)}>` : `<Anonymous>`) +
            (file && includeFile !== false ? ` at ${file}` : ''));
    };
    const repeat = (str, n) => {
        let res = '';
        while (n) {
            if (n % 2 === 1)
                res += str;
            if (n > 1)
                str += str;
            n >>= 1;
        }
        return res;
    };
    generateComponentTrace = (vm) => {
        if (vm._isVue && vm.$parent) {
            const tree = [];
            let currentRecursiveSequence = 0;
            while (vm) {
                if (tree.length > 0) {
                    const last = tree[tree.length - 1];
                    if (last.constructor === vm.constructor) {
                        currentRecursiveSequence++;
                        vm = vm.$parent;
                        continue;
                    }
                    else if (currentRecursiveSequence > 0) {
                        tree[tree.length - 1] = [last, currentRecursiveSequence];
                        currentRecursiveSequence = 0;
                    }
                }
                tree.push(vm);
                vm = vm.$parent;
            }
            return ('\n\nfound in\n\n' +
                tree
                    .map((vm, i) => `${i === 0 ? '---> ' : repeat(' ', 5 + i * 2)}${isArray(vm)
                    ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`
                    : formatComponentName(vm)}`)
                    .join('\n'));
        }
        else {
            return `\n\n(found in ${formatComponentName(vm)})`;
        }
    };
}

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
const strats = config.optionMergeStrategies;
/**
 * Options with restrictions
 */
{
    strats.el = strats.propsData = function (parent, child, vm, key) {
        if (!vm) {
            warn$2(`option "${key}" can only be used during instance ` +
                'creation with the `new` keyword.');
        }
        return defaultStrat(parent, child);
    };
}
/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from, recursive = true) {
    if (!from)
        return to;
    let key, toVal, fromVal;
    const keys = hasSymbol
        ? Reflect.ownKeys(from)
        : Object.keys(from);
    for (let i = 0; i < keys.length; i++) {
        key = keys[i];
        // in case the object is already observed...
        if (key === '__ob__')
            continue;
        toVal = to[key];
        fromVal = from[key];
        if (!recursive || !hasOwn(to, key)) {
            set(to, key, fromVal);
        }
        else if (toVal !== fromVal &&
            isPlainObject(toVal) &&
            isPlainObject(fromVal)) {
            mergeData(toVal, fromVal);
        }
    }
    return to;
}
/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
    if (!vm) {
        // in a Vue.extend merge, both should be functions
        if (!childVal) {
            return parentVal;
        }
        if (!parentVal) {
            return childVal;
        }
        // when parentVal & childVal are both present,
        // we need to return a function that returns the
        // merged result of both functions... no need to
        // check if parentVal is a function here because
        // it has to be a function to pass previous merges.
        return function mergedDataFn() {
            return mergeData(isFunction(childVal) ? childVal.call(this, this) : childVal, isFunction(parentVal) ? parentVal.call(this, this) : parentVal);
        };
    }
    else {
        return function mergedInstanceDataFn() {
            // instance merge
            const instanceData = isFunction(childVal)
                ? childVal.call(vm, vm)
                : childVal;
            const defaultData = isFunction(parentVal)
                ? parentVal.call(vm, vm)
                : parentVal;
            if (instanceData) {
                return mergeData(instanceData, defaultData);
            }
            else {
                return defaultData;
            }
        };
    }
}
strats.data = function (parentVal, childVal, vm) {
    if (!vm) {
        if (childVal && typeof childVal !== 'function') {
            warn$2('The "data" option should be a function ' +
                    'that returns a per-instance value in component ' +
                    'definitions.', vm);
            return parentVal;
        }
        return mergeDataOrFn(parentVal, childVal);
    }
    return mergeDataOrFn(parentVal, childVal, vm);
};
/**
 * Hooks and props are merged as arrays.
 */
function mergeLifecycleHook(parentVal, childVal) {
    const res = childVal
        ? parentVal
            ? parentVal.concat(childVal)
            : isArray(childVal)
                ? childVal
                : [childVal]
        : parentVal;
    return res ? dedupeHooks(res) : res;
}
function dedupeHooks(hooks) {
    const res = [];
    for (let i = 0; i < hooks.length; i++) {
        if (res.indexOf(hooks[i]) === -1) {
            res.push(hooks[i]);
        }
    }
    return res;
}
LIFECYCLE_HOOKS.forEach(hook => {
    strats[hook] = mergeLifecycleHook;
});
/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
    const res = Object.create(parentVal || null);
    if (childVal) {
        assertObjectType(key, childVal, vm);
        return extend(res, childVal);
    }
    else {
        return res;
    }
}
ASSET_TYPES.forEach(function (type) {
    strats[type + 's'] = mergeAssets;
});
/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
    // work around Firefox's Object.prototype.watch...
    //@ts-expect-error work around
    if (parentVal === nativeWatch)
        parentVal = undefined;
    //@ts-expect-error work around
    if (childVal === nativeWatch)
        childVal = undefined;
    /* istanbul ignore if */
    if (!childVal)
        return Object.create(parentVal || null);
    {
        assertObjectType(key, childVal, vm);
    }
    if (!parentVal)
        return childVal;
    const ret = {};
    extend(ret, parentVal);
    for (const key in childVal) {
        let parent = ret[key];
        const child = childVal[key];
        if (parent && !isArray(parent)) {
            parent = [parent];
        }
        ret[key] = parent ? parent.concat(child) : isArray(child) ? child : [child];
    }
    return ret;
};
/**
 * Other object hashes.
 */
strats.props =
    strats.methods =
        strats.inject =
            strats.computed =
                function (parentVal, childVal, vm, key) {
                    if (childVal && true) {
                        assertObjectType(key, childVal, vm);
                    }
                    if (!parentVal)
                        return childVal;
                    const ret = Object.create(null);
                    extend(ret, parentVal);
                    if (childVal)
                        extend(ret, childVal);
                    return ret;
                };
strats.provide = function (parentVal, childVal) {
    if (!parentVal)
        return childVal;
    return function () {
        const ret = Object.create(null);
        mergeData(ret, isFunction(parentVal) ? parentVal.call(this) : parentVal);
        if (childVal) {
            mergeData(ret, isFunction(childVal) ? childVal.call(this) : childVal, false // non-recursive
            );
        }
        return ret;
    };
};
/**
 * Default strategy.
 */
const defaultStrat = function (parentVal, childVal) {
    return childVal === undefined ? parentVal : childVal;
};
/**
 * Validate component names
 */
function checkComponents(options) {
    for (const key in options.components) {
        validateComponentName(key);
    }
}
function validateComponentName(name) {
    if (!new RegExp(`^[a-zA-Z][\\-\\.0-9_${unicodeRegExp.source}]*$`).test(name)) {
        warn$2('Invalid component name: "' +
            name +
            '". Component names ' +
            'should conform to valid custom element name in html5 specification.');
    }
    if (isBuiltInTag(name) || config.isReservedTag(name)) {
        warn$2('Do not use built-in or reserved HTML elements as component ' +
            'id: ' +
            name);
    }
}
/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
    const props = options.props;
    if (!props)
        return;
    const res = {};
    let i, val, name;
    if (isArray(props)) {
        i = props.length;
        while (i--) {
            val = props[i];
            if (typeof val === 'string') {
                name = camelize(val);
                res[name] = { type: null };
            }
            else {
                warn$2('props must be strings when using array syntax.');
            }
        }
    }
    else if (isPlainObject(props)) {
        for (const key in props) {
            val = props[key];
            name = camelize(key);
            res[name] = isPlainObject(val) ? val : { type: val };
        }
    }
    else {
        warn$2(`Invalid value for option "props": expected an Array or an Object, ` +
            `but got ${toRawType(props)}.`, vm);
    }
    options.props = res;
}
/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
    const inject = options.inject;
    if (!inject)
        return;
    const normalized = (options.inject = {});
    if (isArray(inject)) {
        for (let i = 0; i < inject.length; i++) {
            normalized[inject[i]] = { from: inject[i] };
        }
    }
    else if (isPlainObject(inject)) {
        for (const key in inject) {
            const val = inject[key];
            normalized[key] = isPlainObject(val)
                ? extend({ from: key }, val)
                : { from: val };
        }
    }
    else {
        warn$2(`Invalid value for option "inject": expected an Array or an Object, ` +
            `but got ${toRawType(inject)}.`, vm);
    }
}
/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives$1(options) {
    const dirs = options.directives;
    if (dirs) {
        for (const key in dirs) {
            const def = dirs[key];
            if (isFunction(def)) {
                dirs[key] = { bind: def, update: def };
            }
        }
    }
}
function assertObjectType(name, value, vm) {
    if (!isPlainObject(value)) {
        warn$2(`Invalid value for option "${name}": expected an Object, ` +
            `but got ${toRawType(value)}.`, vm);
    }
}
/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
    {
        checkComponents(child);
    }
    if (isFunction(child)) {
        // @ts-expect-error
        child = child.options;
    }
    normalizeProps(child, vm);
    normalizeInject(child, vm);
    normalizeDirectives$1(child);
    // Apply extends and mixins on the child options,
    // but only if it is a raw options object that isn't
    // the result of another mergeOptions call.
    // Only merged options has the _base property.
    if (!child._base) {
        if (child.extends) {
            parent = mergeOptions(parent, child.extends, vm);
        }
        if (child.mixins) {
            for (let i = 0, l = child.mixins.length; i < l; i++) {
                parent = mergeOptions(parent, child.mixins[i], vm);
            }
        }
    }
    const options = {};
    let key;
    for (key in parent) {
        mergeField(key);
    }
    for (key in child) {
        if (!hasOwn(parent, key)) {
            mergeField(key);
        }
    }
    function mergeField(key) {
        const strat = strats[key] || defaultStrat;
        options[key] = strat(parent[key], child[key], vm, key);
    }
    return options;
}
/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
    /* istanbul ignore if */
    if (typeof id !== 'string') {
        return;
    }
    const assets = options[type];
    // check local registration variations first
    if (hasOwn(assets, id))
        return assets[id];
    const camelizedId = camelize(id);
    if (hasOwn(assets, camelizedId))
        return assets[camelizedId];
    const PascalCaseId = capitalize(camelizedId);
    if (hasOwn(assets, PascalCaseId))
        return assets[PascalCaseId];
    // fallback to prototype chain
    const res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
    if (warnMissing && !res) {
        warn$2('Failed to resolve ' + type.slice(0, -1) + ': ' + id);
    }
    return res;
}

function validateProp(key, propOptions, propsData, vm) {
    const prop = propOptions[key];
    const absent = !hasOwn(propsData, key);
    let value = propsData[key];
    // boolean casting
    const booleanIndex = getTypeIndex(Boolean, prop.type);
    if (booleanIndex > -1) {
        if (absent && !hasOwn(prop, 'default')) {
            value = false;
        }
        else if (value === '' || value === hyphenate(key)) {
            // only cast empty string / same name to boolean if
            // boolean has higher priority
            const stringIndex = getTypeIndex(String, prop.type);
            if (stringIndex < 0 || booleanIndex < stringIndex) {
                value = true;
            }
        }
    }
    // check default value
    if (value === undefined) {
        value = getPropDefaultValue(vm, prop, key);
        // since the default value is a fresh copy,
        // make sure to observe it.
        const prevShouldObserve = shouldObserve;
        toggleObserving(true);
        observe(value);
        toggleObserving(prevShouldObserve);
    }
    {
        assertProp(prop, key, value, vm, absent);
    }
    return value;
}
/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
    // no default, return undefined
    if (!hasOwn(prop, 'default')) {
        return undefined;
    }
    const def = prop.default;
    // warn against non-factory defaults for Object & Array
    if (isObject(def)) {
        warn$2('Invalid default value for prop "' +
            key +
            '": ' +
            'Props with type Object/Array must use a factory function ' +
            'to return the default value.', vm);
    }
    // the raw prop value was also undefined from previous render,
    // return previous default value to avoid unnecessary watcher trigger
    if (vm &&
        vm.$options.propsData &&
        vm.$options.propsData[key] === undefined &&
        vm._props[key] !== undefined) {
        return vm._props[key];
    }
    // call factory function for non-Function types
    // a value is Function if its prototype is function even across different execution context
    return isFunction(def) && getType(prop.type) !== 'Function'
        ? def.call(vm)
        : def;
}
/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
    if (prop.required && absent) {
        warn$2('Missing required prop: "' + name + '"', vm);
        return;
    }
    if (value == null && !prop.required) {
        return;
    }
    let type = prop.type;
    let valid = !type || type === true;
    const expectedTypes = [];
    if (type) {
        if (!isArray(type)) {
            type = [type];
        }
        for (let i = 0; i < type.length && !valid; i++) {
            const assertedType = assertType(value, type[i], vm);
            expectedTypes.push(assertedType.expectedType || '');
            valid = assertedType.valid;
        }
    }
    const haveExpectedTypes = expectedTypes.some(t => t);
    if (!valid && haveExpectedTypes) {
        warn$2(getInvalidTypeMessage(name, value, expectedTypes), vm);
        return;
    }
    const validator = prop.validator;
    if (validator) {
        if (!validator(value)) {
            warn$2('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
        }
    }
}
const simpleCheckRE = /^(String|Number|Boolean|Function|Symbol|BigInt)$/;
function assertType(value, type, vm) {
    let valid;
    const expectedType = getType(type);
    if (simpleCheckRE.test(expectedType)) {
        const t = typeof value;
        valid = t === expectedType.toLowerCase();
        // for primitive wrapper objects
        if (!valid && t === 'object') {
            valid = value instanceof type;
        }
    }
    else if (expectedType === 'Object') {
        valid = isPlainObject(value);
    }
    else if (expectedType === 'Array') {
        valid = isArray(value);
    }
    else {
        try {
            valid = value instanceof type;
        }
        catch (e) {
            warn$2('Invalid prop type: "' + String(type) + '" is not a constructor', vm);
            valid = false;
        }
    }
    return {
        valid,
        expectedType
    };
}
const functionTypeCheckRE = /^\s*function (\w+)/;
/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
    const match = fn && fn.toString().match(functionTypeCheckRE);
    return match ? match[1] : '';
}
function isSameType(a, b) {
    return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
    if (!isArray(expectedTypes)) {
        return isSameType(expectedTypes, type) ? 0 : -1;
    }
    for (let i = 0, len = expectedTypes.length; i < len; i++) {
        if (isSameType(expectedTypes[i], type)) {
            return i;
        }
    }
    return -1;
}
function getInvalidTypeMessage(name, value, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}".` +
        ` Expected ${expectedTypes.map(capitalize).join(', ')}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value);
    // check if we need to specify expected value
    if (expectedTypes.length === 1 &&
        isExplicable(expectedType) &&
        isExplicable(typeof value) &&
        !isBoolean(expectedType, receivedType)) {
        message += ` with value ${styleValue(value, expectedType)}`;
    }
    message += `, got ${receivedType} `;
    // check if we need to specify received value
    if (isExplicable(receivedType)) {
        message += `with value ${styleValue(value, receivedType)}.`;
    }
    return message;
}
function styleValue(value, type) {
    if (type === 'String') {
        return `"${value}"`;
    }
    else if (type === 'Number') {
        return `${Number(value)}`;
    }
    else {
        return `${value}`;
    }
}
const EXPLICABLE_TYPES = ['string', 'number', 'boolean'];
function isExplicable(value) {
    return EXPLICABLE_TYPES.some(elem => value.toLowerCase() === elem);
}
function isBoolean(...args) {
    return args.some(elem => elem.toLowerCase() === 'boolean');
}

function Vue(options) {
    if (!(this instanceof Vue)) {
        warn$2('Vue is a constructor and should be called with the `new` keyword');
    }
    this._init(options);
}
//@ts-expect-error Vue has function type
initMixin$1(Vue);
//@ts-expect-error Vue has function type
stateMixin(Vue);
//@ts-expect-error Vue has function type
eventsMixin(Vue);
//@ts-expect-error Vue has function type
lifecycleMixin(Vue);
//@ts-expect-error Vue has function type
renderMixin(Vue);

function initUse(Vue) {
    Vue.use = function (plugin) {
        const installedPlugins = this._installedPlugins || (this._installedPlugins = []);
        if (installedPlugins.indexOf(plugin) > -1) {
            return this;
        }
        // additional parameters
        const args = toArray(arguments, 1);
        args.unshift(this);
        if (isFunction(plugin.install)) {
            plugin.install.apply(plugin, args);
        }
        else if (isFunction(plugin)) {
            plugin.apply(null, args);
        }
        installedPlugins.push(plugin);
        return this;
    };
}

function initMixin(Vue) {
    Vue.mixin = function (mixin) {
        this.options = mergeOptions(this.options, mixin);
        return this;
    };
}

function initExtend(Vue) {
    /**
     * Each instance constructor, including Vue, has a unique
     * cid. This enables us to create wrapped "child
     * constructors" for prototypal inheritance and cache them.
     */
    Vue.cid = 0;
    let cid = 1;
    /**
     * Class inheritance
     */
    Vue.extend = function (extendOptions) {
        extendOptions = extendOptions || {};
        const Super = this;
        const SuperId = Super.cid;
        const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
        if (cachedCtors[SuperId]) {
            return cachedCtors[SuperId];
        }
        const name = getComponentName(extendOptions) || getComponentName(Super.options);
        if (name) {
            validateComponentName(name);
        }
        const Sub = function VueComponent(options) {
            this._init(options);
        };
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(Super.options, extendOptions);
        Sub['super'] = Super;
        // For props and computed properties, we define the proxy getters on
        // the Vue instances at extension time, on the extended prototype. This
        // avoids Object.defineProperty calls for each instance created.
        if (Sub.options.props) {
            initProps(Sub);
        }
        if (Sub.options.computed) {
            initComputed(Sub);
        }
        // allow further extension/mixin/plugin usage
        Sub.extend = Super.extend;
        Sub.mixin = Super.mixin;
        Sub.use = Super.use;
        // create asset registers, so extended classes
        // can have their private assets too.
        ASSET_TYPES.forEach(function (type) {
            Sub[type] = Super[type];
        });
        // enable recursive self-lookup
        if (name) {
            Sub.options.components[name] = Sub;
        }
        // keep a reference to the super options at extension time.
        // later at instantiation we can check if Super's options have
        // been updated.
        Sub.superOptions = Super.options;
        Sub.extendOptions = extendOptions;
        Sub.sealedOptions = extend({}, Sub.options);
        // cache constructor
        cachedCtors[SuperId] = Sub;
        return Sub;
    };
}
function initProps(Comp) {
    const props = Comp.options.props;
    for (const key in props) {
        proxy(Comp.prototype, `_props`, key);
    }
}
function initComputed(Comp) {
    const computed = Comp.options.computed;
    for (const key in computed) {
        defineComputed(Comp.prototype, key, computed[key]);
    }
}

function initAssetRegisters(Vue) {
    /**
     * Create asset registration methods.
     */
    ASSET_TYPES.forEach(type => {
        // @ts-expect-error function is not exact same type
        Vue[type] = function (id, definition) {
            if (!definition) {
                return this.options[type + 's'][id];
            }
            else {
                /* istanbul ignore if */
                if (type === 'component') {
                    validateComponentName(id);
                }
                if (type === 'component' && isPlainObject(definition)) {
                    // @ts-expect-error
                    definition.name = definition.name || id;
                    definition = this.options._base.extend(definition);
                }
                if (type === 'directive' && isFunction(definition)) {
                    definition = { bind: definition, update: definition };
                }
                this.options[type + 's'][id] = definition;
                return definition;
            }
        };
    });
}

function _getComponentName(opts) {
    return opts && (getComponentName(opts.Ctor.options) || opts.tag);
}
function matches(pattern, name) {
    if (isArray(pattern)) {
        return pattern.indexOf(name) > -1;
    }
    else if (typeof pattern === 'string') {
        return pattern.split(',').indexOf(name) > -1;
    }
    else if (isRegExp(pattern)) {
        return pattern.test(name);
    }
    /* istanbul ignore next */
    return false;
}
function pruneCache(keepAliveInstance, filter) {
    const { cache, keys, _vnode, $vnode } = keepAliveInstance;
    for (const key in cache) {
        const entry = cache[key];
        if (entry) {
            const name = entry.name;
            if (name && !filter(name)) {
                pruneCacheEntry(cache, key, keys, _vnode);
            }
        }
    }
    $vnode.componentOptions.children = undefined;
}
function pruneCacheEntry(cache, key, keys, current) {
    const entry = cache[key];
    if (entry && (!current || entry.tag !== current.tag)) {
        // @ts-expect-error can be undefined
        entry.componentInstance.$destroy();
    }
    cache[key] = null;
    remove$2(keys, key);
}
const patternTypes = [String, RegExp, Array];
// TODO defineComponent
var KeepAlive = {
    name: 'keep-alive',
    abstract: true,
    props: {
        include: patternTypes,
        exclude: patternTypes,
        max: [String, Number]
    },
    methods: {
        cacheVNode() {
            const { cache, keys, vnodeToCache, keyToCache } = this;
            if (vnodeToCache) {
                const { tag, componentInstance, componentOptions } = vnodeToCache;
                cache[keyToCache] = {
                    name: _getComponentName(componentOptions),
                    tag,
                    componentInstance
                };
                keys.push(keyToCache);
                // prune oldest entry
                if (this.max && keys.length > parseInt(this.max)) {
                    pruneCacheEntry(cache, keys[0], keys, this._vnode);
                }
                this.vnodeToCache = null;
            }
        }
    },
    created() {
        this.cache = Object.create(null);
        this.keys = [];
    },
    destroyed() {
        for (const key in this.cache) {
            pruneCacheEntry(this.cache, key, this.keys);
        }
    },
    mounted() {
        this.cacheVNode();
        this.$watch('include', val => {
            pruneCache(this, name => matches(val, name));
        });
        this.$watch('exclude', val => {
            pruneCache(this, name => !matches(val, name));
        });
    },
    updated() {
        this.cacheVNode();
    },
    render() {
        const slot = this.$slots.default;
        const vnode = getFirstComponentChild(slot);
        const componentOptions = vnode && vnode.componentOptions;
        if (componentOptions) {
            // check pattern
            const name = _getComponentName(componentOptions);
            const { include, exclude } = this;
            if (
            // not included
            (include && (!name || !matches(include, name))) ||
                // excluded
                (exclude && name && matches(exclude, name))) {
                return vnode;
            }
            const { cache, keys } = this;
            const key = vnode.key == null
                ? // same constructor may get registered as different local components
                    // so cid alone is not enough (#3269)
                    componentOptions.Ctor.cid +
                        (componentOptions.tag ? `::${componentOptions.tag}` : '')
                : vnode.key;
            if (cache[key]) {
                vnode.componentInstance = cache[key].componentInstance;
                // make current key freshest
                remove$2(keys, key);
                keys.push(key);
            }
            else {
                // delay setting the cache until update
                this.vnodeToCache = vnode;
                this.keyToCache = key;
            }
            // @ts-expect-error can vnode.data can be undefined
            vnode.data.keepAlive = true;
        }
        return vnode || (slot && slot[0]);
    }
};

var builtInComponents = {
    KeepAlive
};

function initGlobalAPI(Vue) {
    // config
    const configDef = {};
    configDef.get = () => config;
    {
        configDef.set = () => {
            warn$2('Do not replace the Vue.config object, set individual fields instead.');
        };
    }
    Object.defineProperty(Vue, 'config', configDef);
    // exposed util methods.
    // NOTE: these are not considered part of the public API - avoid relying on
    // them unless you are aware of the risk.
    Vue.util = {
        warn: warn$2,
        extend,
        mergeOptions,
        defineReactive
    };
    Vue.set = set;
    Vue.delete = del;
    Vue.nextTick = nextTick;
    // 2.6 explicit observable API
    Vue.observable = (obj) => {
        observe(obj);
        return obj;
    };
    Vue.options = Object.create(null);
    ASSET_TYPES.forEach(type => {
        Vue.options[type + 's'] = Object.create(null);
    });
    // this is used to identify the "base" constructor to extend all plain-object
    // components with in Weex's multi-instance scenarios.
    Vue.options._base = Vue;
    extend(Vue.options.components, builtInComponents);
    initUse(Vue);
    initMixin(Vue);
    initExtend(Vue);
    initAssetRegisters(Vue);
}

initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, '$isServer', {
    get: isServerRendering
});
Object.defineProperty(Vue.prototype, '$ssrContext', {
    get() {
        /* istanbul ignore next */
        return this.$vnode && this.$vnode.ssrContext;
    }
});
// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
    value: FunctionalRenderContext
});
Vue.version = version;

// these are reserved for web because they are directly compiled away
// during template compilation
const isReservedAttr = makeMap('style,class');
// attributes that should be using props for binding
const acceptValue = makeMap('input,textarea,option,select,progress');
const mustUseProp = (tag, type, attr) => {
    return ((attr === 'value' && acceptValue(tag) && type !== 'button') ||
        (attr === 'selected' && tag === 'option') ||
        (attr === 'checked' && tag === 'input') ||
        (attr === 'muted' && tag === 'video'));
};
const isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
const isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');
const convertEnumeratedValue = (key, value) => {
    return isFalsyAttrValue(value) || value === 'false'
        ? 'false'
        : // allow arbitrary string value for contenteditable
            key === 'contenteditable' && isValidContentEditableValue(value)
                ? value
                : 'true';
};
const isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
    'required,reversed,scoped,seamless,selected,sortable,' +
    'truespeed,typemustmatch,visible');
const xlinkNS = 'http://www.w3.org/1999/xlink';
const isXlink = (name) => {
    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};
const getXlinkProp = (name) => {
    return isXlink(name) ? name.slice(6, name.length) : '';
};
const isFalsyAttrValue = (val) => {
    return val == null || val === false;
};

function genClassForVnode(vnode) {
    let data = vnode.data;
    let parentNode = vnode;
    let childNode = vnode;
    while (isDef(childNode.componentInstance)) {
        childNode = childNode.componentInstance._vnode;
        if (childNode && childNode.data) {
            data = mergeClassData(childNode.data, data);
        }
    }
    // @ts-expect-error parentNode.parent not VNodeWithData
    while (isDef((parentNode = parentNode.parent))) {
        if (parentNode && parentNode.data) {
            data = mergeClassData(data, parentNode.data);
        }
    }
    return renderClass(data.staticClass, data.class);
}
function mergeClassData(child, parent) {
    return {
        staticClass: concat(child.staticClass, parent.staticClass),
        class: isDef(child.class) ? [child.class, parent.class] : parent.class
    };
}
function renderClass(staticClass, dynamicClass) {
    if (isDef(staticClass) || isDef(dynamicClass)) {
        return concat(staticClass, stringifyClass(dynamicClass));
    }
    /* istanbul ignore next */
    return '';
}
function concat(a, b) {
    return a ? (b ? a + ' ' + b : a) : b || '';
}
function stringifyClass(value) {
    if (Array.isArray(value)) {
        return stringifyArray(value);
    }
    if (isObject(value)) {
        return stringifyObject(value);
    }
    if (typeof value === 'string') {
        return value;
    }
    /* istanbul ignore next */
    return '';
}
function stringifyArray(value) {
    let res = '';
    let stringified;
    for (let i = 0, l = value.length; i < l; i++) {
        if (isDef((stringified = stringifyClass(value[i]))) && stringified !== '') {
            if (res)
                res += ' ';
            res += stringified;
        }
    }
    return res;
}
function stringifyObject(value) {
    let res = '';
    for (const key in value) {
        if (value[key]) {
            if (res)
                res += ' ';
            res += key;
        }
    }
    return res;
}

const namespaceMap = {
    svg: 'http://www.w3.org/2000/svg',
    math: 'http://www.w3.org/1998/Math/MathML'
};
const isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' +
    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
    'embed,object,param,source,canvas,script,noscript,del,ins,' +
    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
    'output,progress,select,textarea,' +
    'details,dialog,menu,menuitem,summary,' +
    'content,element,shadow,template,blockquote,iframe,tfoot');
// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
const isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
    'foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);
const isPreTag = (tag) => tag === 'pre';
const isReservedTag = (tag) => {
    return isHTMLTag(tag) || isSVG(tag);
};
function getTagNamespace(tag) {
    if (isSVG(tag)) {
        return 'svg';
    }
    // basic support for MathML
    // note it doesn't support other MathML elements being component roots
    if (tag === 'math') {
        return 'math';
    }
}
const unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
    /* istanbul ignore if */
    if (!inBrowser) {
        return true;
    }
    if (isReservedTag(tag)) {
        return false;
    }
    tag = tag.toLowerCase();
    /* istanbul ignore if */
    if (unknownElementCache[tag] != null) {
        return unknownElementCache[tag];
    }
    const el = document.createElement(tag);
    if (tag.indexOf('-') > -1) {
        // https://stackoverflow.com/a/28210364/1070244
        return (unknownElementCache[tag] =
            el.constructor === window.HTMLUnknownElement ||
                el.constructor === window.HTMLElement);
    }
    else {
        return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()));
    }
}
const isTextInputType = makeMap('text,number,password,search,email,tel,url');

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
    if (typeof el === 'string') {
        const selected = document.querySelector(el);
        if (!selected) {
            warn$2('Cannot find element: ' + el);
            return document.createElement('div');
        }
        return selected;
    }
    else {
        return el;
    }
}

function createElement(tagName, vnode) {
    const elm = document.createElement(tagName);
    if (tagName !== 'select') {
        return elm;
    }
    // false or null will remove the attribute but undefined will not
    if (vnode.data &&
        vnode.data.attrs &&
        vnode.data.attrs.multiple !== undefined) {
        elm.setAttribute('multiple', 'multiple');
    }
    return elm;
}
function createElementNS(namespace, tagName) {
    return document.createElementNS(namespaceMap[namespace], tagName);
}
function createTextNode(text) {
    return document.createTextNode(text);
}
function createComment(text) {
    return document.createComment(text);
}
function insertBefore(parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
    node.removeChild(child);
}
function appendChild(node, child) {
    node.appendChild(child);
}
function parentNode(node) {
    return node.parentNode;
}
function nextSibling(node) {
    return node.nextSibling;
}
function tagName(node) {
    return node.tagName;
}
function setTextContent(node, text) {
    node.textContent = text;
}
function setStyleScope(node, scopeId) {
    node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createElement: createElement,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

var ref = {
    create(_, vnode) {
        registerRef(vnode);
    },
    update(oldVnode, vnode) {
        if (oldVnode.data.ref !== vnode.data.ref) {
            registerRef(oldVnode, true);
            registerRef(vnode);
        }
    },
    destroy(vnode) {
        registerRef(vnode, true);
    }
};
function registerRef(vnode, isRemoval) {
    const ref = vnode.data.ref;
    if (!isDef(ref))
        return;
    const vm = vnode.context;
    const refValue = vnode.componentInstance || vnode.elm;
    const value = isRemoval ? null : refValue;
    const $refsValue = isRemoval ? undefined : refValue;
    if (isFunction(ref)) {
        invokeWithErrorHandling(ref, vm, [value], vm, `template ref function`);
        return;
    }
    const isFor = vnode.data.refInFor;
    const _isString = typeof ref === 'string' || typeof ref === 'number';
    const _isRef = isRef(ref);
    const refs = vm.$refs;
    if (_isString || _isRef) {
        if (isFor) {
            const existing = _isString ? refs[ref] : ref.value;
            if (isRemoval) {
                isArray(existing) && remove$2(existing, refValue);
            }
            else {
                if (!isArray(existing)) {
                    if (_isString) {
                        refs[ref] = [refValue];
                        setSetupRef(vm, ref, refs[ref]);
                    }
                    else {
                        ref.value = [refValue];
                    }
                }
                else if (!existing.includes(refValue)) {
                    existing.push(refValue);
                }
            }
        }
        else if (_isString) {
            if (isRemoval && refs[ref] !== refValue) {
                return;
            }
            refs[ref] = $refsValue;
            setSetupRef(vm, ref, value);
        }
        else if (_isRef) {
            if (isRemoval && ref.value !== refValue) {
                return;
            }
            ref.value = value;
        }
        else {
            warn$2(`Invalid template ref type: ${typeof ref}`);
        }
    }
}
function setSetupRef({ _setupState }, key, val) {
    if (_setupState && hasOwn(_setupState, key)) {
        if (isRef(_setupState[key])) {
            _setupState[key].value = val;
        }
        else {
            _setupState[key] = val;
        }
    }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */
const emptyNode = new VNode('', {}, []);
const hooks = ['create', 'activate', 'update', 'remove', 'destroy'];
function sameVnode(a, b) {
    return (a.key === b.key &&
        a.asyncFactory === b.asyncFactory &&
        ((a.tag === b.tag &&
            a.isComment === b.isComment &&
            isDef(a.data) === isDef(b.data) &&
            sameInputType(a, b)) ||
            (isTrue(a.isAsyncPlaceholder) && isUndef(b.asyncFactory.error))));
}
function sameInputType(a, b) {
    if (a.tag !== 'input')
        return true;
    let i;
    const typeA = isDef((i = a.data)) && isDef((i = i.attrs)) && i.type;
    const typeB = isDef((i = b.data)) && isDef((i = i.attrs)) && i.type;
    return typeA === typeB || (isTextInputType(typeA) && isTextInputType(typeB));
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
    let i, key;
    const map = {};
    for (i = beginIdx; i <= endIdx; ++i) {
        key = children[i].key;
        if (isDef(key))
            map[key] = i;
    }
    return map;
}
function createPatchFunction(backend) {
    let i, j;
    const cbs = {};
    const { modules, nodeOps } = backend;
    for (i = 0; i < hooks.length; ++i) {
        cbs[hooks[i]] = [];
        for (j = 0; j < modules.length; ++j) {
            if (isDef(modules[j][hooks[i]])) {
                cbs[hooks[i]].push(modules[j][hooks[i]]);
            }
        }
    }
    function emptyNodeAt(elm) {
        return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
    }
    function createRmCb(childElm, listeners) {
        function remove() {
            if (--remove.listeners === 0) {
                removeNode(childElm);
            }
        }
        remove.listeners = listeners;
        return remove;
    }
    function removeNode(el) {
        const parent = nodeOps.parentNode(el);
        // element may have already been removed due to v-html / v-text
        if (isDef(parent)) {
            nodeOps.removeChild(parent, el);
        }
    }
    function isUnknownElement(vnode, inVPre) {
        return (!inVPre &&
            !vnode.ns &&
            !(config.ignoredElements.length &&
                config.ignoredElements.some(ignore => {
                    return isRegExp(ignore)
                        ? ignore.test(vnode.tag)
                        : ignore === vnode.tag;
                })) &&
            config.isUnknownElement(vnode.tag));
    }
    let creatingElmInVPre = 0;
    function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) {
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // This vnode was used in a previous render!
            // now it's used as a new node, overwriting its elm would cause
            // potential patch errors down the road when it's used as an insertion
            // reference node. Instead, we clone the node on-demand before creating
            // associated DOM element for it.
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        vnode.isRootInsert = !nested; // for transition enter check
        if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
            return;
        }
        const data = vnode.data;
        const children = vnode.children;
        const tag = vnode.tag;
        if (isDef(tag)) {
            {
                if (data && data.pre) {
                    creatingElmInVPre++;
                }
                if (isUnknownElement(vnode, creatingElmInVPre)) {
                    warn$2('Unknown custom element: <' +
                        tag +
                        '> - did you ' +
                        'register the component correctly? For recursive components, ' +
                        'make sure to provide the "name" option.', vnode.context);
                }
            }
            vnode.elm = vnode.ns
                ? nodeOps.createElementNS(vnode.ns, tag)
                : nodeOps.createElement(tag, vnode);
            setScope(vnode);
            createChildren(vnode, children, insertedVnodeQueue);
            if (isDef(data)) {
                invokeCreateHooks(vnode, insertedVnodeQueue);
            }
            insert(parentElm, vnode.elm, refElm);
            if (data && data.pre) {
                creatingElmInVPre--;
            }
        }
        else if (isTrue(vnode.isComment)) {
            vnode.elm = nodeOps.createComment(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
        else {
            vnode.elm = nodeOps.createTextNode(vnode.text);
            insert(parentElm, vnode.elm, refElm);
        }
    }
    function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        let i = vnode.data;
        if (isDef(i)) {
            const isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
            if (isDef((i = i.hook)) && isDef((i = i.init))) {
                i(vnode, false /* hydrating */);
            }
            // after calling the init hook, if the vnode is a child component
            // it should've created a child instance and mounted it. the child
            // component also has set the placeholder vnode's elm.
            // in that case we can just return the element and be done.
            if (isDef(vnode.componentInstance)) {
                initComponent(vnode, insertedVnodeQueue);
                insert(parentElm, vnode.elm, refElm);
                if (isTrue(isReactivated)) {
                    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
                }
                return true;
            }
        }
    }
    function initComponent(vnode, insertedVnodeQueue) {
        if (isDef(vnode.data.pendingInsert)) {
            insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
            vnode.data.pendingInsert = null;
        }
        vnode.elm = vnode.componentInstance.$el;
        if (isPatchable(vnode)) {
            invokeCreateHooks(vnode, insertedVnodeQueue);
            setScope(vnode);
        }
        else {
            // empty component root.
            // skip all element-related modules except for ref (#3455)
            registerRef(vnode);
            // make sure to invoke the insert hook
            insertedVnodeQueue.push(vnode);
        }
    }
    function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
        let i;
        // hack for #4339: a reactivated component with inner transition
        // does not trigger because the inner node's created hooks are not called
        // again. It's not ideal to involve module-specific logic in here but
        // there doesn't seem to be a better way to do it.
        let innerNode = vnode;
        while (innerNode.componentInstance) {
            innerNode = innerNode.componentInstance._vnode;
            if (isDef((i = innerNode.data)) && isDef((i = i.transition))) {
                for (i = 0; i < cbs.activate.length; ++i) {
                    cbs.activate[i](emptyNode, innerNode);
                }
                insertedVnodeQueue.push(innerNode);
                break;
            }
        }
        // unlike a newly created component,
        // a reactivated keep-alive component doesn't insert itself
        insert(parentElm, vnode.elm, refElm);
    }
    function insert(parent, elm, ref) {
        if (isDef(parent)) {
            if (isDef(ref)) {
                if (nodeOps.parentNode(ref) === parent) {
                    nodeOps.insertBefore(parent, elm, ref);
                }
            }
            else {
                nodeOps.appendChild(parent, elm);
            }
        }
    }
    function createChildren(vnode, children, insertedVnodeQueue) {
        if (isArray(children)) {
            {
                checkDuplicateKeys(children);
            }
            for (let i = 0; i < children.length; ++i) {
                createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
            }
        }
        else if (isPrimitive(vnode.text)) {
            nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
        }
    }
    function isPatchable(vnode) {
        while (vnode.componentInstance) {
            vnode = vnode.componentInstance._vnode;
        }
        return isDef(vnode.tag);
    }
    function invokeCreateHooks(vnode, insertedVnodeQueue) {
        for (let i = 0; i < cbs.create.length; ++i) {
            cbs.create[i](emptyNode, vnode);
        }
        i = vnode.data.hook; // Reuse variable
        if (isDef(i)) {
            if (isDef(i.create))
                i.create(emptyNode, vnode);
            if (isDef(i.insert))
                insertedVnodeQueue.push(vnode);
        }
    }
    // set scope id attribute for scoped CSS.
    // this is implemented as a special case to avoid the overhead
    // of going through the normal attribute patching process.
    function setScope(vnode) {
        let i;
        if (isDef((i = vnode.fnScopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
        else {
            let ancestor = vnode;
            while (ancestor) {
                if (isDef((i = ancestor.context)) && isDef((i = i.$options._scopeId))) {
                    nodeOps.setStyleScope(vnode.elm, i);
                }
                ancestor = ancestor.parent;
            }
        }
        // for slot content they should also get the scopeId from the host instance.
        if (isDef((i = activeInstance)) &&
            i !== vnode.context &&
            i !== vnode.fnContext &&
            isDef((i = i.$options._scopeId))) {
            nodeOps.setStyleScope(vnode.elm, i);
        }
    }
    function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
        for (; startIdx <= endIdx; ++startIdx) {
            createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
        }
    }
    function invokeDestroyHook(vnode) {
        let i, j;
        const data = vnode.data;
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.destroy)))
                i(vnode);
            for (i = 0; i < cbs.destroy.length; ++i)
                cbs.destroy[i](vnode);
        }
        if (isDef((i = vnode.children))) {
            for (j = 0; j < vnode.children.length; ++j) {
                invokeDestroyHook(vnode.children[j]);
            }
        }
    }
    function removeVnodes(vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            const ch = vnodes[startIdx];
            if (isDef(ch)) {
                if (isDef(ch.tag)) {
                    removeAndInvokeRemoveHook(ch);
                    invokeDestroyHook(ch);
                }
                else {
                    // Text node
                    removeNode(ch.elm);
                }
            }
        }
    }
    function removeAndInvokeRemoveHook(vnode, rm) {
        if (isDef(rm) || isDef(vnode.data)) {
            let i;
            const listeners = cbs.remove.length + 1;
            if (isDef(rm)) {
                // we have a recursively passed down rm callback
                // increase the listeners count
                rm.listeners += listeners;
            }
            else {
                // directly removing
                rm = createRmCb(vnode.elm, listeners);
            }
            // recursively invoke hooks on child component root node
            if (isDef((i = vnode.componentInstance)) &&
                isDef((i = i._vnode)) &&
                isDef(i.data)) {
                removeAndInvokeRemoveHook(i, rm);
            }
            for (i = 0; i < cbs.remove.length; ++i) {
                cbs.remove[i](vnode, rm);
            }
            if (isDef((i = vnode.data.hook)) && isDef((i = i.remove))) {
                i(vnode, rm);
            }
            else {
                rm();
            }
        }
        else {
            removeNode(vnode.elm);
        }
    }
    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
        let oldStartIdx = 0;
        let newStartIdx = 0;
        let oldEndIdx = oldCh.length - 1;
        let oldStartVnode = oldCh[0];
        let oldEndVnode = oldCh[oldEndIdx];
        let newEndIdx = newCh.length - 1;
        let newStartVnode = newCh[0];
        let newEndVnode = newCh[newEndIdx];
        let oldKeyToIdx, idxInOld, vnodeToMove, refElm;
        // removeOnly is a special flag used only by <transition-group>
        // to ensure removed elements stay in correct relative positions
        // during leaving transitions
        const canMove = !removeOnly;
        {
            checkDuplicateKeys(newCh);
        }
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (isUndef(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
            }
            else if (isUndef(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                canMove &&
                    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (isUndef(oldKeyToIdx))
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                idxInOld = isDef(newStartVnode.key)
                    ? oldKeyToIdx[newStartVnode.key]
                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
                if (isUndef(idxInOld)) {
                    // New element
                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                }
                else {
                    vnodeToMove = oldCh[idxInOld];
                    if (sameVnode(vnodeToMove, newStartVnode)) {
                        patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
                        oldCh[idxInOld] = undefined;
                        canMove &&
                            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
                    }
                    else {
                        // same key but different element. treat as new element
                        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
                    }
                }
                newStartVnode = newCh[++newStartIdx];
            }
        }
        if (oldStartIdx > oldEndIdx) {
            refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
            addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
        }
        else if (newStartIdx > newEndIdx) {
            removeVnodes(oldCh, oldStartIdx, oldEndIdx);
        }
    }
    function checkDuplicateKeys(children) {
        const seenKeys = {};
        for (let i = 0; i < children.length; i++) {
            const vnode = children[i];
            const key = vnode.key;
            if (isDef(key)) {
                if (seenKeys[key]) {
                    warn$2(`Duplicate keys detected: '${key}'. This may cause an update error.`, vnode.context);
                }
                else {
                    seenKeys[key] = true;
                }
            }
        }
    }
    function findIdxInOld(node, oldCh, start, end) {
        for (let i = start; i < end; i++) {
            const c = oldCh[i];
            if (isDef(c) && sameVnode(node, c))
                return i;
        }
    }
    function patchVnode(oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) {
        if (oldVnode === vnode) {
            return;
        }
        if (isDef(vnode.elm) && isDef(ownerArray)) {
            // clone reused vnode
            vnode = ownerArray[index] = cloneVNode(vnode);
        }
        const elm = (vnode.elm = oldVnode.elm);
        if (isTrue(oldVnode.isAsyncPlaceholder)) {
            if (isDef(vnode.asyncFactory.resolved)) {
                hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
            }
            else {
                vnode.isAsyncPlaceholder = true;
            }
            return;
        }
        // reuse element for static trees.
        // note we only do this if the vnode is cloned -
        // if the new node is not cloned it means the render functions have been
        // reset by the hot-reload-api and we need to do a proper re-render.
        if (isTrue(vnode.isStatic) &&
            isTrue(oldVnode.isStatic) &&
            vnode.key === oldVnode.key &&
            (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
            vnode.componentInstance = oldVnode.componentInstance;
            return;
        }
        let i;
        const data = vnode.data;
        if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
            i(oldVnode, vnode);
        }
        const oldCh = oldVnode.children;
        const ch = vnode.children;
        if (isDef(data) && isPatchable(vnode)) {
            for (i = 0; i < cbs.update.length; ++i)
                cbs.update[i](oldVnode, vnode);
            if (isDef((i = data.hook)) && isDef((i = i.update)))
                i(oldVnode, vnode);
        }
        if (isUndef(vnode.text)) {
            if (isDef(oldCh) && isDef(ch)) {
                if (oldCh !== ch)
                    updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
            }
            else if (isDef(ch)) {
                {
                    checkDuplicateKeys(ch);
                }
                if (isDef(oldVnode.text))
                    nodeOps.setTextContent(elm, '');
                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
            }
            else if (isDef(oldCh)) {
                removeVnodes(oldCh, 0, oldCh.length - 1);
            }
            else if (isDef(oldVnode.text)) {
                nodeOps.setTextContent(elm, '');
            }
        }
        else if (oldVnode.text !== vnode.text) {
            nodeOps.setTextContent(elm, vnode.text);
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.postpatch)))
                i(oldVnode, vnode);
        }
    }
    function invokeInsertHook(vnode, queue, initial) {
        // delay insert hooks for component root nodes, invoke them after the
        // element is really inserted
        if (isTrue(initial) && isDef(vnode.parent)) {
            vnode.parent.data.pendingInsert = queue;
        }
        else {
            for (let i = 0; i < queue.length; ++i) {
                queue[i].data.hook.insert(queue[i]);
            }
        }
    }
    let hydrationBailed = false;
    // list of modules that can skip create hook during hydration because they
    // are already rendered on the client or has no need for initialization
    // Note: style is excluded because it relies on initial clone for future
    // deep updates (#7063).
    const isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');
    // Note: this is a browser-only function so we can assume elms are DOM nodes.
    function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
        let i;
        const { tag, data, children } = vnode;
        inVPre = inVPre || (data && data.pre);
        vnode.elm = elm;
        if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
            vnode.isAsyncPlaceholder = true;
            return true;
        }
        // assert node match
        {
            if (!assertNodeMatch(elm, vnode, inVPre)) {
                return false;
            }
        }
        if (isDef(data)) {
            if (isDef((i = data.hook)) && isDef((i = i.init)))
                i(vnode, true /* hydrating */);
            if (isDef((i = vnode.componentInstance))) {
                // child component. it should have hydrated its own tree.
                initComponent(vnode, insertedVnodeQueue);
                return true;
            }
        }
        if (isDef(tag)) {
            if (isDef(children)) {
                // empty element, allow client to pick up and populate children
                if (!elm.hasChildNodes()) {
                    createChildren(vnode, children, insertedVnodeQueue);
                }
                else {
                    // v-html and domProps: innerHTML
                    if (isDef((i = data)) &&
                        isDef((i = i.domProps)) &&
                        isDef((i = i.innerHTML))) {
                        if (i !== elm.innerHTML) {
                            /* istanbul ignore if */
                            if (typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('server innerHTML: ', i);
                                console.warn('client innerHTML: ', elm.innerHTML);
                            }
                            return false;
                        }
                    }
                    else {
                        // iterate and compare children lists
                        let childrenMatch = true;
                        let childNode = elm.firstChild;
                        for (let i = 0; i < children.length; i++) {
                            if (!childNode ||
                                !hydrate(childNode, children[i], insertedVnodeQueue, inVPre)) {
                                childrenMatch = false;
                                break;
                            }
                            childNode = childNode.nextSibling;
                        }
                        // if childNode is not null, it means the actual childNodes list is
                        // longer than the virtual children list.
                        if (!childrenMatch || childNode) {
                            /* istanbul ignore if */
                            if (typeof console !== 'undefined' &&
                                !hydrationBailed) {
                                hydrationBailed = true;
                                console.warn('Parent: ', elm);
                                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
                            }
                            return false;
                        }
                    }
                }
            }
            if (isDef(data)) {
                let fullInvoke = false;
                for (const key in data) {
                    if (!isRenderedModule(key)) {
                        fullInvoke = true;
                        invokeCreateHooks(vnode, insertedVnodeQueue);
                        break;
                    }
                }
                if (!fullInvoke && data['class']) {
                    // ensure collecting deps for deep class bindings for future updates
                    traverse(data['class']);
                }
            }
        }
        else if (elm.data !== vnode.text) {
            elm.data = vnode.text;
        }
        return true;
    }
    function assertNodeMatch(node, vnode, inVPre) {
        if (isDef(vnode.tag)) {
            return (vnode.tag.indexOf('vue-component') === 0 ||
                (!isUnknownElement(vnode, inVPre) &&
                    vnode.tag.toLowerCase() ===
                        (node.tagName && node.tagName.toLowerCase())));
        }
        else {
            return node.nodeType === (vnode.isComment ? 8 : 3);
        }
    }
    return function patch(oldVnode, vnode, hydrating, removeOnly) {
        if (isUndef(vnode)) {
            if (isDef(oldVnode))
                invokeDestroyHook(oldVnode);
            return;
        }
        let isInitialPatch = false;
        const insertedVnodeQueue = [];
        if (isUndef(oldVnode)) {
            // empty mount (likely as component), create new root element
            isInitialPatch = true;
            createElm(vnode, insertedVnodeQueue);
        }
        else {
            const isRealElement = isDef(oldVnode.nodeType);
            if (!isRealElement && sameVnode(oldVnode, vnode)) {
                // patch existing root node
                patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
            }
            else {
                if (isRealElement) {
                    // mounting to a real element
                    // check if this is server-rendered content and if we can perform
                    // a successful hydration.
                    if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
                        oldVnode.removeAttribute(SSR_ATTR);
                        hydrating = true;
                    }
                    if (isTrue(hydrating)) {
                        if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
                            invokeInsertHook(vnode, insertedVnodeQueue, true);
                            return oldVnode;
                        }
                        else {
                            warn$2('The client-side rendered virtual DOM tree is not matching ' +
                                'server-rendered content. This is likely caused by incorrect ' +
                                'HTML markup, for example nesting block-level elements inside ' +
                                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                                'full client-side render.');
                        }
                    }
                    // either not server-rendered, or hydration failed.
                    // create an empty node and replace it
                    oldVnode = emptyNodeAt(oldVnode);
                }
                // replacing existing element
                const oldElm = oldVnode.elm;
                const parentElm = nodeOps.parentNode(oldElm);
                // create new node
                createElm(vnode, insertedVnodeQueue, 
                // extremely rare edge case: do not insert if old element is in a
                // leaving transition. Only happens when combining transition +
                // keep-alive + HOCs. (#4590)
                oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm));
                // update parent placeholder node element, recursively
                if (isDef(vnode.parent)) {
                    let ancestor = vnode.parent;
                    const patchable = isPatchable(vnode);
                    while (ancestor) {
                        for (let i = 0; i < cbs.destroy.length; ++i) {
                            cbs.destroy[i](ancestor);
                        }
                        ancestor.elm = vnode.elm;
                        if (patchable) {
                            for (let i = 0; i < cbs.create.length; ++i) {
                                cbs.create[i](emptyNode, ancestor);
                            }
                            // #6513
                            // invoke insert hooks that may have been merged by create hooks.
                            // e.g. for directives that uses the "inserted" hook.
                            const insert = ancestor.data.hook.insert;
                            if (insert.merged) {
                                // start at index 1 to avoid re-invoking component mounted hook
                                // clone insert hooks to avoid being mutated during iteration.
                                // e.g. for customed directives under transition group.
                                const cloned = insert.fns.slice(1);
                                for (let i = 0; i < cloned.length; i++) {
                                    cloned[i]();
                                }
                            }
                        }
                        else {
                            registerRef(ancestor);
                        }
                        ancestor = ancestor.parent;
                    }
                }
                // destroy old node
                if (isDef(parentElm)) {
                    removeVnodes([oldVnode], 0, 0);
                }
                else if (isDef(oldVnode.tag)) {
                    invokeDestroyHook(oldVnode);
                }
            }
        }
        invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
        return vnode.elm;
    };
}

var directives$1 = {
    create: updateDirectives,
    update: updateDirectives,
    destroy: function unbindDirectives(vnode) {
        // @ts-expect-error emptyNode is not VNodeWithData
        updateDirectives(vnode, emptyNode);
    }
};
function updateDirectives(oldVnode, vnode) {
    if (oldVnode.data.directives || vnode.data.directives) {
        _update(oldVnode, vnode);
    }
}
function _update(oldVnode, vnode) {
    const isCreate = oldVnode === emptyNode;
    const isDestroy = vnode === emptyNode;
    const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);
    const newDirs = normalizeDirectives(vnode.data.directives, vnode.context);
    const dirsWithInsert = [];
    const dirsWithPostpatch = [];
    let key, oldDir, dir;
    for (key in newDirs) {
        oldDir = oldDirs[key];
        dir = newDirs[key];
        if (!oldDir) {
            // new directive, bind
            callHook(dir, 'bind', vnode, oldVnode);
            if (dir.def && dir.def.inserted) {
                dirsWithInsert.push(dir);
            }
        }
        else {
            // existing directive, update
            dir.oldValue = oldDir.value;
            dir.oldArg = oldDir.arg;
            callHook(dir, 'update', vnode, oldVnode);
            if (dir.def && dir.def.componentUpdated) {
                dirsWithPostpatch.push(dir);
            }
        }
    }
    if (dirsWithInsert.length) {
        const callInsert = () => {
            for (let i = 0; i < dirsWithInsert.length; i++) {
                callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode);
            }
        };
        if (isCreate) {
            mergeVNodeHook(vnode, 'insert', callInsert);
        }
        else {
            callInsert();
        }
    }
    if (dirsWithPostpatch.length) {
        mergeVNodeHook(vnode, 'postpatch', () => {
            for (let i = 0; i < dirsWithPostpatch.length; i++) {
                callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
            }
        });
    }
    if (!isCreate) {
        for (key in oldDirs) {
            if (!newDirs[key]) {
                // no longer present, unbind
                callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
            }
        }
    }
}
const emptyModifiers = Object.create(null);
function normalizeDirectives(dirs, vm) {
    const res = Object.create(null);
    if (!dirs) {
        // $flow-disable-line
        return res;
    }
    let i, dir;
    for (i = 0; i < dirs.length; i++) {
        dir = dirs[i];
        if (!dir.modifiers) {
            // $flow-disable-line
            dir.modifiers = emptyModifiers;
        }
        res[getRawDirName(dir)] = dir;
        if (vm._setupState && vm._setupState.__sfc) {
            const setupDef = dir.def || resolveAsset(vm, '_setupState', 'v-' + dir.name);
            if (typeof setupDef === 'function') {
                dir.def = {
                    bind: setupDef,
                    update: setupDef,
                };
            }
            else {
                dir.def = setupDef;
            }
        }
        dir.def = dir.def || resolveAsset(vm.$options, 'directives', dir.name, true);
    }
    // $flow-disable-line
    return res;
}
function getRawDirName(dir) {
    return (dir.rawName || `${dir.name}.${Object.keys(dir.modifiers || {}).join('.')}`);
}
function callHook(dir, hook, vnode, oldVnode, isDestroy) {
    const fn = dir.def && dir.def[hook];
    if (fn) {
        try {
            fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
        }
        catch (e) {
            handleError(e, vnode.context, `directive ${dir.name} ${hook} hook`);
        }
    }
}

var baseModules = [ref, directives$1];

function updateAttrs(oldVnode, vnode) {
    const opts = vnode.componentOptions;
    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
        return;
    }
    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
        return;
    }
    let key, cur, old;
    const elm = vnode.elm;
    const oldAttrs = oldVnode.data.attrs || {};
    let attrs = vnode.data.attrs || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(attrs.__ob__) || isTrue(attrs._v_attr_proxy)) {
        attrs = vnode.data.attrs = extend({}, attrs);
    }
    for (key in attrs) {
        cur = attrs[key];
        old = oldAttrs[key];
        if (old !== cur) {
            setAttr(elm, key, cur, vnode.data.pre);
        }
    }
    // #4391: in IE9, setting type can reset value for input[type=radio]
    // #6666: IE/Edge forces progress value down to 1 before setting a max
    /* istanbul ignore if */
    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
        setAttr(elm, 'value', attrs.value);
    }
    for (key in oldAttrs) {
        if (isUndef(attrs[key])) {
            if (isXlink(key)) {
                elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
            }
            else if (!isEnumeratedAttr(key)) {
                elm.removeAttribute(key);
            }
        }
    }
}
function setAttr(el, key, value, isInPre) {
    if (isInPre || el.tagName.indexOf('-') > -1) {
        baseSetAttr(el, key, value);
    }
    else if (isBooleanAttr(key)) {
        // set attribute for blank value
        // e.g. <option disabled>Select one</option>
        if (isFalsyAttrValue(value)) {
            el.removeAttribute(key);
        }
        else {
            // technically allowfullscreen is a boolean attribute for <iframe>,
            // but Flash expects a value of "true" when used on <embed> tag
            value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
            el.setAttribute(key, value);
        }
    }
    else if (isEnumeratedAttr(key)) {
        el.setAttribute(key, convertEnumeratedValue(key, value));
    }
    else if (isXlink(key)) {
        if (isFalsyAttrValue(value)) {
            el.removeAttributeNS(xlinkNS, getXlinkProp(key));
        }
        else {
            el.setAttributeNS(xlinkNS, key, value);
        }
    }
    else {
        baseSetAttr(el, key, value);
    }
}
function baseSetAttr(el, key, value) {
    if (isFalsyAttrValue(value)) {
        el.removeAttribute(key);
    }
    else {
        // #7138: IE10 & 11 fires input event when setting placeholder on
        // <textarea>... block the first input event and remove the blocker
        // immediately.
        /* istanbul ignore if */
        if (isIE &&
            !isIE9 &&
            el.tagName === 'TEXTAREA' &&
            key === 'placeholder' &&
            value !== '' &&
            !el.__ieph) {
            const blocker = e => {
                e.stopImmediatePropagation();
                el.removeEventListener('input', blocker);
            };
            el.addEventListener('input', blocker);
            // $flow-disable-line
            el.__ieph = true; /* IE placeholder patched */
        }
        el.setAttribute(key, value);
    }
}
var attrs = {
    create: updateAttrs,
    update: updateAttrs
};

function updateClass(oldVnode, vnode) {
    const el = vnode.elm;
    const data = vnode.data;
    const oldData = oldVnode.data;
    if (isUndef(data.staticClass) &&
        isUndef(data.class) &&
        (isUndef(oldData) ||
            (isUndef(oldData.staticClass) && isUndef(oldData.class)))) {
        return;
    }
    let cls = genClassForVnode(vnode);
    // handle transition classes
    const transitionClass = el._transitionClasses;
    if (isDef(transitionClass)) {
        cls = concat(cls, stringifyClass(transitionClass));
    }
    // set the class
    if (cls !== el._prevClass) {
        el.setAttribute('class', cls);
        el._prevClass = cls;
    }
}
var klass$1 = {
    create: updateClass,
    update: updateClass
};

const validDivisionCharRE = /[\w).+\-_$\]]/;
function parseFilters(exp) {
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters;
    for (i = 0; i < exp.length; i++) {
        prev = c;
        c = exp.charCodeAt(i);
        if (inSingle) {
            if (c === 0x27 && prev !== 0x5c)
                inSingle = false;
        }
        else if (inDouble) {
            if (c === 0x22 && prev !== 0x5c)
                inDouble = false;
        }
        else if (inTemplateString) {
            if (c === 0x60 && prev !== 0x5c)
                inTemplateString = false;
        }
        else if (inRegex) {
            if (c === 0x2f && prev !== 0x5c)
                inRegex = false;
        }
        else if (c === 0x7c && // pipe
            exp.charCodeAt(i + 1) !== 0x7c &&
            exp.charCodeAt(i - 1) !== 0x7c &&
            !curly &&
            !square &&
            !paren) {
            if (expression === undefined) {
                // first filter, end of expression
                lastFilterIndex = i + 1;
                expression = exp.slice(0, i).trim();
            }
            else {
                pushFilter();
            }
        }
        else {
            switch (c) {
                case 0x22:
                    inDouble = true;
                    break; // "
                case 0x27:
                    inSingle = true;
                    break; // '
                case 0x60:
                    inTemplateString = true;
                    break; // `
                case 0x28:
                    paren++;
                    break; // (
                case 0x29:
                    paren--;
                    break; // )
                case 0x5b:
                    square++;
                    break; // [
                case 0x5d:
                    square--;
                    break; // ]
                case 0x7b:
                    curly++;
                    break; // {
                case 0x7d:
                    curly--;
                    break; // }
            }
            if (c === 0x2f) {
                // /
                let j = i - 1;
                let p;
                // find first non-whitespace prev char
                for (; j >= 0; j--) {
                    p = exp.charAt(j);
                    if (p !== ' ')
                        break;
                }
                if (!p || !validDivisionCharRE.test(p)) {
                    inRegex = true;
                }
            }
        }
    }
    if (expression === undefined) {
        expression = exp.slice(0, i).trim();
    }
    else if (lastFilterIndex !== 0) {
        pushFilter();
    }
    function pushFilter() {
        (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
        lastFilterIndex = i + 1;
    }
    if (filters) {
        for (i = 0; i < filters.length; i++) {
            expression = wrapFilter(expression, filters[i]);
        }
    }
    return expression;
}
function wrapFilter(exp, filter) {
    const i = filter.indexOf('(');
    if (i < 0) {
        // _f: resolveFilter
        return `_f("${filter}")(${exp})`;
    }
    else {
        const name = filter.slice(0, i);
        const args = filter.slice(i + 1);
        return `_f("${name}")(${exp}${args !== ')' ? ',' + args : args}`;
    }
}

/* eslint-disable no-unused-vars */
function baseWarn(msg, range) {
    console.error(`[Vue compiler]: ${msg}`);
}
/* eslint-enable no-unused-vars */
function pluckModuleFunction(modules, key) {
    return modules ? modules.map(m => m[key]).filter(_ => _) : [];
}
function addProp(el, name, value, range, dynamic) {
    (el.props || (el.props = [])).push(rangeSetItem({ name, value, dynamic }, range));
    el.plain = false;
}
function addAttr(el, name, value, range, dynamic) {
    const attrs = dynamic
        ? el.dynamicAttrs || (el.dynamicAttrs = [])
        : el.attrs || (el.attrs = []);
    attrs.push(rangeSetItem({ name, value, dynamic }, range));
    el.plain = false;
}
// add a raw attr (use this in preTransforms)
function addRawAttr(el, name, value, range) {
    el.attrsMap[name] = value;
    el.attrsList.push(rangeSetItem({ name, value }, range));
}
function addDirective(el, name, rawName, value, arg, isDynamicArg, modifiers, range) {
    (el.directives || (el.directives = [])).push(rangeSetItem({
        name,
        rawName,
        value,
        arg,
        isDynamicArg,
        modifiers
    }, range));
    el.plain = false;
}
function prependModifierMarker(symbol, name, dynamic) {
    return dynamic ? `_p(${name},"${symbol}")` : symbol + name; // mark the event as captured
}
function addHandler(el, name, value, modifiers, important, warn, range, dynamic) {
    modifiers = modifiers || emptyObject;
    // warn prevent and passive modifier
    /* istanbul ignore if */
    if (warn && modifiers.prevent && modifiers.passive) {
        warn("passive and prevent can't be used together. " +
            "Passive handler can't prevent default event.", range);
    }
    // normalize click.right and click.middle since they don't actually fire
    // this is technically browser-specific, but at least for now browsers are
    // the only target envs that have right/middle clicks.
    if (modifiers.right) {
        if (dynamic) {
            name = `(${name})==='click'?'contextmenu':(${name})`;
        }
        else if (name === 'click') {
            name = 'contextmenu';
            delete modifiers.right;
        }
    }
    else if (modifiers.middle) {
        if (dynamic) {
            name = `(${name})==='click'?'mouseup':(${name})`;
        }
        else if (name === 'click') {
            name = 'mouseup';
        }
    }
    // check capture modifier
    if (modifiers.capture) {
        delete modifiers.capture;
        name = prependModifierMarker('!', name, dynamic);
    }
    if (modifiers.once) {
        delete modifiers.once;
        name = prependModifierMarker('~', name, dynamic);
    }
    /* istanbul ignore if */
    if (modifiers.passive) {
        delete modifiers.passive;
        name = prependModifierMarker('&', name, dynamic);
    }
    let events;
    if (modifiers.native) {
        delete modifiers.native;
        events = el.nativeEvents || (el.nativeEvents = {});
    }
    else {
        events = el.events || (el.events = {});
    }
    const newHandler = rangeSetItem({ value: value.trim(), dynamic }, range);
    if (modifiers !== emptyObject) {
        newHandler.modifiers = modifiers;
    }
    const handlers = events[name];
    /* istanbul ignore if */
    if (Array.isArray(handlers)) {
        important ? handlers.unshift(newHandler) : handlers.push(newHandler);
    }
    else if (handlers) {
        events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
    }
    else {
        events[name] = newHandler;
    }
    el.plain = false;
}
function getRawBindingAttr(el, name) {
    return (el.rawAttrsMap[':' + name] ||
        el.rawAttrsMap['v-bind:' + name] ||
        el.rawAttrsMap[name]);
}
function getBindingAttr(el, name, getStatic) {
    const dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
    if (dynamicValue != null) {
        return parseFilters(dynamicValue);
    }
    else if (getStatic !== false) {
        const staticValue = getAndRemoveAttr(el, name);
        if (staticValue != null) {
            return JSON.stringify(staticValue);
        }
    }
}
// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr(el, name, removeFromMap) {
    let val;
    if ((val = el.attrsMap[name]) != null) {
        const list = el.attrsList;
        for (let i = 0, l = list.length; i < l; i++) {
            if (list[i].name === name) {
                list.splice(i, 1);
                break;
            }
        }
    }
    if (removeFromMap) {
        delete el.attrsMap[name];
    }
    return val;
}
function getAndRemoveAttrByRegex(el, name) {
    const list = el.attrsList;
    for (let i = 0, l = list.length; i < l; i++) {
        const attr = list[i];
        if (name.test(attr.name)) {
            list.splice(i, 1);
            return attr;
        }
    }
}
function rangeSetItem(item, range) {
    if (range) {
        if (range.start != null) {
            item.start = range.start;
        }
        if (range.end != null) {
            item.end = range.end;
        }
    }
    return item;
}

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
    const { number, trim } = modifiers || {};
    const baseValueExpression = '$$v';
    let valueExpression = baseValueExpression;
    if (trim) {
        valueExpression =
            `(typeof ${baseValueExpression} === 'string'` +
                `? ${baseValueExpression}.trim()` +
                `: ${baseValueExpression})`;
    }
    if (number) {
        valueExpression = `_n(${valueExpression})`;
    }
    const assignment = genAssignmentCode(value, valueExpression);
    el.model = {
        value: `(${value})`,
        expression: JSON.stringify(value),
        callback: `function (${baseValueExpression}) {${assignment}}`
    };
}
/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
    const res = parseModel(value);
    if (res.key === null) {
        return `${value}=${assignment}`;
    }
    else {
        return `$set(${res.exp}, ${res.key}, ${assignment})`;
    }
}
/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */
let len, str, chr, index, expressionPos, expressionEndPos;
function parseModel(val) {
    // Fix https://github.com/vuejs/vue/pull/7730
    // allow v-model="obj.val " (trailing whitespace)
    val = val.trim();
    len = val.length;
    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
        index = val.lastIndexOf('.');
        if (index > -1) {
            return {
                exp: val.slice(0, index),
                key: '"' + val.slice(index + 1) + '"'
            };
        }
        else {
            return {
                exp: val,
                key: null
            };
        }
    }
    str = val;
    index = expressionPos = expressionEndPos = 0;
    while (!eof()) {
        chr = next();
        /* istanbul ignore if */
        if (isStringStart(chr)) {
            parseString(chr);
        }
        else if (chr === 0x5b) {
            parseBracket(chr);
        }
    }
    return {
        exp: val.slice(0, expressionPos),
        key: val.slice(expressionPos + 1, expressionEndPos)
    };
}
function next() {
    return str.charCodeAt(++index);
}
function eof() {
    return index >= len;
}
function isStringStart(chr) {
    return chr === 0x22 || chr === 0x27;
}
function parseBracket(chr) {
    let inBracket = 1;
    expressionPos = index;
    while (!eof()) {
        chr = next();
        if (isStringStart(chr)) {
            parseString(chr);
            continue;
        }
        if (chr === 0x5b)
            inBracket++;
        if (chr === 0x5d)
            inBracket--;
        if (inBracket === 0) {
            expressionEndPos = index;
            break;
        }
    }
}
function parseString(chr) {
    const stringQuote = chr;
    while (!eof()) {
        chr = next();
        if (chr === stringQuote) {
            break;
        }
    }
}

let warn$1;
// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
const RANGE_TOKEN = '__r';
const CHECKBOX_RADIO_TOKEN = '__c';
function model$1(el, dir, _warn) {
    warn$1 = _warn;
    const value = dir.value;
    const modifiers = dir.modifiers;
    const tag = el.tag;
    const type = el.attrsMap.type;
    {
        // inputs with type="file" are read only and setting the input's
        // value will throw an error.
        if (tag === 'input' && type === 'file') {
            warn$1(`<${el.tag} v-model="${value}" type="file">:\n` +
                `File inputs are read only. Use a v-on:change listener instead.`, el.rawAttrsMap['v-model']);
        }
    }
    if (el.component) {
        genComponentModel(el, value, modifiers);
        // component v-model doesn't need extra runtime
        return false;
    }
    else if (tag === 'select') {
        genSelect(el, value, modifiers);
    }
    else if (tag === 'input' && type === 'checkbox') {
        genCheckboxModel(el, value, modifiers);
    }
    else if (tag === 'input' && type === 'radio') {
        genRadioModel(el, value, modifiers);
    }
    else if (tag === 'input' || tag === 'textarea') {
        genDefaultModel(el, value, modifiers);
    }
    else if (!config.isReservedTag(tag)) {
        genComponentModel(el, value, modifiers);
        // component v-model doesn't need extra runtime
        return false;
    }
    else {
        warn$1(`<${el.tag} v-model="${value}">: ` +
            `v-model is not supported on this element type. ` +
            "If you are working with contenteditable, it's recommended to " +
            'wrap a library dedicated for that purpose inside a custom component.', el.rawAttrsMap['v-model']);
    }
    // ensure runtime directive metadata
    return true;
}
function genCheckboxModel(el, value, modifiers) {
    const number = modifiers && modifiers.number;
    const valueBinding = getBindingAttr(el, 'value') || 'null';
    const trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
    const falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
    addProp(el, 'checked', `Array.isArray(${value})` +
        `?_i(${value},${valueBinding})>-1` +
        (trueValueBinding === 'true'
            ? `:(${value})`
            : `:_q(${value},${trueValueBinding})`));
    addHandler(el, 'change', `var $$a=${value},` +
        '$$el=$event.target,' +
        `$$c=$$el.checked?(${trueValueBinding}):(${falseValueBinding});` +
        'if(Array.isArray($$a)){' +
        `var $$v=${number ? '_n(' + valueBinding + ')' : valueBinding},` +
        '$$i=_i($$a,$$v);' +
        `if($$el.checked){$$i<0&&(${genAssignmentCode(value, '$$a.concat([$$v])')})}` +
        `else{$$i>-1&&(${genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')})}` +
        `}else{${genAssignmentCode(value, '$$c')}}`, null, true);
}
function genRadioModel(el, value, modifiers) {
    const number = modifiers && modifiers.number;
    let valueBinding = getBindingAttr(el, 'value') || 'null';
    valueBinding = number ? `_n(${valueBinding})` : valueBinding;
    addProp(el, 'checked', `_q(${value},${valueBinding})`);
    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}
function genSelect(el, value, modifiers) {
    const number = modifiers && modifiers.number;
    const selectedVal = `Array.prototype.filter` +
        `.call($event.target.options,function(o){return o.selected})` +
        `.map(function(o){var val = "_value" in o ? o._value : o.value;` +
        `return ${number ? '_n(val)' : 'val'}})`;
    const assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
    let code = `var $$selectedVal = ${selectedVal};`;
    code = `${code} ${genAssignmentCode(value, assignment)}`;
    addHandler(el, 'change', code, null, true);
}
function genDefaultModel(el, value, modifiers) {
    const type = el.attrsMap.type;
    // warn if v-bind:value conflicts with v-model
    // except for inputs with v-bind:type
    {
        const value = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
        const typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
        if (value && !typeBinding) {
            const binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
            warn$1(`${binding}="${value}" conflicts with v-model on the same element ` +
                'because the latter already expands to a value binding internally', el.rawAttrsMap[binding]);
        }
    }
    const { lazy, number, trim } = modifiers || {};
    const needCompositionGuard = !lazy && type !== 'range';
    const event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';
    let valueExpression = '$event.target.value';
    if (trim) {
        valueExpression = `$event.target.value.trim()`;
    }
    if (number) {
        valueExpression = `_n(${valueExpression})`;
    }
    let code = genAssignmentCode(value, valueExpression);
    if (needCompositionGuard) {
        code = `if($event.target.composing)return;${code}`;
    }
    addProp(el, 'value', `(${value})`);
    addHandler(el, event, code, null, true);
    if (trim || number) {
        addHandler(el, 'blur', '$forceUpdate()');
    }
}

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
    /* istanbul ignore if */
    if (isDef(on[RANGE_TOKEN])) {
        // IE input[type=range] only supports `change` event
        const event = isIE ? 'change' : 'input';
        on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
        delete on[RANGE_TOKEN];
    }
    // This was originally intended to fix #4521 but no longer necessary
    // after 2.5. Keeping it for backwards compat with generated code from < 2.4
    /* istanbul ignore if */
    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
        on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
        delete on[CHECKBOX_RADIO_TOKEN];
    }
}
let target;
function createOnceHandler(event, handler, capture) {
    const _target = target; // save current target element in closure
    return function onceHandler() {
        const res = handler.apply(null, arguments);
        if (res !== null) {
            remove(event, onceHandler, capture, _target);
        }
    };
}
// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
const useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
function add(name, handler, capture, passive) {
    // async edge case #6566: inner click event triggers patch, event handler
    // attached to outer element during patch, and triggered again. This
    // happens because browsers fire microtask ticks between event propagation.
    // the solution is simple: we save the timestamp when a handler is attached,
    // and the handler would only fire if the event passed to it was fired
    // AFTER it was attached.
    if (useMicrotaskFix) {
        const attachedTimestamp = currentFlushTimestamp;
        const original = handler;
        //@ts-expect-error
        handler = original._wrapper = function (e) {
            if (
            // no bubbling, should always fire.
            // this is just a safety net in case event.timeStamp is unreliable in
            // certain weird environments...
            e.target === e.currentTarget ||
                // event is fired after handler attachment
                e.timeStamp >= attachedTimestamp ||
                // bail for environments that have buggy event.timeStamp implementations
                // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
                // #9681 QtWebEngine event.timeStamp is negative value
                e.timeStamp <= 0 ||
                // #9448 bail if event is fired in another document in a multi-page
                // electron/nw.js app, since event.timeStamp will be using a different
                // starting reference
                e.target.ownerDocument !== document) {
                return original.apply(this, arguments);
            }
        };
    }
    target.addEventListener(name, handler, supportsPassive ? { capture, passive } : capture);
}
function remove(name, handler, capture, _target) {
    (_target || target).removeEventListener(name, 
    //@ts-expect-error
    handler._wrapper || handler, capture);
}
function updateDOMListeners(oldVnode, vnode) {
    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
        return;
    }
    const on = vnode.data.on || {};
    const oldOn = oldVnode.data.on || {};
    // vnode is empty when removing all listeners,
    // and use old vnode dom element
    target = vnode.elm || oldVnode.elm;
    normalizeEvents(on);
    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);
    target = undefined;
}
var events = {
    create: updateDOMListeners,
    update: updateDOMListeners,
    // @ts-expect-error emptyNode has actually data
    destroy: (vnode) => updateDOMListeners(vnode, emptyNode)
};

let svgContainer;
function updateDOMProps(oldVnode, vnode) {
    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
        return;
    }
    let key, cur;
    const elm = vnode.elm;
    const oldProps = oldVnode.data.domProps || {};
    let props = vnode.data.domProps || {};
    // clone observed objects, as the user probably wants to mutate it
    if (isDef(props.__ob__) || isTrue(props._v_attr_proxy)) {
        props = vnode.data.domProps = extend({}, props);
    }
    for (key in oldProps) {
        if (!(key in props)) {
            elm[key] = '';
        }
    }
    for (key in props) {
        cur = props[key];
        // ignore children if the node has textContent or innerHTML,
        // as these will throw away existing DOM nodes and cause removal errors
        // on subsequent patches (#3360)
        if (key === 'textContent' || key === 'innerHTML') {
            if (vnode.children)
                vnode.children.length = 0;
            if (cur === oldProps[key])
                continue;
            // #6601 work around Chrome version <= 55 bug where single textNode
            // replaced by innerHTML/textContent retains its parentNode property
            if (elm.childNodes.length === 1) {
                elm.removeChild(elm.childNodes[0]);
            }
        }
        if (key === 'value' && elm.tagName !== 'PROGRESS') {
            // store value as _value as well since
            // non-string values will be stringified
            elm._value = cur;
            // avoid resetting cursor position when value is the same
            const strCur = isUndef(cur) ? '' : String(cur);
            if (shouldUpdateValue(elm, strCur)) {
                elm.value = strCur;
            }
        }
        else if (key === 'innerHTML' &&
            isSVG(elm.tagName) &&
            isUndef(elm.innerHTML)) {
            // IE doesn't support innerHTML for SVG elements
            svgContainer = svgContainer || document.createElement('div');
            svgContainer.innerHTML = `<svg>${cur}</svg>`;
            const svg = svgContainer.firstChild;
            while (elm.firstChild) {
                elm.removeChild(elm.firstChild);
            }
            while (svg.firstChild) {
                elm.appendChild(svg.firstChild);
            }
        }
        else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecessary `checked` update.
        cur !== oldProps[key]) {
            // some property updates can throw
            // e.g. `value` on <progress> w/ non-finite value
            try {
                elm[key] = cur;
            }
            catch (e) { }
        }
    }
}
function shouldUpdateValue(elm, checkVal) {
    return (
    //@ts-expect-error
    !elm.composing &&
        (elm.tagName === 'OPTION' ||
            isNotInFocusAndDirty(elm, checkVal) ||
            isDirtyWithModifiers(elm, checkVal)));
}
function isNotInFocusAndDirty(elm, checkVal) {
    // return true when textbox (.number and .trim) loses focus and its value is
    // not equal to the updated value
    let notInFocus = true;
    // #6157
    // work around IE bug when accessing document.activeElement in an iframe
    try {
        notInFocus = document.activeElement !== elm;
    }
    catch (e) { }
    return notInFocus && elm.value !== checkVal;
}
function isDirtyWithModifiers(elm, newVal) {
    const value = elm.value;
    const modifiers = elm._vModifiers; // injected by v-model runtime
    if (isDef(modifiers)) {
        if (modifiers.number) {
            return toNumber(value) !== toNumber(newVal);
        }
        if (modifiers.trim) {
            return value.trim() !== newVal.trim();
        }
    }
    return value !== newVal;
}
var domProps = {
    create: updateDOMProps,
    update: updateDOMProps
};

const parseStyleText = cached(function (cssText) {
    const res = {};
    const listDelimiter = /;(?![^(]*\))/g;
    const propertyDelimiter = /:(.+)/;
    cssText.split(listDelimiter).forEach(function (item) {
        if (item) {
            const tmp = item.split(propertyDelimiter);
            tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
        }
    });
    return res;
});
// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
    const style = normalizeStyleBinding(data.style);
    // static style is pre-processed into an object during compilation
    // and is always a fresh object, so it's safe to merge into it
    return data.staticStyle ? extend(data.staticStyle, style) : style;
}
// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
    if (Array.isArray(bindingStyle)) {
        return toObject(bindingStyle);
    }
    if (typeof bindingStyle === 'string') {
        return parseStyleText(bindingStyle);
    }
    return bindingStyle;
}
/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
    const res = {};
    let styleData;
    if (checkChild) {
        let childNode = vnode;
        while (childNode.componentInstance) {
            childNode = childNode.componentInstance._vnode;
            if (childNode &&
                childNode.data &&
                (styleData = normalizeStyleData(childNode.data))) {
                extend(res, styleData);
            }
        }
    }
    if ((styleData = normalizeStyleData(vnode.data))) {
        extend(res, styleData);
    }
    let parentNode = vnode;
    // @ts-expect-error parentNode.parent not VNodeWithData
    while ((parentNode = parentNode.parent)) {
        if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
            extend(res, styleData);
        }
    }
    return res;
}

const cssVarRE = /^--/;
const importantRE = /\s*!important$/;
const setProp = (el, name, val) => {
    /* istanbul ignore if */
    if (cssVarRE.test(name)) {
        el.style.setProperty(name, val);
    }
    else if (importantRE.test(val)) {
        el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
    }
    else {
        const normalizedName = normalize(name);
        if (Array.isArray(val)) {
            // Support values array created by autoprefixer, e.g.
            // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
            // Set them one by one, and the browser will only set those it can recognize
            for (let i = 0, len = val.length; i < len; i++) {
                el.style[normalizedName] = val[i];
            }
        }
        else {
            el.style[normalizedName] = val;
        }
    }
};
const vendorNames = ['Webkit', 'Moz', 'ms'];
let emptyStyle;
const normalize = cached(function (prop) {
    emptyStyle = emptyStyle || document.createElement('div').style;
    prop = camelize(prop);
    if (prop !== 'filter' && prop in emptyStyle) {
        return prop;
    }
    const capName = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (let i = 0; i < vendorNames.length; i++) {
        const name = vendorNames[i] + capName;
        if (name in emptyStyle) {
            return name;
        }
    }
});
function updateStyle(oldVnode, vnode) {
    const data = vnode.data;
    const oldData = oldVnode.data;
    if (isUndef(data.staticStyle) &&
        isUndef(data.style) &&
        isUndef(oldData.staticStyle) &&
        isUndef(oldData.style)) {
        return;
    }
    let cur, name;
    const el = vnode.elm;
    const oldStaticStyle = oldData.staticStyle;
    const oldStyleBinding = oldData.normalizedStyle || oldData.style || {};
    // if static style exists, stylebinding already merged into it when doing normalizeStyleData
    const oldStyle = oldStaticStyle || oldStyleBinding;
    const style = normalizeStyleBinding(vnode.data.style) || {};
    // store normalized style under a different key for next diff
    // make sure to clone it if it's reactive, since the user likely wants
    // to mutate it.
    vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;
    const newStyle = getStyle(vnode, true);
    for (name in oldStyle) {
        if (isUndef(newStyle[name])) {
            setProp(el, name, '');
        }
    }
    for (name in newStyle) {
        cur = newStyle[name];
        // ie9 setting to null has no effect, must use empty string
        setProp(el, name, cur == null ? '' : cur);
    }
}
var style$1 = {
    create: updateStyle,
    update: updateStyle
};

const whitespaceRE$1 = /\s+/;
/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE$1).forEach(c => el.classList.add(c));
        }
        else {
            el.classList.add(cls);
        }
    }
    else {
        const cur = ` ${el.getAttribute('class') || ''} `;
        if (cur.indexOf(' ' + cls + ' ') < 0) {
            el.setAttribute('class', (cur + cls).trim());
        }
    }
}
/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
    /* istanbul ignore if */
    if (!cls || !(cls = cls.trim())) {
        return;
    }
    /* istanbul ignore else */
    if (el.classList) {
        if (cls.indexOf(' ') > -1) {
            cls.split(whitespaceRE$1).forEach(c => el.classList.remove(c));
        }
        else {
            el.classList.remove(cls);
        }
        if (!el.classList.length) {
            el.removeAttribute('class');
        }
    }
    else {
        let cur = ` ${el.getAttribute('class') || ''} `;
        const tar = ' ' + cls + ' ';
        while (cur.indexOf(tar) >= 0) {
            cur = cur.replace(tar, ' ');
        }
        cur = cur.trim();
        if (cur) {
            el.setAttribute('class', cur);
        }
        else {
            el.removeAttribute('class');
        }
    }
}

function resolveTransition(def) {
    if (!def) {
        return;
    }
    /* istanbul ignore else */
    if (typeof def === 'object') {
        const res = {};
        if (def.css !== false) {
            extend(res, autoCssTransition(def.name || 'v'));
        }
        extend(res, def);
        return res;
    }
    else if (typeof def === 'string') {
        return autoCssTransition(def);
    }
}
const autoCssTransition = cached(name => {
    return {
        enterClass: `${name}-enter`,
        enterToClass: `${name}-enter-to`,
        enterActiveClass: `${name}-enter-active`,
        leaveClass: `${name}-leave`,
        leaveToClass: `${name}-leave-to`,
        leaveActiveClass: `${name}-leave-active`
    };
});
const hasTransition = inBrowser && !isIE9;
const TRANSITION = 'transition';
const ANIMATION = 'animation';
// Transition property/event sniffing
let transitionProp = 'transition';
let transitionEndEvent = 'transitionend';
let animationProp = 'animation';
let animationEndEvent = 'animationend';
if (hasTransition) {
    /* istanbul ignore if */
    if (window.ontransitionend === undefined &&
        window.onwebkittransitionend !== undefined) {
        transitionProp = 'WebkitTransition';
        transitionEndEvent = 'webkitTransitionEnd';
    }
    if (window.onanimationend === undefined &&
        window.onwebkitanimationend !== undefined) {
        animationProp = 'WebkitAnimation';
        animationEndEvent = 'webkitAnimationEnd';
    }
}
// binding to window is necessary to make hot reload work in IE in strict mode
const raf = inBrowser
    ? window.requestAnimationFrame
        ? window.requestAnimationFrame.bind(window)
        : setTimeout
    : /* istanbul ignore next */ /* istanbul ignore next */ fn => fn();
function nextFrame(fn) {
    raf(() => {
        // @ts-expect-error
        raf(fn);
    });
}
function addTransitionClass(el, cls) {
    const transitionClasses = el._transitionClasses || (el._transitionClasses = []);
    if (transitionClasses.indexOf(cls) < 0) {
        transitionClasses.push(cls);
        addClass(el, cls);
    }
}
function removeTransitionClass(el, cls) {
    if (el._transitionClasses) {
        remove$2(el._transitionClasses, cls);
    }
    removeClass(el, cls);
}
function whenTransitionEnds(el, expectedType, cb) {
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type)
        return cb();
    const event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
    let ended = 0;
    const end = () => {
        el.removeEventListener(event, onEnd);
        cb();
    };
    const onEnd = e => {
        if (e.target === el) {
            if (++ended >= propCount) {
                end();
            }
        }
    };
    setTimeout(() => {
        if (ended < propCount) {
            end();
        }
    }, timeout + 1);
    el.addEventListener(event, onEnd);
}
const transformRE = /\b(transform|all)(,|$)/;
function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    // JSDOM may return undefined for transition properties
    const transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
    const transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
    const animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type;
    let timeout = 0;
    let propCount = 0;
    /* istanbul ignore if */
    if (expectedType === TRANSITION) {
        if (transitionTimeout > 0) {
            type = TRANSITION;
            timeout = transitionTimeout;
            propCount = transitionDurations.length;
        }
    }
    else if (expectedType === ANIMATION) {
        if (animationTimeout > 0) {
            type = ANIMATION;
            timeout = animationTimeout;
            propCount = animationDurations.length;
        }
    }
    else {
        timeout = Math.max(transitionTimeout, animationTimeout);
        type =
            timeout > 0
                ? transitionTimeout > animationTimeout
                    ? TRANSITION
                    : ANIMATION
                : null;
        propCount = type
            ? type === TRANSITION
                ? transitionDurations.length
                : animationDurations.length
            : 0;
    }
    const hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
    return {
        type,
        timeout,
        propCount,
        hasTransform
    };
}
function getTimeout(delays, durations) {
    /* istanbul ignore next */
    while (delays.length < durations.length) {
        delays = delays.concat(delays);
    }
    return Math.max.apply(null, durations.map((d, i) => {
        return toMs(d) + toMs(delays[i]);
    }));
}
// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs(s) {
    return Number(s.slice(0, -1).replace(',', '.')) * 1000;
}

function enter(vnode, toggleDisplay) {
    const el = vnode.elm;
    // call leave callback now
    if (isDef(el._leaveCb)) {
        el._leaveCb.cancelled = true;
        el._leaveCb();
    }
    const data = resolveTransition(vnode.data.transition);
    if (isUndef(data)) {
        return;
    }
    /* istanbul ignore if */
    if (isDef(el._enterCb) || el.nodeType !== 1) {
        return;
    }
    const { css, type, enterClass, enterToClass, enterActiveClass, appearClass, appearToClass, appearActiveClass, beforeEnter, enter, afterEnter, enterCancelled, beforeAppear, appear, afterAppear, appearCancelled, duration } = data;
    // activeInstance will always be the <transition> component managing this
    // transition. One edge case to check is when the <transition> is placed
    // as the root node of a child component. In that case we need to check
    // <transition>'s parent for appear check.
    let context = activeInstance;
    let transitionNode = activeInstance.$vnode;
    while (transitionNode && transitionNode.parent) {
        context = transitionNode.context;
        transitionNode = transitionNode.parent;
    }
    const isAppear = !context._isMounted || !vnode.isRootInsert;
    if (isAppear && !appear && appear !== '') {
        return;
    }
    const startClass = isAppear && appearClass ? appearClass : enterClass;
    const activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
    const toClass = isAppear && appearToClass ? appearToClass : enterToClass;
    const beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
    const enterHook = isAppear ? (isFunction(appear) ? appear : enter) : enter;
    const afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
    const enterCancelledHook = isAppear
        ? appearCancelled || enterCancelled
        : enterCancelled;
    const explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);
    if (explicitEnterDuration != null) {
        checkDuration(explicitEnterDuration, 'enter', vnode);
    }
    const expectsCSS = css !== false && !isIE9;
    const userWantsControl = getHookArgumentsLength(enterHook);
    const cb = (el._enterCb = once(() => {
        if (expectsCSS) {
            removeTransitionClass(el, toClass);
            removeTransitionClass(el, activeClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, startClass);
            }
            enterCancelledHook && enterCancelledHook(el);
        }
        else {
            afterEnterHook && afterEnterHook(el);
        }
        el._enterCb = null;
    }));
    if (!vnode.data.show) {
        // remove pending leave element on enter by injecting an insert hook
        mergeVNodeHook(vnode, 'insert', () => {
            const parent = el.parentNode;
            const pendingNode = parent && parent._pending && parent._pending[vnode.key];
            if (pendingNode &&
                pendingNode.tag === vnode.tag &&
                pendingNode.elm._leaveCb) {
                pendingNode.elm._leaveCb();
            }
            enterHook && enterHook(el, cb);
        });
    }
    // start enter transition
    beforeEnterHook && beforeEnterHook(el);
    if (expectsCSS) {
        addTransitionClass(el, startClass);
        addTransitionClass(el, activeClass);
        nextFrame(() => {
            removeTransitionClass(el, startClass);
            // @ts-expect-error
            if (!cb.cancelled) {
                addTransitionClass(el, toClass);
                if (!userWantsControl) {
                    if (isValidDuration(explicitEnterDuration)) {
                        setTimeout(cb, explicitEnterDuration);
                    }
                    else {
                        whenTransitionEnds(el, type, cb);
                    }
                }
            }
        });
    }
    if (vnode.data.show) {
        toggleDisplay && toggleDisplay();
        enterHook && enterHook(el, cb);
    }
    if (!expectsCSS && !userWantsControl) {
        cb();
    }
}
function leave(vnode, rm) {
    const el = vnode.elm;
    // call enter callback now
    if (isDef(el._enterCb)) {
        el._enterCb.cancelled = true;
        el._enterCb();
    }
    const data = resolveTransition(vnode.data.transition);
    if (isUndef(data) || el.nodeType !== 1) {
        return rm();
    }
    /* istanbul ignore if */
    if (isDef(el._leaveCb)) {
        return;
    }
    const { css, type, leaveClass, leaveToClass, leaveActiveClass, beforeLeave, leave, afterLeave, leaveCancelled, delayLeave, duration } = data;
    const expectsCSS = css !== false && !isIE9;
    const userWantsControl = getHookArgumentsLength(leave);
    const explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);
    if (isDef(explicitLeaveDuration)) {
        checkDuration(explicitLeaveDuration, 'leave', vnode);
    }
    const cb = (el._leaveCb = once(() => {
        if (el.parentNode && el.parentNode._pending) {
            el.parentNode._pending[vnode.key] = null;
        }
        if (expectsCSS) {
            removeTransitionClass(el, leaveToClass);
            removeTransitionClass(el, leaveActiveClass);
        }
        // @ts-expect-error
        if (cb.cancelled) {
            if (expectsCSS) {
                removeTransitionClass(el, leaveClass);
            }
            leaveCancelled && leaveCancelled(el);
        }
        else {
            rm();
            afterLeave && afterLeave(el);
        }
        el._leaveCb = null;
    }));
    if (delayLeave) {
        delayLeave(performLeave);
    }
    else {
        performLeave();
    }
    function performLeave() {
        // the delayed leave may have already been cancelled
        // @ts-expect-error
        if (cb.cancelled) {
            return;
        }
        // record leaving element
        if (!vnode.data.show && el.parentNode) {
            (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] =
                vnode;
        }
        beforeLeave && beforeLeave(el);
        if (expectsCSS) {
            addTransitionClass(el, leaveClass);
            addTransitionClass(el, leaveActiveClass);
            nextFrame(() => {
                removeTransitionClass(el, leaveClass);
                // @ts-expect-error
                if (!cb.cancelled) {
                    addTransitionClass(el, leaveToClass);
                    if (!userWantsControl) {
                        if (isValidDuration(explicitLeaveDuration)) {
                            setTimeout(cb, explicitLeaveDuration);
                        }
                        else {
                            whenTransitionEnds(el, type, cb);
                        }
                    }
                }
            });
        }
        leave && leave(el, cb);
        if (!expectsCSS && !userWantsControl) {
            cb();
        }
    }
}
// only used in dev mode
function checkDuration(val, name, vnode) {
    if (typeof val !== 'number') {
        warn$2(`<transition> explicit ${name} duration is not a valid number - ` +
            `got ${JSON.stringify(val)}.`, vnode.context);
    }
    else if (isNaN(val)) {
        warn$2(`<transition> explicit ${name} duration is NaN - ` +
            'the duration expression might be incorrect.', vnode.context);
    }
}
function isValidDuration(val) {
    return typeof val === 'number' && !isNaN(val);
}
/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
    if (isUndef(fn)) {
        return false;
    }
    // @ts-expect-error
    const invokerFns = fn.fns;
    if (isDef(invokerFns)) {
        // invoker
        return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
    }
    else {
        // @ts-expect-error
        return (fn._length || fn.length) > 1;
    }
}
function _enter(_, vnode) {
    if (vnode.data.show !== true) {
        enter(vnode);
    }
}
var transition = inBrowser
    ? {
        create: _enter,
        activate: _enter,
        remove(vnode, rm) {
            /* istanbul ignore else */
            if (vnode.data.show !== true) {
                // @ts-expect-error
                leave(vnode, rm);
            }
            else {
                rm();
            }
        }
    }
    : {};

var platformModules = [attrs, klass$1, events, domProps, style$1, transition];

// the directive module should be applied last, after all
// built-in modules have been applied.
const modules$1 = platformModules.concat(baseModules);
const patch = createPatchFunction({ nodeOps, modules: modules$1 });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */
/* istanbul ignore if */
if (isIE9) {
    // http://www.matts411.com/post/internet-explorer-9-oninput/
    document.addEventListener('selectionchange', () => {
        const el = document.activeElement;
        // @ts-expect-error
        if (el && el.vmodel) {
            trigger(el, 'input');
        }
    });
}
const directive = {
    inserted(el, binding, vnode, oldVnode) {
        if (vnode.tag === 'select') {
            // #6903
            if (oldVnode.elm && !oldVnode.elm._vOptions) {
                mergeVNodeHook(vnode, 'postpatch', () => {
                    directive.componentUpdated(el, binding, vnode);
                });
            }
            else {
                setSelected(el, binding, vnode.context);
            }
            el._vOptions = [].map.call(el.options, getValue);
        }
        else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
            el._vModifiers = binding.modifiers;
            if (!binding.modifiers.lazy) {
                el.addEventListener('compositionstart', onCompositionStart);
                el.addEventListener('compositionend', onCompositionEnd);
                // Safari < 10.2 & UIWebView doesn't fire compositionend when
                // switching focus before confirming composition choice
                // this also fixes the issue where some browsers e.g. iOS Chrome
                // fires "change" instead of "input" on autocomplete.
                el.addEventListener('change', onCompositionEnd);
                /* istanbul ignore if */
                if (isIE9) {
                    el.vmodel = true;
                }
            }
        }
    },
    componentUpdated(el, binding, vnode) {
        if (vnode.tag === 'select') {
            setSelected(el, binding, vnode.context);
            // in case the options rendered by v-for have changed,
            // it's possible that the value is out-of-sync with the rendered options.
            // detect such cases and filter out values that no longer has a matching
            // option in the DOM.
            const prevOptions = el._vOptions;
            const curOptions = (el._vOptions = [].map.call(el.options, getValue));
            if (curOptions.some((o, i) => !looseEqual(o, prevOptions[i]))) {
                // trigger change event if
                // no matching option found for at least one value
                const needReset = el.multiple
                    ? binding.value.some(v => hasNoMatchingOption(v, curOptions))
                    : binding.value !== binding.oldValue &&
                        hasNoMatchingOption(binding.value, curOptions);
                if (needReset) {
                    trigger(el, 'change');
                }
            }
        }
    }
};
function setSelected(el, binding, vm) {
    actuallySetSelected(el, binding, vm);
    /* istanbul ignore if */
    if (isIE || isEdge) {
        setTimeout(() => {
            actuallySetSelected(el, binding, vm);
        }, 0);
    }
}
function actuallySetSelected(el, binding, vm) {
    const value = binding.value;
    const isMultiple = el.multiple;
    if (isMultiple && !Array.isArray(value)) {
        warn$2(`<select multiple v-model="${binding.expression}"> ` +
                `expects an Array value for its binding, but got ${Object.prototype.toString
                    .call(value)
                    .slice(8, -1)}`, vm);
        return;
    }
    let selected, option;
    for (let i = 0, l = el.options.length; i < l; i++) {
        option = el.options[i];
        if (isMultiple) {
            selected = looseIndexOf(value, getValue(option)) > -1;
            if (option.selected !== selected) {
                option.selected = selected;
            }
        }
        else {
            if (looseEqual(getValue(option), value)) {
                if (el.selectedIndex !== i) {
                    el.selectedIndex = i;
                }
                return;
            }
        }
    }
    if (!isMultiple) {
        el.selectedIndex = -1;
    }
}
function hasNoMatchingOption(value, options) {
    return options.every(o => !looseEqual(o, value));
}
function getValue(option) {
    return '_value' in option ? option._value : option.value;
}
function onCompositionStart(e) {
    e.target.composing = true;
}
function onCompositionEnd(e) {
    // prevent triggering an input event for no reason
    if (!e.target.composing)
        return;
    e.target.composing = false;
    trigger(e.target, 'input');
}
function trigger(el, type) {
    const e = document.createEvent('HTMLEvents');
    e.initEvent(type, true, true);
    el.dispatchEvent(e);
}

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
    // @ts-expect-error
    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
        ? locateNode(vnode.componentInstance._vnode)
        : vnode;
}
var show = {
    bind(el, { value }, vnode) {
        vnode = locateNode(vnode);
        const transition = vnode.data && vnode.data.transition;
        const originalDisplay = (el.__vOriginalDisplay =
            el.style.display === 'none' ? '' : el.style.display);
        if (value && transition) {
            vnode.data.show = true;
            enter(vnode, () => {
                el.style.display = originalDisplay;
            });
        }
        else {
            el.style.display = value ? originalDisplay : 'none';
        }
    },
    update(el, { value, oldValue }, vnode) {
        /* istanbul ignore if */
        if (!value === !oldValue)
            return;
        vnode = locateNode(vnode);
        const transition = vnode.data && vnode.data.transition;
        if (transition) {
            vnode.data.show = true;
            if (value) {
                enter(vnode, () => {
                    el.style.display = el.__vOriginalDisplay;
                });
            }
            else {
                leave(vnode, () => {
                    el.style.display = 'none';
                });
            }
        }
        else {
            el.style.display = value ? el.__vOriginalDisplay : 'none';
        }
    },
    unbind(el, binding, vnode, oldVnode, isDestroy) {
        if (!isDestroy) {
            el.style.display = el.__vOriginalDisplay;
        }
    }
};

var platformDirectives = {
    model: directive,
    show
};

// Provides transition support for a single element/component.
const transitionProps = {
    name: String,
    appear: Boolean,
    css: Boolean,
    mode: String,
    type: String,
    enterClass: String,
    leaveClass: String,
    enterToClass: String,
    leaveToClass: String,
    enterActiveClass: String,
    leaveActiveClass: String,
    appearClass: String,
    appearActiveClass: String,
    appearToClass: String,
    duration: [Number, String, Object]
};
// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
    const compOptions = vnode && vnode.componentOptions;
    if (compOptions && compOptions.Ctor.options.abstract) {
        return getRealChild(getFirstComponentChild(compOptions.children));
    }
    else {
        return vnode;
    }
}
function extractTransitionData(comp) {
    const data = {};
    const options = comp.$options;
    // props
    for (const key in options.propsData) {
        data[key] = comp[key];
    }
    // events.
    // extract listeners and pass them directly to the transition methods
    const listeners = options._parentListeners;
    for (const key in listeners) {
        data[camelize(key)] = listeners[key];
    }
    return data;
}
function placeholder(h, rawChild) {
    // @ts-expect-error
    if (/\d-keep-alive$/.test(rawChild.tag)) {
        return h('keep-alive', {
            props: rawChild.componentOptions.propsData
        });
    }
}
function hasParentTransition(vnode) {
    while ((vnode = vnode.parent)) {
        if (vnode.data.transition) {
            return true;
        }
    }
}
function isSameChild(child, oldChild) {
    return oldChild.key === child.key && oldChild.tag === child.tag;
}
const isNotTextNode = (c) => c.tag || isAsyncPlaceholder(c);
const isVShowDirective = d => d.name === 'show';
var Transition = {
    name: 'transition',
    props: transitionProps,
    abstract: true,
    render(h) {
        let children = this.$slots.default;
        if (!children) {
            return;
        }
        // filter out text nodes (possible whitespaces)
        children = children.filter(isNotTextNode);
        /* istanbul ignore if */
        if (!children.length) {
            return;
        }
        // warn multiple elements
        if (children.length > 1) {
            warn$2('<transition> can only be used on a single element. Use ' +
                '<transition-group> for lists.', this.$parent);
        }
        const mode = this.mode;
        // warn invalid mode
        if (mode && mode !== 'in-out' && mode !== 'out-in') {
            warn$2('invalid <transition> mode: ' + mode, this.$parent);
        }
        const rawChild = children[0];
        // if this is a component root node and the component's
        // parent container node also has transition, skip.
        if (hasParentTransition(this.$vnode)) {
            return rawChild;
        }
        // apply transition data to child
        // use getRealChild() to ignore abstract components e.g. keep-alive
        const child = getRealChild(rawChild);
        /* istanbul ignore if */
        if (!child) {
            return rawChild;
        }
        if (this._leaving) {
            return placeholder(h, rawChild);
        }
        // ensure a key that is unique to the vnode type and to this transition
        // component instance. This key will be used to remove pending leaving nodes
        // during entering.
        const id = `__transition-${this._uid}-`;
        child.key =
            child.key == null
                ? child.isComment
                    ? id + 'comment'
                    : id + child.tag
                : isPrimitive(child.key)
                    ? String(child.key).indexOf(id) === 0
                        ? child.key
                        : id + child.key
                    : child.key;
        const data = ((child.data || (child.data = {})).transition =
            extractTransitionData(this));
        const oldRawChild = this._vnode;
        const oldChild = getRealChild(oldRawChild);
        // mark v-show
        // so that the transition module can hand over the control to the directive
        if (child.data.directives && child.data.directives.some(isVShowDirective)) {
            child.data.show = true;
        }
        if (oldChild &&
            oldChild.data &&
            !isSameChild(child, oldChild) &&
            !isAsyncPlaceholder(oldChild) &&
            // #6687 component root is a comment node
            !(oldChild.componentInstance &&
                oldChild.componentInstance._vnode.isComment)) {
            // replace old child transition data with fresh one
            // important for dynamic transitions!
            const oldData = (oldChild.data.transition = extend({}, data));
            // handle transition mode
            if (mode === 'out-in') {
                // return placeholder node and queue update when leave finishes
                this._leaving = true;
                mergeVNodeHook(oldData, 'afterLeave', () => {
                    this._leaving = false;
                    this.$forceUpdate();
                });
                return placeholder(h, rawChild);
            }
            else if (mode === 'in-out') {
                if (isAsyncPlaceholder(child)) {
                    return oldRawChild;
                }
                let delayedLeave;
                const performLeave = () => {
                    delayedLeave();
                };
                mergeVNodeHook(data, 'afterEnter', performLeave);
                mergeVNodeHook(data, 'enterCancelled', performLeave);
                mergeVNodeHook(oldData, 'delayLeave', leave => {
                    delayedLeave = leave;
                });
            }
        }
        return rawChild;
    }
};

// Provides transition support for list items.
const props = extend({
    tag: String,
    moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
    props,
    beforeMount() {
        const update = this._update;
        this._update = (vnode, hydrating) => {
            const restoreActiveInstance = setActiveInstance(this);
            // force removing pass
            this.__patch__(this._vnode, this.kept, false, // hydrating
            true // removeOnly (!important, avoids unnecessary moves)
            );
            this._vnode = this.kept;
            restoreActiveInstance();
            update.call(this, vnode, hydrating);
        };
    },
    render(h) {
        const tag = this.tag || this.$vnode.data.tag || 'span';
        const map = Object.create(null);
        const prevChildren = (this.prevChildren = this.children);
        const rawChildren = this.$slots.default || [];
        const children = (this.children = []);
        const transitionData = extractTransitionData(this);
        for (let i = 0; i < rawChildren.length; i++) {
            const c = rawChildren[i];
            if (c.tag) {
                if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
                    children.push(c);
                    map[c.key] = c;
                    (c.data || (c.data = {})).transition = transitionData;
                }
                else {
                    const opts = c.componentOptions;
                    const name = opts
                        ? getComponentName(opts.Ctor.options) || opts.tag || ''
                        : c.tag;
                    warn$2(`<transition-group> children must be keyed: <${name}>`);
                }
            }
        }
        if (prevChildren) {
            const kept = [];
            const removed = [];
            for (let i = 0; i < prevChildren.length; i++) {
                const c = prevChildren[i];
                c.data.transition = transitionData;
                // @ts-expect-error .getBoundingClientRect is not typed in Node
                c.data.pos = c.elm.getBoundingClientRect();
                if (map[c.key]) {
                    kept.push(c);
                }
                else {
                    removed.push(c);
                }
            }
            this.kept = h(tag, null, kept);
            this.removed = removed;
        }
        return h(tag, null, children);
    },
    updated() {
        const children = this.prevChildren;
        const moveClass = this.moveClass || (this.name || 'v') + '-move';
        if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
            return;
        }
        // we divide the work into three loops to avoid mixing DOM reads and writes
        // in each iteration - which helps prevent layout thrashing.
        children.forEach(callPendingCbs);
        children.forEach(recordPosition);
        children.forEach(applyTranslation);
        // force reflow to put everything in position
        // assign to this to avoid being removed in tree-shaking
        // $flow-disable-line
        this._reflow = document.body.offsetHeight;
        children.forEach((c) => {
            if (c.data.moved) {
                const el = c.elm;
                const s = el.style;
                addTransitionClass(el, moveClass);
                s.transform = s.WebkitTransform = s.transitionDuration = '';
                el.addEventListener(transitionEndEvent, (el._moveCb = function cb(e) {
                    if (e && e.target !== el) {
                        return;
                    }
                    if (!e || /transform$/.test(e.propertyName)) {
                        el.removeEventListener(transitionEndEvent, cb);
                        el._moveCb = null;
                        removeTransitionClass(el, moveClass);
                    }
                }));
            }
        });
    },
    methods: {
        hasMove(el, moveClass) {
            /* istanbul ignore if */
            if (!hasTransition) {
                return false;
            }
            /* istanbul ignore if */
            if (this._hasMove) {
                return this._hasMove;
            }
            // Detect whether an element with the move class applied has
            // CSS transitions. Since the element may be inside an entering
            // transition at this very moment, we make a clone of it and remove
            // all other transition classes applied to ensure only the move class
            // is applied.
            const clone = el.cloneNode();
            if (el._transitionClasses) {
                el._transitionClasses.forEach((cls) => {
                    removeClass(clone, cls);
                });
            }
            addClass(clone, moveClass);
            clone.style.display = 'none';
            this.$el.appendChild(clone);
            const info = getTransitionInfo(clone);
            this.$el.removeChild(clone);
            return (this._hasMove = info.hasTransform);
        }
    }
};
function callPendingCbs(c) {
    /* istanbul ignore if */
    if (c.elm._moveCb) {
        c.elm._moveCb();
    }
    /* istanbul ignore if */
    if (c.elm._enterCb) {
        c.elm._enterCb();
    }
}
function recordPosition(c) {
    c.data.newPos = c.elm.getBoundingClientRect();
}
function applyTranslation(c) {
    const oldPos = c.data.pos;
    const newPos = c.data.newPos;
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
        c.data.moved = true;
        const s = c.elm.style;
        s.transform = s.WebkitTransform = `translate(${dx}px,${dy}px)`;
        s.transitionDuration = '0s';
    }
}

var platformComponents = {
    Transition,
    TransitionGroup
};

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;
// public mount method
Vue.prototype.$mount = function (el, hydrating) {
    el = el && inBrowser ? query(el) : undefined;
    return mountComponent(this, el, hydrating);
};
// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
    setTimeout(() => {
        if (config.devtools) {
            if (devtools) {
                devtools.emit('init', Vue);
            }
            else {
                // @ts-expect-error
                console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' +
                    'https://github.com/vuejs/vue-devtools');
            }
        }
        if (config.productionTip !== false &&
            typeof console !== 'undefined') {
            // @ts-expect-error
            console[console.info ? 'info' : 'log'](`You are running Vue in development mode.\n` +
                `Make sure to turn on production mode when deploying for production.\n` +
                `See more tips at https://vuejs.org/guide/deployment.html`);
        }
    }, 0);
}

const defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g;
const regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
const buildRegex = cached(delimiters => {
    const open = delimiters[0].replace(regexEscapeRE, '\\$&');
    const close = delimiters[1].replace(regexEscapeRE, '\\$&');
    return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});
function parseText(text, delimiters) {
    //@ts-expect-error
    const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
    if (!tagRE.test(text)) {
        return;
    }
    const tokens = [];
    const rawTokens = [];
    let lastIndex = (tagRE.lastIndex = 0);
    let match, index, tokenValue;
    while ((match = tagRE.exec(text))) {
        index = match.index;
        // push text token
        if (index > lastIndex) {
            rawTokens.push((tokenValue = text.slice(lastIndex, index)));
            tokens.push(JSON.stringify(tokenValue));
        }
        // tag token
        const exp = parseFilters(match[1].trim());
        tokens.push(`_s(${exp})`);
        rawTokens.push({ '@binding': exp });
        lastIndex = index + match[0].length;
    }
    if (lastIndex < text.length) {
        rawTokens.push((tokenValue = text.slice(lastIndex)));
        tokens.push(JSON.stringify(tokenValue));
    }
    return {
        expression: tokens.join('+'),
        tokens: rawTokens
    };
}

function transformNode$1(el, options) {
    const warn = options.warn || baseWarn;
    const staticClass = getAndRemoveAttr(el, 'class');
    if (staticClass) {
        const res = parseText(staticClass, options.delimiters);
        if (res) {
            warn(`class="${staticClass}": ` +
                'Interpolation inside attributes has been removed. ' +
                'Use v-bind or the colon shorthand instead. For example, ' +
                'instead of <div class="{{ val }}">, use <div :class="val">.', el.rawAttrsMap['class']);
        }
    }
    if (staticClass) {
        el.staticClass = JSON.stringify(staticClass.replace(/\s+/g, ' ').trim());
    }
    const classBinding = getBindingAttr(el, 'class', false /* getStatic */);
    if (classBinding) {
        el.classBinding = classBinding;
    }
}
function genData$2(el) {
    let data = '';
    if (el.staticClass) {
        data += `staticClass:${el.staticClass},`;
    }
    if (el.classBinding) {
        data += `class:${el.classBinding},`;
    }
    return data;
}
var klass = {
    staticKeys: ['staticClass'],
    transformNode: transformNode$1,
    genData: genData$2
};

function transformNode(el, options) {
    const warn = options.warn || baseWarn;
    const staticStyle = getAndRemoveAttr(el, 'style');
    if (staticStyle) {
        /* istanbul ignore if */
        {
            const res = parseText(staticStyle, options.delimiters);
            if (res) {
                warn(`style="${staticStyle}": ` +
                    'Interpolation inside attributes has been removed. ' +
                    'Use v-bind or the colon shorthand instead. For example, ' +
                    'instead of <div style="{{ val }}">, use <div :style="val">.', el.rawAttrsMap['style']);
            }
        }
        el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
    }
    const styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
    if (styleBinding) {
        el.styleBinding = styleBinding;
    }
}
function genData$1(el) {
    let data = '';
    if (el.staticStyle) {
        data += `staticStyle:${el.staticStyle},`;
    }
    if (el.styleBinding) {
        data += `style:(${el.styleBinding}),`;
    }
    return data;
}
var style = {
    staticKeys: ['staticStyle'],
    transformNode,
    genData: genData$1
};

let decoder;
var he = {
    decode(html) {
        decoder = decoder || document.createElement('div');
        decoder.innerHTML = html;
        return decoder.textContent;
    }
};

const isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
    'link,meta,param,source,track,wbr');
// Elements that you can, intentionally, leave open
// (and which close themselves)
const canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');
// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
const isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
    'title,tr,track');

/**
 * Not type-checking this file because it's mostly vendor code.
 */
// Regular Expressions for parsing tags and attributes
const attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
const dynamicArgAttribute = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
const ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z${unicodeRegExp.source}]*`;
const qnameCapture = `((?:${ncname}\\:)?${ncname})`;
const startTagOpen = new RegExp(`^<${qnameCapture}`);
const startTagClose = /^\s*(\/?)>/;
const endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`);
const doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being passed as HTML comment when inlined in page
const comment = /^<!\--/;
const conditionalComment = /^<!\[/;
// Special Elements (can contain anything)
const isPlainTextElement = makeMap('script,style,textarea', true);
const reCache = {};
const decodingMap = {
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&amp;': '&',
    '&#10;': '\n',
    '&#9;': '\t',
    '&#39;': "'"
};
const encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;
const encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;
// #5992
const isIgnoreNewlineTag = makeMap('pre,textarea', true);
const shouldIgnoreFirstNewline = (tag, html) => tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
function decodeAttr(value, shouldDecodeNewlines) {
    const re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
    return value.replace(re, match => decodingMap[match]);
}
function parseHTML(html, options) {
    const stack = [];
    const expectHTML = options.expectHTML;
    const isUnaryTag = options.isUnaryTag || no;
    const canBeLeftOpenTag = options.canBeLeftOpenTag || no;
    let index = 0;
    let last, lastTag;
    while (html) {
        last = html;
        // Make sure we're not in a plaintext content element like script/style
        if (!lastTag || !isPlainTextElement(lastTag)) {
            let textEnd = html.indexOf('<');
            if (textEnd === 0) {
                // Comment:
                if (comment.test(html)) {
                    const commentEnd = html.indexOf('-->');
                    if (commentEnd >= 0) {
                        if (options.shouldKeepComment && options.comment) {
                            options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);
                        }
                        advance(commentEnd + 3);
                        continue;
                    }
                }
                // https://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
                if (conditionalComment.test(html)) {
                    const conditionalEnd = html.indexOf(']>');
                    if (conditionalEnd >= 0) {
                        advance(conditionalEnd + 2);
                        continue;
                    }
                }
                // Doctype:
                const doctypeMatch = html.match(doctype);
                if (doctypeMatch) {
                    advance(doctypeMatch[0].length);
                    continue;
                }
                // End tag:
                const endTagMatch = html.match(endTag);
                if (endTagMatch) {
                    const curIndex = index;
                    advance(endTagMatch[0].length);
                    parseEndTag(endTagMatch[1], curIndex, index);
                    continue;
                }
                // Start tag:
                const startTagMatch = parseStartTag();
                if (startTagMatch) {
                    handleStartTag(startTagMatch);
                    if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {
                        advance(1);
                    }
                    continue;
                }
            }
            let text, rest, next;
            if (textEnd >= 0) {
                rest = html.slice(textEnd);
                while (!endTag.test(rest) &&
                    !startTagOpen.test(rest) &&
                    !comment.test(rest) &&
                    !conditionalComment.test(rest)) {
                    // < in plain text, be forgiving and treat it as text
                    next = rest.indexOf('<', 1);
                    if (next < 0)
                        break;
                    textEnd += next;
                    rest = html.slice(textEnd);
                }
                text = html.substring(0, textEnd);
            }
            if (textEnd < 0) {
                text = html;
            }
            if (text) {
                advance(text.length);
            }
            if (options.chars && text) {
                options.chars(text, index - text.length, index);
            }
        }
        else {
            let endTagLength = 0;
            const stackedTag = lastTag.toLowerCase();
            const reStackedTag = reCache[stackedTag] ||
                (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
            const rest = html.replace(reStackedTag, function (all, text, endTag) {
                endTagLength = endTag.length;
                if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
                    text = text
                        .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
                        .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
                }
                if (shouldIgnoreFirstNewline(stackedTag, text)) {
                    text = text.slice(1);
                }
                if (options.chars) {
                    options.chars(text);
                }
                return '';
            });
            index += html.length - rest.length;
            html = rest;
            parseEndTag(stackedTag, index - endTagLength, index);
        }
        if (html === last) {
            options.chars && options.chars(html);
            if (!stack.length && options.warn) {
                options.warn(`Mal-formatted tag at end of template: "${html}"`, {
                    start: index + html.length
                });
            }
            break;
        }
    }
    // Clean up any remaining tags
    parseEndTag();
    function advance(n) {
        index += n;
        html = html.substring(n);
    }
    function parseStartTag() {
        const start = html.match(startTagOpen);
        if (start) {
            const match = {
                tagName: start[1],
                attrs: [],
                start: index
            };
            advance(start[0].length);
            let end, attr;
            while (!(end = html.match(startTagClose)) &&
                (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {
                attr.start = index;
                advance(attr[0].length);
                attr.end = index;
                match.attrs.push(attr);
            }
            if (end) {
                match.unarySlash = end[1];
                advance(end[0].length);
                match.end = index;
                return match;
            }
        }
    }
    function handleStartTag(match) {
        const tagName = match.tagName;
        const unarySlash = match.unarySlash;
        if (expectHTML) {
            if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
                parseEndTag(lastTag);
            }
            if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
                parseEndTag(tagName);
            }
        }
        const unary = isUnaryTag(tagName) || !!unarySlash;
        const l = match.attrs.length;
        const attrs = new Array(l);
        for (let i = 0; i < l; i++) {
            const args = match.attrs[i];
            const value = args[3] || args[4] || args[5] || '';
            const shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
                ? options.shouldDecodeNewlinesForHref
                : options.shouldDecodeNewlines;
            attrs[i] = {
                name: args[1],
                value: decodeAttr(value, shouldDecodeNewlines)
            };
            if (options.outputSourceRange) {
                attrs[i].start = args.start + args[0].match(/^\s*/).length;
                attrs[i].end = args.end;
            }
        }
        if (!unary) {
            stack.push({
                tag: tagName,
                lowerCasedTag: tagName.toLowerCase(),
                attrs: attrs,
                start: match.start,
                end: match.end
            });
            lastTag = tagName;
        }
        if (options.start) {
            options.start(tagName, attrs, unary, match.start, match.end);
        }
    }
    function parseEndTag(tagName, start, end) {
        let pos, lowerCasedTagName;
        if (start == null)
            start = index;
        if (end == null)
            end = index;
        // Find the closest opened tag of the same type
        if (tagName) {
            lowerCasedTagName = tagName.toLowerCase();
            for (pos = stack.length - 1; pos >= 0; pos--) {
                if (stack[pos].lowerCasedTag === lowerCasedTagName) {
                    break;
                }
            }
        }
        else {
            // If no tag name is provided, clean shop
            pos = 0;
        }
        if (pos >= 0) {
            // Close all the open elements, up the stack
            for (let i = stack.length - 1; i >= pos; i--) {
                if ((i > pos || !tagName) && options.warn) {
                    options.warn(`tag <${stack[i].tag}> has no matching end tag.`, {
                        start: stack[i].start,
                        end: stack[i].end
                    });
                }
                if (options.end) {
                    options.end(stack[i].tag, start, end);
                }
            }
            // Remove the open elements from the stack
            stack.length = pos;
            lastTag = pos && stack[pos - 1].tag;
        }
        else if (lowerCasedTagName === 'br') {
            if (options.start) {
                options.start(tagName, [], true, start, end);
            }
        }
        else if (lowerCasedTagName === 'p') {
            if (options.start) {
                options.start(tagName, [], false, start, end);
            }
            if (options.end) {
                options.end(tagName, start, end);
            }
        }
    }
}

const onRE = /^@|^v-on:/;
const dirRE = /^v-|^@|^:|^#/;
const forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
const forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
const stripParensRE = /^\(|\)$/g;
const dynamicArgRE = /^\[.*\]$/;
const argRE = /:(.*)$/;
const bindRE = /^:|^\.|^v-bind:/;
const modifierRE = /\.[^.\]]+(?=[^\]]*$)/g;
const slotRE = /^v-slot(:|$)|^#/;
const lineBreakRE = /[\r\n]/;
const whitespaceRE = /[ \f\t\r\n]+/g;
const invalidAttributeRE = /[\s"'<>\/=]/;
const decodeHTMLCached = cached(he.decode);
const emptySlotScopeToken = `_empty_`;
// configurable state
let warn;
let delimiters;
let transforms;
let preTransforms;
let postTransforms;
let platformIsPreTag;
let platformMustUseProp;
let platformGetTagNamespace;
let maybeComponent;
function createASTElement(tag, attrs, parent) {
    return {
        type: 1,
        tag,
        attrsList: attrs,
        attrsMap: makeAttrsMap(attrs),
        rawAttrsMap: {},
        parent,
        children: []
    };
}
/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
    warn = options.warn || baseWarn;
    platformIsPreTag = options.isPreTag || no;
    platformMustUseProp = options.mustUseProp || no;
    platformGetTagNamespace = options.getTagNamespace || no;
    const isReservedTag = options.isReservedTag || no;
    maybeComponent = (el) => !!(el.component ||
        el.attrsMap[':is'] ||
        el.attrsMap['v-bind:is'] ||
        !(el.attrsMap.is ? isReservedTag(el.attrsMap.is) : isReservedTag(el.tag)));
    transforms = pluckModuleFunction(options.modules, 'transformNode');
    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
    delimiters = options.delimiters;
    const stack = [];
    const preserveWhitespace = options.preserveWhitespace !== false;
    const whitespaceOption = options.whitespace;
    let root;
    let currentParent;
    let inVPre = false;
    let inPre = false;
    let warned = false;
    function warnOnce(msg, range) {
        if (!warned) {
            warned = true;
            warn(msg, range);
        }
    }
    function closeElement(element) {
        trimEndingWhitespace(element);
        if (!inVPre && !element.processed) {
            element = processElement(element, options);
        }
        // tree management
        if (!stack.length && element !== root) {
            // allow root elements with v-if, v-else-if and v-else
            if (root.if && (element.elseif || element.else)) {
                {
                    checkRootConstraints(element);
                }
                addIfCondition(root, {
                    exp: element.elseif,
                    block: element
                });
            }
            else {
                warnOnce(`Component template should contain exactly one root element. ` +
                    `If you are using v-if on multiple elements, ` +
                    `use v-else-if to chain them instead.`, { start: element.start });
            }
        }
        if (currentParent && !element.forbidden) {
            if (element.elseif || element.else) {
                processIfConditions(element, currentParent);
            }
            else {
                if (element.slotScope) {
                    // scoped slot
                    // keep it in the children list so that v-else(-if) conditions can
                    // find it as the prev node.
                    const name = element.slotTarget || '"default"';
                    (currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
                }
                currentParent.children.push(element);
                element.parent = currentParent;
            }
        }
        // final children cleanup
        // filter out scoped slots
        element.children = element.children.filter(c => !c.slotScope);
        // remove trailing whitespace node again
        trimEndingWhitespace(element);
        // check pre state
        if (element.pre) {
            inVPre = false;
        }
        if (platformIsPreTag(element.tag)) {
            inPre = false;
        }
        // apply post-transforms
        for (let i = 0; i < postTransforms.length; i++) {
            postTransforms[i](element, options);
        }
    }
    function trimEndingWhitespace(el) {
        // remove trailing whitespace node
        if (!inPre) {
            let lastNode;
            while ((lastNode = el.children[el.children.length - 1]) &&
                lastNode.type === 3 &&
                lastNode.text === ' ') {
                el.children.pop();
            }
        }
    }
    function checkRootConstraints(el) {
        if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce(`Cannot use <${el.tag}> as component root element because it may ` +
                'contain multiple nodes.', { start: el.start });
        }
        if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' +
                'it renders multiple elements.', el.rawAttrsMap['v-for']);
        }
    }
    parseHTML(template, {
        warn,
        expectHTML: options.expectHTML,
        isUnaryTag: options.isUnaryTag,
        canBeLeftOpenTag: options.canBeLeftOpenTag,
        shouldDecodeNewlines: options.shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
        shouldKeepComment: options.comments,
        outputSourceRange: options.outputSourceRange,
        start(tag, attrs, unary, start, end) {
            // check namespace.
            // inherit parent ns if there is one
            const ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);
            // handle IE svg bug
            /* istanbul ignore if */
            if (isIE && ns === 'svg') {
                attrs = guardIESVGBug(attrs);
            }
            let element = createASTElement(tag, attrs, currentParent);
            if (ns) {
                element.ns = ns;
            }
            {
                if (options.outputSourceRange) {
                    element.start = start;
                    element.end = end;
                    element.rawAttrsMap = element.attrsList.reduce((cumulated, attr) => {
                        cumulated[attr.name] = attr;
                        return cumulated;
                    }, {});
                }
                attrs.forEach(attr => {
                    if (invalidAttributeRE.test(attr.name)) {
                        warn(`Invalid dynamic argument expression: attribute names cannot contain ` +
                            `spaces, quotes, <, >, / or =.`, options.outputSourceRange
                            ? {
                                start: attr.start + attr.name.indexOf(`[`),
                                end: attr.start + attr.name.length
                            }
                            : undefined);
                    }
                });
            }
            if (isForbiddenTag(element) && !isServerRendering()) {
                element.forbidden = true;
                warn('Templates should only be responsible for mapping the state to the ' +
                        'UI. Avoid placing tags with side-effects in your templates, such as ' +
                        `<${tag}>` +
                        ', as they will not be parsed.', { start: element.start });
            }
            // apply pre-transforms
            for (let i = 0; i < preTransforms.length; i++) {
                element = preTransforms[i](element, options) || element;
            }
            if (!inVPre) {
                processPre(element);
                if (element.pre) {
                    inVPre = true;
                }
            }
            if (platformIsPreTag(element.tag)) {
                inPre = true;
            }
            if (inVPre) {
                processRawAttrs(element);
            }
            else if (!element.processed) {
                // structural directives
                processFor(element);
                processIf(element);
                processOnce(element);
            }
            if (!root) {
                root = element;
                {
                    checkRootConstraints(root);
                }
            }
            if (!unary) {
                currentParent = element;
                stack.push(element);
            }
            else {
                closeElement(element);
            }
        },
        end(tag, start, end) {
            const element = stack[stack.length - 1];
            // pop stack
            stack.length -= 1;
            currentParent = stack[stack.length - 1];
            if (options.outputSourceRange) {
                element.end = end;
            }
            closeElement(element);
        },
        chars(text, start, end) {
            if (!currentParent) {
                {
                    if (text === template) {
                        warnOnce('Component template requires a root element, rather than just text.', { start });
                    }
                    else if ((text = text.trim())) {
                        warnOnce(`text "${text}" outside root element will be ignored.`, {
                            start
                        });
                    }
                }
                return;
            }
            // IE textarea placeholder bug
            /* istanbul ignore if */
            if (isIE &&
                currentParent.tag === 'textarea' &&
                currentParent.attrsMap.placeholder === text) {
                return;
            }
            const children = currentParent.children;
            if (inPre || text.trim()) {
                text = isTextTag(currentParent)
                    ? text
                    : decodeHTMLCached(text);
            }
            else if (!children.length) {
                // remove the whitespace-only node right after an opening tag
                text = '';
            }
            else if (whitespaceOption) {
                if (whitespaceOption === 'condense') {
                    // in condense mode, remove the whitespace node if it contains
                    // line break, otherwise condense to a single space
                    text = lineBreakRE.test(text) ? '' : ' ';
                }
                else {
                    text = ' ';
                }
            }
            else {
                text = preserveWhitespace ? ' ' : '';
            }
            if (text) {
                if (!inPre && whitespaceOption === 'condense') {
                    // condense consecutive whitespaces into single space
                    text = text.replace(whitespaceRE, ' ');
                }
                let res;
                let child;
                if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
                    child = {
                        type: 2,
                        expression: res.expression,
                        tokens: res.tokens,
                        text
                    };
                }
                else if (text !== ' ' ||
                    !children.length ||
                    children[children.length - 1].text !== ' ') {
                    child = {
                        type: 3,
                        text
                    };
                }
                if (child) {
                    if (options.outputSourceRange) {
                        child.start = start;
                        child.end = end;
                    }
                    children.push(child);
                }
            }
        },
        comment(text, start, end) {
            // adding anything as a sibling to the root node is forbidden
            // comments should still be allowed, but ignored
            if (currentParent) {
                const child = {
                    type: 3,
                    text,
                    isComment: true
                };
                if (options.outputSourceRange) {
                    child.start = start;
                    child.end = end;
                }
                currentParent.children.push(child);
            }
        }
    });
    return root;
}
function processPre(el) {
    if (getAndRemoveAttr(el, 'v-pre') != null) {
        el.pre = true;
    }
}
function processRawAttrs(el) {
    const list = el.attrsList;
    const len = list.length;
    if (len) {
        const attrs = (el.attrs = new Array(len));
        for (let i = 0; i < len; i++) {
            attrs[i] = {
                name: list[i].name,
                value: JSON.stringify(list[i].value)
            };
            if (list[i].start != null) {
                attrs[i].start = list[i].start;
                attrs[i].end = list[i].end;
            }
        }
    }
    else if (!el.pre) {
        // non root node in pre blocks with no attributes
        el.plain = true;
    }
}
function processElement(element, options) {
    processKey(element);
    // determine whether this is a plain element after
    // removing structural attributes
    element.plain =
        !element.key && !element.scopedSlots && !element.attrsList.length;
    processRef(element);
    processSlotContent(element);
    processSlotOutlet(element);
    processComponent(element);
    for (let i = 0; i < transforms.length; i++) {
        element = transforms[i](element, options) || element;
    }
    processAttrs(element);
    return element;
}
function processKey(el) {
    const exp = getBindingAttr(el, 'key');
    if (exp) {
        {
            if (el.tag === 'template') {
                warn(`<template> cannot be keyed. Place the key on real elements instead.`, getRawBindingAttr(el, 'key'));
            }
            if (el.for) {
                const iterator = el.iterator2 || el.iterator1;
                const parent = el.parent;
                if (iterator &&
                    iterator === exp &&
                    parent &&
                    parent.tag === 'transition-group') {
                    warn(`Do not use v-for index as key on <transition-group> children, ` +
                        `this is the same as not using keys.`, getRawBindingAttr(el, 'key'), true /* tip */);
                }
            }
        }
        el.key = exp;
    }
}
function processRef(el) {
    const ref = getBindingAttr(el, 'ref');
    if (ref) {
        el.ref = ref;
        el.refInFor = checkInFor(el);
    }
}
function processFor(el) {
    let exp;
    if ((exp = getAndRemoveAttr(el, 'v-for'))) {
        const res = parseFor(exp);
        if (res) {
            extend(el, res);
        }
        else {
            warn(`Invalid v-for expression: ${exp}`, el.rawAttrsMap['v-for']);
        }
    }
}
function parseFor(exp) {
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
        return;
    const res = {};
    res.for = inMatch[2].trim();
    const alias = inMatch[1].trim().replace(stripParensRE, '');
    const iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
        res.alias = alias.replace(forIteratorRE, '').trim();
        res.iterator1 = iteratorMatch[1].trim();
        if (iteratorMatch[2]) {
            res.iterator2 = iteratorMatch[2].trim();
        }
    }
    else {
        res.alias = alias;
    }
    return res;
}
function processIf(el) {
    const exp = getAndRemoveAttr(el, 'v-if');
    if (exp) {
        el.if = exp;
        addIfCondition(el, {
            exp: exp,
            block: el
        });
    }
    else {
        if (getAndRemoveAttr(el, 'v-else') != null) {
            el.else = true;
        }
        const elseif = getAndRemoveAttr(el, 'v-else-if');
        if (elseif) {
            el.elseif = elseif;
        }
    }
}
function processIfConditions(el, parent) {
    const prev = findPrevElement(parent.children);
    if (prev && prev.if) {
        addIfCondition(prev, {
            exp: el.elseif,
            block: el
        });
    }
    else {
        warn(`v-${el.elseif ? 'else-if="' + el.elseif + '"' : 'else'} ` +
            `used on element <${el.tag}> without corresponding v-if.`, el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']);
    }
}
function findPrevElement(children) {
    let i = children.length;
    while (i--) {
        if (children[i].type === 1) {
            return children[i];
        }
        else {
            if (children[i].text !== ' ') {
                warn(`text "${children[i].text.trim()}" between v-if and v-else(-if) ` +
                    `will be ignored.`, children[i]);
            }
            children.pop();
        }
    }
}
function addIfCondition(el, condition) {
    if (!el.ifConditions) {
        el.ifConditions = [];
    }
    el.ifConditions.push(condition);
}
function processOnce(el) {
    const once = getAndRemoveAttr(el, 'v-once');
    if (once != null) {
        el.once = true;
    }
}
// handle content being passed to a component as slot,
// e.g. <template slot="xxx">, <div slot-scope="xxx">
function processSlotContent(el) {
    let slotScope;
    if (el.tag === 'template') {
        slotScope = getAndRemoveAttr(el, 'scope');
        /* istanbul ignore if */
        if (slotScope) {
            warn(`the "scope" attribute for scoped slots have been deprecated and ` +
                `replaced by "slot-scope" since 2.5. The new "slot-scope" attribute ` +
                `can also be used on plain elements in addition to <template> to ` +
                `denote scoped slots.`, el.rawAttrsMap['scope'], true);
        }
        el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    }
    else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
        /* istanbul ignore if */
        if (el.attrsMap['v-for']) {
            warn(`Ambiguous combined usage of slot-scope and v-for on <${el.tag}> ` +
                `(v-for takes higher priority). Use a wrapper <template> for the ` +
                `scoped slot to make it clearer.`, el.rawAttrsMap['slot-scope'], true);
        }
        el.slotScope = slotScope;
    }
    // slot="xxx"
    const slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
        el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
        el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);
        // preserve slot as an attribute for native shadow DOM compat
        // only for non-scoped slots.
        if (el.tag !== 'template' && !el.slotScope) {
            addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));
        }
    }
    // 2.6 v-slot syntax
    {
        if (el.tag === 'template') {
            // v-slot on <template>
            const slotBinding = getAndRemoveAttrByRegex(el, slotRE);
            if (slotBinding) {
                {
                    if (el.slotTarget || el.slotScope) {
                        warn(`Unexpected mixed usage of different slot syntaxes.`, el);
                    }
                    if (el.parent && !maybeComponent(el.parent)) {
                        warn(`<template v-slot> can only appear at the root level inside ` +
                            `the receiving component`, el);
                    }
                }
                const { name, dynamic } = getSlotName(slotBinding);
                el.slotTarget = name;
                el.slotTargetDynamic = dynamic;
                el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf
            }
        }
        else {
            // v-slot on component, denotes default slot
            const slotBinding = getAndRemoveAttrByRegex(el, slotRE);
            if (slotBinding) {
                {
                    if (!maybeComponent(el)) {
                        warn(`v-slot can only be used on components or <template>.`, slotBinding);
                    }
                    if (el.slotScope || el.slotTarget) {
                        warn(`Unexpected mixed usage of different slot syntaxes.`, el);
                    }
                    if (el.scopedSlots) {
                        warn(`To avoid scope ambiguity, the default slot should also use ` +
                            `<template> syntax when there are other named slots.`, slotBinding);
                    }
                }
                // add the component's children to its default slot
                const slots = el.scopedSlots || (el.scopedSlots = {});
                const { name, dynamic } = getSlotName(slotBinding);
                const slotContainer = (slots[name] = createASTElement('template', [], el));
                slotContainer.slotTarget = name;
                slotContainer.slotTargetDynamic = dynamic;
                slotContainer.children = el.children.filter((c) => {
                    if (!c.slotScope) {
                        c.parent = slotContainer;
                        return true;
                    }
                });
                slotContainer.slotScope = slotBinding.value || emptySlotScopeToken;
                // remove children as they are returned from scopedSlots now
                el.children = [];
                // mark el non-plain so data gets generated
                el.plain = false;
            }
        }
    }
}
function getSlotName(binding) {
    let name = binding.name.replace(slotRE, '');
    if (!name) {
        if (binding.name[0] !== '#') {
            name = 'default';
        }
        else {
            warn(`v-slot shorthand syntax requires a slot name.`, binding);
        }
    }
    return dynamicArgRE.test(name)
        ? // dynamic [name]
            { name: name.slice(1, -1), dynamic: true }
        : // static name
            { name: `"${name}"`, dynamic: false };
}
// handle <slot/> outlets
function processSlotOutlet(el) {
    if (el.tag === 'slot') {
        el.slotName = getBindingAttr(el, 'name');
        if (el.key) {
            warn(`\`key\` does not work on <slot> because slots are abstract outlets ` +
                `and can possibly expand into multiple elements. ` +
                `Use the key on a wrapping element instead.`, getRawBindingAttr(el, 'key'));
        }
    }
}
function processComponent(el) {
    let binding;
    if ((binding = getBindingAttr(el, 'is'))) {
        el.component = binding;
    }
    if (getAndRemoveAttr(el, 'inline-template') != null) {
        el.inlineTemplate = true;
    }
}
function processAttrs(el) {
    const list = el.attrsList;
    let i, l, name, rawName, value, modifiers, syncGen, isDynamic;
    for (i = 0, l = list.length; i < l; i++) {
        name = rawName = list[i].name;
        value = list[i].value;
        if (dirRE.test(name)) {
            // mark element as dynamic
            el.hasBindings = true;
            // modifiers
            modifiers = parseModifiers(name.replace(dirRE, ''));
            // support .foo shorthand syntax for the .prop modifier
            if (modifiers) {
                name = name.replace(modifierRE, '');
            }
            if (bindRE.test(name)) {
                // v-bind
                name = name.replace(bindRE, '');
                value = parseFilters(value);
                isDynamic = dynamicArgRE.test(name);
                if (isDynamic) {
                    name = name.slice(1, -1);
                }
                if (value.trim().length === 0) {
                    warn(`The value for a v-bind expression cannot be empty. Found in "v-bind:${name}"`);
                }
                if (modifiers) {
                    if (modifiers.prop && !isDynamic) {
                        name = camelize(name);
                        if (name === 'innerHtml')
                            name = 'innerHTML';
                    }
                    if (modifiers.camel && !isDynamic) {
                        name = camelize(name);
                    }
                    if (modifiers.sync) {
                        syncGen = genAssignmentCode(value, `$event`);
                        if (!isDynamic) {
                            addHandler(el, `update:${camelize(name)}`, syncGen, null, false, warn, list[i]);
                            if (hyphenate(name) !== camelize(name)) {
                                addHandler(el, `update:${hyphenate(name)}`, syncGen, null, false, warn, list[i]);
                            }
                        }
                        else {
                            // handler w/ dynamic event name
                            addHandler(el, `"update:"+(${name})`, syncGen, null, false, warn, list[i], true // dynamic
                            );
                        }
                    }
                }
                if ((modifiers && modifiers.prop) ||
                    (!el.component && platformMustUseProp(el.tag, el.attrsMap.type, name))) {
                    addProp(el, name, value, list[i], isDynamic);
                }
                else {
                    addAttr(el, name, value, list[i], isDynamic);
                }
            }
            else if (onRE.test(name)) {
                // v-on
                name = name.replace(onRE, '');
                isDynamic = dynamicArgRE.test(name);
                if (isDynamic) {
                    name = name.slice(1, -1);
                }
                addHandler(el, name, value, modifiers, false, warn, list[i], isDynamic);
            }
            else {
                // normal directives
                name = name.replace(dirRE, '');
                // parse arg
                const argMatch = name.match(argRE);
                let arg = argMatch && argMatch[1];
                isDynamic = false;
                if (arg) {
                    name = name.slice(0, -(arg.length + 1));
                    if (dynamicArgRE.test(arg)) {
                        arg = arg.slice(1, -1);
                        isDynamic = true;
                    }
                }
                addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);
                if (name === 'model') {
                    checkForAliasModel(el, value);
                }
            }
        }
        else {
            // literal attribute
            {
                const res = parseText(value, delimiters);
                if (res) {
                    warn(`${name}="${value}": ` +
                        'Interpolation inside attributes has been removed. ' +
                        'Use v-bind or the colon shorthand instead. For example, ' +
                        'instead of <div id="{{ val }}">, use <div :id="val">.', list[i]);
                }
            }
            addAttr(el, name, JSON.stringify(value), list[i]);
            // #6887 firefox doesn't update muted state if set via attribute
            // even immediately after element creation
            if (!el.component &&
                name === 'muted' &&
                platformMustUseProp(el.tag, el.attrsMap.type, name)) {
                addProp(el, name, 'true', list[i]);
            }
        }
    }
}
function checkInFor(el) {
    let parent = el;
    while (parent) {
        if (parent.for !== undefined) {
            return true;
        }
        parent = parent.parent;
    }
    return false;
}
function parseModifiers(name) {
    const match = name.match(modifierRE);
    if (match) {
        const ret = {};
        match.forEach(m => {
            ret[m.slice(1)] = true;
        });
        return ret;
    }
}
function makeAttrsMap(attrs) {
    const map = {};
    for (let i = 0, l = attrs.length; i < l; i++) {
        if (map[attrs[i].name] && !isIE && !isEdge) {
            warn('duplicate attribute: ' + attrs[i].name, attrs[i]);
        }
        map[attrs[i].name] = attrs[i].value;
    }
    return map;
}
// for script (e.g. type="x/template") or style, do not decode content
function isTextTag(el) {
    return el.tag === 'script' || el.tag === 'style';
}
function isForbiddenTag(el) {
    return (el.tag === 'style' ||
        (el.tag === 'script' &&
            (!el.attrsMap.type || el.attrsMap.type === 'text/javascript')));
}
const ieNSBug = /^xmlns:NS\d+/;
const ieNSPrefix = /^NS\d+:/;
/* istanbul ignore next */
function guardIESVGBug(attrs) {
    const res = [];
    for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (!ieNSBug.test(attr.name)) {
            attr.name = attr.name.replace(ieNSPrefix, '');
            res.push(attr);
        }
    }
    return res;
}
function checkForAliasModel(el, value) {
    let _el = el;
    while (_el) {
        if (_el.for && _el.alias === value) {
            warn(`<${el.tag} v-model="${value}">: ` +
                `You are binding v-model directly to a v-for iteration alias. ` +
                `This will not be able to modify the v-for source array because ` +
                `writing to the alias is like modifying a function local variable. ` +
                `Consider using an array of objects and use v-model on an object property instead.`, el.rawAttrsMap['v-model']);
        }
        _el = _el.parent;
    }
}

/**
 * Expand input[v-model] with dynamic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */
function preTransformNode(el, options) {
    if (el.tag === 'input') {
        const map = el.attrsMap;
        if (!map['v-model']) {
            return;
        }
        let typeBinding;
        if (map[':type'] || map['v-bind:type']) {
            typeBinding = getBindingAttr(el, 'type');
        }
        if (!map.type && !typeBinding && map['v-bind']) {
            typeBinding = `(${map['v-bind']}).type`;
        }
        if (typeBinding) {
            const ifCondition = getAndRemoveAttr(el, 'v-if', true);
            const ifConditionExtra = ifCondition ? `&&(${ifCondition})` : ``;
            const hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
            const elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
            // 1. checkbox
            const branch0 = cloneASTElement(el);
            // process for on the main node
            processFor(branch0);
            addRawAttr(branch0, 'type', 'checkbox');
            processElement(branch0, options);
            branch0.processed = true; // prevent it from double-processed
            branch0.if = `(${typeBinding})==='checkbox'` + ifConditionExtra;
            addIfCondition(branch0, {
                exp: branch0.if,
                block: branch0
            });
            // 2. add radio else-if condition
            const branch1 = cloneASTElement(el);
            getAndRemoveAttr(branch1, 'v-for', true);
            addRawAttr(branch1, 'type', 'radio');
            processElement(branch1, options);
            addIfCondition(branch0, {
                exp: `(${typeBinding})==='radio'` + ifConditionExtra,
                block: branch1
            });
            // 3. other
            const branch2 = cloneASTElement(el);
            getAndRemoveAttr(branch2, 'v-for', true);
            addRawAttr(branch2, ':type', typeBinding);
            processElement(branch2, options);
            addIfCondition(branch0, {
                exp: ifCondition,
                block: branch2
            });
            if (hasElse) {
                branch0.else = true;
            }
            else if (elseIfCondition) {
                branch0.elseif = elseIfCondition;
            }
            return branch0;
        }
    }
}
function cloneASTElement(el) {
    return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}
var model = {
    preTransformNode
};

var modules = [klass, style, model];

function text(el, dir) {
    if (dir.value) {
        addProp(el, 'textContent', `_s(${dir.value})`, dir);
    }
}

function html(el, dir) {
    if (dir.value) {
        addProp(el, 'innerHTML', `_s(${dir.value})`, dir);
    }
}

var directives = {
    model: model$1,
    text,
    html
};

const baseOptions = {
    expectHTML: true,
    modules,
    directives,
    isPreTag,
    isUnaryTag,
    mustUseProp,
    canBeLeftOpenTag,
    isReservedTag,
    getTagNamespace,
    staticKeys: genStaticKeys$1(modules)
};

let isStaticKey;
let isPlatformReservedTag;
const genStaticKeysCached = cached(genStaticKeys);
/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
    if (!root)
        return;
    isStaticKey = genStaticKeysCached(options.staticKeys || '');
    isPlatformReservedTag = options.isReservedTag || no;
    // first pass: mark all non-static nodes.
    markStatic(root);
    // second pass: mark static roots.
    markStaticRoots(root, false);
}
function genStaticKeys(keys) {
    return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +
        (keys ? ',' + keys : ''));
}
function markStatic(node) {
    node.static = isStatic(node);
    if (node.type === 1) {
        // do not make component slot content static. this avoids
        // 1. components not able to mutate slot nodes
        // 2. static slot content fails for hot-reloading
        if (!isPlatformReservedTag(node.tag) &&
            node.tag !== 'slot' &&
            node.attrsMap['inline-template'] == null) {
            return;
        }
        for (let i = 0, l = node.children.length; i < l; i++) {
            const child = node.children[i];
            markStatic(child);
            if (!child.static) {
                node.static = false;
            }
        }
        if (node.ifConditions) {
            for (let i = 1, l = node.ifConditions.length; i < l; i++) {
                const block = node.ifConditions[i].block;
                markStatic(block);
                if (!block.static) {
                    node.static = false;
                }
            }
        }
    }
}
function markStaticRoots(node, isInFor) {
    if (node.type === 1) {
        if (node.static || node.once) {
            node.staticInFor = isInFor;
        }
        // For a node to qualify as a static root, it should have children that
        // are not just static text. Otherwise the cost of hoisting out will
        // outweigh the benefits and it's better off to just always render it fresh.
        if (node.static &&
            node.children.length &&
            !(node.children.length === 1 && node.children[0].type === 3)) {
            node.staticRoot = true;
            return;
        }
        else {
            node.staticRoot = false;
        }
        if (node.children) {
            for (let i = 0, l = node.children.length; i < l; i++) {
                markStaticRoots(node.children[i], isInFor || !!node.for);
            }
        }
        if (node.ifConditions) {
            for (let i = 1, l = node.ifConditions.length; i < l; i++) {
                markStaticRoots(node.ifConditions[i].block, isInFor);
            }
        }
    }
}
function isStatic(node) {
    if (node.type === 2) {
        // expression
        return false;
    }
    if (node.type === 3) {
        // text
        return true;
    }
    return !!(node.pre ||
        (!node.hasBindings && // no dynamic bindings
            !node.if &&
            !node.for && // not v-if or v-for or v-else
            !isBuiltInTag(node.tag) && // not a built-in
            isPlatformReservedTag(node.tag) && // not a component
            !isDirectChildOfTemplateFor(node) &&
            Object.keys(node).every(isStaticKey)));
}
function isDirectChildOfTemplateFor(node) {
    while (node.parent) {
        node = node.parent;
        if (node.tag !== 'template') {
            return false;
        }
        if (node.for) {
            return true;
        }
    }
    return false;
}

const fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/;
const fnInvokeRE = /\([^)]*?\);*$/;
const simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;
// KeyboardEvent.keyCode aliases
const keyCodes = {
    esc: 27,
    tab: 9,
    enter: 13,
    space: 32,
    up: 38,
    left: 37,
    right: 39,
    down: 40,
    delete: [8, 46]
};
// KeyboardEvent.key aliases
const keyNames = {
    // #7880: IE11 and Edge use `Esc` for Escape key name.
    esc: ['Esc', 'Escape'],
    tab: 'Tab',
    enter: 'Enter',
    // #9112: IE11 uses `Spacebar` for Space key name.
    space: [' ', 'Spacebar'],
    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
    up: ['Up', 'ArrowUp'],
    left: ['Left', 'ArrowLeft'],
    right: ['Right', 'ArrowRight'],
    down: ['Down', 'ArrowDown'],
    // #9112: IE11 uses `Del` for Delete key name.
    delete: ['Backspace', 'Delete', 'Del']
};
// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
const genGuard = condition => `if(${condition})return null;`;
const modifierCode = {
    stop: '$event.stopPropagation();',
    prevent: '$event.preventDefault();',
    self: genGuard(`$event.target !== $event.currentTarget`),
    ctrl: genGuard(`!$event.ctrlKey`),
    shift: genGuard(`!$event.shiftKey`),
    alt: genGuard(`!$event.altKey`),
    meta: genGuard(`!$event.metaKey`),
    left: genGuard(`'button' in $event && $event.button !== 0`),
    middle: genGuard(`'button' in $event && $event.button !== 1`),
    right: genGuard(`'button' in $event && $event.button !== 2`)
};
function genHandlers(events, isNative) {
    const prefix = isNative ? 'nativeOn:' : 'on:';
    let staticHandlers = ``;
    let dynamicHandlers = ``;
    for (const name in events) {
        const handlerCode = genHandler(events[name]);
        //@ts-expect-error
        if (events[name] && events[name].dynamic) {
            dynamicHandlers += `${name},${handlerCode},`;
        }
        else {
            staticHandlers += `"${name}":${handlerCode},`;
        }
    }
    staticHandlers = `{${staticHandlers.slice(0, -1)}}`;
    if (dynamicHandlers) {
        return prefix + `_d(${staticHandlers},[${dynamicHandlers.slice(0, -1)}])`;
    }
    else {
        return prefix + staticHandlers;
    }
}
function genHandler(handler) {
    if (!handler) {
        return 'function(){}';
    }
    if (Array.isArray(handler)) {
        return `[${handler.map(handler => genHandler(handler)).join(',')}]`;
    }
    const isMethodPath = simplePathRE.test(handler.value);
    const isFunctionExpression = fnExpRE.test(handler.value);
    const isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));
    if (!handler.modifiers) {
        if (isMethodPath || isFunctionExpression) {
            return handler.value;
        }
        return `function($event){${isFunctionInvocation ? `return ${handler.value}` : handler.value}}`; // inline statement
    }
    else {
        let code = '';
        let genModifierCode = '';
        const keys = [];
        for (const key in handler.modifiers) {
            if (modifierCode[key]) {
                genModifierCode += modifierCode[key];
                // left/right
                if (keyCodes[key]) {
                    keys.push(key);
                }
            }
            else if (key === 'exact') {
                const modifiers = handler.modifiers;
                genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta']
                    .filter(keyModifier => !modifiers[keyModifier])
                    .map(keyModifier => `$event.${keyModifier}Key`)
                    .join('||'));
            }
            else {
                keys.push(key);
            }
        }
        if (keys.length) {
            code += genKeyFilter(keys);
        }
        // Make sure modifiers like prevent and stop get executed after key filtering
        if (genModifierCode) {
            code += genModifierCode;
        }
        const handlerCode = isMethodPath
            ? `return ${handler.value}.apply(null, arguments)`
            : isFunctionExpression
                ? `return (${handler.value}).apply(null, arguments)`
                : isFunctionInvocation
                    ? `return ${handler.value}`
                    : handler.value;
        return `function($event){${code}${handlerCode}}`;
    }
}
function genKeyFilter(keys) {
    return (
    // make sure the key filters only apply to KeyboardEvents
    // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake
    // key events that do not have keyCode property...
    `if(!$event.type.indexOf('key')&&` +
        `${keys.map(genFilterCode).join('&&')})return null;`);
}
function genFilterCode(key) {
    const keyVal = parseInt(key, 10);
    if (keyVal) {
        return `$event.keyCode!==${keyVal}`;
    }
    const keyCode = keyCodes[key];
    const keyName = keyNames[key];
    return (`_k($event.keyCode,` +
        `${JSON.stringify(key)},` +
        `${JSON.stringify(keyCode)},` +
        `$event.key,` +
        `${JSON.stringify(keyName)}` +
        `)`);
}

function on(el, dir) {
    if (dir.modifiers) {
        warn$2(`v-on without argument does not support modifiers.`);
    }
    el.wrapListeners = (code) => `_g(${code},${dir.value})`;
}

function bind(el, dir) {
    el.wrapData = (code) => {
        return `_b(${code},'${el.tag}',${dir.value},${dir.modifiers && dir.modifiers.prop ? 'true' : 'false'}${dir.modifiers && dir.modifiers.sync ? ',true' : ''})`;
    };
}

var baseDirectives = {
    on,
    bind,
    cloak: noop
};

class CodegenState {
    constructor(options) {
        this.options = options;
        this.warn = options.warn || baseWarn;
        this.transforms = pluckModuleFunction(options.modules, 'transformCode');
        this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
        this.directives = extend(extend({}, baseDirectives), options.directives);
        const isReservedTag = options.isReservedTag || no;
        this.maybeComponent = (el) => !!el.component || !isReservedTag(el.tag);
        this.onceId = 0;
        this.staticRenderFns = [];
        this.pre = false;
    }
}
function generate(ast, options) {
    const state = new CodegenState(options);
    // fix #11483, Root level <script> tags should not be rendered.
    const code = ast
        ? ast.tag === 'script'
            ? 'null'
            : genElement(ast, state)
        : '_c("div")';
    return {
        render: `with(this){return ${code}}`,
        staticRenderFns: state.staticRenderFns
    };
}
function genElement(el, state) {
    if (el.parent) {
        el.pre = el.pre || el.parent.pre;
    }
    if (el.staticRoot && !el.staticProcessed) {
        return genStatic(el, state);
    }
    else if (el.once && !el.onceProcessed) {
        return genOnce(el, state);
    }
    else if (el.for && !el.forProcessed) {
        return genFor(el, state);
    }
    else if (el.if && !el.ifProcessed) {
        return genIf(el, state);
    }
    else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
        return genChildren(el, state) || 'void 0';
    }
    else if (el.tag === 'slot') {
        return genSlot(el, state);
    }
    else {
        // component or element
        let code;
        if (el.component) {
            code = genComponent(el.component, el, state);
        }
        else {
            let data;
            const maybeComponent = state.maybeComponent(el);
            if (!el.plain || (el.pre && maybeComponent)) {
                data = genData(el, state);
            }
            let tag;
            // check if this is a component in <script setup>
            const bindings = state.options.bindings;
            if (maybeComponent && bindings && bindings.__isScriptSetup !== false) {
                tag = checkBindingType(bindings, el.tag);
            }
            if (!tag)
                tag = `'${el.tag}'`;
            const children = el.inlineTemplate ? null : genChildren(el, state, true);
            code = `_c(${tag}${data ? `,${data}` : '' // data
            }${children ? `,${children}` : '' // children
            })`;
        }
        // module transforms
        for (let i = 0; i < state.transforms.length; i++) {
            code = state.transforms[i](el, code);
        }
        return code;
    }
}
function checkBindingType(bindings, key) {
    const camelName = camelize(key);
    const PascalName = capitalize(camelName);
    const checkType = (type) => {
        if (bindings[key] === type) {
            return key;
        }
        if (bindings[camelName] === type) {
            return camelName;
        }
        if (bindings[PascalName] === type) {
            return PascalName;
        }
    };
    const fromConst = checkType("setup-const" /* BindingTypes.SETUP_CONST */) ||
        checkType("setup-reactive-const" /* BindingTypes.SETUP_REACTIVE_CONST */);
    if (fromConst) {
        return fromConst;
    }
    const fromMaybeRef = checkType("setup-let" /* BindingTypes.SETUP_LET */) ||
        checkType("setup-ref" /* BindingTypes.SETUP_REF */) ||
        checkType("setup-maybe-ref" /* BindingTypes.SETUP_MAYBE_REF */);
    if (fromMaybeRef) {
        return fromMaybeRef;
    }
}
// hoist static sub-trees out
function genStatic(el, state) {
    el.staticProcessed = true;
    // Some elements (templates) need to behave differently inside of a v-pre
    // node.  All pre nodes are static roots, so we can use this as a location to
    // wrap a state change and reset it upon exiting the pre node.
    const originalPreState = state.pre;
    if (el.pre) {
        state.pre = el.pre;
    }
    state.staticRenderFns.push(`with(this){return ${genElement(el, state)}}`);
    state.pre = originalPreState;
    return `_m(${state.staticRenderFns.length - 1}${el.staticInFor ? ',true' : ''})`;
}
// v-once
function genOnce(el, state) {
    el.onceProcessed = true;
    if (el.if && !el.ifProcessed) {
        return genIf(el, state);
    }
    else if (el.staticInFor) {
        let key = '';
        let parent = el.parent;
        while (parent) {
            if (parent.for) {
                key = parent.key;
                break;
            }
            parent = parent.parent;
        }
        if (!key) {
            state.warn(`v-once can only be used inside v-for that is keyed. `, el.rawAttrsMap['v-once']);
            return genElement(el, state);
        }
        return `_o(${genElement(el, state)},${state.onceId++},${key})`;
    }
    else {
        return genStatic(el, state);
    }
}
function genIf(el, state, altGen, altEmpty) {
    el.ifProcessed = true; // avoid recursion
    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}
function genIfConditions(conditions, state, altGen, altEmpty) {
    if (!conditions.length) {
        return altEmpty || '_e()';
    }
    const condition = conditions.shift();
    if (condition.exp) {
        return `(${condition.exp})?${genTernaryExp(condition.block)}:${genIfConditions(conditions, state, altGen, altEmpty)}`;
    }
    else {
        return `${genTernaryExp(condition.block)}`;
    }
    // v-if with v-once should generate code like (a)?_m(0):_m(1)
    function genTernaryExp(el) {
        return altGen
            ? altGen(el, state)
            : el.once
                ? genOnce(el, state)
                : genElement(el, state);
    }
}
function genFor(el, state, altGen, altHelper) {
    const exp = el.for;
    const alias = el.alias;
    const iterator1 = el.iterator1 ? `,${el.iterator1}` : '';
    const iterator2 = el.iterator2 ? `,${el.iterator2}` : '';
    if (state.maybeComponent(el) &&
        el.tag !== 'slot' &&
        el.tag !== 'template' &&
        !el.key) {
        state.warn(`<${el.tag} v-for="${alias} in ${exp}">: component lists rendered with ` +
            `v-for should have explicit keys. ` +
            `See https://v2.vuejs.org/v2/guide/list.html#key for more info.`, el.rawAttrsMap['v-for'], true /* tip */);
    }
    el.forProcessed = true; // avoid recursion
    return (`${altHelper || '_l'}((${exp}),` +
        `function(${alias}${iterator1}${iterator2}){` +
        `return ${(altGen || genElement)(el, state)}` +
        '})');
}
function genData(el, state) {
    let data = '{';
    // directives first.
    // directives may mutate the el's other properties before they are generated.
    const dirs = genDirectives(el, state);
    if (dirs)
        data += dirs + ',';
    // key
    if (el.key) {
        data += `key:${el.key},`;
    }
    // ref
    if (el.ref) {
        data += `ref:${el.ref},`;
    }
    if (el.refInFor) {
        data += `refInFor:true,`;
    }
    // pre
    if (el.pre) {
        data += `pre:true,`;
    }
    // record original tag name for components using "is" attribute
    if (el.component) {
        data += `tag:"${el.tag}",`;
    }
    // module data generation functions
    for (let i = 0; i < state.dataGenFns.length; i++) {
        data += state.dataGenFns[i](el);
    }
    // attributes
    if (el.attrs) {
        data += `attrs:${genProps(el.attrs)},`;
    }
    // DOM props
    if (el.props) {
        data += `domProps:${genProps(el.props)},`;
    }
    // event handlers
    if (el.events) {
        data += `${genHandlers(el.events, false)},`;
    }
    if (el.nativeEvents) {
        data += `${genHandlers(el.nativeEvents, true)},`;
    }
    // slot target
    // only for non-scoped slots
    if (el.slotTarget && !el.slotScope) {
        data += `slot:${el.slotTarget},`;
    }
    // scoped slots
    if (el.scopedSlots) {
        data += `${genScopedSlots(el, el.scopedSlots, state)},`;
    }
    // component v-model
    if (el.model) {
        data += `model:{value:${el.model.value},callback:${el.model.callback},expression:${el.model.expression}},`;
    }
    // inline-template
    if (el.inlineTemplate) {
        const inlineTemplate = genInlineTemplate(el, state);
        if (inlineTemplate) {
            data += `${inlineTemplate},`;
        }
    }
    data = data.replace(/,$/, '') + '}';
    // v-bind dynamic argument wrap
    // v-bind with dynamic arguments must be applied using the same v-bind object
    // merge helper so that class/style/mustUseProp attrs are handled correctly.
    if (el.dynamicAttrs) {
        data = `_b(${data},"${el.tag}",${genProps(el.dynamicAttrs)})`;
    }
    // v-bind data wrap
    if (el.wrapData) {
        data = el.wrapData(data);
    }
    // v-on data wrap
    if (el.wrapListeners) {
        data = el.wrapListeners(data);
    }
    return data;
}
function genDirectives(el, state) {
    const dirs = el.directives;
    if (!dirs)
        return;
    let res = 'directives:[';
    let hasRuntime = false;
    let i, l, dir, needRuntime;
    for (i = 0, l = dirs.length; i < l; i++) {
        dir = dirs[i];
        needRuntime = true;
        const gen = state.directives[dir.name];
        if (gen) {
            // compile-time directive that manipulates AST.
            // returns true if it also needs a runtime counterpart.
            needRuntime = !!gen(el, dir, state.warn);
        }
        if (needRuntime) {
            hasRuntime = true;
            res += `{name:"${dir.name}",rawName:"${dir.rawName}"${dir.value
                ? `,value:(${dir.value}),expression:${JSON.stringify(dir.value)}`
                : ''}${dir.arg ? `,arg:${dir.isDynamicArg ? dir.arg : `"${dir.arg}"`}` : ''}${dir.modifiers ? `,modifiers:${JSON.stringify(dir.modifiers)}` : ''}},`;
        }
    }
    if (hasRuntime) {
        return res.slice(0, -1) + ']';
    }
}
function genInlineTemplate(el, state) {
    const ast = el.children[0];
    if ((el.children.length !== 1 || ast.type !== 1)) {
        state.warn('Inline-template components must have exactly one child element.', { start: el.start });
    }
    if (ast && ast.type === 1) {
        const inlineRenderFns = generate(ast, state.options);
        return `inlineTemplate:{render:function(){${inlineRenderFns.render}},staticRenderFns:[${inlineRenderFns.staticRenderFns
            .map(code => `function(){${code}}`)
            .join(',')}]}`;
    }
}
function genScopedSlots(el, slots, state) {
    // by default scoped slots are considered "stable", this allows child
    // components with only scoped slots to skip forced updates from parent.
    // but in some cases we have to bail-out of this optimization
    // for example if the slot contains dynamic names, has v-if or v-for on them...
    let needsForceUpdate = el.for ||
        Object.keys(slots).some(key => {
            const slot = slots[key];
            return (slot.slotTargetDynamic || slot.if || slot.for || containsSlotChild(slot) // is passing down slot from parent which may be dynamic
            );
        });
    // #9534: if a component with scoped slots is inside a conditional branch,
    // it's possible for the same component to be reused but with different
    // compiled slot content. To avoid that, we generate a unique key based on
    // the generated code of all the slot contents.
    let needsKey = !!el.if;
    // OR when it is inside another scoped slot or v-for (the reactivity may be
    // disconnected due to the intermediate scope variable)
    // #9438, #9506
    // TODO: this can be further optimized by properly analyzing in-scope bindings
    // and skip force updating ones that do not actually use scope variables.
    if (!needsForceUpdate) {
        let parent = el.parent;
        while (parent) {
            if ((parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||
                parent.for) {
                needsForceUpdate = true;
                break;
            }
            if (parent.if) {
                needsKey = true;
            }
            parent = parent.parent;
        }
    }
    const generatedSlots = Object.keys(slots)
        .map(key => genScopedSlot(slots[key], state))
        .join(',');
    return `scopedSlots:_u([${generatedSlots}]${needsForceUpdate ? `,null,true` : ``}${!needsForceUpdate && needsKey ? `,null,false,${hash(generatedSlots)}` : ``})`;
}
function hash(str) {
    let hash = 5381;
    let i = str.length;
    while (i) {
        hash = (hash * 33) ^ str.charCodeAt(--i);
    }
    return hash >>> 0;
}
function containsSlotChild(el) {
    if (el.type === 1) {
        if (el.tag === 'slot') {
            return true;
        }
        return el.children.some(containsSlotChild);
    }
    return false;
}
function genScopedSlot(el, state) {
    const isLegacySyntax = el.attrsMap['slot-scope'];
    if (el.if && !el.ifProcessed && !isLegacySyntax) {
        return genIf(el, state, genScopedSlot, `null`);
    }
    if (el.for && !el.forProcessed) {
        return genFor(el, state, genScopedSlot);
    }
    const slotScope = el.slotScope === emptySlotScopeToken ? `` : String(el.slotScope);
    const fn = `function(${slotScope}){` +
        `return ${el.tag === 'template'
            ? el.if && isLegacySyntax
                ? `(${el.if})?${genChildren(el, state) || 'undefined'}:undefined`
                : genChildren(el, state) || 'undefined'
            : genElement(el, state)}}`;
    // reverse proxy v-slot without scope on this.$slots
    const reverseProxy = slotScope ? `` : `,proxy:true`;
    return `{key:${el.slotTarget || `"default"`},fn:${fn}${reverseProxy}}`;
}
function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
    const children = el.children;
    if (children.length) {
        const el = children[0];
        // optimize single v-for
        if (children.length === 1 &&
            el.for &&
            el.tag !== 'template' &&
            el.tag !== 'slot') {
            const normalizationType = checkSkip
                ? state.maybeComponent(el)
                    ? `,1`
                    : `,0`
                : ``;
            return `${(altGenElement || genElement)(el, state)}${normalizationType}`;
        }
        const normalizationType = checkSkip
            ? getNormalizationType(children, state.maybeComponent)
            : 0;
        const gen = altGenNode || genNode;
        return `[${children.map(c => gen(c, state)).join(',')}]${normalizationType ? `,${normalizationType}` : ''}`;
    }
}
// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children, maybeComponent) {
    let res = 0;
    for (let i = 0; i < children.length; i++) {
        const el = children[i];
        if (el.type !== 1) {
            continue;
        }
        if (needsNormalization(el) ||
            (el.ifConditions &&
                el.ifConditions.some(c => needsNormalization(c.block)))) {
            res = 2;
            break;
        }
        if (maybeComponent(el) ||
            (el.ifConditions && el.ifConditions.some(c => maybeComponent(c.block)))) {
            res = 1;
        }
    }
    return res;
}
function needsNormalization(el) {
    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}
function genNode(node, state) {
    if (node.type === 1) {
        return genElement(node, state);
    }
    else if (node.type === 3 && node.isComment) {
        return genComment(node);
    }
    else {
        return genText(node);
    }
}
function genText(text) {
    return `_v(${text.type === 2
        ? text.expression // no need for () because already wrapped in _s()
        : transformSpecialNewlines(JSON.stringify(text.text))})`;
}
function genComment(comment) {
    return `_e(${JSON.stringify(comment.text)})`;
}
function genSlot(el, state) {
    const slotName = el.slotName || '"default"';
    const children = genChildren(el, state);
    let res = `_t(${slotName}${children ? `,function(){return ${children}}` : ''}`;
    const attrs = el.attrs || el.dynamicAttrs
        ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(attr => ({
            // slot props are camelized
            name: camelize(attr.name),
            value: attr.value,
            dynamic: attr.dynamic
        })))
        : null;
    const bind = el.attrsMap['v-bind'];
    if ((attrs || bind) && !children) {
        res += `,null`;
    }
    if (attrs) {
        res += `,${attrs}`;
    }
    if (bind) {
        res += `${attrs ? '' : ',null'},${bind}`;
    }
    return res + ')';
}
// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el, state) {
    const children = el.inlineTemplate ? null : genChildren(el, state, true);
    return `_c(${componentName},${genData(el, state)}${children ? `,${children}` : ''})`;
}
function genProps(props) {
    let staticProps = ``;
    let dynamicProps = ``;
    for (let i = 0; i < props.length; i++) {
        const prop = props[i];
        const value = transformSpecialNewlines(prop.value);
        if (prop.dynamic) {
            dynamicProps += `${prop.name},${value},`;
        }
        else {
            staticProps += `"${prop.name}":${value},`;
        }
    }
    staticProps = `{${staticProps.slice(0, -1)}}`;
    if (dynamicProps) {
        return `_d(${staticProps},[${dynamicProps.slice(0, -1)}])`;
    }
    else {
        return staticProps;
    }
}
// #3895, #4268
function transformSpecialNewlines(text) {
    return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
const prohibitedKeywordRE = new RegExp('\\b' +
    ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
        'super,throw,while,yield,delete,export,import,return,switch,default,' +
        'extends,finally,continue,debugger,function,arguments')
        .split(',')
        .join('\\b|\\b') +
    '\\b');
// these unary operators should not be used as property/method names
const unaryOperatorsRE = new RegExp('\\b' +
    'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') +
    '\\s*\\([^\\)]*\\)');
// strip strings in expressions
const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
// detect problematic expressions in a template
function detectErrors(ast, warn) {
    if (ast) {
        checkNode(ast, warn);
    }
}
function checkNode(node, warn) {
    if (node.type === 1) {
        for (const name in node.attrsMap) {
            if (dirRE.test(name)) {
                const value = node.attrsMap[name];
                if (value) {
                    const range = node.rawAttrsMap[name];
                    if (name === 'v-for') {
                        checkFor(node, `v-for="${value}"`, warn, range);
                    }
                    else if (name === 'v-slot' || name[0] === '#') {
                        checkFunctionParameterExpression(value, `${name}="${value}"`, warn, range);
                    }
                    else if (onRE.test(name)) {
                        checkEvent(value, `${name}="${value}"`, warn, range);
                    }
                    else {
                        checkExpression(value, `${name}="${value}"`, warn, range);
                    }
                }
            }
        }
        if (node.children) {
            for (let i = 0; i < node.children.length; i++) {
                checkNode(node.children[i], warn);
            }
        }
    }
    else if (node.type === 2) {
        checkExpression(node.expression, node.text, warn, node);
    }
}
function checkEvent(exp, text, warn, range) {
    const stripped = exp.replace(stripStringRE, '');
    const keywordMatch = stripped.match(unaryOperatorsRE);
    if (keywordMatch && stripped.charAt(keywordMatch.index - 1) !== '$') {
        warn(`avoid using JavaScript unary operator as property name: ` +
            `"${keywordMatch[0]}" in expression ${text.trim()}`, range);
    }
    checkExpression(exp, text, warn, range);
}
function checkFor(node, text, warn, range) {
    checkExpression(node.for || '', text, warn, range);
    checkIdentifier(node.alias, 'v-for alias', text, warn, range);
    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);
    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);
}
function checkIdentifier(ident, type, text, warn, range) {
    if (typeof ident === 'string') {
        try {
            new Function(`var ${ident}=_`);
        }
        catch (e) {
            warn(`invalid ${type} "${ident}" in expression: ${text.trim()}`, range);
        }
    }
}
function checkExpression(exp, text, warn, range) {
    try {
        new Function(`return ${exp}`);
    }
    catch (e) {
        const keywordMatch = exp
            .replace(stripStringRE, '')
            .match(prohibitedKeywordRE);
        if (keywordMatch) {
            warn(`avoid using JavaScript keyword as property name: ` +
                `"${keywordMatch[0]}"\n  Raw expression: ${text.trim()}`, range);
        }
        else {
            warn(`invalid expression: ${e.message} in\n\n` +
                `    ${exp}\n\n` +
                `  Raw expression: ${text.trim()}\n`, range);
        }
    }
}
function checkFunctionParameterExpression(exp, text, warn, range) {
    try {
        new Function(exp, '');
    }
    catch (e) {
        warn(`invalid function parameter expression: ${e.message} in\n\n` +
            `    ${exp}\n\n` +
            `  Raw expression: ${text.trim()}\n`, range);
    }
}

const range = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
    const lines = source.split(/\r?\n/);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
        count += lines[i].length + 1;
        if (count >= start) {
            for (let j = i - range; j <= i + range || end > count; j++) {
                if (j < 0 || j >= lines.length)
                    continue;
                res.push(`${j + 1}${repeat(` `, 3 - String(j + 1).length)}|  ${lines[j]}`);
                const lineLength = lines[j].length;
                if (j === i) {
                    // push underline
                    const pad = start - (count - lineLength) + 1;
                    const length = end > count ? lineLength - pad : end - start;
                    res.push(`   |  ` + repeat(` `, pad) + repeat(`^`, length));
                }
                else if (j > i) {
                    if (end > count) {
                        const length = Math.min(end - count, lineLength);
                        res.push(`   |  ` + repeat(`^`, length));
                    }
                    count += lineLength + 1;
                }
            }
            break;
        }
    }
    return res.join('\n');
}
function repeat(str, n) {
    let result = '';
    if (n > 0) {
        // eslint-disable-next-line no-constant-condition
        while (true) {
            // eslint-disable-line
            if (n & 1)
                result += str;
            n >>>= 1;
            if (n <= 0)
                break;
            str += str;
        }
    }
    return result;
}

function createFunction(code, errors) {
    try {
        return new Function(code);
    }
    catch (err) {
        errors.push({ err, code });
        return noop;
    }
}
function createCompileToFunctionFn(compile) {
    const cache = Object.create(null);
    return function compileToFunctions(template, options, vm) {
        options = extend({}, options);
        const warn = options.warn || warn$2;
        delete options.warn;
        /* istanbul ignore if */
        {
            // detect possible CSP restriction
            try {
                new Function('return 1');
            }
            catch (e) {
                if (e.toString().match(/unsafe-eval|CSP/)) {
                    warn('It seems you are using the standalone build of Vue.js in an ' +
                        'environment with Content Security Policy that prohibits unsafe-eval. ' +
                        'The template compiler cannot work in this environment. Consider ' +
                        'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
                        'templates into render functions.');
                }
            }
        }
        // check cache
        const key = options.delimiters
            ? String(options.delimiters) + template
            : template;
        if (cache[key]) {
            return cache[key];
        }
        // compile
        const compiled = compile(template, options);
        // check compilation errors/tips
        {
            if (compiled.errors && compiled.errors.length) {
                if (options.outputSourceRange) {
                    compiled.errors.forEach(e => {
                        warn(`Error compiling template:\n\n${e.msg}\n\n` +
                            generateCodeFrame(template, e.start, e.end), vm);
                    });
                }
                else {
                    warn(`Error compiling template:\n\n${template}\n\n` +
                        compiled.errors.map(e => `- ${e}`).join('\n') +
                        '\n', vm);
                }
            }
            if (compiled.tips && compiled.tips.length) {
                if (options.outputSourceRange) {
                    compiled.tips.forEach(e => tip(e.msg, vm));
                }
                else {
                    compiled.tips.forEach(msg => tip(msg, vm));
                }
            }
        }
        // turn code into functions
        const res = {};
        const fnGenErrors = [];
        res.render = createFunction(compiled.render, fnGenErrors);
        res.staticRenderFns = compiled.staticRenderFns.map(code => {
            return createFunction(code, fnGenErrors);
        });
        // check function generation errors.
        // this should only happen if there is a bug in the compiler itself.
        // mostly for codegen development use
        /* istanbul ignore if */
        {
            if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
                warn(`Failed to generate render function:\n\n` +
                    fnGenErrors
                        .map(({ err, code }) => `${err.toString()} in\n\n${code}\n`)
                        .join('\n'), vm);
            }
        }
        return (cache[key] = res);
    };
}

function createCompilerCreator(baseCompile) {
    return function createCompiler(baseOptions) {
        function compile(template, options) {
            const finalOptions = Object.create(baseOptions);
            const errors = [];
            const tips = [];
            let warn = (msg, range, tip) => {
                (tip ? tips : errors).push(msg);
            };
            if (options) {
                if (options.outputSourceRange) {
                    // $flow-disable-line
                    const leadingSpaceLength = template.match(/^\s*/)[0].length;
                    warn = (msg, range, tip) => {
                        const data = typeof msg === 'string' ? { msg } : msg;
                        if (range) {
                            if (range.start != null) {
                                data.start = range.start + leadingSpaceLength;
                            }
                            if (range.end != null) {
                                data.end = range.end + leadingSpaceLength;
                            }
                        }
                        (tip ? tips : errors).push(data);
                    };
                }
                // merge custom modules
                if (options.modules) {
                    finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
                }
                // merge custom directives
                if (options.directives) {
                    finalOptions.directives = extend(Object.create(baseOptions.directives || null), options.directives);
                }
                // copy other options
                for (const key in options) {
                    if (key !== 'modules' && key !== 'directives') {
                        finalOptions[key] = options[key];
                    }
                }
            }
            finalOptions.warn = warn;
            const compiled = baseCompile(template.trim(), finalOptions);
            {
                detectErrors(compiled.ast, warn);
            }
            compiled.errors = errors;
            compiled.tips = tips;
            return compiled;
        }
        return {
            compile,
            compileToFunctions: createCompileToFunctionFn(compile)
        };
    };
}

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
const createCompiler = createCompilerCreator(function baseCompile(template, options) {
    const ast = parse(template.trim(), options);
    if (options.optimize !== false) {
        optimize(ast, options);
    }
    const code = generate(ast, options);
    return {
        ast,
        render: code.render,
        staticRenderFns: code.staticRenderFns
    };
});

const { compile, compileToFunctions } = createCompiler(baseOptions);

// check whether current browser encodes a char inside attribute values
let div;
function getShouldDecode(href) {
    div = div || document.createElement('div');
    div.innerHTML = href ? `<a href="\n"/>` : `<div a="\n"/>`;
    return div.innerHTML.indexOf('&#10;') > 0;
}
// #3663: IE encodes newlines inside attribute values while other browsers don't
const shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
const shouldDecodeNewlinesForHref = inBrowser
    ? getShouldDecode(true)
    : false;

const idToTemplate = cached(id => {
    const el = query(id);
    return el && el.innerHTML;
});
const mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (el, hydrating) {
    el = el && query(el);
    /* istanbul ignore if */
    if (el === document.body || el === document.documentElement) {
        warn$2(`Do not mount Vue to <html> or <body> - mount to normal elements instead.`);
        return this;
    }
    const options = this.$options;
    // resolve template/el and convert to render function
    if (!options.render) {
        let template = options.template;
        if (template) {
            if (typeof template === 'string') {
                if (template.charAt(0) === '#') {
                    template = idToTemplate(template);
                    /* istanbul ignore if */
                    if (!template) {
                        warn$2(`Template element not found or is empty: ${options.template}`, this);
                    }
                }
            }
            else if (template.nodeType) {
                template = template.innerHTML;
            }
            else {
                {
                    warn$2('invalid template option:' + template, this);
                }
                return this;
            }
        }
        else if (el) {
            // @ts-expect-error
            template = getOuterHTML(el);
        }
        if (template) {
            /* istanbul ignore if */
            if (config.performance && mark) {
                mark('compile');
            }
            const { render, staticRenderFns } = compileToFunctions(template, {
                outputSourceRange: true,
                shouldDecodeNewlines,
                shouldDecodeNewlinesForHref,
                delimiters: options.delimiters,
                comments: options.comments
            }, this);
            options.render = render;
            options.staticRenderFns = staticRenderFns;
            /* istanbul ignore if */
            if (config.performance && mark) {
                mark('compile end');
                measure(`vue ${this._name} compile`, 'compile', 'compile end');
            }
        }
    }
    return mount.call(this, el, hydrating);
};
/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
    if (el.outerHTML) {
        return el.outerHTML;
    }
    else {
        const container = document.createElement('div');
        container.appendChild(el.cloneNode(true));
        return container.innerHTML;
    }
}
Vue.compile = compileToFunctions;

// export type EffectScheduler = (...args: any[]) => any
/**
 * @internal since we are not exposing this in Vue 2, it's used only for
 * internal testing.
 */
function effect(fn, scheduler) {
    const watcher = new Watcher(currentInstance, fn, noop, {
        sync: true
    });
    if (scheduler) {
        watcher.update = () => {
            scheduler(() => watcher.run());
        };
    }
}

extend(Vue, vca);
Vue.effect = effect;

module.exports = Vue;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":38}],41:[function(require,module,exports){
(function (process){(function (){
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./vue.common.prod.js')
} else {
  module.exports = require('./vue.common.dev.js')
}

}).call(this)}).call(this,require('_process'))

},{"./vue.common.dev.js":40,"./vue.common.prod.js":42,"_process":37}],42:[function(require,module,exports){
(function (global,setImmediate){(function (){
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
"use strict";const t=Object.freeze({}),e=Array.isArray;function n(t){return null==t}function o(t){return null!=t}function r(t){return!0===t}function s(t){return"string"==typeof t||"number"==typeof t||"symbol"==typeof t||"boolean"==typeof t}function i(t){return"function"==typeof t}function c(t){return null!==t&&"object"==typeof t}const a=Object.prototype.toString;function l(t){return"[object Object]"===a.call(t)}function u(t){const e=parseFloat(String(t));return e>=0&&Math.floor(e)===e&&isFinite(t)}function f(t){return o(t)&&"function"==typeof t.then&&"function"==typeof t.catch}function d(t){return null==t?"":Array.isArray(t)||l(t)&&t.toString===a?JSON.stringify(t,p,2):String(t)}function p(t,e){return e&&e.__v_isRef?e.value:e}function h(t){const e=parseFloat(t);return isNaN(e)?t:e}function m(t,e){const n=Object.create(null),o=t.split(",");for(let t=0;t<o.length;t++)n[o[t]]=!0;return e?t=>n[t.toLowerCase()]:t=>n[t]}const g=m("slot,component",!0),v=m("key,ref,slot,slot-scope,is");function y(t,e){const n=t.length;if(n){if(e===t[n-1])return void(t.length=n-1);const o=t.indexOf(e);if(o>-1)return t.splice(o,1)}}const _=Object.prototype.hasOwnProperty;function $(t,e){return _.call(t,e)}function b(t){const e=Object.create(null);return function(n){return e[n]||(e[n]=t(n))}}const w=/-(\w)/g,x=b((t=>t.replace(w,((t,e)=>e?e.toUpperCase():"")))),C=b((t=>t.charAt(0).toUpperCase()+t.slice(1))),k=/\B([A-Z])/g,S=b((t=>t.replace(k,"-$1").toLowerCase()));const O=Function.prototype.bind?function(t,e){return t.bind(e)}:function(t,e){function n(n){const o=arguments.length;return o?o>1?t.apply(e,arguments):t.call(e,n):t.call(e)}return n._length=t.length,n};function T(t,e){e=e||0;let n=t.length-e;const o=new Array(n);for(;n--;)o[n]=t[n+e];return o}function A(t,e){for(const n in e)t[n]=e[n];return t}function j(t){const e={};for(let n=0;n<t.length;n++)t[n]&&A(e,t[n]);return e}function E(t,e,n){}const N=(t,e,n)=>!1,P=t=>t;function D(t,e){if(t===e)return!0;const n=c(t),o=c(e);if(!n||!o)return!n&&!o&&String(t)===String(e);try{const n=Array.isArray(t),o=Array.isArray(e);if(n&&o)return t.length===e.length&&t.every(((t,n)=>D(t,e[n])));if(t instanceof Date&&e instanceof Date)return t.getTime()===e.getTime();if(n||o)return!1;{const n=Object.keys(t),o=Object.keys(e);return n.length===o.length&&n.every((n=>D(t[n],e[n])))}}catch(t){return!1}}function M(t,e){for(let n=0;n<t.length;n++)if(D(t[n],e))return n;return-1}function I(t){let e=!1;return function(){e||(e=!0,t.apply(this,arguments))}}function L(t,e){return t===e?0===t&&1/t!=1/e:t==t||e==e}const R="data-server-rendered",F=["component","directive","filter"],H=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"];var B={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:N,isReservedAttr:N,isUnknownElement:N,getTagNamespace:E,parsePlatformTagName:P,mustUseProp:N,async:!0,_lifecycleHooks:H};const U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function z(t){const e=(t+"").charCodeAt(0);return 36===e||95===e}function V(t,e,n,o){Object.defineProperty(t,e,{value:n,enumerable:!!o,writable:!0,configurable:!0})}const K=new RegExp(`[^${U.source}.$_\\d]`);const J="__proto__"in{},q="undefined"!=typeof window,W=q&&window.navigator.userAgent.toLowerCase(),Z=W&&/msie|trident/.test(W),G=W&&W.indexOf("msie 9.0")>0,X=W&&W.indexOf("edge/")>0;W&&W.indexOf("android");const Y=W&&/iphone|ipad|ipod|ios/.test(W);W&&/chrome\/\d+/.test(W),W&&/phantomjs/.test(W);const Q=W&&W.match(/firefox\/(\d+)/),tt={}.watch;let et,nt=!1;if(q)try{const t={};Object.defineProperty(t,"passive",{get(){nt=!0}}),window.addEventListener("test-passive",null,t)}catch(t){}const ot=()=>(void 0===et&&(et=!q&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),et),rt=q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function st(t){return"function"==typeof t&&/native code/.test(t.toString())}const it="undefined"!=typeof Symbol&&st(Symbol)&&"undefined"!=typeof Reflect&&st(Reflect.ownKeys);let ct;ct="undefined"!=typeof Set&&st(Set)?Set:class{constructor(){this.set=Object.create(null)}has(t){return!0===this.set[t]}add(t){this.set[t]=!0}clear(){this.set=Object.create(null)}};let at=null;function lt(t=null){t||at&&at._scope.off(),at=t,t&&t._scope.on()}class ut{constructor(t,e,n,o,r,s,i,c){this.tag=t,this.data=e,this.children=n,this.text=o,this.elm=r,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=c,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}get child(){return this.componentInstance}}const ft=(t="")=>{const e=new ut;return e.text=t,e.isComment=!0,e};function dt(t){return new ut(void 0,void 0,void 0,String(t))}function pt(t){const e=new ut(t.tag,t.data,t.children&&t.children.slice(),t.text,t.elm,t.context,t.componentOptions,t.asyncFactory);return e.ns=t.ns,e.isStatic=t.isStatic,e.key=t.key,e.isComment=t.isComment,e.fnContext=t.fnContext,e.fnOptions=t.fnOptions,e.fnScopeId=t.fnScopeId,e.asyncMeta=t.asyncMeta,e.isCloned=!0,e}let ht=0;const mt=[],gt=()=>{for(let t=0;t<mt.length;t++){const e=mt[t];e.subs=e.subs.filter((t=>t)),e._pending=!1}mt.length=0};class vt{constructor(){this._pending=!1,this.id=ht++,this.subs=[]}addSub(t){this.subs.push(t)}removeSub(t){this.subs[this.subs.indexOf(t)]=null,this._pending||(this._pending=!0,mt.push(this))}depend(t){vt.target&&vt.target.addDep(this)}notify(t){const e=this.subs.filter((t=>t));for(let t=0,n=e.length;t<n;t++){e[t].update()}}}vt.target=null;const yt=[];function _t(t){yt.push(t),vt.target=t}function $t(){yt.pop(),vt.target=yt[yt.length-1]}const bt=Array.prototype,wt=Object.create(bt);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(t){const e=bt[t];V(wt,t,(function(...n){const o=e.apply(this,n),r=this.__ob__;let s;switch(t){case"push":case"unshift":s=n;break;case"splice":s=n.slice(2)}return s&&r.observeArray(s),r.dep.notify(),o}))}));const xt=Object.getOwnPropertyNames(wt),Ct={};let kt=!0;function St(t){kt=t}const Ot={notify:E,depend:E,addSub:E,removeSub:E};class Tt{constructor(t,n=!1,o=!1){if(this.value=t,this.shallow=n,this.mock=o,this.dep=o?Ot:new vt,this.vmCount=0,V(t,"__ob__",this),e(t)){if(!o)if(J)t.__proto__=wt;else for(let e=0,n=xt.length;e<n;e++){const n=xt[e];V(t,n,wt[n])}n||this.observeArray(t)}else{const e=Object.keys(t);for(let r=0;r<e.length;r++){jt(t,e[r],Ct,void 0,n,o)}}}observeArray(t){for(let e=0,n=t.length;e<n;e++)At(t[e],!1,this.mock)}}function At(t,n,o){return t&&$(t,"__ob__")&&t.__ob__ instanceof Tt?t.__ob__:!kt||!o&&ot()||!e(t)&&!l(t)||!Object.isExtensible(t)||t.__v_skip||Ht(t)||t instanceof ut?void 0:new Tt(t,n,o)}function jt(t,n,o,r,s,i,c=!1){const a=new vt,l=Object.getOwnPropertyDescriptor(t,n);if(l&&!1===l.configurable)return;const u=l&&l.get,f=l&&l.set;u&&!f||o!==Ct&&2!==arguments.length||(o=t[n]);let d=s?o&&o.__ob__:At(o,!1,i);return Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:function(){const n=u?u.call(t):o;return vt.target&&(a.depend(),d&&(d.dep.depend(),e(n)&&Pt(n))),Ht(n)&&!s?n.value:n},set:function(e){const n=u?u.call(t):o;if(L(n,e)){if(f)f.call(t,e);else{if(u)return;if(!s&&Ht(n)&&!Ht(e))return void(n.value=e);o=e}d=s?e&&e.__ob__:At(e,!1,i),a.notify()}}}),a}function Et(t,n,o){if(Rt(t))return;const r=t.__ob__;return e(t)&&u(n)?(t.length=Math.max(t.length,n),t.splice(n,1,o),r&&!r.shallow&&r.mock&&At(o,!1,!0),o):n in t&&!(n in Object.prototype)?(t[n]=o,o):t._isVue||r&&r.vmCount?o:r?(jt(r.value,n,o,void 0,r.shallow,r.mock),r.dep.notify(),o):(t[n]=o,o)}function Nt(t,n){if(e(t)&&u(n))return void t.splice(n,1);const o=t.__ob__;t._isVue||o&&o.vmCount||Rt(t)||$(t,n)&&(delete t[n],o&&o.dep.notify())}function Pt(t){for(let n,o=0,r=t.length;o<r;o++)n=t[o],n&&n.__ob__&&n.__ob__.dep.depend(),e(n)&&Pt(n)}function Dt(t){return Mt(t,!0),V(t,"__v_isShallow",!0),t}function Mt(t,e){Rt(t)||At(t,e,ot())}function It(t){return Rt(t)?It(t.__v_raw):!(!t||!t.__ob__)}function Lt(t){return!(!t||!t.__v_isShallow)}function Rt(t){return!(!t||!t.__v_isReadonly)}const Ft="__v_isRef";function Ht(t){return!(!t||!0!==t.__v_isRef)}function Bt(t,e){if(Ht(t))return t;const n={};return V(n,Ft,!0),V(n,"__v_isShallow",e),V(n,"dep",jt(n,"value",t,null,e,ot())),n}function Ut(t,e,n){Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get:()=>{const t=e[n];if(Ht(t))return t.value;{const e=t&&t.__ob__;return e&&e.dep.depend(),t}},set:t=>{const o=e[n];Ht(o)&&!Ht(t)?o.value=t:e[n]=t}})}function zt(t,e,n){const o=t[e];if(Ht(o))return o;const r={get value(){const o=t[e];return void 0===o?n:o},set value(n){t[e]=n}};return V(r,Ft,!0),r}const Vt="__v_rawToReadonly",Kt="__v_rawToShallowReadonly";function Jt(t){return qt(t,!1)}function qt(t,e){if(!l(t))return t;if(Rt(t))return t;const n=e?Kt:Vt,o=t[n];if(o)return o;const r=Object.create(Object.getPrototypeOf(t));V(t,n,r),V(r,"__v_isReadonly",!0),V(r,"__v_raw",t),Ht(t)&&V(r,Ft,!0),(e||Lt(t))&&V(r,"__v_isShallow",!0);const s=Object.keys(t);for(let n=0;n<s.length;n++)Wt(r,t,s[n],e);return r}function Wt(t,e,n,o){Object.defineProperty(t,n,{enumerable:!0,configurable:!0,get(){const t=e[n];return o||!l(t)?t:Jt(t)},set(){}})}const Zt=b((t=>{const e="&"===t.charAt(0),n="~"===(t=e?t.slice(1):t).charAt(0),o="!"===(t=n?t.slice(1):t).charAt(0);return{name:t=o?t.slice(1):t,once:n,capture:o,passive:e}}));function Gt(t,n){function o(){const t=o.fns;if(!e(t))return vn(t,null,arguments,n,"v-on handler");{const e=t.slice();for(let t=0;t<e.length;t++)vn(e[t],null,arguments,n,"v-on handler")}}return o.fns=t,o}function Xt(t,e,o,s,i,c){let a,l,u,f;for(a in t)l=t[a],u=e[a],f=Zt(a),n(l)||(n(u)?(n(l.fns)&&(l=t[a]=Gt(l,c)),r(f.once)&&(l=t[a]=i(f.name,l,f.capture)),o(f.name,l,f.capture,f.passive,f.params)):l!==u&&(u.fns=l,t[a]=u));for(a in e)n(t[a])&&(f=Zt(a),s(f.name,e[a],f.capture))}function Yt(t,e,s){let i;t instanceof ut&&(t=t.data.hook||(t.data.hook={}));const c=t[e];function a(){s.apply(this,arguments),y(i.fns,a)}n(c)?i=Gt([a]):o(c.fns)&&r(c.merged)?(i=c,i.fns.push(a)):i=Gt([c,a]),i.merged=!0,t[e]=i}function Qt(t,e,n,r,s){if(o(e)){if($(e,n))return t[n]=e[n],s||delete e[n],!0;if($(e,r))return t[n]=e[r],s||delete e[r],!0}return!1}function te(t){return s(t)?[dt(t)]:e(t)?ne(t):void 0}function ee(t){return o(t)&&o(t.text)&&!1===t.isComment}function ne(t,i){const c=[];let a,l,u,f;for(a=0;a<t.length;a++)l=t[a],n(l)||"boolean"==typeof l||(u=c.length-1,f=c[u],e(l)?l.length>0&&(l=ne(l,`${i||""}_${a}`),ee(l[0])&&ee(f)&&(c[u]=dt(f.text+l[0].text),l.shift()),c.push.apply(c,l)):s(l)?ee(f)?c[u]=dt(f.text+l):""!==l&&c.push(dt(l)):ee(l)&&ee(f)?c[u]=dt(f.text+l.text):(r(t._isVList)&&o(l.tag)&&n(l.key)&&o(i)&&(l.key=`__vlist${i}_${a}__`),c.push(l)));return c}const oe=1,re=2;function se(t,n,a,l,u,f){return(e(a)||s(a))&&(u=l,l=a,a=void 0),r(f)&&(u=re),function(t,n,r,s,a){if(o(r)&&o(r.__ob__))return ft();o(r)&&o(r.is)&&(n=r.is);if(!n)return ft();e(s)&&i(s[0])&&((r=r||{}).scopedSlots={default:s[0]},s.length=0);a===re?s=te(s):a===oe&&(s=function(t){for(let n=0;n<t.length;n++)if(e(t[n]))return Array.prototype.concat.apply([],t);return t}(s));let l,u;if("string"==typeof n){let e;u=t.$vnode&&t.$vnode.ns||B.getTagNamespace(n),l=B.isReservedTag(n)?new ut(B.parsePlatformTagName(n),r,s,void 0,void 0,t):r&&r.pre||!o(e=$o(t.$options,"components",n))?new ut(n,r,s,void 0,void 0,t):lo(e,r,t,s,n)}else l=lo(n,r,t,s);return e(l)?l:o(l)?(o(u)&&ie(l,u),o(r)&&function(t){c(t.style)&&Un(t.style);c(t.class)&&Un(t.class)}(r),l):ft()}(t,n,a,l,u)}function ie(t,e,s){if(t.ns=e,"foreignObject"===t.tag&&(e=void 0,s=!0),o(t.children))for(let i=0,c=t.children.length;i<c;i++){const c=t.children[i];o(c.tag)&&(n(c.ns)||r(s)&&"svg"!==c.tag)&&ie(c,e,s)}}function ce(t,n){let r,s,i,a,l=null;if(e(t)||"string"==typeof t)for(l=new Array(t.length),r=0,s=t.length;r<s;r++)l[r]=n(t[r],r);else if("number"==typeof t)for(l=new Array(t),r=0;r<t;r++)l[r]=n(r+1,r);else if(c(t))if(it&&t[Symbol.iterator]){l=[];const e=t[Symbol.iterator]();let o=e.next();for(;!o.done;)l.push(n(o.value,l.length)),o=e.next()}else for(i=Object.keys(t),l=new Array(i.length),r=0,s=i.length;r<s;r++)a=i[r],l[r]=n(t[a],a,r);return o(l)||(l=[]),l._isVList=!0,l}function ae(t,e,n,o){const r=this.$scopedSlots[t];let s;r?(n=n||{},o&&(n=A(A({},o),n)),s=r(n)||(i(e)?e():e)):s=this.$slots[t]||(i(e)?e():e);const c=n&&n.slot;return c?this.$createElement("template",{slot:c},s):s}function le(t){return $o(this.$options,"filters",t)||P}function ue(t,n){return e(t)?-1===t.indexOf(n):t!==n}function fe(t,e,n,o,r){const s=B.keyCodes[e]||n;return r&&o&&!B.keyCodes[e]?ue(r,o):s?ue(s,t):o?S(o)!==e:void 0===t}function de(t,n,o,r,s){if(o)if(c(o)){let i;e(o)&&(o=j(o));for(const e in o){if("class"===e||"style"===e||v(e))i=t;else{const o=t.attrs&&t.attrs.type;i=r||B.mustUseProp(n,o,e)?t.domProps||(t.domProps={}):t.attrs||(t.attrs={})}const c=x(e),a=S(e);if(!(c in i)&&!(a in i)&&(i[e]=o[e],s)){(t.on||(t.on={}))[`update:${e}`]=function(t){o[e]=t}}}}else;return t}function pe(t,e){const n=this._staticTrees||(this._staticTrees=[]);let o=n[t];return o&&!e||(o=n[t]=this.$options.staticRenderFns[t].call(this._renderProxy,this._c,this),me(o,`__static__${t}`,!1)),o}function he(t,e,n){return me(t,`__once__${e}${n?`_${n}`:""}`,!0),t}function me(t,n,o){if(e(t))for(let e=0;e<t.length;e++)t[e]&&"string"!=typeof t[e]&&ge(t[e],`${n}_${e}`,o);else ge(t,n,o)}function ge(t,e,n){t.isStatic=!0,t.key=e,t.isOnce=n}function ve(t,e){if(e)if(l(e)){const n=t.on=t.on?A({},t.on):{};for(const t in e){const o=n[t],r=e[t];n[t]=o?[].concat(o,r):r}}else;return t}function ye(t,n,o,r){n=n||{$stable:!o};for(let r=0;r<t.length;r++){const s=t[r];e(s)?ye(s,n,o):s&&(s.proxy&&(s.fn.proxy=!0),n[s.key]=s.fn)}return r&&(n.$key=r),n}function _e(t,e){for(let n=0;n<e.length;n+=2){const o=e[n];"string"==typeof o&&o&&(t[e[n]]=e[n+1])}return t}function $e(t,e){return"string"==typeof t?e+t:t}function be(t){t._o=he,t._n=h,t._s=d,t._l=ce,t._t=ae,t._q=D,t._i=M,t._m=pe,t._f=le,t._k=fe,t._b=de,t._v=dt,t._e=ft,t._u=ye,t._g=ve,t._d=_e,t._p=$e}function we(t,e){if(!t||!t.length)return{};const n={};for(let o=0,r=t.length;o<r;o++){const r=t[o],s=r.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,r.context!==e&&r.fnContext!==e||!s||null==s.slot)(n.default||(n.default=[])).push(r);else{const t=s.slot,e=n[t]||(n[t]=[]);"template"===r.tag?e.push.apply(e,r.children||[]):e.push(r)}}for(const t in n)n[t].every(xe)&&delete n[t];return n}function xe(t){return t.isComment&&!t.asyncFactory||" "===t.text}function Ce(t){return t.isComment&&t.asyncFactory}function ke(e,n,o,r){let s;const i=Object.keys(o).length>0,c=n?!!n.$stable:!i,a=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(c&&r&&r!==t&&a===r.$key&&!i&&!r.$hasNormal)return r;s={};for(const t in n)n[t]&&"$"!==t[0]&&(s[t]=Se(e,o,t,n[t]))}else s={};for(const t in o)t in s||(s[t]=Oe(o,t));return n&&Object.isExtensible(n)&&(n._normalized=s),V(s,"$stable",c),V(s,"$key",a),V(s,"$hasNormal",i),s}function Se(t,n,o,r){const s=function(){const n=at;lt(t);let o=arguments.length?r.apply(null,arguments):r({});o=o&&"object"==typeof o&&!e(o)?[o]:te(o);const s=o&&o[0];return lt(n),o&&(!s||1===o.length&&s.isComment&&!Ce(s))?void 0:o};return r.proxy&&Object.defineProperty(n,o,{get:s,enumerable:!0,configurable:!0}),s}function Oe(t,e){return()=>t[e]}function Te(e){return{get attrs(){if(!e._attrsProxy){const n=e._attrsProxy={};V(n,"_v_attr_proxy",!0),Ae(n,e.$attrs,t,e,"$attrs")}return e._attrsProxy},get listeners(){if(!e._listenersProxy){Ae(e._listenersProxy={},e.$listeners,t,e,"$listeners")}return e._listenersProxy},get slots(){return function(t){t._slotsProxy||Ee(t._slotsProxy={},t.$scopedSlots);return t._slotsProxy}(e)},emit:O(e.$emit,e),expose(t){t&&Object.keys(t).forEach((n=>Ut(e,t,n)))}}}function Ae(t,e,n,o,r){let s=!1;for(const i in e)i in t?e[i]!==n[i]&&(s=!0):(s=!0,je(t,i,o,r));for(const n in t)n in e||(s=!0,delete t[n]);return s}function je(t,e,n,o){Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:()=>n[o][e]})}function Ee(t,e){for(const n in e)t[n]=e[n];for(const n in t)n in e||delete t[n]}function Ne(){const t=at;return t._setupContext||(t._setupContext=Te(t))}let Pe,De,Me=null;function Ie(t,e){return(t.__esModule||it&&"Module"===t[Symbol.toStringTag])&&(t=t.default),c(t)?e.extend(t):t}function Le(t){if(e(t))for(let e=0;e<t.length;e++){const n=t[e];if(o(n)&&(o(n.componentOptions)||Ce(n)))return n}}function Re(t,e){Pe.$on(t,e)}function Fe(t,e){Pe.$off(t,e)}function He(t,e){const n=Pe;return function o(){null!==e.apply(null,arguments)&&n.$off(t,o)}}function Be(t,e,n){Pe=t,Xt(e,n||{},Re,Fe,He,t),Pe=void 0}class Ue{constructor(t=!1){this.detached=t,this.active=!0,this.effects=[],this.cleanups=[],this.parent=De,!t&&De&&(this.index=(De.scopes||(De.scopes=[])).push(this)-1)}run(t){if(this.active){const e=De;try{return De=this,t()}finally{De=e}}}on(){De=this}off(){De=this.parent}stop(t){if(this.active){let e,n;for(e=0,n=this.effects.length;e<n;e++)this.effects[e].teardown();for(e=0,n=this.cleanups.length;e<n;e++)this.cleanups[e]();if(this.scopes)for(e=0,n=this.scopes.length;e<n;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!t){const t=this.parent.scopes.pop();t&&t!==this&&(this.parent.scopes[this.index]=t,t.index=this.index)}this.parent=void 0,this.active=!1}}}function ze(){return De}let Ve=null;function Ke(t){const e=Ve;return Ve=t,()=>{Ve=e}}function Je(t){for(;t&&(t=t.$parent);)if(t._inactive)return!0;return!1}function qe(t,e){if(e){if(t._directInactive=!1,Je(t))return}else if(t._directInactive)return;if(t._inactive||null===t._inactive){t._inactive=!1;for(let e=0;e<t.$children.length;e++)qe(t.$children[e]);Ze(t,"activated")}}function We(t,e){if(!(e&&(t._directInactive=!0,Je(t))||t._inactive)){t._inactive=!0;for(let e=0;e<t.$children.length;e++)We(t.$children[e]);Ze(t,"deactivated")}}function Ze(t,e,n,o=!0){_t();const r=at,s=ze();o&&lt(t);const i=t.$options[e],c=`${e} hook`;if(i)for(let e=0,o=i.length;e<o;e++)vn(i[e],t,n||null,t,c);t._hasHookEvent&&t.$emit("hook:"+e),o&&(lt(r),s&&s.on()),$t()}const Ge=[],Xe=[];let Ye={},Qe=!1,tn=!1,en=0;let nn=0,on=Date.now;if(q&&!Z){const t=window.performance;t&&"function"==typeof t.now&&on()>document.createEvent("Event").timeStamp&&(on=()=>t.now())}const rn=(t,e)=>{if(t.post){if(!e.post)return 1}else if(e.post)return-1;return t.id-e.id};function sn(){let t,e;for(nn=on(),tn=!0,Ge.sort(rn),en=0;en<Ge.length;en++)t=Ge[en],t.before&&t.before(),e=t.id,Ye[e]=null,t.run();const n=Xe.slice(),o=Ge.slice();en=Ge.length=Xe.length=0,Ye={},Qe=tn=!1,function(t){for(let e=0;e<t.length;e++)t[e]._inactive=!0,qe(t[e],!0)}(n),function(t){let e=t.length;for(;e--;){const n=t[e],o=n.vm;o&&o._watcher===n&&o._isMounted&&!o._isDestroyed&&Ze(o,"updated")}}(o),gt(),rt&&B.devtools&&rt.emit("flush")}function cn(t){const e=t.id;if(null==Ye[e]&&(t!==vt.target||!t.noRecurse)){if(Ye[e]=!0,tn){let e=Ge.length-1;for(;e>en&&Ge[e].id>t.id;)e--;Ge.splice(e+1,0,t)}else Ge.push(t);Qe||(Qe=!0,kn(sn))}}const an="watcher",ln=`${an} callback`,un=`${an} getter`,fn=`${an} cleanup`;function dn(t,e){return hn(t,null,{flush:"post"})}const pn={};function hn(n,o,{immediate:r,deep:s,flush:c="pre",onTrack:a,onTrigger:l}=t){const u=at,f=(t,e,n=null)=>{const o=vn(t,null,n,u,e);return s&&o&&o.__ob__&&o.__ob__.dep.depend(),o};let d,p,h=!1,m=!1;if(Ht(n)?(d=()=>n.value,h=Lt(n)):It(n)?(d=()=>(n.__ob__.dep.depend(),n),s=!0):e(n)?(m=!0,h=n.some((t=>It(t)||Lt(t))),d=()=>n.map((t=>Ht(t)?t.value:It(t)?(t.__ob__.dep.depend(),Un(t)):i(t)?f(t,un):void 0))):d=i(n)?o?()=>f(n,un):()=>{if(!u||!u._isDestroyed)return p&&p(),f(n,an,[g])}:E,o&&s){const t=d;d=()=>Un(t())}let g=t=>{p=v.onStop=()=>{f(t,fn)}};if(ot())return g=E,o?r&&f(o,ln,[d(),m?[]:void 0,g]):d(),E;const v=new Kn(at,d,E,{lazy:!0});v.noRecurse=!o;let y=m?[]:pn;return v.run=()=>{if(v.active)if(o){const t=v.get();(s||h||(m?t.some(((t,e)=>L(t,y[e]))):L(t,y)))&&(p&&p(),f(o,ln,[t,y===pn?void 0:y,g]),y=t)}else v.get()},"sync"===c?v.update=v.run:"post"===c?(v.post=!0,v.update=()=>cn(v)):v.update=()=>{if(u&&u===at&&!u._isMounted){const t=u._preWatchers||(u._preWatchers=[]);t.indexOf(v)<0&&t.push(v)}else cn(v)},o?r?v.run():y=v.get():"post"===c&&u?u.$once("hook:mounted",(()=>v.get())):v.get(),()=>{v.teardown()}}function mn(t){const e=t._provided,n=t.$parent&&t.$parent._provided;return n===e?t._provided=Object.create(n):e}function gn(t,e,n){_t();try{if(e){let o=e;for(;o=o.$parent;){const r=o.$options.errorCaptured;if(r)for(let s=0;s<r.length;s++)try{if(!1===r[s].call(o,t,e,n))return}catch(t){yn(t,o,"errorCaptured hook")}}}yn(t,e,n)}finally{$t()}}function vn(t,e,n,o,r){let s;try{s=n?t.apply(e,n):t.call(e),s&&!s._isVue&&f(s)&&!s._handled&&(s.catch((t=>gn(t,o,r+" (Promise/async)"))),s._handled=!0)}catch(t){gn(t,o,r)}return s}function yn(t,e,n){if(B.errorHandler)try{return B.errorHandler.call(null,t,e,n)}catch(e){e!==t&&_n(e)}_n(t)}function _n(t,e,n){if(!q||"undefined"==typeof console)throw t;console.error(t)}let $n=!1;const bn=[];let wn,xn=!1;function Cn(){xn=!1;const t=bn.slice(0);bn.length=0;for(let e=0;e<t.length;e++)t[e]()}if("undefined"!=typeof Promise&&st(Promise)){const t=Promise.resolve();wn=()=>{t.then(Cn),Y&&setTimeout(E)},$n=!0}else if(Z||"undefined"==typeof MutationObserver||!st(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())wn="undefined"!=typeof setImmediate&&st(setImmediate)?()=>{setImmediate(Cn)}:()=>{setTimeout(Cn,0)};else{let t=1;const e=new MutationObserver(Cn),n=document.createTextNode(String(t));e.observe(n,{characterData:!0}),wn=()=>{t=(t+1)%2,n.data=String(t)},$n=!0}function kn(t,e){let n;if(bn.push((()=>{if(t)try{t.call(e)}catch(t){gn(t,e,"nextTick")}else n&&n(e)})),xn||(xn=!0,wn()),!t&&"undefined"!=typeof Promise)return new Promise((t=>{n=t}))}function Sn(t){return(e,n=at)=>{if(n)return function(t,e,n){const o=t.$options;o[e]=go(o[e],n)}(n,t,e)}}const On=Sn("beforeMount"),Tn=Sn("mounted"),An=Sn("beforeUpdate"),jn=Sn("updated"),En=Sn("beforeDestroy"),Nn=Sn("destroyed"),Pn=Sn("activated"),Dn=Sn("deactivated"),Mn=Sn("serverPrefetch"),In=Sn("renderTracked"),Ln=Sn("renderTriggered"),Rn=Sn("errorCaptured");const Fn="2.7.16";var Hn=Object.freeze({__proto__:null,version:Fn,defineComponent:function(t){return t},ref:function(t){return Bt(t,!1)},shallowRef:function(t){return Bt(t,!0)},isRef:Ht,toRef:zt,toRefs:function(t){const n=e(t)?new Array(t.length):{};for(const e in t)n[e]=zt(t,e);return n},unref:function(t){return Ht(t)?t.value:t},proxyRefs:function(t){if(It(t))return t;const e={},n=Object.keys(t);for(let o=0;o<n.length;o++)Ut(e,t,n[o]);return e},customRef:function(t){const e=new vt,{get:n,set:o}=t((()=>{e.depend()}),(()=>{e.notify()})),r={get value(){return n()},set value(t){o(t)}};return V(r,Ft,!0),r},triggerRef:function(t){t.dep&&t.dep.notify()},reactive:function(t){return Mt(t,!1),t},isReactive:It,isReadonly:Rt,isShallow:Lt,isProxy:function(t){return It(t)||Rt(t)},shallowReactive:Dt,markRaw:function(t){return Object.isExtensible(t)&&V(t,"__v_skip",!0),t},toRaw:function t(e){const n=e&&e.__v_raw;return n?t(n):e},readonly:Jt,shallowReadonly:function(t){return qt(t,!0)},computed:function(t,e){let n,o;const r=i(t);r?(n=t,o=E):(n=t.get,o=t.set);const s=ot()?null:new Kn(at,n,E,{lazy:!0}),c={effect:s,get value(){return s?(s.dirty&&s.evaluate(),vt.target&&s.depend(),s.value):n()},set value(t){o(t)}};return V(c,Ft,!0),V(c,"__v_isReadonly",r),c},watch:function(t,e,n){return hn(t,e,n)},watchEffect:function(t,e){return hn(t,null,e)},watchPostEffect:dn,watchSyncEffect:function(t,e){return hn(t,null,{flush:"sync"})},EffectScope:Ue,effectScope:function(t){return new Ue(t)},onScopeDispose:function(t){De&&De.cleanups.push(t)},getCurrentScope:ze,provide:function(t,e){at&&(mn(at)[t]=e)},inject:function(t,e,n=!1){const o=at;if(o){const r=o.$parent&&o.$parent._provided;if(r&&t in r)return r[t];if(arguments.length>1)return n&&i(e)?e.call(o):e}},h:function(t,e,n){return se(at,t,e,n,2,!0)},getCurrentInstance:function(){return at&&{proxy:at}},useSlots:function(){return Ne().slots},useAttrs:function(){return Ne().attrs},useListeners:function(){return Ne().listeners},mergeDefaults:function(t,n){const o=e(t)?t.reduce(((t,e)=>(t[e]={},t)),{}):t;for(const t in n){const r=o[t];r?e(r)||i(r)?o[t]={type:r,default:n[t]}:r.default=n[t]:null===r&&(o[t]={default:n[t]})}return o},nextTick:kn,set:Et,del:Nt,useCssModule:function(e="$style"){{if(!at)return t;const n=at[e];return n||t}},useCssVars:function(t){if(!q)return;const e=at;e&&dn((()=>{const n=e.$el,o=t(e,e._setupProxy);if(n&&1===n.nodeType){const t=n.style;for(const e in o)t.setProperty(`--${e}`,o[e])}}))},defineAsyncComponent:function(t){i(t)&&(t={loader:t});const{loader:e,loadingComponent:n,errorComponent:o,delay:r=200,timeout:s,suspensible:c=!1,onError:a}=t;let l=null,u=0;const f=()=>{let t;return l||(t=l=e().catch((t=>{if(t=t instanceof Error?t:new Error(String(t)),a)return new Promise(((e,n)=>{a(t,(()=>e((u++,l=null,f()))),(()=>n(t)),u+1)}));throw t})).then((e=>t!==l&&l?l:(e&&(e.__esModule||"Module"===e[Symbol.toStringTag])&&(e=e.default),e))))};return()=>({component:f(),delay:r,timeout:s,error:o,loading:n})},onBeforeMount:On,onMounted:Tn,onBeforeUpdate:An,onUpdated:jn,onBeforeUnmount:En,onUnmounted:Nn,onActivated:Pn,onDeactivated:Dn,onServerPrefetch:Mn,onRenderTracked:In,onRenderTriggered:Ln,onErrorCaptured:function(t,e=at){Rn(t,e)}});const Bn=new ct;function Un(t){return zn(t,Bn),Bn.clear(),t}function zn(t,n){let o,r;const s=e(t);if(!(!s&&!c(t)||t.__v_skip||Object.isFrozen(t)||t instanceof ut)){if(t.__ob__){const e=t.__ob__.dep.id;if(n.has(e))return;n.add(e)}if(s)for(o=t.length;o--;)zn(t[o],n);else if(Ht(t))zn(t.value,n);else for(r=Object.keys(t),o=r.length;o--;)zn(t[r[o]],n)}}let Vn=0;class Kn{constructor(t,e,n,o,r){!function(t,e=De){e&&e.active&&e.effects.push(t)}(this,De&&!De._vm?De:t?t._scope:void 0),(this.vm=t)&&r&&(t._watcher=this),o?(this.deep=!!o.deep,this.user=!!o.user,this.lazy=!!o.lazy,this.sync=!!o.sync,this.before=o.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++Vn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ct,this.newDepIds=new ct,this.expression="",i(e)?this.getter=e:(this.getter=function(t){if(K.test(t))return;const e=t.split(".");return function(t){for(let n=0;n<e.length;n++){if(!t)return;t=t[e[n]]}return t}}(e),this.getter||(this.getter=E)),this.value=this.lazy?void 0:this.get()}get(){let t;_t(this);const e=this.vm;try{t=this.getter.call(e,e)}catch(t){if(!this.user)throw t;gn(t,e,`getter for watcher "${this.expression}"`)}finally{this.deep&&Un(t),$t(),this.cleanupDeps()}return t}addDep(t){const e=t.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(t),this.depIds.has(e)||t.addSub(this))}cleanupDeps(){let t=this.deps.length;for(;t--;){const e=this.deps[t];this.newDepIds.has(e.id)||e.removeSub(this)}let e=this.depIds;this.depIds=this.newDepIds,this.newDepIds=e,this.newDepIds.clear(),e=this.deps,this.deps=this.newDeps,this.newDeps=e,this.newDeps.length=0}update(){this.lazy?this.dirty=!0:this.sync?this.run():cn(this)}run(){if(this.active){const t=this.get();if(t!==this.value||c(t)||this.deep){const e=this.value;if(this.value=t,this.user){const n=`callback for watcher "${this.expression}"`;vn(this.cb,this.vm,[t,e],this.vm,n)}else this.cb.call(this.vm,t,e)}}}evaluate(){this.value=this.get(),this.dirty=!1}depend(){let t=this.deps.length;for(;t--;)this.deps[t].depend()}teardown(){if(this.vm&&!this.vm._isBeingDestroyed&&y(this.vm._scope.effects,this),this.active){let t=this.deps.length;for(;t--;)this.deps[t].removeSub(this);this.active=!1,this.onStop&&this.onStop()}}}const Jn={enumerable:!0,configurable:!0,get:E,set:E};function qn(t,e,n){Jn.get=function(){return this[e][n]},Jn.set=function(t){this[e][n]=t},Object.defineProperty(t,n,Jn)}function Wn(t){const n=t.$options;if(n.props&&function(t,e){const n=t.$options.propsData||{},o=t._props=Dt({}),r=t.$options._propKeys=[],s=!t.$parent;s||St(!1);for(const s in e){r.push(s);jt(o,s,bo(s,e,n,t),void 0,!0),s in t||qn(t,"_props",s)}St(!0)}(t,n.props),function(t){const e=t.$options,n=e.setup;if(n){const o=t._setupContext=Te(t);lt(t),_t();const r=vn(n,null,[t._props||Dt({}),o],t,"setup");if($t(),lt(),i(r))e.render=r;else if(c(r))if(t._setupState=r,r.__sfc){const e=t._setupProxy={};for(const t in r)"__sfc"!==t&&Ut(e,r,t)}else for(const e in r)z(e)||Ut(t,r,e)}}(t),n.methods&&function(t,e){t.$options.props;for(const n in e)t[n]="function"!=typeof e[n]?E:O(e[n],t)}(t,n.methods),n.data)!function(t){let e=t.$options.data;e=t._data=i(e)?function(t,e){_t();try{return t.call(e,e)}catch(t){return gn(t,e,"data()"),{}}finally{$t()}}(e,t):e||{},l(e)||(e={});const n=Object.keys(e),o=t.$options.props;t.$options.methods;let r=n.length;for(;r--;){const e=n[r];o&&$(o,e)||z(e)||qn(t,"_data",e)}const s=At(e);s&&s.vmCount++}(t);else{const e=At(t._data={});e&&e.vmCount++}n.computed&&function(t,e){const n=t._computedWatchers=Object.create(null),o=ot();for(const r in e){const s=e[r],c=i(s)?s:s.get;o||(n[r]=new Kn(t,c||E,E,Zn)),r in t||Gn(t,r,s)}}(t,n.computed),n.watch&&n.watch!==tt&&function(t,n){for(const o in n){const r=n[o];if(e(r))for(let e=0;e<r.length;e++)Qn(t,o,r[e]);else Qn(t,o,r)}}(t,n.watch)}const Zn={lazy:!0};function Gn(t,e,n){const o=!ot();i(n)?(Jn.get=o?Xn(e):Yn(n),Jn.set=E):(Jn.get=n.get?o&&!1!==n.cache?Xn(e):Yn(n.get):E,Jn.set=n.set||E),Object.defineProperty(t,e,Jn)}function Xn(t){return function(){const e=this._computedWatchers&&this._computedWatchers[t];if(e)return e.dirty&&e.evaluate(),vt.target&&e.depend(),e.value}}function Yn(t){return function(){return t.call(this,this)}}function Qn(t,e,n,o){return l(n)&&(o=n,n=n.handler),"string"==typeof n&&(n=t[n]),t.$watch(e,n,o)}function to(t,e){if(t){const n=Object.create(null),o=it?Reflect.ownKeys(t):Object.keys(t);for(let r=0;r<o.length;r++){const s=o[r];if("__ob__"===s)continue;const c=t[s].from;if(c in e._provided)n[s]=e._provided[c];else if("default"in t[s]){const o=t[s].default;n[s]=i(o)?o.call(e):o}}return n}}let eo=0;function no(t){let e=t.options;if(t.super){const n=no(t.super);if(n!==t.superOptions){t.superOptions=n;const o=function(t){let e;const n=t.options,o=t.sealedOptions;for(const t in n)n[t]!==o[t]&&(e||(e={}),e[t]=n[t]);return e}(t);o&&A(t.extendOptions,o),e=t.options=_o(n,t.extendOptions),e.name&&(e.components[e.name]=t)}}return e}function oo(n,o,s,i,c){const a=c.options;let l;$(i,"_uid")?(l=Object.create(i),l._original=i):(l=i,i=i._original);const u=r(a._compiled),f=!u;this.data=n,this.props=o,this.children=s,this.parent=i,this.listeners=n.on||t,this.injections=to(a.inject,i),this.slots=()=>(this.$slots||ke(i,n.scopedSlots,this.$slots=we(s,i)),this.$slots),Object.defineProperty(this,"scopedSlots",{enumerable:!0,get(){return ke(i,n.scopedSlots,this.slots())}}),u&&(this.$options=a,this.$slots=this.slots(),this.$scopedSlots=ke(i,n.scopedSlots,this.$slots)),a._scopeId?this._c=(t,n,o,r)=>{const s=se(l,t,n,o,r,f);return s&&!e(s)&&(s.fnScopeId=a._scopeId,s.fnContext=i),s}:this._c=(t,e,n,o)=>se(l,t,e,n,o,f)}function ro(t,e,n,o,r){const s=pt(t);return s.fnContext=n,s.fnOptions=o,e.slot&&((s.data||(s.data={})).slot=e.slot),s}function so(t,e){for(const n in e)t[x(n)]=e[n]}function io(t){return t.name||t.__name||t._componentTag}be(oo.prototype);const co={init(t,e){if(t.componentInstance&&!t.componentInstance._isDestroyed&&t.data.keepAlive){const e=t;co.prepatch(e,e)}else{(t.componentInstance=function(t,e){const n={_isComponent:!0,_parentVnode:t,parent:e},r=t.data.inlineTemplate;o(r)&&(n.render=r.render,n.staticRenderFns=r.staticRenderFns);return new t.componentOptions.Ctor(n)}(t,Ve)).$mount(e?t.elm:void 0,e)}},prepatch(e,n){const o=n.componentOptions;!function(e,n,o,r,s){const i=r.data.scopedSlots,c=e.$scopedSlots,a=!!(i&&!i.$stable||c!==t&&!c.$stable||i&&e.$scopedSlots.$key!==i.$key||!i&&e.$scopedSlots.$key);let l=!!(s||e.$options._renderChildren||a);const u=e.$vnode;e.$options._parentVnode=r,e.$vnode=r,e._vnode&&(e._vnode.parent=r),e.$options._renderChildren=s;const f=r.data.attrs||t;e._attrsProxy&&Ae(e._attrsProxy,f,u.data&&u.data.attrs||t,e,"$attrs")&&(l=!0),e.$attrs=f,o=o||t;const d=e.$options._parentListeners;if(e._listenersProxy&&Ae(e._listenersProxy,o,d||t,e,"$listeners"),e.$listeners=e.$options._parentListeners=o,Be(e,o,d),n&&e.$options.props){St(!1);const t=e._props,o=e.$options._propKeys||[];for(let r=0;r<o.length;r++){const s=o[r],i=e.$options.props;t[s]=bo(s,i,n,e)}St(!0),e.$options.propsData=n}l&&(e.$slots=we(s,r.context),e.$forceUpdate())}(n.componentInstance=e.componentInstance,o.propsData,o.listeners,n,o.children)},insert(t){const{context:e,componentInstance:n}=t;var o;n._isMounted||(n._isMounted=!0,Ze(n,"mounted")),t.data.keepAlive&&(e._isMounted?((o=n)._inactive=!1,Xe.push(o)):qe(n,!0))},destroy(t){const{componentInstance:e}=t;e._isDestroyed||(t.data.keepAlive?We(e,!0):e.$destroy())}},ao=Object.keys(co);function lo(s,i,a,l,u){if(n(s))return;const d=a.$options._base;if(c(s)&&(s=d.extend(s)),"function"!=typeof s)return;let p;if(n(s.cid)&&(p=s,s=function(t,e){if(r(t.error)&&o(t.errorComp))return t.errorComp;if(o(t.resolved))return t.resolved;const s=Me;if(s&&o(t.owners)&&-1===t.owners.indexOf(s)&&t.owners.push(s),r(t.loading)&&o(t.loadingComp))return t.loadingComp;if(s&&!o(t.owners)){const r=t.owners=[s];let i=!0,a=null,l=null;s.$on("hook:destroyed",(()=>y(r,s)));const u=t=>{for(let t=0,e=r.length;t<e;t++)r[t].$forceUpdate();t&&(r.length=0,null!==a&&(clearTimeout(a),a=null),null!==l&&(clearTimeout(l),l=null))},d=I((n=>{t.resolved=Ie(n,e),i?r.length=0:u(!0)})),p=I((e=>{o(t.errorComp)&&(t.error=!0,u(!0))})),h=t(d,p);return c(h)&&(f(h)?n(t.resolved)&&h.then(d,p):f(h.component)&&(h.component.then(d,p),o(h.error)&&(t.errorComp=Ie(h.error,e)),o(h.loading)&&(t.loadingComp=Ie(h.loading,e),0===h.delay?t.loading=!0:a=setTimeout((()=>{a=null,n(t.resolved)&&n(t.error)&&(t.loading=!0,u(!1))}),h.delay||200)),o(h.timeout)&&(l=setTimeout((()=>{l=null,n(t.resolved)&&p(null)}),h.timeout)))),i=!1,t.loading?t.loadingComp:t.resolved}}(p,d),void 0===s))return function(t,e,n,o,r){const s=ft();return s.asyncFactory=t,s.asyncMeta={data:e,context:n,children:o,tag:r},s}(p,i,a,l,u);i=i||{},no(s),o(i.model)&&function(t,n){const r=t.model&&t.model.prop||"value",s=t.model&&t.model.event||"input";(n.attrs||(n.attrs={}))[r]=n.model.value;const i=n.on||(n.on={}),c=i[s],a=n.model.callback;o(c)?(e(c)?-1===c.indexOf(a):c!==a)&&(i[s]=[a].concat(c)):i[s]=a}(s.options,i);const h=function(t,e,r){const s=e.options.props;if(n(s))return;const i={},{attrs:c,props:a}=t;if(o(c)||o(a))for(const t in s){const e=S(t);Qt(i,a,t,e,!0)||Qt(i,c,t,e,!1)}return i}(i,s);if(r(s.options.functional))return function(n,r,s,i,c){const a=n.options,l={},u=a.props;if(o(u))for(const e in u)l[e]=bo(e,u,r||t);else o(s.attrs)&&so(l,s.attrs),o(s.props)&&so(l,s.props);const f=new oo(s,l,c,i,n),d=a.render.call(null,f._c,f);if(d instanceof ut)return ro(d,s,f.parent,a);if(e(d)){const t=te(d)||[],e=new Array(t.length);for(let n=0;n<t.length;n++)e[n]=ro(t[n],s,f.parent,a);return e}}(s,h,i,a,l);const m=i.on;if(i.on=i.nativeOn,r(s.options.abstract)){const t=i.slot;i={},t&&(i.slot=t)}!function(t){const e=t.hook||(t.hook={});for(let t=0;t<ao.length;t++){const n=ao[t],o=e[n],r=co[n];o===r||o&&o._merged||(e[n]=o?uo(r,o):r)}}(i);const g=io(s.options)||u;return new ut(`vue-component-${s.cid}${g?`-${g}`:""}`,i,void 0,void 0,void 0,a,{Ctor:s,propsData:h,listeners:m,tag:u,children:l},p)}function uo(t,e){const n=(n,o)=>{t(n,o),e(n,o)};return n._merged=!0,n}let fo=E;const po=B.optionMergeStrategies;function ho(t,e,n=!0){if(!e)return t;let o,r,s;const i=it?Reflect.ownKeys(e):Object.keys(e);for(let c=0;c<i.length;c++)o=i[c],"__ob__"!==o&&(r=t[o],s=e[o],n&&$(t,o)?r!==s&&l(r)&&l(s)&&ho(r,s):Et(t,o,s));return t}function mo(t,e,n){return n?function(){const o=i(e)?e.call(n,n):e,r=i(t)?t.call(n,n):t;return o?ho(o,r):r}:e?t?function(){return ho(i(e)?e.call(this,this):e,i(t)?t.call(this,this):t)}:e:t}function go(t,n){const o=n?t?t.concat(n):e(n)?n:[n]:t;return o?function(t){const e=[];for(let n=0;n<t.length;n++)-1===e.indexOf(t[n])&&e.push(t[n]);return e}(o):o}function vo(t,e,n,o){const r=Object.create(t||null);return e?A(r,e):r}po.data=function(t,e,n){return n?mo(t,e,n):e&&"function"!=typeof e?t:mo(t,e)},H.forEach((t=>{po[t]=go})),F.forEach((function(t){po[t+"s"]=vo})),po.watch=function(t,n,o,r){if(t===tt&&(t=void 0),n===tt&&(n=void 0),!n)return Object.create(t||null);if(!t)return n;const s={};A(s,t);for(const t in n){let o=s[t];const r=n[t];o&&!e(o)&&(o=[o]),s[t]=o?o.concat(r):e(r)?r:[r]}return s},po.props=po.methods=po.inject=po.computed=function(t,e,n,o){if(!t)return e;const r=Object.create(null);return A(r,t),e&&A(r,e),r},po.provide=function(t,e){return t?function(){const n=Object.create(null);return ho(n,i(t)?t.call(this):t),e&&ho(n,i(e)?e.call(this):e,!1),n}:e};const yo=function(t,e){return void 0===e?t:e};function _o(t,n,o){if(i(n)&&(n=n.options),function(t,n){const o=t.props;if(!o)return;const r={};let s,i,c;if(e(o))for(s=o.length;s--;)i=o[s],"string"==typeof i&&(c=x(i),r[c]={type:null});else if(l(o))for(const t in o)i=o[t],c=x(t),r[c]=l(i)?i:{type:i};t.props=r}(n),function(t,n){const o=t.inject;if(!o)return;const r=t.inject={};if(e(o))for(let t=0;t<o.length;t++)r[o[t]]={from:o[t]};else if(l(o))for(const t in o){const e=o[t];r[t]=l(e)?A({from:t},e):{from:e}}}(n),function(t){const e=t.directives;if(e)for(const t in e){const n=e[t];i(n)&&(e[t]={bind:n,update:n})}}(n),!n._base&&(n.extends&&(t=_o(t,n.extends,o)),n.mixins))for(let e=0,r=n.mixins.length;e<r;e++)t=_o(t,n.mixins[e],o);const r={};let s;for(s in t)c(s);for(s in n)$(t,s)||c(s);function c(e){const s=po[e]||yo;r[e]=s(t[e],n[e],o,e)}return r}function $o(t,e,n,o){if("string"!=typeof n)return;const r=t[e];if($(r,n))return r[n];const s=x(n);if($(r,s))return r[s];const i=C(s);if($(r,i))return r[i];return r[n]||r[s]||r[i]}function bo(t,e,n,o){const r=e[t],s=!$(n,t);let c=n[t];const a=ko(Boolean,r.type);if(a>-1)if(s&&!$(r,"default"))c=!1;else if(""===c||c===S(t)){const t=ko(String,r.type);(t<0||a<t)&&(c=!0)}if(void 0===c){c=function(t,e,n){if(!$(e,"default"))return;const o=e.default;if(t&&t.$options.propsData&&void 0===t.$options.propsData[n]&&void 0!==t._props[n])return t._props[n];return i(o)&&"Function"!==xo(e.type)?o.call(t):o}(o,r,t);const e=kt;St(!0),At(c),St(e)}return c}const wo=/^\s*function (\w+)/;function xo(t){const e=t&&t.toString().match(wo);return e?e[1]:""}function Co(t,e){return xo(t)===xo(e)}function ko(t,n){if(!e(n))return Co(n,t)?0:-1;for(let e=0,o=n.length;e<o;e++)if(Co(n[e],t))return e;return-1}function So(t){this._init(t)}function Oo(t){t.cid=0;let e=1;t.extend=function(t){t=t||{};const n=this,o=n.cid,r=t._Ctor||(t._Ctor={});if(r[o])return r[o];const s=io(t)||io(n.options),i=function(t){this._init(t)};return(i.prototype=Object.create(n.prototype)).constructor=i,i.cid=e++,i.options=_o(n.options,t),i.super=n,i.options.props&&function(t){const e=t.options.props;for(const n in e)qn(t.prototype,"_props",n)}(i),i.options.computed&&function(t){const e=t.options.computed;for(const n in e)Gn(t.prototype,n,e[n])}(i),i.extend=n.extend,i.mixin=n.mixin,i.use=n.use,F.forEach((function(t){i[t]=n[t]})),s&&(i.options.components[s]=i),i.superOptions=n.options,i.extendOptions=t,i.sealedOptions=A({},i.options),r[o]=i,i}}function To(t){return t&&(io(t.Ctor.options)||t.tag)}function Ao(t,n){return e(t)?t.indexOf(n)>-1:"string"==typeof t?t.split(",").indexOf(n)>-1:(o=t,"[object RegExp]"===a.call(o)&&t.test(n));var o}function jo(t,e){const{cache:n,keys:o,_vnode:r,$vnode:s}=t;for(const t in n){const s=n[t];if(s){const i=s.name;i&&!e(i)&&Eo(n,t,o,r)}}s.componentOptions.children=void 0}function Eo(t,e,n,o){const r=t[e];!r||o&&r.tag===o.tag||r.componentInstance.$destroy(),t[e]=null,y(n,e)}!function(e){e.prototype._init=function(e){const n=this;n._uid=eo++,n._isVue=!0,n.__v_skip=!0,n._scope=new Ue(!0),n._scope.parent=void 0,n._scope._vm=!0,e&&e._isComponent?function(t,e){const n=t.$options=Object.create(t.constructor.options),o=e._parentVnode;n.parent=e.parent,n._parentVnode=o;const r=o.componentOptions;n.propsData=r.propsData,n._parentListeners=r.listeners,n._renderChildren=r.children,n._componentTag=r.tag,e.render&&(n.render=e.render,n.staticRenderFns=e.staticRenderFns)}(n,e):n.$options=_o(no(n.constructor),e||{},n),n._renderProxy=n,n._self=n,function(t){const e=t.$options;let n=e.parent;if(n&&!e.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(t)}t.$parent=n,t.$root=n?n.$root:t,t.$children=[],t.$refs={},t._provided=n?n._provided:Object.create(null),t._watcher=null,t._inactive=null,t._directInactive=!1,t._isMounted=!1,t._isDestroyed=!1,t._isBeingDestroyed=!1}(n),function(t){t._events=Object.create(null),t._hasHookEvent=!1;const e=t.$options._parentListeners;e&&Be(t,e)}(n),function(e){e._vnode=null,e._staticTrees=null;const n=e.$options,o=e.$vnode=n._parentVnode,r=o&&o.context;e.$slots=we(n._renderChildren,r),e.$scopedSlots=o?ke(e.$parent,o.data.scopedSlots,e.$slots):t,e._c=(t,n,o,r)=>se(e,t,n,o,r,!1),e.$createElement=(t,n,o,r)=>se(e,t,n,o,r,!0);const s=o&&o.data;jt(e,"$attrs",s&&s.attrs||t,null,!0),jt(e,"$listeners",n._parentListeners||t,null,!0)}(n),Ze(n,"beforeCreate",void 0,!1),function(t){const e=to(t.$options.inject,t);e&&(St(!1),Object.keys(e).forEach((n=>{jt(t,n,e[n])})),St(!0))}(n),Wn(n),function(t){const e=t.$options.provide;if(e){const n=i(e)?e.call(t):e;if(!c(n))return;const o=mn(t),r=it?Reflect.ownKeys(n):Object.keys(n);for(let t=0;t<r.length;t++){const e=r[t];Object.defineProperty(o,e,Object.getOwnPropertyDescriptor(n,e))}}}(n),Ze(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(So),function(t){const e={get:function(){return this._data}},n={get:function(){return this._props}};Object.defineProperty(t.prototype,"$data",e),Object.defineProperty(t.prototype,"$props",n),t.prototype.$set=Et,t.prototype.$delete=Nt,t.prototype.$watch=function(t,e,n){const o=this;if(l(e))return Qn(o,t,e,n);(n=n||{}).user=!0;const r=new Kn(o,t,e,n);if(n.immediate){const t=`callback for immediate watcher "${r.expression}"`;_t(),vn(e,o,[r.value],o,t),$t()}return function(){r.teardown()}}}(So),function(t){const n=/^hook:/;t.prototype.$on=function(t,o){const r=this;if(e(t))for(let e=0,n=t.length;e<n;e++)r.$on(t[e],o);else(r._events[t]||(r._events[t]=[])).push(o),n.test(t)&&(r._hasHookEvent=!0);return r},t.prototype.$once=function(t,e){const n=this;function o(){n.$off(t,o),e.apply(n,arguments)}return o.fn=e,n.$on(t,o),n},t.prototype.$off=function(t,n){const o=this;if(!arguments.length)return o._events=Object.create(null),o;if(e(t)){for(let e=0,r=t.length;e<r;e++)o.$off(t[e],n);return o}const r=o._events[t];if(!r)return o;if(!n)return o._events[t]=null,o;let s,i=r.length;for(;i--;)if(s=r[i],s===n||s.fn===n){r.splice(i,1);break}return o},t.prototype.$emit=function(t){const e=this;let n=e._events[t];if(n){n=n.length>1?T(n):n;const o=T(arguments,1),r=`event handler for "${t}"`;for(let t=0,s=n.length;t<s;t++)vn(n[t],e,o,e,r)}return e}}(So),function(t){t.prototype._update=function(t,e){const n=this,o=n.$el,r=n._vnode,s=Ke(n);n._vnode=t,n.$el=r?n.__patch__(r,t):n.__patch__(n.$el,t,e,!1),s(),o&&(o.__vue__=null),n.$el&&(n.$el.__vue__=n);let i=n;for(;i&&i.$vnode&&i.$parent&&i.$vnode===i.$parent._vnode;)i.$parent.$el=i.$el,i=i.$parent},t.prototype.$forceUpdate=function(){const t=this;t._watcher&&t._watcher.update()},t.prototype.$destroy=function(){const t=this;if(t._isBeingDestroyed)return;Ze(t,"beforeDestroy"),t._isBeingDestroyed=!0;const e=t.$parent;!e||e._isBeingDestroyed||t.$options.abstract||y(e.$children,t),t._scope.stop(),t._data.__ob__&&t._data.__ob__.vmCount--,t._isDestroyed=!0,t.__patch__(t._vnode,null),Ze(t,"destroyed"),t.$off(),t.$el&&(t.$el.__vue__=null),t.$vnode&&(t.$vnode.parent=null)}}(So),function(t){be(t.prototype),t.prototype.$nextTick=function(t){return kn(t,this)},t.prototype._render=function(){const t=this,{render:n,_parentVnode:o}=t.$options;o&&t._isMounted&&(t.$scopedSlots=ke(t.$parent,o.data.scopedSlots,t.$slots,t.$scopedSlots),t._slotsProxy&&Ee(t._slotsProxy,t.$scopedSlots)),t.$vnode=o;const r=at,s=Me;let i;try{lt(t),Me=t,i=n.call(t._renderProxy,t.$createElement)}catch(e){gn(e,t,"render"),i=t._vnode}finally{Me=s,lt(r)}return e(i)&&1===i.length&&(i=i[0]),i instanceof ut||(i=ft()),i.parent=o,i}}(So);const No=[String,RegExp,Array];var Po={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:No,exclude:No,max:[String,Number]},methods:{cacheVNode(){const{cache:t,keys:e,vnodeToCache:n,keyToCache:o}=this;if(n){const{tag:r,componentInstance:s,componentOptions:i}=n;t[o]={name:To(i),tag:r,componentInstance:s},e.push(o),this.max&&e.length>parseInt(this.max)&&Eo(t,e[0],e,this._vnode),this.vnodeToCache=null}}},created(){this.cache=Object.create(null),this.keys=[]},destroyed(){for(const t in this.cache)Eo(this.cache,t,this.keys)},mounted(){this.cacheVNode(),this.$watch("include",(t=>{jo(this,(e=>Ao(t,e)))})),this.$watch("exclude",(t=>{jo(this,(e=>!Ao(t,e)))}))},updated(){this.cacheVNode()},render(){const t=this.$slots.default,e=Le(t),n=e&&e.componentOptions;if(n){const t=To(n),{include:o,exclude:r}=this;if(o&&(!t||!Ao(o,t))||r&&t&&Ao(r,t))return e;const{cache:s,keys:i}=this,c=null==e.key?n.Ctor.cid+(n.tag?`::${n.tag}`:""):e.key;s[c]?(e.componentInstance=s[c].componentInstance,y(i,c),i.push(c)):(this.vnodeToCache=e,this.keyToCache=c),e.data.keepAlive=!0}return e||t&&t[0]}}};!function(t){const e={get:()=>B};Object.defineProperty(t,"config",e),t.util={warn:fo,extend:A,mergeOptions:_o,defineReactive:jt},t.set=Et,t.delete=Nt,t.nextTick=kn,t.observable=t=>(At(t),t),t.options=Object.create(null),F.forEach((e=>{t.options[e+"s"]=Object.create(null)})),t.options._base=t,A(t.options.components,Po),function(t){t.use=function(t){const e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(t)>-1)return this;const n=T(arguments,1);return n.unshift(this),i(t.install)?t.install.apply(t,n):i(t)&&t.apply(null,n),e.push(t),this}}(t),function(t){t.mixin=function(t){return this.options=_o(this.options,t),this}}(t),Oo(t),function(t){F.forEach((e=>{t[e]=function(t,n){return n?("component"===e&&l(n)&&(n.name=n.name||t,n=this.options._base.extend(n)),"directive"===e&&i(n)&&(n={bind:n,update:n}),this.options[e+"s"][t]=n,n):this.options[e+"s"][t]}}))}(t)}(So),Object.defineProperty(So.prototype,"$isServer",{get:ot}),Object.defineProperty(So.prototype,"$ssrContext",{get(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(So,"FunctionalRenderContext",{value:oo}),So.version=Fn;const Do=m("style,class"),Mo=m("input,textarea,option,select,progress"),Io=(t,e,n)=>"value"===n&&Mo(t)&&"button"!==e||"selected"===n&&"option"===t||"checked"===n&&"input"===t||"muted"===n&&"video"===t,Lo=m("contenteditable,draggable,spellcheck"),Ro=m("events,caret,typing,plaintext-only"),Fo=(t,e)=>Vo(e)||"false"===e?"false":"contenteditable"===t&&Ro(e)?e:"true",Ho=m("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Bo="http://www.w3.org/1999/xlink",Uo=t=>":"===t.charAt(5)&&"xlink"===t.slice(0,5),zo=t=>Uo(t)?t.slice(6,t.length):"",Vo=t=>null==t||!1===t;function Ko(t){let e=t.data,n=t,r=t;for(;o(r.componentInstance);)r=r.componentInstance._vnode,r&&r.data&&(e=Jo(r.data,e));for(;o(n=n.parent);)n&&n.data&&(e=Jo(e,n.data));return function(t,e){if(o(t)||o(e))return qo(t,Wo(e));return""}(e.staticClass,e.class)}function Jo(t,e){return{staticClass:qo(t.staticClass,e.staticClass),class:o(t.class)?[t.class,e.class]:e.class}}function qo(t,e){return t?e?t+" "+e:t:e||""}function Wo(t){return Array.isArray(t)?function(t){let e,n="";for(let r=0,s=t.length;r<s;r++)o(e=Wo(t[r]))&&""!==e&&(n&&(n+=" "),n+=e);return n}(t):c(t)?function(t){let e="";for(const n in t)t[n]&&(e&&(e+=" "),e+=n);return e}(t):"string"==typeof t?t:""}const Zo={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Go=m("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Xo=m("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Yo=t=>Go(t)||Xo(t);function Qo(t){return Xo(t)?"svg":"math"===t?"math":void 0}const tr=Object.create(null);const er=m("text,number,password,search,email,tel,url");function nr(t){if("string"==typeof t){const e=document.querySelector(t);return e||document.createElement("div")}return t}var or=Object.freeze({__proto__:null,createElement:function(t,e){const n=document.createElement(t);return"select"!==t||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(t,e){return document.createElementNS(Zo[t],e)},createTextNode:function(t){return document.createTextNode(t)},createComment:function(t){return document.createComment(t)},insertBefore:function(t,e,n){t.insertBefore(e,n)},removeChild:function(t,e){t.removeChild(e)},appendChild:function(t,e){t.appendChild(e)},parentNode:function(t){return t.parentNode},nextSibling:function(t){return t.nextSibling},tagName:function(t){return t.tagName},setTextContent:function(t,e){t.textContent=e},setStyleScope:function(t,e){t.setAttribute(e,"")}}),rr={create(t,e){sr(e)},update(t,e){t.data.ref!==e.data.ref&&(sr(t,!0),sr(e))},destroy(t){sr(t,!0)}};function sr(t,n){const r=t.data.ref;if(!o(r))return;const s=t.context,c=t.componentInstance||t.elm,a=n?null:c,l=n?void 0:c;if(i(r))return void vn(r,s,[a],s,"template ref function");const u=t.data.refInFor,f="string"==typeof r||"number"==typeof r,d=Ht(r),p=s.$refs;if(f||d)if(u){const t=f?p[r]:r.value;n?e(t)&&y(t,c):e(t)?t.includes(c)||t.push(c):f?(p[r]=[c],ir(s,r,p[r])):r.value=[c]}else if(f){if(n&&p[r]!==c)return;p[r]=l,ir(s,r,a)}else if(d){if(n&&r.value!==c)return;r.value=a}}function ir({_setupState:t},e,n){t&&$(t,e)&&(Ht(t[e])?t[e].value=n:t[e]=n)}const cr=new ut("",{},[]),ar=["create","activate","update","remove","destroy"];function lr(t,e){return t.key===e.key&&t.asyncFactory===e.asyncFactory&&(t.tag===e.tag&&t.isComment===e.isComment&&o(t.data)===o(e.data)&&function(t,e){if("input"!==t.tag)return!0;let n;const r=o(n=t.data)&&o(n=n.attrs)&&n.type,s=o(n=e.data)&&o(n=n.attrs)&&n.type;return r===s||er(r)&&er(s)}(t,e)||r(t.isAsyncPlaceholder)&&n(e.asyncFactory.error))}function ur(t,e,n){let r,s;const i={};for(r=e;r<=n;++r)s=t[r].key,o(s)&&(i[s]=r);return i}var fr={create:dr,update:dr,destroy:function(t){dr(t,cr)}};function dr(t,e){(t.data.directives||e.data.directives)&&function(t,e){const n=t===cr,o=e===cr,r=hr(t.data.directives,t.context),s=hr(e.data.directives,e.context),i=[],c=[];let a,l,u;for(a in s)l=r[a],u=s[a],l?(u.oldValue=l.value,u.oldArg=l.arg,gr(u,"update",e,t),u.def&&u.def.componentUpdated&&c.push(u)):(gr(u,"bind",e,t),u.def&&u.def.inserted&&i.push(u));if(i.length){const o=()=>{for(let n=0;n<i.length;n++)gr(i[n],"inserted",e,t)};n?Yt(e,"insert",o):o()}c.length&&Yt(e,"postpatch",(()=>{for(let n=0;n<c.length;n++)gr(c[n],"componentUpdated",e,t)}));if(!n)for(a in r)s[a]||gr(r[a],"unbind",t,t,o)}(t,e)}const pr=Object.create(null);function hr(t,e){const n=Object.create(null);if(!t)return n;let o,r;for(o=0;o<t.length;o++){if(r=t[o],r.modifiers||(r.modifiers=pr),n[mr(r)]=r,e._setupState&&e._setupState.__sfc){const t=r.def||$o(e,"_setupState","v-"+r.name);r.def="function"==typeof t?{bind:t,update:t}:t}r.def=r.def||$o(e.$options,"directives",r.name)}return n}function mr(t){return t.rawName||`${t.name}.${Object.keys(t.modifiers||{}).join(".")}`}function gr(t,e,n,o,r){const s=t.def&&t.def[e];if(s)try{s(n.elm,t,n,o,r)}catch(o){gn(o,n.context,`directive ${t.name} ${e} hook`)}}var vr=[rr,fr];function yr(t,e){const s=e.componentOptions;if(o(s)&&!1===s.Ctor.options.inheritAttrs)return;if(n(t.data.attrs)&&n(e.data.attrs))return;let i,c,a;const l=e.elm,u=t.data.attrs||{};let f=e.data.attrs||{};for(i in(o(f.__ob__)||r(f._v_attr_proxy))&&(f=e.data.attrs=A({},f)),f)c=f[i],a=u[i],a!==c&&_r(l,i,c,e.data.pre);for(i in(Z||X)&&f.value!==u.value&&_r(l,"value",f.value),u)n(f[i])&&(Uo(i)?l.removeAttributeNS(Bo,zo(i)):Lo(i)||l.removeAttribute(i))}function _r(t,e,n,o){o||t.tagName.indexOf("-")>-1?$r(t,e,n):Ho(e)?Vo(n)?t.removeAttribute(e):(n="allowfullscreen"===e&&"EMBED"===t.tagName?"true":e,t.setAttribute(e,n)):Lo(e)?t.setAttribute(e,Fo(e,n)):Uo(e)?Vo(n)?t.removeAttributeNS(Bo,zo(e)):t.setAttributeNS(Bo,e,n):$r(t,e,n)}function $r(t,e,n){if(Vo(n))t.removeAttribute(e);else{if(Z&&!G&&"TEXTAREA"===t.tagName&&"placeholder"===e&&""!==n&&!t.__ieph){const e=n=>{n.stopImmediatePropagation(),t.removeEventListener("input",e)};t.addEventListener("input",e),t.__ieph=!0}t.setAttribute(e,n)}}var br={create:yr,update:yr};function wr(t,e){const r=e.elm,s=e.data,i=t.data;if(n(s.staticClass)&&n(s.class)&&(n(i)||n(i.staticClass)&&n(i.class)))return;let c=Ko(e);const a=r._transitionClasses;o(a)&&(c=qo(c,Wo(a))),c!==r._prevClass&&(r.setAttribute("class",c),r._prevClass=c)}var xr={create:wr,update:wr};const Cr=/[\w).+\-_$\]]/;function kr(t){let e,n,o,r,s,i=!1,c=!1,a=!1,l=!1,u=0,f=0,d=0,p=0;for(o=0;o<t.length;o++)if(n=e,e=t.charCodeAt(o),i)39===e&&92!==n&&(i=!1);else if(c)34===e&&92!==n&&(c=!1);else if(a)96===e&&92!==n&&(a=!1);else if(l)47===e&&92!==n&&(l=!1);else if(124!==e||124===t.charCodeAt(o+1)||124===t.charCodeAt(o-1)||u||f||d){switch(e){case 34:c=!0;break;case 39:i=!0;break;case 96:a=!0;break;case 40:d++;break;case 41:d--;break;case 91:f++;break;case 93:f--;break;case 123:u++;break;case 125:u--}if(47===e){let e,n=o-1;for(;n>=0&&(e=t.charAt(n)," "===e);n--);e&&Cr.test(e)||(l=!0)}}else void 0===r?(p=o+1,r=t.slice(0,o).trim()):h();function h(){(s||(s=[])).push(t.slice(p,o).trim()),p=o+1}if(void 0===r?r=t.slice(0,o).trim():0!==p&&h(),s)for(o=0;o<s.length;o++)r=Sr(r,s[o]);return r}function Sr(t,e){const n=e.indexOf("(");if(n<0)return`_f("${e}")(${t})`;{const o=e.slice(0,n),r=e.slice(n+1);return`_f("${o}")(${t}${")"!==r?","+r:r}`}}function Or(t,e){console.error(`[Vue compiler]: ${t}`)}function Tr(t,e){return t?t.map((t=>t[e])).filter((t=>t)):[]}function Ar(t,e,n,o,r){(t.props||(t.props=[])).push(Rr({name:e,value:n,dynamic:r},o)),t.plain=!1}function jr(t,e,n,o,r){(r?t.dynamicAttrs||(t.dynamicAttrs=[]):t.attrs||(t.attrs=[])).push(Rr({name:e,value:n,dynamic:r},o)),t.plain=!1}function Er(t,e,n,o){t.attrsMap[e]=n,t.attrsList.push(Rr({name:e,value:n},o))}function Nr(t,e,n,o,r,s,i,c){(t.directives||(t.directives=[])).push(Rr({name:e,rawName:n,value:o,arg:r,isDynamicArg:s,modifiers:i},c)),t.plain=!1}function Pr(t,e,n){return n?`_p(${e},"${t}")`:t+e}function Dr(e,n,o,r,s,i,c,a){let l;(r=r||t).right?a?n=`(${n})==='click'?'contextmenu':(${n})`:"click"===n&&(n="contextmenu",delete r.right):r.middle&&(a?n=`(${n})==='click'?'mouseup':(${n})`:"click"===n&&(n="mouseup")),r.capture&&(delete r.capture,n=Pr("!",n,a)),r.once&&(delete r.once,n=Pr("~",n,a)),r.passive&&(delete r.passive,n=Pr("&",n,a)),r.native?(delete r.native,l=e.nativeEvents||(e.nativeEvents={})):l=e.events||(e.events={});const u=Rr({value:o.trim(),dynamic:a},c);r!==t&&(u.modifiers=r);const f=l[n];Array.isArray(f)?s?f.unshift(u):f.push(u):l[n]=f?s?[u,f]:[f,u]:u,e.plain=!1}function Mr(t,e,n){const o=Ir(t,":"+e)||Ir(t,"v-bind:"+e);if(null!=o)return kr(o);if(!1!==n){const n=Ir(t,e);if(null!=n)return JSON.stringify(n)}}function Ir(t,e,n){let o;if(null!=(o=t.attrsMap[e])){const n=t.attrsList;for(let t=0,o=n.length;t<o;t++)if(n[t].name===e){n.splice(t,1);break}}return n&&delete t.attrsMap[e],o}function Lr(t,e){const n=t.attrsList;for(let t=0,o=n.length;t<o;t++){const o=n[t];if(e.test(o.name))return n.splice(t,1),o}}function Rr(t,e){return e&&(null!=e.start&&(t.start=e.start),null!=e.end&&(t.end=e.end)),t}function Fr(t,e,n){const{number:o,trim:r}=n||{},s="$$v";let i=s;r&&(i=`(typeof ${s} === 'string'? ${s}.trim(): ${s})`),o&&(i=`_n(${i})`);const c=Hr(e,i);t.model={value:`(${e})`,expression:JSON.stringify(e),callback:`function (${s}) {${c}}`}}function Hr(t,e){const n=function(t){if(t=t.trim(),Br=t.length,t.indexOf("[")<0||t.lastIndexOf("]")<Br-1)return Vr=t.lastIndexOf("."),Vr>-1?{exp:t.slice(0,Vr),key:'"'+t.slice(Vr+1)+'"'}:{exp:t,key:null};Ur=t,Vr=Kr=Jr=0;for(;!Wr();)zr=qr(),Zr(zr)?Xr(zr):91===zr&&Gr(zr);return{exp:t.slice(0,Kr),key:t.slice(Kr+1,Jr)}}(t);return null===n.key?`${t}=${e}`:`$set(${n.exp}, ${n.key}, ${e})`}let Br,Ur,zr,Vr,Kr,Jr;function qr(){return Ur.charCodeAt(++Vr)}function Wr(){return Vr>=Br}function Zr(t){return 34===t||39===t}function Gr(t){let e=1;for(Kr=Vr;!Wr();)if(Zr(t=qr()))Xr(t);else if(91===t&&e++,93===t&&e--,0===e){Jr=Vr;break}}function Xr(t){const e=t;for(;!Wr()&&(t=qr())!==e;);}const Yr="__r",Qr="__c";let ts;function es(t,e,n){const o=ts;return function r(){null!==e.apply(null,arguments)&&rs(t,r,n,o)}}const ns=$n&&!(Q&&Number(Q[1])<=53);function os(t,e,n,o){if(ns){const t=nn,n=e;e=n._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=t||e.timeStamp<=0||e.target.ownerDocument!==document)return n.apply(this,arguments)}}ts.addEventListener(t,e,nt?{capture:n,passive:o}:n)}function rs(t,e,n,o){(o||ts).removeEventListener(t,e._wrapper||e,n)}function ss(t,e){if(n(t.data.on)&&n(e.data.on))return;const r=e.data.on||{},s=t.data.on||{};ts=e.elm||t.elm,function(t){if(o(t[Yr])){const e=Z?"change":"input";t[e]=[].concat(t[Yr],t[e]||[]),delete t[Yr]}o(t[Qr])&&(t.change=[].concat(t[Qr],t.change||[]),delete t[Qr])}(r),Xt(r,s,os,rs,es,e.context),ts=void 0}var is={create:ss,update:ss,destroy:t=>ss(t,cr)};let cs;function as(t,e){if(n(t.data.domProps)&&n(e.data.domProps))return;let s,i;const c=e.elm,a=t.data.domProps||{};let l=e.data.domProps||{};for(s in(o(l.__ob__)||r(l._v_attr_proxy))&&(l=e.data.domProps=A({},l)),a)s in l||(c[s]="");for(s in l){if(i=l[s],"textContent"===s||"innerHTML"===s){if(e.children&&(e.children.length=0),i===a[s])continue;1===c.childNodes.length&&c.removeChild(c.childNodes[0])}if("value"===s&&"PROGRESS"!==c.tagName){c._value=i;const t=n(i)?"":String(i);ls(c,t)&&(c.value=t)}else if("innerHTML"===s&&Xo(c.tagName)&&n(c.innerHTML)){cs=cs||document.createElement("div"),cs.innerHTML=`<svg>${i}</svg>`;const t=cs.firstChild;for(;c.firstChild;)c.removeChild(c.firstChild);for(;t.firstChild;)c.appendChild(t.firstChild)}else if(i!==a[s])try{c[s]=i}catch(t){}}}function ls(t,e){return!t.composing&&("OPTION"===t.tagName||function(t,e){let n=!0;try{n=document.activeElement!==t}catch(t){}return n&&t.value!==e}(t,e)||function(t,e){const n=t.value,r=t._vModifiers;if(o(r)){if(r.number)return h(n)!==h(e);if(r.trim)return n.trim()!==e.trim()}return n!==e}(t,e))}var us={create:as,update:as};const fs=b((function(t){const e={},n=/:(.+)/;return t.split(/;(?![^(]*\))/g).forEach((function(t){if(t){const o=t.split(n);o.length>1&&(e[o[0].trim()]=o[1].trim())}})),e}));function ds(t){const e=ps(t.style);return t.staticStyle?A(t.staticStyle,e):e}function ps(t){return Array.isArray(t)?j(t):"string"==typeof t?fs(t):t}const hs=/^--/,ms=/\s*!important$/,gs=(t,e,n)=>{if(hs.test(e))t.style.setProperty(e,n);else if(ms.test(n))t.style.setProperty(S(e),n.replace(ms,""),"important");else{const o=_s(e);if(Array.isArray(n))for(let e=0,r=n.length;e<r;e++)t.style[o]=n[e];else t.style[o]=n}},vs=["Webkit","Moz","ms"];let ys;const _s=b((function(t){if(ys=ys||document.createElement("div").style,"filter"!==(t=x(t))&&t in ys)return t;const e=t.charAt(0).toUpperCase()+t.slice(1);for(let t=0;t<vs.length;t++){const n=vs[t]+e;if(n in ys)return n}}));function $s(t,e){const r=e.data,s=t.data;if(n(r.staticStyle)&&n(r.style)&&n(s.staticStyle)&&n(s.style))return;let i,c;const a=e.elm,l=s.staticStyle,u=s.normalizedStyle||s.style||{},f=l||u,d=ps(e.data.style)||{};e.data.normalizedStyle=o(d.__ob__)?A({},d):d;const p=function(t,e){const n={};let o;if(e){let e=t;for(;e.componentInstance;)e=e.componentInstance._vnode,e&&e.data&&(o=ds(e.data))&&A(n,o)}(o=ds(t.data))&&A(n,o);let r=t;for(;r=r.parent;)r.data&&(o=ds(r.data))&&A(n,o);return n}(e,!0);for(c in f)n(p[c])&&gs(a,c,"");for(c in p)i=p[c],gs(a,c,null==i?"":i)}var bs={create:$s,update:$s};const ws=/\s+/;function xs(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(ws).forEach((e=>t.classList.add(e))):t.classList.add(e);else{const n=` ${t.getAttribute("class")||""} `;n.indexOf(" "+e+" ")<0&&t.setAttribute("class",(n+e).trim())}}function Cs(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(ws).forEach((e=>t.classList.remove(e))):t.classList.remove(e),t.classList.length||t.removeAttribute("class");else{let n=` ${t.getAttribute("class")||""} `;const o=" "+e+" ";for(;n.indexOf(o)>=0;)n=n.replace(o," ");n=n.trim(),n?t.setAttribute("class",n):t.removeAttribute("class")}}function ks(t){if(t){if("object"==typeof t){const e={};return!1!==t.css&&A(e,Ss(t.name||"v")),A(e,t),e}return"string"==typeof t?Ss(t):void 0}}const Ss=b((t=>({enterClass:`${t}-enter`,enterToClass:`${t}-enter-to`,enterActiveClass:`${t}-enter-active`,leaveClass:`${t}-leave`,leaveToClass:`${t}-leave-to`,leaveActiveClass:`${t}-leave-active`}))),Os=q&&!G,Ts="transition",As="animation";let js="transition",Es="transitionend",Ns="animation",Ps="animationend";Os&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(js="WebkitTransition",Es="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ns="WebkitAnimation",Ps="webkitAnimationEnd"));const Ds=q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:t=>t();function Ms(t){Ds((()=>{Ds(t)}))}function Is(t,e){const n=t._transitionClasses||(t._transitionClasses=[]);n.indexOf(e)<0&&(n.push(e),xs(t,e))}function Ls(t,e){t._transitionClasses&&y(t._transitionClasses,e),Cs(t,e)}function Rs(t,e,n){const{type:o,timeout:r,propCount:s}=Hs(t,e);if(!o)return n();const i=o===Ts?Es:Ps;let c=0;const a=()=>{t.removeEventListener(i,l),n()},l=e=>{e.target===t&&++c>=s&&a()};setTimeout((()=>{c<s&&a()}),r+1),t.addEventListener(i,l)}const Fs=/\b(transform|all)(,|$)/;function Hs(t,e){const n=window.getComputedStyle(t),o=(n[js+"Delay"]||"").split(", "),r=(n[js+"Duration"]||"").split(", "),s=Bs(o,r),i=(n[Ns+"Delay"]||"").split(", "),c=(n[Ns+"Duration"]||"").split(", "),a=Bs(i,c);let l,u=0,f=0;e===Ts?s>0&&(l=Ts,u=s,f=r.length):e===As?a>0&&(l=As,u=a,f=c.length):(u=Math.max(s,a),l=u>0?s>a?Ts:As:null,f=l?l===Ts?r.length:c.length:0);return{type:l,timeout:u,propCount:f,hasTransform:l===Ts&&Fs.test(n[js+"Property"])}}function Bs(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max.apply(null,e.map(((e,n)=>Us(e)+Us(t[n]))))}function Us(t){return 1e3*Number(t.slice(0,-1).replace(",","."))}function zs(t,e){const r=t.elm;o(r._leaveCb)&&(r._leaveCb.cancelled=!0,r._leaveCb());const s=ks(t.data.transition);if(n(s))return;if(o(r._enterCb)||1!==r.nodeType)return;const{css:a,type:l,enterClass:u,enterToClass:f,enterActiveClass:d,appearClass:p,appearToClass:m,appearActiveClass:g,beforeEnter:v,enter:y,afterEnter:_,enterCancelled:$,beforeAppear:b,appear:w,afterAppear:x,appearCancelled:C,duration:k}=s;let S=Ve,O=Ve.$vnode;for(;O&&O.parent;)S=O.context,O=O.parent;const T=!S._isMounted||!t.isRootInsert;if(T&&!w&&""!==w)return;const A=T&&p?p:u,j=T&&g?g:d,E=T&&m?m:f,N=T&&b||v,P=T&&i(w)?w:y,D=T&&x||_,M=T&&C||$,L=h(c(k)?k.enter:k),R=!1!==a&&!G,F=Js(P),H=r._enterCb=I((()=>{R&&(Ls(r,E),Ls(r,j)),H.cancelled?(R&&Ls(r,A),M&&M(r)):D&&D(r),r._enterCb=null}));t.data.show||Yt(t,"insert",(()=>{const e=r.parentNode,n=e&&e._pending&&e._pending[t.key];n&&n.tag===t.tag&&n.elm._leaveCb&&n.elm._leaveCb(),P&&P(r,H)})),N&&N(r),R&&(Is(r,A),Is(r,j),Ms((()=>{Ls(r,A),H.cancelled||(Is(r,E),F||(Ks(L)?setTimeout(H,L):Rs(r,l,H)))}))),t.data.show&&(e&&e(),P&&P(r,H)),R||F||H()}function Vs(t,e){const r=t.elm;o(r._enterCb)&&(r._enterCb.cancelled=!0,r._enterCb());const s=ks(t.data.transition);if(n(s)||1!==r.nodeType)return e();if(o(r._leaveCb))return;const{css:i,type:a,leaveClass:l,leaveToClass:u,leaveActiveClass:f,beforeLeave:d,leave:p,afterLeave:m,leaveCancelled:g,delayLeave:v,duration:y}=s,_=!1!==i&&!G,$=Js(p),b=h(c(y)?y.leave:y),w=r._leaveCb=I((()=>{r.parentNode&&r.parentNode._pending&&(r.parentNode._pending[t.key]=null),_&&(Ls(r,u),Ls(r,f)),w.cancelled?(_&&Ls(r,l),g&&g(r)):(e(),m&&m(r)),r._leaveCb=null}));function x(){w.cancelled||(!t.data.show&&r.parentNode&&((r.parentNode._pending||(r.parentNode._pending={}))[t.key]=t),d&&d(r),_&&(Is(r,l),Is(r,f),Ms((()=>{Ls(r,l),w.cancelled||(Is(r,u),$||(Ks(b)?setTimeout(w,b):Rs(r,a,w)))}))),p&&p(r,w),_||$||w())}v?v(x):x()}function Ks(t){return"number"==typeof t&&!isNaN(t)}function Js(t){if(n(t))return!1;const e=t.fns;return o(e)?Js(Array.isArray(e)?e[0]:e):(t._length||t.length)>1}function qs(t,e){!0!==e.data.show&&zs(e)}const Ws=function(t){let i,c;const a={},{modules:l,nodeOps:u}=t;for(i=0;i<ar.length;++i)for(a[ar[i]]=[],c=0;c<l.length;++c)o(l[c][ar[i]])&&a[ar[i]].push(l[c][ar[i]]);function f(t){const e=u.parentNode(t);o(e)&&u.removeChild(e,t)}function d(t,e,n,s,i,c,l){if(o(t.elm)&&o(c)&&(t=c[l]=pt(t)),t.isRootInsert=!i,function(t,e,n,s){let i=t.data;if(o(i)){const c=o(t.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(t,!1),o(t.componentInstance))return p(t,e),h(n,t.elm,s),r(c)&&function(t,e,n,r){let s,i=t;for(;i.componentInstance;)if(i=i.componentInstance._vnode,o(s=i.data)&&o(s=s.transition)){for(s=0;s<a.activate.length;++s)a.activate[s](cr,i);e.push(i);break}h(n,t.elm,r)}(t,e,n,s),!0}}(t,e,n,s))return;const f=t.data,d=t.children,m=t.tag;o(m)?(t.elm=t.ns?u.createElementNS(t.ns,m):u.createElement(m,t),_(t),g(t,d,e),o(f)&&y(t,e),h(n,t.elm,s)):r(t.isComment)?(t.elm=u.createComment(t.text),h(n,t.elm,s)):(t.elm=u.createTextNode(t.text),h(n,t.elm,s))}function p(t,e){o(t.data.pendingInsert)&&(e.push.apply(e,t.data.pendingInsert),t.data.pendingInsert=null),t.elm=t.componentInstance.$el,v(t)?(y(t,e),_(t)):(sr(t),e.push(t))}function h(t,e,n){o(t)&&(o(n)?u.parentNode(n)===t&&u.insertBefore(t,e,n):u.appendChild(t,e))}function g(t,n,o){if(e(n))for(let e=0;e<n.length;++e)d(n[e],o,t.elm,null,!0,n,e);else s(t.text)&&u.appendChild(t.elm,u.createTextNode(String(t.text)))}function v(t){for(;t.componentInstance;)t=t.componentInstance._vnode;return o(t.tag)}function y(t,e){for(let e=0;e<a.create.length;++e)a.create[e](cr,t);i=t.data.hook,o(i)&&(o(i.create)&&i.create(cr,t),o(i.insert)&&e.push(t))}function _(t){let e;if(o(e=t.fnScopeId))u.setStyleScope(t.elm,e);else{let n=t;for(;n;)o(e=n.context)&&o(e=e.$options._scopeId)&&u.setStyleScope(t.elm,e),n=n.parent}o(e=Ve)&&e!==t.context&&e!==t.fnContext&&o(e=e.$options._scopeId)&&u.setStyleScope(t.elm,e)}function $(t,e,n,o,r,s){for(;o<=r;++o)d(n[o],s,t,e,!1,n,o)}function b(t){let e,n;const r=t.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(t),e=0;e<a.destroy.length;++e)a.destroy[e](t);if(o(e=t.children))for(n=0;n<t.children.length;++n)b(t.children[n])}function w(t,e,n){for(;e<=n;++e){const n=t[e];o(n)&&(o(n.tag)?(x(n),b(n)):f(n.elm))}}function x(t,e){if(o(e)||o(t.data)){let n;const r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(t,e){function n(){0==--n.listeners&&f(t)}return n.listeners=e,n}(t.elm,r),o(n=t.componentInstance)&&o(n=n._vnode)&&o(n.data)&&x(n,e),n=0;n<a.remove.length;++n)a.remove[n](t,e);o(n=t.data.hook)&&o(n=n.remove)?n(t,e):e()}else f(t.elm)}function C(t,e,n,r){for(let s=n;s<r;s++){const n=e[s];if(o(n)&&lr(t,n))return s}}function k(t,e,s,i,c,l){if(t===e)return;o(e.elm)&&o(i)&&(e=i[c]=pt(e));const f=e.elm=t.elm;if(r(t.isAsyncPlaceholder))return void(o(e.asyncFactory.resolved)?T(t.elm,e,s):e.isAsyncPlaceholder=!0);if(r(e.isStatic)&&r(t.isStatic)&&e.key===t.key&&(r(e.isCloned)||r(e.isOnce)))return void(e.componentInstance=t.componentInstance);let p;const h=e.data;o(h)&&o(p=h.hook)&&o(p=p.prepatch)&&p(t,e);const m=t.children,g=e.children;if(o(h)&&v(e)){for(p=0;p<a.update.length;++p)a.update[p](t,e);o(p=h.hook)&&o(p=p.update)&&p(t,e)}n(e.text)?o(m)&&o(g)?m!==g&&function(t,e,r,s,i){let c,a,l,f,p=0,h=0,m=e.length-1,g=e[0],v=e[m],y=r.length-1,_=r[0],b=r[y];const x=!i;for(;p<=m&&h<=y;)n(g)?g=e[++p]:n(v)?v=e[--m]:lr(g,_)?(k(g,_,s,r,h),g=e[++p],_=r[++h]):lr(v,b)?(k(v,b,s,r,y),v=e[--m],b=r[--y]):lr(g,b)?(k(g,b,s,r,y),x&&u.insertBefore(t,g.elm,u.nextSibling(v.elm)),g=e[++p],b=r[--y]):lr(v,_)?(k(v,_,s,r,h),x&&u.insertBefore(t,v.elm,g.elm),v=e[--m],_=r[++h]):(n(c)&&(c=ur(e,p,m)),a=o(_.key)?c[_.key]:C(_,e,p,m),n(a)?d(_,s,t,g.elm,!1,r,h):(l=e[a],lr(l,_)?(k(l,_,s,r,h),e[a]=void 0,x&&u.insertBefore(t,l.elm,g.elm)):d(_,s,t,g.elm,!1,r,h)),_=r[++h]);p>m?(f=n(r[y+1])?null:r[y+1].elm,$(t,f,r,h,y,s)):h>y&&w(e,p,m)}(f,m,g,s,l):o(g)?(o(t.text)&&u.setTextContent(f,""),$(f,null,g,0,g.length-1,s)):o(m)?w(m,0,m.length-1):o(t.text)&&u.setTextContent(f,""):t.text!==e.text&&u.setTextContent(f,e.text),o(h)&&o(p=h.hook)&&o(p=p.postpatch)&&p(t,e)}function S(t,e,n){if(r(n)&&o(t.parent))t.parent.data.pendingInsert=e;else for(let t=0;t<e.length;++t)e[t].data.hook.insert(e[t])}const O=m("attrs,class,staticClass,staticStyle,key");function T(t,e,n,s){let i;const{tag:c,data:a,children:l}=e;if(s=s||a&&a.pre,e.elm=t,r(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(a)&&(o(i=a.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return p(e,n),!0;if(o(c)){if(o(l))if(t.hasChildNodes())if(o(i=a)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==t.innerHTML)return!1}else{let e=!0,o=t.firstChild;for(let t=0;t<l.length;t++){if(!o||!T(o,l[t],n,s)){e=!1;break}o=o.nextSibling}if(!e||o)return!1}else g(e,l,n);if(o(a)){let t=!1;for(const o in a)if(!O(o)){t=!0,y(e,n);break}!t&&a.class&&Un(a.class)}}else t.data!==e.text&&(t.data=e.text);return!0}return function(t,e,s,i){if(n(e))return void(o(t)&&b(t));let c=!1;const l=[];if(n(t))c=!0,d(e,l);else{const n=o(t.nodeType);if(!n&&lr(t,e))k(t,e,l,null,null,i);else{if(n){if(1===t.nodeType&&t.hasAttribute(R)&&(t.removeAttribute(R),s=!0),r(s)&&T(t,e,l))return S(e,l,!0),t;f=t,t=new ut(u.tagName(f).toLowerCase(),{},[],void 0,f)}const i=t.elm,c=u.parentNode(i);if(d(e,l,i._leaveCb?null:c,u.nextSibling(i)),o(e.parent)){let t=e.parent;const n=v(e);for(;t;){for(let e=0;e<a.destroy.length;++e)a.destroy[e](t);if(t.elm=e.elm,n){for(let e=0;e<a.create.length;++e)a.create[e](cr,t);const e=t.data.hook.insert;if(e.merged){const t=e.fns.slice(1);for(let e=0;e<t.length;e++)t[e]()}}else sr(t);t=t.parent}}o(c)?w([t],0,0):o(t.tag)&&b(t)}}var f;return S(e,l,c),e.elm}}({nodeOps:or,modules:[br,xr,is,us,bs,q?{create:qs,activate:qs,remove(t,e){!0!==t.data.show?Vs(t,e):e()}}:{}].concat(vr)});G&&document.addEventListener("selectionchange",(()=>{const t=document.activeElement;t&&t.vmodel&&ni(t,"input")}));const Zs={inserted(t,e,n,o){"select"===n.tag?(o.elm&&!o.elm._vOptions?Yt(n,"postpatch",(()=>{Zs.componentUpdated(t,e,n)})):Gs(t,e,n.context),t._vOptions=[].map.call(t.options,Qs)):("textarea"===n.tag||er(t.type))&&(t._vModifiers=e.modifiers,e.modifiers.lazy||(t.addEventListener("compositionstart",ti),t.addEventListener("compositionend",ei),t.addEventListener("change",ei),G&&(t.vmodel=!0)))},componentUpdated(t,e,n){if("select"===n.tag){Gs(t,e,n.context);const o=t._vOptions,r=t._vOptions=[].map.call(t.options,Qs);if(r.some(((t,e)=>!D(t,o[e])))){(t.multiple?e.value.some((t=>Ys(t,r))):e.value!==e.oldValue&&Ys(e.value,r))&&ni(t,"change")}}}};function Gs(t,e,n){Xs(t,e),(Z||X)&&setTimeout((()=>{Xs(t,e)}),0)}function Xs(t,e,n){const o=e.value,r=t.multiple;if(r&&!Array.isArray(o))return;let s,i;for(let e=0,n=t.options.length;e<n;e++)if(i=t.options[e],r)s=M(o,Qs(i))>-1,i.selected!==s&&(i.selected=s);else if(D(Qs(i),o))return void(t.selectedIndex!==e&&(t.selectedIndex=e));r||(t.selectedIndex=-1)}function Ys(t,e){return e.every((e=>!D(e,t)))}function Qs(t){return"_value"in t?t._value:t.value}function ti(t){t.target.composing=!0}function ei(t){t.target.composing&&(t.target.composing=!1,ni(t.target,"input"))}function ni(t,e){const n=document.createEvent("HTMLEvents");n.initEvent(e,!0,!0),t.dispatchEvent(n)}function oi(t){return!t.componentInstance||t.data&&t.data.transition?t:oi(t.componentInstance._vnode)}var ri={bind(t,{value:e},n){const o=(n=oi(n)).data&&n.data.transition,r=t.__vOriginalDisplay="none"===t.style.display?"":t.style.display;e&&o?(n.data.show=!0,zs(n,(()=>{t.style.display=r}))):t.style.display=e?r:"none"},update(t,{value:e,oldValue:n},o){if(!e==!n)return;(o=oi(o)).data&&o.data.transition?(o.data.show=!0,e?zs(o,(()=>{t.style.display=t.__vOriginalDisplay})):Vs(o,(()=>{t.style.display="none"}))):t.style.display=e?t.__vOriginalDisplay:"none"},unbind(t,e,n,o,r){r||(t.style.display=t.__vOriginalDisplay)}},si={model:Zs,show:ri};const ii={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ci(t){const e=t&&t.componentOptions;return e&&e.Ctor.options.abstract?ci(Le(e.children)):t}function ai(t){const e={},n=t.$options;for(const o in n.propsData)e[o]=t[o];const o=n._parentListeners;for(const t in o)e[x(t)]=o[t];return e}function li(t,e){if(/\d-keep-alive$/.test(e.tag))return t("keep-alive",{props:e.componentOptions.propsData})}const ui=t=>t.tag||Ce(t),fi=t=>"show"===t.name;var di={name:"transition",props:ii,abstract:!0,render(t){let e=this.$slots.default;if(!e)return;if(e=e.filter(ui),!e.length)return;const n=this.mode,o=e[0];if(function(t){for(;t=t.parent;)if(t.data.transition)return!0}(this.$vnode))return o;const r=ci(o);if(!r)return o;if(this._leaving)return li(t,o);const i=`__transition-${this._uid}-`;r.key=null==r.key?r.isComment?i+"comment":i+r.tag:s(r.key)?0===String(r.key).indexOf(i)?r.key:i+r.key:r.key;const c=(r.data||(r.data={})).transition=ai(this),a=this._vnode,l=ci(a);if(r.data.directives&&r.data.directives.some(fi)&&(r.data.show=!0),l&&l.data&&!function(t,e){return e.key===t.key&&e.tag===t.tag}(r,l)&&!Ce(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){const e=l.data.transition=A({},c);if("out-in"===n)return this._leaving=!0,Yt(e,"afterLeave",(()=>{this._leaving=!1,this.$forceUpdate()})),li(t,o);if("in-out"===n){if(Ce(r))return a;let t;const n=()=>{t()};Yt(c,"afterEnter",n),Yt(c,"enterCancelled",n),Yt(e,"delayLeave",(e=>{t=e}))}}return o}};const pi=A({tag:String,moveClass:String},ii);delete pi.mode;var hi={props:pi,beforeMount(){const t=this._update;this._update=(e,n)=>{const o=Ke(this);this.__patch__(this._vnode,this.kept,!1,!0),this._vnode=this.kept,o(),t.call(this,e,n)}},render(t){const e=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),o=this.prevChildren=this.children,r=this.$slots.default||[],s=this.children=[],i=ai(this);for(let t=0;t<r.length;t++){const e=r[t];e.tag&&null!=e.key&&0!==String(e.key).indexOf("__vlist")&&(s.push(e),n[e.key]=e,(e.data||(e.data={})).transition=i)}if(o){const r=[],s=[];for(let t=0;t<o.length;t++){const e=o[t];e.data.transition=i,e.data.pos=e.elm.getBoundingClientRect(),n[e.key]?r.push(e):s.push(e)}this.kept=t(e,null,r),this.removed=s}return t(e,null,s)},updated(){const t=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";t.length&&this.hasMove(t[0].elm,e)&&(t.forEach(mi),t.forEach(gi),t.forEach(vi),this._reflow=document.body.offsetHeight,t.forEach((t=>{if(t.data.moved){const n=t.elm,o=n.style;Is(n,e),o.transform=o.WebkitTransform=o.transitionDuration="",n.addEventListener(Es,n._moveCb=function t(o){o&&o.target!==n||o&&!/transform$/.test(o.propertyName)||(n.removeEventListener(Es,t),n._moveCb=null,Ls(n,e))})}})))},methods:{hasMove(t,e){if(!Os)return!1;if(this._hasMove)return this._hasMove;const n=t.cloneNode();t._transitionClasses&&t._transitionClasses.forEach((t=>{Cs(n,t)})),xs(n,e),n.style.display="none",this.$el.appendChild(n);const o=Hs(n);return this.$el.removeChild(n),this._hasMove=o.hasTransform}}};function mi(t){t.elm._moveCb&&t.elm._moveCb(),t.elm._enterCb&&t.elm._enterCb()}function gi(t){t.data.newPos=t.elm.getBoundingClientRect()}function vi(t){const e=t.data.pos,n=t.data.newPos,o=e.left-n.left,r=e.top-n.top;if(o||r){t.data.moved=!0;const e=t.elm.style;e.transform=e.WebkitTransform=`translate(${o}px,${r}px)`,e.transitionDuration="0s"}}var yi={Transition:di,TransitionGroup:hi};So.config.mustUseProp=Io,So.config.isReservedTag=Yo,So.config.isReservedAttr=Do,So.config.getTagNamespace=Qo,So.config.isUnknownElement=function(t){if(!q)return!0;if(Yo(t))return!1;if(t=t.toLowerCase(),null!=tr[t])return tr[t];const e=document.createElement(t);return t.indexOf("-")>-1?tr[t]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:tr[t]=/HTMLUnknownElement/.test(e.toString())},A(So.options.directives,si),A(So.options.components,yi),So.prototype.__patch__=q?Ws:E,So.prototype.$mount=function(t,e){return function(t,e,n){let o;t.$el=e,t.$options.render||(t.$options.render=ft),Ze(t,"beforeMount"),o=()=>{t._update(t._render(),n)},new Kn(t,o,E,{before(){t._isMounted&&!t._isDestroyed&&Ze(t,"beforeUpdate")}},!0),n=!1;const r=t._preWatchers;if(r)for(let t=0;t<r.length;t++)r[t].run();return null==t.$vnode&&(t._isMounted=!0,Ze(t,"mounted")),t}(this,t=t&&q?nr(t):void 0,e)},q&&setTimeout((()=>{B.devtools&&rt&&rt.emit("init",So)}),0);const _i=/\{\{((?:.|\r?\n)+?)\}\}/g,$i=/[-.*+?^${}()|[\]\/\\]/g,bi=b((t=>{const e=t[0].replace($i,"\\$&"),n=t[1].replace($i,"\\$&");return new RegExp(e+"((?:.|\\n)+?)"+n,"g")}));var wi={staticKeys:["staticClass"],transformNode:function(t,e){e.warn;const n=Ir(t,"class");n&&(t.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));const o=Mr(t,"class",!1);o&&(t.classBinding=o)},genData:function(t){let e="";return t.staticClass&&(e+=`staticClass:${t.staticClass},`),t.classBinding&&(e+=`class:${t.classBinding},`),e}};var xi={staticKeys:["staticStyle"],transformNode:function(t,e){e.warn;const n=Ir(t,"style");n&&(t.staticStyle=JSON.stringify(fs(n)));const o=Mr(t,"style",!1);o&&(t.styleBinding=o)},genData:function(t){let e="";return t.staticStyle&&(e+=`staticStyle:${t.staticStyle},`),t.styleBinding&&(e+=`style:(${t.styleBinding}),`),e}};let Ci;var ki={decode:t=>(Ci=Ci||document.createElement("div"),Ci.innerHTML=t,Ci.textContent)};const Si=m("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Oi=m("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Ti=m("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Ai=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,ji=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Ei=`[a-zA-Z_][\\-\\.0-9_a-zA-Z${U.source}]*`,Ni=`((?:${Ei}\\:)?${Ei})`,Pi=new RegExp(`^<${Ni}`),Di=/^\s*(\/?)>/,Mi=new RegExp(`^<\\/${Ni}[^>]*>`),Ii=/^<!DOCTYPE [^>]+>/i,Li=/^<!\--/,Ri=/^<!\[/,Fi=m("script,style,textarea",!0),Hi={},Bi={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},Ui=/&(?:lt|gt|quot|amp|#39);/g,zi=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,Vi=m("pre,textarea",!0),Ki=(t,e)=>t&&Vi(t)&&"\n"===e[0];function Ji(t,e){const n=e?zi:Ui;return t.replace(n,(t=>Bi[t]))}const qi=/^@|^v-on:/,Wi=/^v-|^@|^:|^#/,Zi=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,Gi=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,Xi=/^\(|\)$/g,Yi=/^\[.*\]$/,Qi=/:(.*)$/,tc=/^:|^\.|^v-bind:/,ec=/\.[^.\]]+(?=[^\]]*$)/g,nc=/^v-slot(:|$)|^#/,oc=/[\r\n]/,rc=/[ \f\t\r\n]+/g,sc=b(ki.decode),ic="_empty_";let cc,ac,lc,uc,fc,dc,pc,hc;function mc(t,e,n){return{type:1,tag:t,attrsList:e,attrsMap:wc(e),rawAttrsMap:{},parent:n,children:[]}}function gc(t,e){cc=e.warn||Or,dc=e.isPreTag||N,pc=e.mustUseProp||N,hc=e.getTagNamespace||N,e.isReservedTag,lc=Tr(e.modules,"transformNode"),uc=Tr(e.modules,"preTransformNode"),fc=Tr(e.modules,"postTransformNode"),ac=e.delimiters;const n=[],o=!1!==e.preserveWhitespace,r=e.whitespace;let s,i,c=!1,a=!1;function l(t){if(u(t),c||t.processed||(t=vc(t,e)),n.length||t===s||s.if&&(t.elseif||t.else)&&_c(s,{exp:t.elseif,block:t}),i&&!t.forbidden)if(t.elseif||t.else)!function(t,e){const n=function(t){let e=t.length;for(;e--;){if(1===t[e].type)return t[e];t.pop()}}(e.children);n&&n.if&&_c(n,{exp:t.elseif,block:t})}(t,i);else{if(t.slotScope){const e=t.slotTarget||'"default"';(i.scopedSlots||(i.scopedSlots={}))[e]=t}i.children.push(t),t.parent=i}t.children=t.children.filter((t=>!t.slotScope)),u(t),t.pre&&(c=!1),dc(t.tag)&&(a=!1);for(let n=0;n<fc.length;n++)fc[n](t,e)}function u(t){if(!a){let e;for(;(e=t.children[t.children.length-1])&&3===e.type&&" "===e.text;)t.children.pop()}}return function(t,e){const n=[],o=e.expectHTML,r=e.isUnaryTag||N,s=e.canBeLeftOpenTag||N;let i,c,a=0;for(;t;){if(i=t,c&&Fi(c)){let n=0;const o=c.toLowerCase(),r=Hi[o]||(Hi[o]=new RegExp("([\\s\\S]*?)(</"+o+"[^>]*>)","i")),s=t.replace(r,(function(t,r,s){return n=s.length,Fi(o)||"noscript"===o||(r=r.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),Ki(o,r)&&(r=r.slice(1)),e.chars&&e.chars(r),""}));a+=t.length-s.length,t=s,d(o,a-n,a)}else{let n,o,r,s=t.indexOf("<");if(0===s){if(Li.test(t)){const n=t.indexOf("--\x3e");if(n>=0){e.shouldKeepComment&&e.comment&&e.comment(t.substring(4,n),a,a+n+3),l(n+3);continue}}if(Ri.test(t)){const e=t.indexOf("]>");if(e>=0){l(e+2);continue}}const n=t.match(Ii);if(n){l(n[0].length);continue}const o=t.match(Mi);if(o){const t=a;l(o[0].length),d(o[1],t,a);continue}const r=u();if(r){f(r),Ki(r.tagName,t)&&l(1);continue}}if(s>=0){for(o=t.slice(s);!(Mi.test(o)||Pi.test(o)||Li.test(o)||Ri.test(o)||(r=o.indexOf("<",1),r<0));)s+=r,o=t.slice(s);n=t.substring(0,s)}s<0&&(n=t),n&&l(n.length),e.chars&&n&&e.chars(n,a-n.length,a)}if(t===i){e.chars&&e.chars(t);break}}function l(e){a+=e,t=t.substring(e)}function u(){const e=t.match(Pi);if(e){const n={tagName:e[1],attrs:[],start:a};let o,r;for(l(e[0].length);!(o=t.match(Di))&&(r=t.match(ji)||t.match(Ai));)r.start=a,l(r[0].length),r.end=a,n.attrs.push(r);if(o)return n.unarySlash=o[1],l(o[0].length),n.end=a,n}}function f(t){const i=t.tagName,a=t.unarySlash;o&&("p"===c&&Ti(i)&&d(c),s(i)&&c===i&&d(i));const l=r(i)||!!a,u=t.attrs.length,f=new Array(u);for(let n=0;n<u;n++){const o=t.attrs[n],r=o[3]||o[4]||o[5]||"",s="a"===i&&"href"===o[1]?e.shouldDecodeNewlinesForHref:e.shouldDecodeNewlines;f[n]={name:o[1],value:Ji(r,s)}}l||(n.push({tag:i,lowerCasedTag:i.toLowerCase(),attrs:f,start:t.start,end:t.end}),c=i),e.start&&e.start(i,f,l,t.start,t.end)}function d(t,o,r){let s,i;if(null==o&&(o=a),null==r&&(r=a),t)for(i=t.toLowerCase(),s=n.length-1;s>=0&&n[s].lowerCasedTag!==i;s--);else s=0;if(s>=0){for(let t=n.length-1;t>=s;t--)e.end&&e.end(n[t].tag,o,r);n.length=s,c=s&&n[s-1].tag}else"br"===i?e.start&&e.start(t,[],!0,o,r):"p"===i&&(e.start&&e.start(t,[],!1,o,r),e.end&&e.end(t,o,r))}d()}(t,{warn:cc,expectHTML:e.expectHTML,isUnaryTag:e.isUnaryTag,canBeLeftOpenTag:e.canBeLeftOpenTag,shouldDecodeNewlines:e.shouldDecodeNewlines,shouldDecodeNewlinesForHref:e.shouldDecodeNewlinesForHref,shouldKeepComment:e.comments,outputSourceRange:e.outputSourceRange,start(t,o,r,u,f){const d=i&&i.ns||hc(t);Z&&"svg"===d&&(o=function(t){const e=[];for(let n=0;n<t.length;n++){const o=t[n];xc.test(o.name)||(o.name=o.name.replace(Cc,""),e.push(o))}return e}(o));let p=mc(t,o,i);var h;d&&(p.ns=d),"style"!==(h=p).tag&&("script"!==h.tag||h.attrsMap.type&&"text/javascript"!==h.attrsMap.type)||ot()||(p.forbidden=!0);for(let t=0;t<uc.length;t++)p=uc[t](p,e)||p;c||(!function(t){null!=Ir(t,"v-pre")&&(t.pre=!0)}(p),p.pre&&(c=!0)),dc(p.tag)&&(a=!0),c?function(t){const e=t.attrsList,n=e.length;if(n){const o=t.attrs=new Array(n);for(let t=0;t<n;t++)o[t]={name:e[t].name,value:JSON.stringify(e[t].value)},null!=e[t].start&&(o[t].start=e[t].start,o[t].end=e[t].end)}else t.pre||(t.plain=!0)}(p):p.processed||(yc(p),function(t){const e=Ir(t,"v-if");if(e)t.if=e,_c(t,{exp:e,block:t});else{null!=Ir(t,"v-else")&&(t.else=!0);const e=Ir(t,"v-else-if");e&&(t.elseif=e)}}(p),function(t){const e=Ir(t,"v-once");null!=e&&(t.once=!0)}(p)),s||(s=p),r?l(p):(i=p,n.push(p))},end(t,e,o){const r=n[n.length-1];n.length-=1,i=n[n.length-1],l(r)},chars(t,e,n){if(!i)return;if(Z&&"textarea"===i.tag&&i.attrsMap.placeholder===t)return;const s=i.children;var l;if(t=a||t.trim()?"script"===(l=i).tag||"style"===l.tag?t:sc(t):s.length?r?"condense"===r&&oc.test(t)?"":" ":o?" ":"":""){let e,n;a||"condense"!==r||(t=t.replace(rc," ")),!c&&" "!==t&&(e=function(t,e){const n=e?bi(e):_i;if(!n.test(t))return;const o=[],r=[];let s,i,c,a=n.lastIndex=0;for(;s=n.exec(t);){i=s.index,i>a&&(r.push(c=t.slice(a,i)),o.push(JSON.stringify(c)));const e=kr(s[1].trim());o.push(`_s(${e})`),r.push({"@binding":e}),a=i+s[0].length}return a<t.length&&(r.push(c=t.slice(a)),o.push(JSON.stringify(c))),{expression:o.join("+"),tokens:r}}(t,ac))?n={type:2,expression:e.expression,tokens:e.tokens,text:t}:" "===t&&s.length&&" "===s[s.length-1].text||(n={type:3,text:t}),n&&s.push(n)}},comment(t,e,n){if(i){const e={type:3,text:t,isComment:!0};i.children.push(e)}}}),s}function vc(t,e){var n;!function(t){const e=Mr(t,"key");e&&(t.key=e)}(t),t.plain=!t.key&&!t.scopedSlots&&!t.attrsList.length,function(t){const e=Mr(t,"ref");e&&(t.ref=e,t.refInFor=function(t){let e=t;for(;e;){if(void 0!==e.for)return!0;e=e.parent}return!1}(t))}(t),function(t){let e;"template"===t.tag?(e=Ir(t,"scope"),t.slotScope=e||Ir(t,"slot-scope")):(e=Ir(t,"slot-scope"))&&(t.slotScope=e);const n=Mr(t,"slot");n&&(t.slotTarget='""'===n?'"default"':n,t.slotTargetDynamic=!(!t.attrsMap[":slot"]&&!t.attrsMap["v-bind:slot"]),"template"===t.tag||t.slotScope||jr(t,"slot",n,function(t,e){return t.rawAttrsMap[":"+e]||t.rawAttrsMap["v-bind:"+e]||t.rawAttrsMap[e]}(t,"slot")));if("template"===t.tag){const e=Lr(t,nc);if(e){const{name:n,dynamic:o}=$c(e);t.slotTarget=n,t.slotTargetDynamic=o,t.slotScope=e.value||ic}}else{const e=Lr(t,nc);if(e){const n=t.scopedSlots||(t.scopedSlots={}),{name:o,dynamic:r}=$c(e),s=n[o]=mc("template",[],t);s.slotTarget=o,s.slotTargetDynamic=r,s.children=t.children.filter((t=>{if(!t.slotScope)return t.parent=s,!0})),s.slotScope=e.value||ic,t.children=[],t.plain=!1}}}(t),"slot"===(n=t).tag&&(n.slotName=Mr(n,"name")),function(t){let e;(e=Mr(t,"is"))&&(t.component=e);null!=Ir(t,"inline-template")&&(t.inlineTemplate=!0)}(t);for(let n=0;n<lc.length;n++)t=lc[n](t,e)||t;return function(t){const e=t.attrsList;let n,o,r,s,i,c,a,l;for(n=0,o=e.length;n<o;n++)if(r=s=e[n].name,i=e[n].value,Wi.test(r))if(t.hasBindings=!0,c=bc(r.replace(Wi,"")),c&&(r=r.replace(ec,"")),tc.test(r))r=r.replace(tc,""),i=kr(i),l=Yi.test(r),l&&(r=r.slice(1,-1)),c&&(c.prop&&!l&&(r=x(r),"innerHtml"===r&&(r="innerHTML")),c.camel&&!l&&(r=x(r)),c.sync&&(a=Hr(i,"$event"),l?Dr(t,`"update:"+(${r})`,a,null,!1,0,e[n],!0):(Dr(t,`update:${x(r)}`,a,null,!1,0,e[n]),S(r)!==x(r)&&Dr(t,`update:${S(r)}`,a,null,!1,0,e[n])))),c&&c.prop||!t.component&&pc(t.tag,t.attrsMap.type,r)?Ar(t,r,i,e[n],l):jr(t,r,i,e[n],l);else if(qi.test(r))r=r.replace(qi,""),l=Yi.test(r),l&&(r=r.slice(1,-1)),Dr(t,r,i,c,!1,0,e[n],l);else{r=r.replace(Wi,"");const o=r.match(Qi);let a=o&&o[1];l=!1,a&&(r=r.slice(0,-(a.length+1)),Yi.test(a)&&(a=a.slice(1,-1),l=!0)),Nr(t,r,s,i,a,l,c,e[n])}else jr(t,r,JSON.stringify(i),e[n]),!t.component&&"muted"===r&&pc(t.tag,t.attrsMap.type,r)&&Ar(t,r,"true",e[n])}(t),t}function yc(t){let e;if(e=Ir(t,"v-for")){const n=function(t){const e=t.match(Zi);if(!e)return;const n={};n.for=e[2].trim();const o=e[1].trim().replace(Xi,""),r=o.match(Gi);r?(n.alias=o.replace(Gi,"").trim(),n.iterator1=r[1].trim(),r[2]&&(n.iterator2=r[2].trim())):n.alias=o;return n}(e);n&&A(t,n)}}function _c(t,e){t.ifConditions||(t.ifConditions=[]),t.ifConditions.push(e)}function $c(t){let e=t.name.replace(nc,"");return e||"#"!==t.name[0]&&(e="default"),Yi.test(e)?{name:e.slice(1,-1),dynamic:!0}:{name:`"${e}"`,dynamic:!1}}function bc(t){const e=t.match(ec);if(e){const t={};return e.forEach((e=>{t[e.slice(1)]=!0})),t}}function wc(t){const e={};for(let n=0,o=t.length;n<o;n++)e[t[n].name]=t[n].value;return e}const xc=/^xmlns:NS\d+/,Cc=/^NS\d+:/;function kc(t){return mc(t.tag,t.attrsList.slice(),t.parent)}var Sc=[wi,xi,{preTransformNode:function(t,e){if("input"===t.tag){const n=t.attrsMap;if(!n["v-model"])return;let o;if((n[":type"]||n["v-bind:type"])&&(o=Mr(t,"type")),n.type||o||!n["v-bind"]||(o=`(${n["v-bind"]}).type`),o){const n=Ir(t,"v-if",!0),r=n?`&&(${n})`:"",s=null!=Ir(t,"v-else",!0),i=Ir(t,"v-else-if",!0),c=kc(t);yc(c),Er(c,"type","checkbox"),vc(c,e),c.processed=!0,c.if=`(${o})==='checkbox'`+r,_c(c,{exp:c.if,block:c});const a=kc(t);Ir(a,"v-for",!0),Er(a,"type","radio"),vc(a,e),_c(c,{exp:`(${o})==='radio'`+r,block:a});const l=kc(t);return Ir(l,"v-for",!0),Er(l,":type",o),vc(l,e),_c(c,{exp:n,block:l}),s?c.else=!0:i&&(c.elseif=i),c}}}}];const Oc={expectHTML:!0,modules:Sc,directives:{model:function(t,e,n){const o=e.value,r=e.modifiers,s=t.tag,i=t.attrsMap.type;if(t.component)return Fr(t,o,r),!1;if("select"===s)!function(t,e,n){const o=n&&n.number;let r=`var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ${o?"_n(val)":"val"}});`;r=`${r} ${Hr(e,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]")}`,Dr(t,"change",r,null,!0)}(t,o,r);else if("input"===s&&"checkbox"===i)!function(t,e,n){const o=n&&n.number,r=Mr(t,"value")||"null",s=Mr(t,"true-value")||"true",i=Mr(t,"false-value")||"false";Ar(t,"checked",`Array.isArray(${e})?_i(${e},${r})>-1`+("true"===s?`:(${e})`:`:_q(${e},${s})`)),Dr(t,"change",`var $$a=${e},$$el=$event.target,$$c=$$el.checked?(${s}):(${i});if(Array.isArray($$a)){var $$v=${o?"_n("+r+")":r},$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(${Hr(e,"$$a.concat([$$v])")})}else{$$i>-1&&(${Hr(e,"$$a.slice(0,$$i).concat($$a.slice($$i+1))")})}}else{${Hr(e,"$$c")}}`,null,!0)}(t,o,r);else if("input"===s&&"radio"===i)!function(t,e,n){const o=n&&n.number;let r=Mr(t,"value")||"null";r=o?`_n(${r})`:r,Ar(t,"checked",`_q(${e},${r})`),Dr(t,"change",Hr(e,r),null,!0)}(t,o,r);else if("input"===s||"textarea"===s)!function(t,e,n){const o=t.attrsMap.type,{lazy:r,number:s,trim:i}=n||{},c=!r&&"range"!==o,a=r?"change":"range"===o?Yr:"input";let l="$event.target.value";i&&(l="$event.target.value.trim()");s&&(l=`_n(${l})`);let u=Hr(e,l);c&&(u=`if($event.target.composing)return;${u}`);Ar(t,"value",`(${e})`),Dr(t,a,u,null,!0),(i||s)&&Dr(t,"blur","$forceUpdate()")}(t,o,r);else if(!B.isReservedTag(s))return Fr(t,o,r),!1;return!0},text:function(t,e){e.value&&Ar(t,"textContent",`_s(${e.value})`,e)},html:function(t,e){e.value&&Ar(t,"innerHTML",`_s(${e.value})`,e)}},isPreTag:t=>"pre"===t,isUnaryTag:Si,mustUseProp:Io,canBeLeftOpenTag:Oi,isReservedTag:Yo,getTagNamespace:Qo,staticKeys:function(t){return t.reduce(((t,e)=>t.concat(e.staticKeys||[])),[]).join(",")}(Sc)};let Tc,Ac;const jc=b((function(t){return m("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(t?","+t:""))}));function Ec(t,e){t&&(Tc=jc(e.staticKeys||""),Ac=e.isReservedTag||N,Nc(t),Pc(t,!1))}function Nc(t){if(t.static=function(t){if(2===t.type)return!1;if(3===t.type)return!0;return!(!t.pre&&(t.hasBindings||t.if||t.for||g(t.tag)||!Ac(t.tag)||function(t){for(;t.parent;){if("template"!==(t=t.parent).tag)return!1;if(t.for)return!0}return!1}(t)||!Object.keys(t).every(Tc)))}(t),1===t.type){if(!Ac(t.tag)&&"slot"!==t.tag&&null==t.attrsMap["inline-template"])return;for(let e=0,n=t.children.length;e<n;e++){const n=t.children[e];Nc(n),n.static||(t.static=!1)}if(t.ifConditions)for(let e=1,n=t.ifConditions.length;e<n;e++){const n=t.ifConditions[e].block;Nc(n),n.static||(t.static=!1)}}}function Pc(t,e){if(1===t.type){if((t.static||t.once)&&(t.staticInFor=e),t.static&&t.children.length&&(1!==t.children.length||3!==t.children[0].type))return void(t.staticRoot=!0);if(t.staticRoot=!1,t.children)for(let n=0,o=t.children.length;n<o;n++)Pc(t.children[n],e||!!t.for);if(t.ifConditions)for(let n=1,o=t.ifConditions.length;n<o;n++)Pc(t.ifConditions[n].block,e)}}const Dc=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Mc=/\([^)]*?\);*$/,Ic=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Lc={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Rc={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Fc=t=>`if(${t})return null;`,Hc={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Fc("$event.target !== $event.currentTarget"),ctrl:Fc("!$event.ctrlKey"),shift:Fc("!$event.shiftKey"),alt:Fc("!$event.altKey"),meta:Fc("!$event.metaKey"),left:Fc("'button' in $event && $event.button !== 0"),middle:Fc("'button' in $event && $event.button !== 1"),right:Fc("'button' in $event && $event.button !== 2")};function Bc(t,e){const n=e?"nativeOn:":"on:";let o="",r="";for(const e in t){const n=Uc(t[e]);t[e]&&t[e].dynamic?r+=`${e},${n},`:o+=`"${e}":${n},`}return o=`{${o.slice(0,-1)}}`,r?n+`_d(${o},[${r.slice(0,-1)}])`:n+o}function Uc(t){if(!t)return"function(){}";if(Array.isArray(t))return`[${t.map((t=>Uc(t))).join(",")}]`;const e=Ic.test(t.value),n=Dc.test(t.value),o=Ic.test(t.value.replace(Mc,""));if(t.modifiers){let r="",s="";const i=[];for(const e in t.modifiers)if(Hc[e])s+=Hc[e],Lc[e]&&i.push(e);else if("exact"===e){const e=t.modifiers;s+=Fc(["ctrl","shift","alt","meta"].filter((t=>!e[t])).map((t=>`$event.${t}Key`)).join("||"))}else i.push(e);i.length&&(r+=function(t){return`if(!$event.type.indexOf('key')&&${t.map(zc).join("&&")})return null;`}(i)),s&&(r+=s);return`function($event){${r}${e?`return ${t.value}.apply(null, arguments)`:n?`return (${t.value}).apply(null, arguments)`:o?`return ${t.value}`:t.value}}`}return e||n?t.value:`function($event){${o?`return ${t.value}`:t.value}}`}function zc(t){const e=parseInt(t,10);if(e)return`$event.keyCode!==${e}`;const n=Lc[t],o=Rc[t];return`_k($event.keyCode,${JSON.stringify(t)},${JSON.stringify(n)},$event.key,${JSON.stringify(o)})`}var Vc={on:function(t,e){t.wrapListeners=t=>`_g(${t},${e.value})`},bind:function(t,e){t.wrapData=n=>`_b(${n},'${t.tag}',${e.value},${e.modifiers&&e.modifiers.prop?"true":"false"}${e.modifiers&&e.modifiers.sync?",true":""})`},cloak:E};class Kc{constructor(t){this.options=t,this.warn=t.warn||Or,this.transforms=Tr(t.modules,"transformCode"),this.dataGenFns=Tr(t.modules,"genData"),this.directives=A(A({},Vc),t.directives);const e=t.isReservedTag||N;this.maybeComponent=t=>!!t.component||!e(t.tag),this.onceId=0,this.staticRenderFns=[],this.pre=!1}}function Jc(t,e){const n=new Kc(e);return{render:`with(this){return ${t?"script"===t.tag?"null":qc(t,n):'_c("div")'}}`,staticRenderFns:n.staticRenderFns}}function qc(t,e){if(t.parent&&(t.pre=t.pre||t.parent.pre),t.staticRoot&&!t.staticProcessed)return Wc(t,e);if(t.once&&!t.onceProcessed)return Zc(t,e);if(t.for&&!t.forProcessed)return Yc(t,e);if(t.if&&!t.ifProcessed)return Gc(t,e);if("template"!==t.tag||t.slotTarget||e.pre){if("slot"===t.tag)return function(t,e){const n=t.slotName||'"default"',o=na(t,e);let r=`_t(${n}${o?`,function(){return ${o}}`:""}`;const s=t.attrs||t.dynamicAttrs?sa((t.attrs||[]).concat(t.dynamicAttrs||[]).map((t=>({name:x(t.name),value:t.value,dynamic:t.dynamic})))):null,i=t.attrsMap["v-bind"];!s&&!i||o||(r+=",null");s&&(r+=`,${s}`);i&&(r+=`${s?"":",null"},${i}`);return r+")"}(t,e);{let n;if(t.component)n=function(t,e,n){const o=e.inlineTemplate?null:na(e,n,!0);return`_c(${t},${Qc(e,n)}${o?`,${o}`:""})`}(t.component,t,e);else{let o;const r=e.maybeComponent(t);let s;(!t.plain||t.pre&&r)&&(o=Qc(t,e));const i=e.options.bindings;r&&i&&!1!==i.__isScriptSetup&&(s=function(t,e){const n=x(e),o=C(n),r=r=>t[e]===r?e:t[n]===r?n:t[o]===r?o:void 0,s=r("setup-const")||r("setup-reactive-const");if(s)return s;const i=r("setup-let")||r("setup-ref")||r("setup-maybe-ref");if(i)return i}(i,t.tag)),s||(s=`'${t.tag}'`);const c=t.inlineTemplate?null:na(t,e,!0);n=`_c(${s}${o?`,${o}`:""}${c?`,${c}`:""})`}for(let o=0;o<e.transforms.length;o++)n=e.transforms[o](t,n);return n}}return na(t,e)||"void 0"}function Wc(t,e){t.staticProcessed=!0;const n=e.pre;return t.pre&&(e.pre=t.pre),e.staticRenderFns.push(`with(this){return ${qc(t,e)}}`),e.pre=n,`_m(${e.staticRenderFns.length-1}${t.staticInFor?",true":""})`}function Zc(t,e){if(t.onceProcessed=!0,t.if&&!t.ifProcessed)return Gc(t,e);if(t.staticInFor){let n="",o=t.parent;for(;o;){if(o.for){n=o.key;break}o=o.parent}return n?`_o(${qc(t,e)},${e.onceId++},${n})`:qc(t,e)}return Wc(t,e)}function Gc(t,e,n,o){return t.ifProcessed=!0,Xc(t.ifConditions.slice(),e,n,o)}function Xc(t,e,n,o){if(!t.length)return o||"_e()";const r=t.shift();return r.exp?`(${r.exp})?${s(r.block)}:${Xc(t,e,n,o)}`:`${s(r.block)}`;function s(t){return n?n(t,e):t.once?Zc(t,e):qc(t,e)}}function Yc(t,e,n,o){const r=t.for,s=t.alias,i=t.iterator1?`,${t.iterator1}`:"",c=t.iterator2?`,${t.iterator2}`:"";return t.forProcessed=!0,`${o||"_l"}((${r}),function(${s}${i}${c}){return ${(n||qc)(t,e)}})`}function Qc(t,e){let n="{";const o=function(t,e){const n=t.directives;if(!n)return;let o,r,s,i,c="directives:[",a=!1;for(o=0,r=n.length;o<r;o++){s=n[o],i=!0;const r=e.directives[s.name];r&&(i=!!r(t,s,e.warn)),i&&(a=!0,c+=`{name:"${s.name}",rawName:"${s.rawName}"${s.value?`,value:(${s.value}),expression:${JSON.stringify(s.value)}`:""}${s.arg?`,arg:${s.isDynamicArg?s.arg:`"${s.arg}"`}`:""}${s.modifiers?`,modifiers:${JSON.stringify(s.modifiers)}`:""}},`)}if(a)return c.slice(0,-1)+"]"}(t,e);o&&(n+=o+","),t.key&&(n+=`key:${t.key},`),t.ref&&(n+=`ref:${t.ref},`),t.refInFor&&(n+="refInFor:true,"),t.pre&&(n+="pre:true,"),t.component&&(n+=`tag:"${t.tag}",`);for(let o=0;o<e.dataGenFns.length;o++)n+=e.dataGenFns[o](t);if(t.attrs&&(n+=`attrs:${sa(t.attrs)},`),t.props&&(n+=`domProps:${sa(t.props)},`),t.events&&(n+=`${Bc(t.events,!1)},`),t.nativeEvents&&(n+=`${Bc(t.nativeEvents,!0)},`),t.slotTarget&&!t.slotScope&&(n+=`slot:${t.slotTarget},`),t.scopedSlots&&(n+=`${function(t,e,n){let o=t.for||Object.keys(e).some((t=>{const n=e[t];return n.slotTargetDynamic||n.if||n.for||ta(n)})),r=!!t.if;if(!o){let e=t.parent;for(;e;){if(e.slotScope&&e.slotScope!==ic||e.for){o=!0;break}e.if&&(r=!0),e=e.parent}}const s=Object.keys(e).map((t=>ea(e[t],n))).join(",");return`scopedSlots:_u([${s}]${o?",null,true":""}${!o&&r?`,null,false,${function(t){let e=5381,n=t.length;for(;n;)e=33*e^t.charCodeAt(--n);return e>>>0}(s)}`:""})`}(t,t.scopedSlots,e)},`),t.model&&(n+=`model:{value:${t.model.value},callback:${t.model.callback},expression:${t.model.expression}},`),t.inlineTemplate){const o=function(t,e){const n=t.children[0];if(n&&1===n.type){const t=Jc(n,e.options);return`inlineTemplate:{render:function(){${t.render}},staticRenderFns:[${t.staticRenderFns.map((t=>`function(){${t}}`)).join(",")}]}`}}(t,e);o&&(n+=`${o},`)}return n=n.replace(/,$/,"")+"}",t.dynamicAttrs&&(n=`_b(${n},"${t.tag}",${sa(t.dynamicAttrs)})`),t.wrapData&&(n=t.wrapData(n)),t.wrapListeners&&(n=t.wrapListeners(n)),n}function ta(t){return 1===t.type&&("slot"===t.tag||t.children.some(ta))}function ea(t,e){const n=t.attrsMap["slot-scope"];if(t.if&&!t.ifProcessed&&!n)return Gc(t,e,ea,"null");if(t.for&&!t.forProcessed)return Yc(t,e,ea);const o=t.slotScope===ic?"":String(t.slotScope),r=`function(${o}){return ${"template"===t.tag?t.if&&n?`(${t.if})?${na(t,e)||"undefined"}:undefined`:na(t,e)||"undefined":qc(t,e)}}`,s=o?"":",proxy:true";return`{key:${t.slotTarget||'"default"'},fn:${r}${s}}`}function na(t,e,n,o,r){const s=t.children;if(s.length){const t=s[0];if(1===s.length&&t.for&&"template"!==t.tag&&"slot"!==t.tag){const r=n?e.maybeComponent(t)?",1":",0":"";return`${(o||qc)(t,e)}${r}`}const i=n?function(t,e){let n=0;for(let o=0;o<t.length;o++){const r=t[o];if(1===r.type){if(oa(r)||r.ifConditions&&r.ifConditions.some((t=>oa(t.block)))){n=2;break}(e(r)||r.ifConditions&&r.ifConditions.some((t=>e(t.block))))&&(n=1)}}return n}(s,e.maybeComponent):0,c=r||ra;return`[${s.map((t=>c(t,e))).join(",")}]${i?`,${i}`:""}`}}function oa(t){return void 0!==t.for||"template"===t.tag||"slot"===t.tag}function ra(t,e){return 1===t.type?qc(t,e):3===t.type&&t.isComment?function(t){return`_e(${JSON.stringify(t.text)})`}(t):function(t){return`_v(${2===t.type?t.expression:ia(JSON.stringify(t.text))})`}(t)}function sa(t){let e="",n="";for(let o=0;o<t.length;o++){const r=t[o],s=ia(r.value);r.dynamic?n+=`${r.name},${s},`:e+=`"${r.name}":${s},`}return e=`{${e.slice(0,-1)}}`,n?`_d(${e},[${n.slice(0,-1)}])`:e}function ia(t){return t.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function ca(t,e){try{return new Function(t)}catch(n){return e.push({err:n,code:t}),E}}function aa(t){const e=Object.create(null);return function(n,o,r){(o=A({},o)).warn,delete o.warn;const s=o.delimiters?String(o.delimiters)+n:n;if(e[s])return e[s];const i=t(n,o),c={},a=[];return c.render=ca(i.render,a),c.staticRenderFns=i.staticRenderFns.map((t=>ca(t,a))),e[s]=c}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");const la=(ua=function(t,e){const n=gc(t.trim(),e);!1!==e.optimize&&Ec(n,e);const o=Jc(n,e);return{ast:n,render:o.render,staticRenderFns:o.staticRenderFns}},function(t){function e(e,n){const o=Object.create(t),r=[],s=[];if(n){n.modules&&(o.modules=(t.modules||[]).concat(n.modules)),n.directives&&(o.directives=A(Object.create(t.directives||null),n.directives));for(const t in n)"modules"!==t&&"directives"!==t&&(o[t]=n[t])}o.warn=(t,e,n)=>{(n?s:r).push(t)};const i=ua(e.trim(),o);return i.errors=r,i.tips=s,i}return{compile:e,compileToFunctions:aa(e)}});var ua;const{compile:fa,compileToFunctions:da}=la(Oc);let pa;function ha(t){return pa=pa||document.createElement("div"),pa.innerHTML=t?'<a href="\n"/>':'<div a="\n"/>',pa.innerHTML.indexOf("&#10;")>0}const ma=!!q&&ha(!1),ga=!!q&&ha(!0),va=b((t=>{const e=nr(t);return e&&e.innerHTML})),ya=So.prototype.$mount;So.prototype.$mount=function(t,e){if((t=t&&nr(t))===document.body||t===document.documentElement)return this;const n=this.$options;if(!n.render){let e=n.template;if(e)if("string"==typeof e)"#"===e.charAt(0)&&(e=va(e));else{if(!e.nodeType)return this;e=e.innerHTML}else t&&(e=function(t){if(t.outerHTML)return t.outerHTML;{const e=document.createElement("div");return e.appendChild(t.cloneNode(!0)),e.innerHTML}}(t));if(e){const{render:t,staticRenderFns:o}=da(e,{outputSourceRange:!1,shouldDecodeNewlines:ma,shouldDecodeNewlinesForHref:ga,delimiters:n.delimiters,comments:n.comments},this);n.render=t,n.staticRenderFns=o}}return ya.call(this,t,e)},So.compile=da,A(So,Hn),So.effect=function(t,e){const n=new Kn(at,t,E,{sync:!0});e&&(n.update=()=>{e((()=>n.run()))})},module.exports=So;
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":38}]},{},[7])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJhcHAvc3JjL2RvbS1oZWxwZXIuanMiLCJhcHAvc3JjL2VkaXRvci1pbWFnZS5qcyIsImFwcC9zcmMvZWRpdG9yLW1ldGEuanMiLCJhcHAvc3JjL2VkaXRvci10ZXh0LmpzIiwiYXBwL3NyYy9lZGl0b3IuanMiLCJhcHAvc3JjL2lmcmFtZS1sb2FkLmpzIiwiYXBwL3NyYy9tYWluLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91aWtpdC9kaXN0L2pzL3Vpa2l0LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uZGV2LmpzIiwibm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanMiLCJub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmNvbW1vbi5wcm9kLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUNBQSxNQUFNLENBQUMsT0FBTztFQUFBLFNBQUEsVUFBQTtJQUFBLGVBQUEsT0FBQSxTQUFBO0VBQUE7RUFBQSxPQUFBLFlBQUEsQ0FBQSxTQUFBO0lBQUEsR0FBQTtJQUFBLEtBQUEsRUFFVixTQUFPLGFBQWEsQ0FBQyxHQUFHLEVBQUU7TUFDdEIsSUFBTSxNQUFNLEdBQUcsSUFBSSxTQUFTLENBQUMsQ0FBQztNQUM5QixPQUFPLE1BQU0sQ0FBQyxlQUFlLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQztJQUNuRDtFQUFDO0lBQUEsR0FBQTtJQUFBLEtBQUEsRUFFRCxTQUFPLGlCQUFpQixDQUFDLEdBQUcsRUFBRTtNQUMxQixJQUFNLFVBQVUsR0FBRyxJQUFJLGFBQWEsQ0FBQyxDQUFDO01BQ3RDLE9BQU8sVUFBVSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQztJQUM1QztFQUFDO0lBQUEsR0FBQTtJQUFBLEtBQUEsRUFFRCxTQUFPLGFBQWEsQ0FBQyxHQUFHLEVBQUU7TUFDdEIsSUFBTSxJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUk7TUFFckIsSUFBSSxTQUFTLEdBQUcsRUFBRTtNQUVsQixTQUFTLE9BQU8sQ0FBQyxPQUFPLEVBQUU7UUFDdEIsT0FBTyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJLEVBQUs7VUFFakMsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLE9BQU8sSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUM1RSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztZQUNwQjtVQUNKLENBQUMsTUFBTTtZQUNILE9BQU8sQ0FBQyxJQUFJLENBQUM7VUFDakI7UUFDSixDQUFDLENBQUM7TUFDTjtNQUFDO01BQ0QsT0FBTyxDQUFDLElBQUksQ0FBQztNQUViLFNBQVMsQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJLEVBQUUsQ0FBQyxFQUFLO1FBQzNCLElBQU0sT0FBTyxHQUFHLEdBQUcsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDO1FBRWhELElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUM7UUFDM0MsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7UUFDekIsT0FBTyxDQUFDLGVBQWUsR0FBRyxJQUFJO1FBQzlCLE9BQU8sQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztNQUNyQyxDQUFDLENBQUM7TUFFRixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztNQUVoQixPQUFPLEdBQUc7SUFDZDtFQUFDO0lBQUEsR0FBQTtJQUFBLEtBQUEsRUFFRCxTQUFPLGVBQWUsQ0FBQyxHQUFHLEVBQUU7TUFDeEIsR0FBRyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUs7UUFDMUQsT0FBTyxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUM7TUFDaEUsQ0FBQyxDQUFDO0lBQ047RUFBQztJQUFBLEdBQUE7SUFBQSxLQUFBLEVBRUQsU0FBTyxVQUFVLENBQUMsR0FBRyxFQUFFO01BQ25CLEdBQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUMsR0FBRyxFQUFFLElBQUksRUFBSztRQUNwRDtRQUNBO1FBQ0E7UUFDQSxHQUFHLENBQUMsWUFBWSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUM7TUFDM0MsQ0FBQyxDQUFDO01BRUYsT0FBTyxHQUFHO0lBQ2Q7RUFBQztJQUFBLEdBQUE7SUFBQSxLQUFBLEVBRUQsU0FBTyxZQUFZLENBQUMsR0FBRyxFQUFFO01BQ3JCLEdBQUcsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUFHLEVBQUs7UUFDMUQsR0FBRyxDQUFDLGVBQWUsQ0FBQyxlQUFlLENBQUM7TUFDeEMsQ0FBQyxDQUFDO0lBQ047RUFBQztBQUFBLEdBQ0o7Ozs7Ozs7Ozs7O0FDbEVELElBQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQUM7QUFFOUIsTUFBTSxDQUFDLE9BQU87RUFFVixTQUFBLFlBQVksT0FBTyxFQUFFLGNBQWMsRUFBRTtJQUFBLElBQUEsS0FBQTtJQUFBLGVBQUEsT0FBQSxXQUFBO0lBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUN0QixJQUFJLENBQUMsY0FBYyxHQUFHLGNBQWM7SUFFcEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUU7TUFBQSxPQUFNLEtBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUFBLEVBQUM7SUFFNUQsSUFBSSxDQUFDLFdBQVcsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQztFQUM1RDtFQUFDLE9BQUEsWUFBQSxDQUFBLFdBQUE7SUFBQSxHQUFBO0lBQUEsS0FBQSxFQUVELFNBQUEsT0FBTyxDQUFBLEVBQUc7TUFBQSxJQUFBLE1BQUE7TUFDTixJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO01BRXhCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxHQUFHLFlBQU07UUFDOUIsSUFBSSxNQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssSUFBSSxNQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRTtVQUNyRCxNQUFNLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO1VBQ3pCLElBQUksUUFBUSxHQUFHLElBQUksUUFBUSxDQUFDLENBQUM7VUFDN0IsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsTUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7VUFFbkQsS0FBSyxDQUNBLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxRQUFRLEVBQUU7WUFDdEMsU0FBUyxFQUFFO2NBQ1AsY0FBYyxFQUFFO1lBQ3BCO1VBQ0osQ0FBQyxDQUFDLENBQ0QsSUFBSSxDQUFDLFVBQUMsR0FBRyxFQUFLO1lBQ1gsTUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEdBQUcsTUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsUUFBUSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRztVQUN4RSxDQUFDLENBQUMsU0FDSSxDQUFDO1lBQUEsT0FBTSxNQUFNLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLDhCQUE4QixDQUFDO1VBQUEsRUFBQyxXQUNsRSxDQUFDLFlBQU07WUFDWCxNQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssR0FBRyxFQUFFO1lBQzNCLE1BQU0sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7VUFDOUIsQ0FBQyxDQUFDO1FBQ1Y7TUFDSixDQUFDO0lBQ0w7RUFBQztBQUFBLEdBRUo7Ozs7Ozs7Ozs7O0FDeENELE1BQU0sQ0FBQyxPQUFPO0VBQ1YsU0FBQSxXQUFZLFVBQVUsRUFBRTtJQUFBLGVBQUEsT0FBQSxVQUFBO0lBQ3BCLElBQUksQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUVySCxJQUFJLENBQUMsUUFBUSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLHVCQUF1QixDQUFDO0lBQ3RFLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO01BQ2hCLElBQUksQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztNQUM3RSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDO0lBQ2xEO0lBRUEsSUFBSSxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQztJQUM1RSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRTtNQUNuQixJQUFJLENBQUMsV0FBVyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7TUFDaEYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLGFBQWEsQ0FBQztJQUN4RDtFQUNKO0VBQUMsT0FBQSxZQUFBLENBQUEsVUFBQTtJQUFBLEdBQUE7SUFBQSxLQUFBLEVBRUQsU0FBQSxPQUFPLENBQUEsRUFBRztNQUNOLE9BQU87UUFDSCxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTO1FBQzNCLFdBQVcsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUM7UUFDckQsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLFNBQVM7TUFDbEQsQ0FBQztJQUNMO0VBQUM7SUFBQSxHQUFBO0lBQUEsS0FBQSxFQUVELFNBQUEsT0FBTyxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFO01BQ2xDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLEtBQUs7TUFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQztNQUNyRCxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDO0lBQ25EO0VBQUM7QUFBQSxHQUNKOzs7Ozs7Ozs7OztBQzlCRCxNQUFNLENBQUMsT0FBTztFQUVWLFNBQUEsV0FBWSxPQUFPLEVBQUUsY0FBYyxFQUFFO0lBQUEsSUFBQSxLQUFBO0lBQUEsZUFBQSxPQUFBLFVBQUE7SUFDakMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3RCLElBQUksQ0FBQyxjQUFjLEdBQUcsY0FBYztJQUVwQyxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtNQUFBLE9BQU0sS0FBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQUEsRUFBQztJQUU1RCxJQUNJLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFFBQVEsS0FBSyxHQUFHLElBQ3hDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFFBQVEsS0FBSyxRQUFRLEVBQy9DO01BQ0UsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsVUFBQyxDQUFDO1FBQUEsT0FBSyxLQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztNQUFBLEVBQUM7SUFDOUU7SUFFQSxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRTtNQUFBLE9BQU0sS0FBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQUEsRUFBQztJQUMxRCxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxVQUFDLENBQUM7TUFBQSxPQUFLLEtBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQUEsRUFBQztJQUNwRSxJQUFJLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRTtNQUFBLE9BQU0sS0FBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQUEsRUFBQztFQUNuRTtFQUFDLE9BQUEsWUFBQSxDQUFBLFVBQUE7SUFBQSxHQUFBO0lBQUEsS0FBQSxFQUVELFNBQUEsT0FBTyxDQUFBLEVBQUc7TUFDTixJQUFJLENBQUMsT0FBTyxDQUFDLGVBQWUsR0FBRyxJQUFJO01BQ25DLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEI7RUFBQztJQUFBLEdBQUE7SUFBQSxLQUFBLEVBRUQsU0FBQSxhQUFhLENBQUMsQ0FBQyxFQUFFO01BQ2IsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDO01BQ2xCLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNsQjtFQUFDO0lBQUEsR0FBQTtJQUFBLEtBQUEsRUFFRCxTQUFBLE1BQU0sQ0FBQSxFQUFHO01BQ0wsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsaUJBQWlCLENBQUM7SUFDbkQ7RUFBQztJQUFBLEdBQUE7SUFBQSxLQUFBLEVBRUQsU0FBQSxVQUFVLENBQUMsQ0FBQyxFQUFFO01BQ1YsSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLEVBQUUsRUFBRTtRQUNsQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO01BQ3ZCO0lBQ0o7RUFBQztJQUFBLEdBQUE7SUFBQSxLQUFBLEVBRUQsU0FBQSxVQUFVLENBQUEsRUFBRztNQUNULElBQUksQ0FBQyxjQUFjLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUztJQUMxRDtFQUFDO0FBQUEsR0FFSjs7Ozs7Ozs7Ozs7QUM1Q0QsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUM5QixJQUFNLFNBQVMsR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDO0FBQ3pDLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUM7QUFDM0MsSUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDO0FBQzdDLElBQU0sVUFBVSxHQUFHLE9BQU8sQ0FBQyxlQUFlLENBQUM7QUFFM0MsT0FBTyxDQUFDLGVBQWUsQ0FBQztBQUV4QixNQUFNLENBQUMsT0FBTztFQUVWLFNBQUEsT0FBQSxFQUFjO0lBQUEsZUFBQSxPQUFBLE1BQUE7SUFDVixJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDO0VBQ2xEO0VBQUMsT0FBQSxZQUFBLENBQUEsTUFBQTtJQUFBLEdBQUE7SUFBQSxLQUFBLEVBRUQsU0FBQSxJQUFJLENBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRTtNQUFBLElBQUEsS0FBQTtNQUNqQixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUk7TUFFeEIsS0FBSyxDQUNBLEdBQUcsQ0FBQyxLQUFLLEdBQUcsSUFBSSxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUMzQyxJQUFJLENBQUMsVUFBQyxHQUFHO1FBQUEsT0FBSyxTQUFTLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7TUFBQSxFQUFDLENBQ2hELElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQzdCLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQzFCLElBQUksQ0FBQyxVQUFDLEdBQUcsRUFBSztRQUNYLEtBQUksQ0FBQyxVQUFVLEdBQUcsR0FBRztRQUNyQixPQUFPLEdBQUc7TUFDZCxDQUFDLENBQUMsQ0FDRCxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUFDLENBQ2pDLElBQUksQ0FBQyxVQUFDLElBQUk7UUFBQSxPQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsMEJBQTBCLEVBQUU7VUFBRSxJQUFJLEVBQUo7UUFBSyxDQUFDLENBQUM7TUFBQSxFQUFDLENBQ2hFLElBQUksQ0FBQztRQUFBLE9BQU0sS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUM7TUFBQSxFQUFDLENBQ2hELElBQUksQ0FBQyxVQUFDLElBQUk7UUFBQSxPQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsNEJBQTRCLENBQUM7TUFBQSxFQUFDLENBQ3hELElBQUksQ0FBQztRQUFBLE9BQU0sS0FBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO01BQUEsRUFBQyxDQUNoQyxJQUFJLENBQUM7UUFBQSxPQUFNLEtBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztNQUFBLEVBQUMsQ0FDL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN2QjtFQUFDO0lBQUEsR0FBQTtJQUFBLEtBQUEsRUFFRCxTQUFBLGFBQWEsQ0FBQSxFQUFHO01BQUEsSUFBQSxNQUFBO01BQ1osSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFDLE9BQU8sRUFBSztRQUNsRixJQUFNLEVBQUUsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQztRQUN6QyxJQUFNLGNBQWMsR0FBRyxNQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLGNBQUEsTUFBQSxDQUFhLEVBQUUsUUFBSSxDQUFDO1FBQzdFLElBQUksVUFBVSxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUM7TUFDM0MsQ0FBQyxDQUFDO01BRUYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUMsT0FBTyxFQUFLO1FBQ3RGLElBQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDO1FBQ2hELElBQU0sY0FBYyxHQUFHLE1BQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGFBQWEscUJBQUEsTUFBQSxDQUFvQixFQUFFLFFBQUksQ0FBQztRQUNwRixJQUFJLFdBQVcsQ0FBQyxPQUFPLEVBQUUsY0FBYyxDQUFDO01BQzVDLENBQUMsQ0FBQztNQUVGLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUNyRDtFQUFDO0lBQUEsR0FBQTtJQUFBLEtBQUEsRUFFRCxTQUFBLFlBQVksQ0FBQSxFQUFHO01BQ1gsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQztNQUNoRSxLQUFLLENBQUMsU0FBUywwVkFXZDtNQUNELElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO0lBQ3ZEO0VBQUM7SUFBQSxHQUFBO0lBQUEsS0FBQSxFQUVELFNBQUEsSUFBSSxDQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUU7TUFDcEIsSUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztNQUMxRCxTQUFTLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQztNQUNsQyxTQUFTLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQztNQUMvQixJQUFNLElBQUksR0FBRyxTQUFTLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDO01BRWpELEtBQUssQ0FDQSxJQUFJLENBQUMscUJBQXFCLEVBQUU7UUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLFlBQVk7UUFBRSxJQUFJLEVBQUo7TUFBSyxDQUFDLENBQUMsQ0FDbEUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUNULENBQUMsT0FBTyxDQUFDO0lBQ3ZCO0VBQUM7QUFBQSxHQUVKOzs7OztBQ2hGRDtBQUNBLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxJQUFJLEdBQUcsVUFBVSxHQUFHLEVBQUUsUUFBUSxFQUFFO0VBQ3hELElBQU0sTUFBTSxHQUFHLElBQUk7RUFDbkIsSUFBSTtJQUNBLE1BQU0sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7RUFDdEUsQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFO0lBQ1osSUFBSSxDQUFDLFFBQVEsRUFBRTtNQUNYLE9BQU8sSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFLO1FBQ3BDLE1BQU0sQ0FBQyxLQUFLLENBQUM7TUFDakIsQ0FBQyxDQUFDO0lBQ04sQ0FBQyxNQUFNO01BQ0gsUUFBUSxDQUFDLEtBQUssQ0FBQztJQUNuQjtFQUNKO0VBRUEsSUFBTSxPQUFPLEdBQUcsS0FBSztFQUNyQixJQUFNLFFBQVEsR0FBRyxHQUFHO0VBRXBCLElBQUksVUFBVSxHQUFHLENBQUM7RUFFbEIsSUFBSSxDQUFDLFFBQVEsRUFBRTtJQUNYLE9BQU8sSUFBSSxPQUFPLENBQUMsVUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFLO01BQ3BDLElBQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxZQUFZO1FBQ2xDLElBQUksQ0FBQyxNQUFNLEVBQUUsT0FBTyxhQUFhLENBQUMsS0FBSyxDQUFDO1FBQ3hDLFVBQVUsRUFBRTtRQUNaLElBQUksTUFBTSxDQUFDLGVBQWUsSUFBSSxNQUFNLENBQUMsZUFBZSxDQUFDLFVBQVUsS0FBSyxVQUFVLEVBQUU7VUFDNUUsYUFBYSxDQUFDLEtBQUssQ0FBQztVQUNwQixPQUFPLENBQUMsQ0FBQztRQUNiLENBQUMsTUFBTSxJQUFJLFVBQVUsR0FBRyxRQUFRLEdBQUcsT0FBTyxFQUFFO1VBQ3hDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQzFDO01BQ0osQ0FBQyxFQUFFLFFBQVEsQ0FBQztJQUNoQixDQUFDLENBQUM7RUFDTixDQUFDLE1BQU07SUFDSCxJQUFNLEtBQUssR0FBRyxXQUFXLENBQUMsWUFBWTtNQUNsQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sYUFBYSxDQUFDLEtBQUssQ0FBQztNQUN4QyxJQUFJLE1BQU0sQ0FBQyxlQUFlLElBQUksTUFBTSxDQUFDLGVBQWUsQ0FBQyxVQUFVLEtBQUssVUFBVSxFQUFFO1FBQzVFLGFBQWEsQ0FBQyxLQUFLLENBQUM7UUFDcEIsUUFBUSxDQUFDLENBQUM7TUFDZCxDQUFDLE1BQU0sSUFBSSxVQUFVLEdBQUcsUUFBUSxHQUFHLE9BQU8sRUFBRTtRQUN4QyxRQUFRLENBQUMsSUFBSSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztNQUM1QztJQUNKLENBQUMsRUFBRSxRQUFRLENBQUM7RUFDaEI7QUFDSixDQUFDOzs7OztBQzVDRCxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDO0FBQ3JDLElBQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7QUFDMUIsSUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUM5QixJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO0FBRTlCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsQ0FBQztBQUU1QixNQUFNLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDO0VBQ2pCLEVBQUUsRUFBRSxNQUFNO0VBQ1YsSUFBSSxFQUFFO0lBQ0YsVUFBVSxFQUFFLElBQUk7SUFDaEIsSUFBSSxFQUFFLFlBQVk7SUFDbEIsVUFBVSxFQUFFLEVBQUU7SUFDZCxZQUFZLEVBQUUsRUFBRTtJQUVoQixJQUFJLEVBQUU7TUFDRixLQUFLLEVBQUUsRUFBRTtNQUNULFdBQVcsRUFBRSxFQUFFO01BQ2YsUUFBUSxFQUFFO0lBQ2QsQ0FBQztJQUVELElBQUksRUFBRSxLQUFLO0lBQ1gsUUFBUSxFQUFFLEVBQUU7SUFDWixVQUFVLEVBQUU7RUFDaEIsQ0FBQztFQUNELE9BQU8sRUFBRTtJQUNMLFNBQVMsV0FBVCxTQUFTLENBQUEsRUFBRztNQUFBLElBQUEsS0FBQTtNQUNSLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSTtNQUN0QixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FDZCxZQUFNO1FBQ0YsS0FBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQ3JCLEtBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSztRQUN2QixLQUFLLENBQUMsWUFBWSxDQUFDO1VBQUMsT0FBTyxFQUFFLHVCQUF1QjtVQUFFLE1BQU0sRUFBRTtRQUFTLENBQUMsQ0FBQztNQUM3RSxDQUFDLEVBQ0QsWUFBTTtRQUNGLEtBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSztRQUN2QixLQUFLLENBQUMsWUFBWSxDQUFDO1VBQUMsT0FBTyxFQUFFLDhCQUE4QjtVQUFFLE1BQU0sRUFBRTtRQUFRLENBQUMsQ0FBQztNQUNuRixDQUNKLENBQUM7SUFDTCxDQUFDO0lBRUQsUUFBUSxXQUFSLFFBQVEsQ0FBQyxJQUFJLEVBQUU7TUFBQSxJQUFBLE1BQUE7TUFDWCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUk7TUFDaEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO01BQ3JCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSTtNQUN0QixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsWUFBTTtRQUMzQixNQUFJLENBQUMsVUFBVSxHQUFHLEtBQUs7UUFDdkIsTUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztNQUNsRCxDQUFDLENBQUM7SUFDTixDQUFDO0lBRUQsY0FBYyxXQUFkLGNBQWMsQ0FBQSxFQUFHO01BQUEsSUFBQSxNQUFBO01BQ2IsS0FBSyxDQUNBLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQyxDQUMxQixJQUFJLENBQUMsVUFBQyxRQUFRLEVBQUs7UUFDaEIsTUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsSUFBSTtNQUNqQyxDQUFDLENBQUM7SUFDVixDQUFDO0lBRUQsY0FBYyxXQUFkLGNBQWMsQ0FBQSxFQUFHO01BQUEsSUFBQSxNQUFBO01BQ2IsS0FBSyxDQUNBLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQyxDQUM3QixJQUFJLENBQUMsVUFBQSxRQUFRLEVBQUk7UUFDZCxNQUFJLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQUMsTUFBTSxFQUFLO1VBQy9DLE9BQVEsTUFBTSxDQUFDLElBQUksS0FBSyxNQUFJLENBQUMsSUFBSTtRQUNyQyxDQUFDLENBQUM7TUFDTixDQUFDLENBQUM7SUFDVixDQUFDO0lBRUQsYUFBYSxXQUFiLGFBQWEsQ0FBQyxNQUFNLEVBQUU7TUFBQSxJQUFBLE1BQUE7TUFDbEIsS0FBSyxDQUFDLEtBQUssQ0FDTixPQUFPLENBQUMsdURBQXVELEVBQUU7UUFDOUQsTUFBTSxFQUFFO1VBQUUsRUFBRSxFQUFFLGNBQWM7VUFBRSxNQUFNLEVBQUU7UUFBUTtNQUNsRCxDQUFDLENBQUMsQ0FDRCxJQUFJLENBQUMsWUFBTTtRQUNSLE1BQUksQ0FBQyxVQUFVLEdBQUcsSUFBSTtRQUN0QixPQUFPLEtBQUssQ0FDUCxJQUFJLENBQUMsMEJBQTBCLEVBQUU7VUFDOUIsTUFBTSxFQUFFLE1BQU0sQ0FBQyxJQUFJO1VBQ25CLE1BQU0sRUFBRSxNQUFJLENBQUM7UUFDakIsQ0FBQyxDQUFDO01BQ1YsQ0FBQyxDQUFDLENBQ0QsSUFBSSxDQUFDLFlBQU07UUFDUixNQUFJLENBQUMsUUFBUSxDQUFDLE1BQUksQ0FBQyxJQUFJLENBQUM7TUFDNUIsQ0FBQyxDQUFDO0lBQ1YsQ0FBQztJQUVELFNBQVMsV0FBVCxTQUFTLENBQUEsRUFBRztNQUNSLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUNoRyxDQUFDO0lBRUQsS0FBSyxXQUFMLEtBQUssQ0FBQSxFQUFHO01BQUEsSUFBQSxNQUFBO01BQ0osSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDMUIsS0FBSyxDQUNBLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtVQUNyQixRQUFRLEVBQUUsSUFBSSxDQUFDO1FBQ25CLENBQUMsQ0FBQyxDQUNELElBQUksQ0FBQyxVQUFDLEdBQUcsRUFBSztVQUNYLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztVQUVyQixJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLElBQUksRUFBRTtZQUN4QixNQUFJLENBQUMsSUFBSSxHQUFHLElBQUk7WUFDaEIsTUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1VBQ2hCLENBQUMsTUFBTTtZQUNILE1BQUksQ0FBQyxVQUFVLEdBQUcsSUFBSTtVQUMxQjtRQUNKLENBQUMsQ0FBQyxTQUNJLENBQUMsVUFBQyxLQUFLLEVBQUs7VUFDZCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztRQUN0QixDQUFDLENBQUM7TUFDVixDQUFDLE1BQU07UUFDSCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUk7TUFDMUI7SUFDSixDQUFDO0lBRUQsTUFBTSxXQUFOLE1BQU0sQ0FBQSxFQUFHO01BQ0wsS0FBSyxDQUNBLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUN4QixJQUFJLENBQUMsWUFBTTtRQUNSLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztNQUNoQyxDQUFDLENBQUM7SUFDVixDQUFDO0lBRUQsS0FBSyxXQUFMLEtBQUssQ0FBQSxFQUFHO01BQ0osSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO01BQ3hCLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztNQUNyQixJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDekIsQ0FBQztJQUVELFlBQVksV0FBWixZQUFZLENBQUEsRUFBRztNQUNYLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSTtJQUMxQixDQUFDO0lBRUQsYUFBYSxXQUFiLGFBQWEsQ0FBQSxFQUFHO01BQ1osSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLO0lBQzNCLENBQUM7SUFFRCxpQkFBaUIsV0FBakIsaUJBQWlCLENBQUMsR0FBRyxFQUFFO01BQ25CLEtBQUssQ0FBQyxZQUFZLENBQUM7UUFBQyxPQUFPLEVBQUUsR0FBRztRQUFFLE1BQU0sRUFBRTtNQUFRLENBQUMsQ0FBQztJQUN4RDtFQUNKLENBQUM7RUFDRCxPQUFPLFdBQVAsT0FBTyxDQUFBLEVBQUc7SUFBQSxJQUFBLE1BQUE7SUFDTixLQUFLLENBQ0EsR0FBRyxDQUFDLHNCQUFzQixDQUFDLENBQzNCLElBQUksQ0FBQyxVQUFBLEdBQUcsRUFBSTtNQUNUOztNQUVBLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxFQUFFO1FBQ3hCLE1BQUksQ0FBQyxJQUFJLEdBQUcsSUFBSTtRQUNoQixNQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7TUFDaEI7SUFDSixDQUFDLENBQUMsU0FDSSxDQUFDLFVBQUMsS0FBSyxFQUFLO01BQ2QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7SUFDdEIsQ0FBQyxDQUFDO0VBQ1Y7QUFDSixDQUFDLENBQUM7OztBQzVKRjs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoclRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMWlYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRE9NSGVscGVyIHtcblxuICAgIHN0YXRpYyBwYXJzZVN0clRvRG9tKHN0cikge1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN0ciwgJ3RleHQvaHRtbCcpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzZXJpYWxpemVEb21Ub1N0cihkb20pIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplciA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKGRvbSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHdyYXBUZXh0Tm9kZXMoZG9tKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBkb20uYm9keTtcblxuICAgICAgICBsZXQgdGV4dE5vZGVzID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gcmVjdXJzeShlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZU5hbWUgPT09ICcjdGV4dCcgJiYgbm9kZS5ub2RlVmFsdWUucmVwbGFjZSgvXFxzKy9nLCAnJykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjdXJzeShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVjdXJzeShib2R5KTtcblxuICAgICAgICB0ZXh0Tm9kZXMuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlciA9IGRvbS5jcmVhdGVFbGVtZW50KCd0ZXh0LWVkaXRvcicpO1xuXG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHdyYXBwZXIsIG5vZGUpO1xuICAgICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgICAgIHdyYXBwZXIuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKCdub2RlSWQnLCBpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc29sZS5sb2coZG9tKTtcblxuICAgICAgICByZXR1cm4gZG9tO1xuICAgIH1cblxuICAgIHN0YXRpYyB1bndyYXBUZXh0Tm9kZXMoZG9tKSB7XG4gICAgICAgIGRvbS5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHQtZWRpdG9yJykuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbGVtZW50LmZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgd3JhcEltYWdlcyhkb20pIHtcbiAgICAgICAgZG9tLmJvZHkucXVlcnlTZWxlY3RvckFsbCgnaW1nJykuZm9yRWFjaCgoaW1nLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAvLyB2YXIgaW1faW0gPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIC8vIGltX2ltLnNyYyA9IGltZy5zcmM7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpbV9pbS53aWR0aClcbiAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ2VkaXRhYmxlaW1naWQnLCBpdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICBzdGF0aWMgdW53cmFwSW1hZ2VzKGRvbSkge1xuICAgICAgICBkb20uYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdbZWRpdGFibGVpbWdpZF0nKS5mb3JFYWNoKChpbWcpID0+IHtcbiAgICAgICAgICAgIGltZy5yZW1vdmVBdHRyaWJ1dGUoJ2VkaXRhYmxlaW1naWQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiY29uc3QgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEVkaXRvckltYWdlIHtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHZpcnR1YWxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMudmlydHVhbEVsZW1lbnQgPSB2aXJ0dWFsRWxlbWVudDtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm9uQ2xpY2soKSk7XG5cbiAgICAgICAgdGhpcy5pbWdVcGxvYWRlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNpbWctdXBsb2FkJyk7XG4gICAgfVxuXG4gICAgb25DbGljaygpIHtcbiAgICAgICAgdGhpcy5pbWdVcGxvYWRlci5jbGljaygpO1xuXG4gICAgICAgIHRoaXMuaW1nVXBsb2FkZXIub25jaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbWdVcGxvYWRlci5maWxlcyAmJiB0aGlzLmltZ1VwbG9hZGVyLmZpbGVzWzBdKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnZ1ZS5lbmFibGVMb2FkZXIoKTtcbiAgICAgICAgICAgICAgICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ltYWdlJywgdGhpcy5pbWdVcGxvYWRlci5maWxlc1swXSk7XG5cbiAgICAgICAgICAgICAgICBheGlvc1xuICAgICAgICAgICAgICAgICAgICAucG9zdCgnLi9hcGkvdXBsb2FkX2ltYWdlLnBocCcsIGZvcm1EYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaGVhZGVycyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2Zvcm0vbXVsdGlwYXJ0J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpcnR1YWxFbGVtZW50LnNyYyA9IHRoaXMuZWxlbWVudC5zcmMgPSAnLi9pbWcvJyArIHJlcy5kYXRhLnNyYztcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHdpbmRvdy52dWUuZXJyb3JOb3RpZmljYXRpb24oJ9Ce0YjQuNCx0LrQsCDQt9Cw0LPRgNGD0LfQutC4INC40LfQvtCx0YDQsNC20LXQvdC40Y8hJykpXG4gICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1nVXBsb2FkZXIudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy52dWUuZGlzYWJsZUxvYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRWRpdG9yTWV0YSB7XG4gICAgY29uc3RydWN0b3IodmlydHVhbERvbSkge1xuICAgICAgICB0aGlzLnRpdGxlID0gdmlydHVhbERvbS5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlJykgfHwgdmlydHVhbERvbS5oZWFkLmFwcGVuZENoaWxkKHZpcnR1YWxEb20uY3JlYXRlRWxlbWVudCgndGl0bGUnKSk7XG5cbiAgICAgICAgdGhpcy5rZXl3b3JkcyA9IHZpcnR1YWxEb20uaGVhZC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJrZXl3b3Jkc1wiXScpO1xuICAgICAgICBpZiAoIXRoaXMua2V5d29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMua2V5d29yZHMgPSB2aXJ0dWFsRG9tLmhlYWQuYXBwZW5kQ2hpbGQodmlydHVhbERvbS5jcmVhdGVFbGVtZW50KCdtZXRhJykpO1xuICAgICAgICAgICAgdGhpcy5rZXl3b3Jkcy5zZXRBdHRyaWJ1dGUoJ25hbWUnLCAna2V5d29yZHMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSB2aXJ0dWFsRG9tLmhlYWQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiZGVzY3JpcHRpb25cIl0nKTtcbiAgICAgICAgaWYgKCF0aGlzLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gdmlydHVhbERvbS5oZWFkLmFwcGVuZENoaWxkKHZpcnR1YWxEb20uY3JlYXRlRWxlbWVudCgnbWV0YScpKTtcbiAgICAgICAgICAgIHRoaXMuZGVzY3JpcHRpb24uc2V0QXR0cmlidXRlKCduYW1lJywgJ2Rlc2NyaXB0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRNZXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGl0bGU6IHRoaXMudGl0bGUuaW5uZXJIVE1MLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24uZ2V0QXR0cmlidXRlKCdjb250ZW50JyksXG4gICAgICAgICAgICBrZXl3b3JkczogdGhpcy5rZXl3b3Jkcy5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldE1ldGEodGl0bGUsIGRlc2NyaXB0aW9uLCBrZXl3b3Jkcykge1xuICAgICAgICB0aGlzLnRpdGxlLmlubmVySFRNTCA9IHRpdGxlO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uLnNldEF0dHJpYnV0ZSgnY29udGVudCcsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5rZXl3b3Jkcy5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCBrZXl3b3Jkcyk7XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFZGl0b3JUZXh0IHtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHZpcnR1YWxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMudmlydHVhbEVsZW1lbnQgPSB2aXJ0dWFsRWxlbWVudDtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLm9uQ2xpY2soKSk7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUgPT09ICdBJyB8fFxuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUubm9kZU5hbWUgPT09ICdCVVRUT04nXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgKGUpID0+IHRoaXMub25Db250ZXh0TWVudShlKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICgpID0+IHRoaXMub25CbHVyKCkpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCAoZSkgPT4gdGhpcy5vbktleXByZXNzKGUpKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4gdGhpcy5vblRleHRFZGl0KCkpO1xuICAgIH1cblxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBvbkNvbnRleHRNZW51KGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLm9uQ2xpY2soKTtcbiAgICB9XG5cbiAgICBvbkJsdXIoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgIH1cblxuICAgIG9uS2V5cHJlc3MoZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uVGV4dEVkaXQoKSB7XG4gICAgICAgIHRoaXMudmlydHVhbEVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5lbGVtZW50LmlubmVySFRNTDtcbiAgICB9XG5cbn1cbiIsImNvbnN0IGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcbmNvbnN0IERPTUhlbHBlciA9IHJlcXVpcmUoJy4vZG9tLWhlbHBlcicpO1xuY29uc3QgRWRpdG9yVGV4dCA9IHJlcXVpcmUoJy4vZWRpdG9yLXRleHQnKTtcbmNvbnN0IEVkaXRvckltYWdlID0gcmVxdWlyZSgnLi9lZGl0b3ItaW1hZ2UnKTtcbmNvbnN0IEVkaXRvck1ldGEgPSByZXF1aXJlKCcuL2VkaXRvci1tZXRhJyk7XG5cbnJlcXVpcmUoJy4vaWZyYW1lLWxvYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFZGl0b3Ige1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaWZyYW1lJyk7XG4gICAgfVxuXG4gICAgb3BlbihwYWdlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmN1cnJlbnRfcGFnZSA9IHBhZ2U7XG5cbiAgICAgICAgYXhpb3NcbiAgICAgICAgICAgIC5nZXQoJy4uLycgKyBwYWdlICsgJz9ybmQ9JyArIE1hdGgucmFuZG9tKCkpXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiBET01IZWxwZXIucGFyc2VTdHJUb0RvbShyZXMuZGF0YSkpXG4gICAgICAgICAgICAudGhlbihET01IZWxwZXIud3JhcFRleHROb2RlcylcbiAgICAgICAgICAgIC50aGVuKERPTUhlbHBlci53cmFwSW1hZ2VzKVxuICAgICAgICAgICAgLnRoZW4oKGRvbSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmlydHVhbERvbSA9IGRvbTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKERPTUhlbHBlci5zZXJpYWxpemVEb21Ub1N0cilcbiAgICAgICAgICAgIC50aGVuKChodG1sKSA9PiBheGlvcy5wb3N0KCcuL2FwaS9zYXZlX3RlbXBfcGFnZS5waHAnLCB7IGh0bWwgfSkpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB0aGlzLmlmcmFtZS5sb2FkKCcuLi9mc2ZlcmdnZC5odG1sJykpXG4gICAgICAgICAgICAudGhlbigoaHRtbCkgPT4gYXhpb3MucG9zdCgnLi9hcGkvZGVsZXRlX3RlbXBfcGFnZS5waHAnKSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuZW5hYmxlRWRpdGluZygpKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5pbmplY3RTdHlsZXMoKSlcbiAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgIH1cblxuICAgIGVuYWJsZUVkaXRpbmcoKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHQtZWRpdG9yJykuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnbm9kZUlkJyk7XG4gICAgICAgICAgICBjb25zdCB2aXJ0dWFsRWxlbWVudCA9IHRoaXMudmlydHVhbERvbS5ib2R5LnF1ZXJ5U2VsZWN0b3IoYFtub2RlSWQ9XCIke2lkfVwiXWApO1xuICAgICAgICAgICAgbmV3IEVkaXRvclRleHQoZWxlbWVudCwgdmlydHVhbEVsZW1lbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdbZWRpdGFibGVpbWdpZF0nKS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdlZGl0YWJsZWltZ2lkJyk7XG4gICAgICAgICAgICBjb25zdCB2aXJ0dWFsRWxlbWVudCA9IHRoaXMudmlydHVhbERvbS5ib2R5LnF1ZXJ5U2VsZWN0b3IoYFtlZGl0YWJsZWltZ2lkPVwiJHtpZH1cIl1gKTtcbiAgICAgICAgICAgIG5ldyBFZGl0b3JJbWFnZShlbGVtZW50LCB2aXJ0dWFsRWxlbWVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWV0YUVkaXRvciA9IG5ldyBFZGl0b3JNZXRhKHRoaXMudmlydHVhbERvbSk7XG4gICAgfVxuXG4gICAgaW5qZWN0U3R5bGVzKCkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IHRoaXMuaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgICB0ZXh0LWVkaXRvcjpob3ZlcixcbiAgICAgICAgICAgIFtlZGl0YWJsZWltZ2lkXTpob3ZlciB7XG4gICAgICAgICAgICAgICAgb3V0bGluZTogM3B4IHNvbGlkIG9yYW5nZTtcbiAgICAgICAgICAgICAgICBvdXRsaW5lLW9mZnNldDogOHB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dC1lZGl0b3I6Zm9jdXMsXG4gICAgICAgICAgICBbZWRpdGFibGVpbWdpZF06aG92ZXIge1xuICAgICAgICAgICAgICAgIG91dGxpbmU6IDNweCBzb2xpZCBncmVlbjtcbiAgICAgICAgICAgICAgICBvdXRsaW5lLW9mZnNldDogOHB4O1xuICAgICAgICAgICAgfVxuICAgICAgICBgO1xuICAgICAgICB0aGlzLmlmcmFtZS5jb250ZW50RG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuXG4gICAgc2F2ZShvblN1Y2Nlcywgb25FcnJvcikge1xuICAgICAgICBjb25zdCBuZXdfZG9tID0gdGhpcy52aXJ0dWFsRG9tLmNsb25lTm9kZSh0aGlzLnZpcnR1YWxEb20pO1xuICAgICAgICBET01IZWxwZXIudW53cmFwVGV4dE5vZGVzKG5ld19kb20pO1xuICAgICAgICBET01IZWxwZXIudW53cmFwSW1hZ2VzKG5ld19kb20pO1xuICAgICAgICBjb25zdCBodG1sID0gRE9NSGVscGVyLnNlcmlhbGl6ZURvbVRvU3RyKG5ld19kb20pO1xuXG4gICAgICAgIGF4aW9zXG4gICAgICAgICAgICAucG9zdCgnLi9hcGkvc2F2ZV9wYWdlLnBocCcsIHsgcGFnZU5hbWU6IHRoaXMuY3VycmVudF9wYWdlLCBodG1sIH0pXG4gICAgICAgICAgICAudGhlbihvblN1Y2NlcylcbiAgICAgICAgICAgIC5jYXRjaChvbkVycm9yKTtcbiAgICB9XG5cbn1cbiIsIi8qZXNsaW50LWRpc2FibGUgKi9cbkhUTUxJRnJhbWVFbGVtZW50LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHVybCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpZnJhbWUgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSB1cmwgKyBcIj9ybmQ9XCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtYXhUaW1lID0gNjAwMDA7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSAyMDA7XG5cbiAgICBsZXQgdGltZXJDb3VudCA9IDA7XG5cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlmcmFtZSkgcmV0dXJuIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyQ291bnQrKztcbiAgICAgICAgICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnREb2N1bWVudCAmJiBpZnJhbWUuY29udGVudERvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZXJDb3VudCAqIGludGVydmFsID4gbWF4VGltZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiSWZyYW1lIGxvYWQgZmFpbCFcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghaWZyYW1lKSByZXR1cm4gY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICBpZiAoaWZyYW1lLmNvbnRlbnREb2N1bWVudCAmJiBpZnJhbWUuY29udGVudERvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWVyQ291bnQgKiBpbnRlcnZhbCA+IG1heFRpbWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJJZnJhbWUgbG9hZCBmYWlsIVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGludGVydmFsKTtcbiAgICB9XG59XG4iLCJjb25zdCBFZGl0b3IgPSByZXF1aXJlKCcuL2VkaXRvci5qcycpO1xuY29uc3QgVnVlID0gcmVxdWlyZSgndnVlJyk7XG5jb25zdCBVaWtpdCA9IHJlcXVpcmUoJ3Vpa2l0Jyk7XG5jb25zdCBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XG5cbndpbmRvdy5lZGl0b3IgPSBuZXcgRWRpdG9yKCk7XG5cbndpbmRvdy52dWUgPSBuZXcgVnVlKHtcbiAgICBlbDogJyNhcHAnLFxuICAgIGRhdGE6IHtcbiAgICAgICAgc2hvd0xvYWRlcjogdHJ1ZSxcbiAgICAgICAgcGFnZTogJ2luZGV4Lmh0bWwnLFxuICAgICAgICAncGFnZUxpc3QnOiBbXSxcbiAgICAgICAgJ2JhY2t1cExpc3QnOiBbXSxcblxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICB0aXRsZTogJycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgICAgICBrZXl3b3JkczogJydcbiAgICAgICAgfSxcblxuICAgICAgICBhdXRoOiBmYWxzZSxcbiAgICAgICAgcGFzc3dvcmQ6ICcnLFxuICAgICAgICBsb2dpbkVycm9yOiBmYWxzZSxcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgb25CdG5TYXZlKCkge1xuICAgICAgICAgICAgdGhpcy5zaG93TG9hZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHdpbmRvdy5lZGl0b3Iuc2F2ZShcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZEJhY2t1cExpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93TG9hZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIFVpa2l0Lm5vdGlmaWNhdGlvbih7bWVzc2FnZTogJ9Cj0YHQv9C10YjQvdC+0LUg0YHQvtGF0YDQsNC90LjQtdC90LjQtS4nLCBzdGF0dXM6ICdzdWNjZXNzJ30pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dMb2FkZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgVWlraXQubm90aWZpY2F0aW9uKHttZXNzYWdlOiAn0J/RgNC+0LjQt9C+0YjQu9CwINC+0YjQuNCx0LrQsCDRgdC+0YXRgNCw0L3QtdC90LjRjy4nLCBzdGF0dXM6ICdkYW5nZXInfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvcGVuUGFnZShwYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlO1xuICAgICAgICAgICAgdGhpcy5sb2FkQmFja3VwTGlzdCgpO1xuICAgICAgICAgICAgdGhpcy5zaG93TG9hZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHdpbmRvdy5lZGl0b3Iub3BlbihwYWdlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93TG9hZGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhID0gd2luZG93LmVkaXRvci5tZXRhRWRpdG9yLmdldE1ldGEoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVBhZ2VMaXN0KCkge1xuICAgICAgICAgICAgYXhpb3NcbiAgICAgICAgICAgICAgICAuZ2V0KCcuL2FwaS9wYWdlX2xpc3QucGhwJylcbiAgICAgICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWdlTGlzdCA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcblxuICAgICAgICBsb2FkQmFja3VwTGlzdCgpIHtcbiAgICAgICAgICAgIGF4aW9zXG4gICAgICAgICAgICAgICAgLmdldCgnLi9iYWNrdXBzL2JhY2t1cHMuanNvbicpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2t1cExpc3QgPSByZXNwb25zZS5kYXRhLmZpbHRlcigoYmFja3VwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJhY2t1cC5wYWdlID09PSB0aGlzLnBhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlc3RvcmVCYWNrdXAoYmFja3VwKSB7XG4gICAgICAgICAgICBVaWtpdC5tb2RhbFxuICAgICAgICAgICAgICAgIC5jb25maXJtKCfQktGLINC00LXQudGB0YLQstC40YLQtdC70YzQvdC+INGF0L7RgtC40YLQtSDQstC+0YHRgdGC0LDQvdC+0LLQuNGC0Ywg0YDQtdC30LXRgNCy0L3Rg9GOINC60L7Qv9C40Y4/Jywge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbHM6IHsgb2s6ICfQktC+0YHRgdGC0LDQvdC+0LLQuNGC0YwnLCBjYW5jZWw6ICfQntGC0LzQtdC90LAnfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dMb2FkZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhpb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC5wb3N0KCcuL2FwaS9yZXN0b3JlX2JhY2t1cC5waHAnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGUnOiBiYWNrdXAuZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncGFnZSc6IHRoaXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3BlblBhZ2UodGhpcy5wYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhcHBseU1ldGEoKSB7XG4gICAgICAgICAgICB3aW5kb3cuZWRpdG9yLm1ldGFFZGl0b3Iuc2V0TWV0YSh0aGlzLm1ldGEudGl0bGUsIHRoaXMubWV0YS5rZXl3b3JkcywgdGhpcy5tZXRhLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICBsb2dpbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhc3N3b3JkLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgICAgICBheGlvc1xuICAgICAgICAgICAgICAgICAgICAucG9zdCgnLi9hcGkvbG9naW4ucGhwJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHRoaXMucGFzc3dvcmRcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmVzLmRhdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmRhdGEuYXV0aCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxvZ291dCgpIHtcbiAgICAgICAgICAgIGF4aW9zXG4gICAgICAgICAgICAgICAgLmdldCgnLi9hcGkvbG9nX291dC5waHAnKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoJy8nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMub3BlblBhZ2UodGhpcy5wYWdlKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFnZUxpc3QoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZEJhY2t1cExpc3QoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmFibGVMb2FkZXIoKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dMb2FkZXIgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRpc2FibGVMb2FkZXIoKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dMb2FkZXIgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBlcnJvck5vdGlmaWNhdGlvbihtc2cpIHtcbiAgICAgICAgICAgIFVpa2l0Lm5vdGlmaWNhdGlvbih7bWVzc2FnZTogbXNnLCBzdGF0dXM6ICdkYW5nZXInfSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBjcmVhdGVkKCkge1xuICAgICAgICBheGlvc1xuICAgICAgICAgICAgLmdldCgnLi9hcGkvY2hlY2tfYXV0aC5waHAnKVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmF1dGggPSByZXMuZGF0YS5hdXRoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlcy5kYXRhLmF1dGggPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdXRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcbiAgICB2YXIgcmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bGxQYXRoID0gYnVpbGRGdWxsUGF0aChjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgZnVuY3Rpb24gb25sb2FkZW5kKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIXJlc3BvbnNlVHlwZSB8fCByZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCAgcmVzcG9uc2VUeXBlID09PSAnanNvbicgP1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XG4gICAgICAvLyBVc2Ugb25sb2FkZW5kIGlmIGF2YWlsYWJsZVxuICAgICAgcmVxdWVzdC5vbmxvYWRlbmQgPSBvbmxvYWRlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGUgdG8gZW11bGF0ZSBvbmxvYWRlbmRcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWFkeXN0YXRlIGhhbmRsZXIgaXMgY2FsbGluZyBiZWZvcmUgb25lcnJvciBvciBvbnRpbWVvdXQgaGFuZGxlcnMsXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcbiAgICAgICAgc2V0VGltZW91dChvbmxvYWRlbmQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYnJvd3NlciByZXF1ZXN0IGNhbmNlbGxhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIG1hbnVhbCBjYW5jZWxsYXRpb24pXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgdmFyIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnO1xuICAgICAgaWYgKGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBjb25maWcudHJhbnNpdGlvbmFsICYmIGNvbmZpZy50cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/ICdFVElNRURPVVQnIDogJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihmdWxsUGF0aCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnLndpdGhDcmVkZW50aWFscykpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gISFjb25maWcud2l0aENyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAocmVzcG9uc2VUeXBlICYmIHJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxuLy8gRXhwb3NlIGlzQXhpb3NFcnJvclxuYXhpb3MuaXNBeGlvc0Vycm9yID0gcmVxdWlyZSgnLi9oZWxwZXJzL2lzQXhpb3NFcnJvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xudmFyIHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdmFsaWRhdG9yJyk7XG5cbnZhciB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICB2YXIgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbDtcblxuICBpZiAodHJhbnNpdGlvbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyh0cmFuc2l0aW9uYWwsIHtcbiAgICAgIHNpbGVudEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4sICcxLjAuMCcpLFxuICAgICAgZm9yY2VkSlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJyksXG4gICAgICBjbGFyaWZ5VGltZW91dEVycm9yOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4sICcxLjAuMCcpXG4gICAgfSwgZmFsc2UpO1xuICB9XG5cbiAgLy8gZmlsdGVyIG91dCBza2lwcGVkIGludGVyY2VwdG9yc1xuICB2YXIgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdmFyIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHRydWU7XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGlmICh0eXBlb2YgaW50ZXJjZXB0b3IucnVuV2hlbiA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnRlcmNlcHRvci5ydW5XaGVuKGNvbmZpZykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9yLnN5bmNocm9ub3VzO1xuXG4gICAgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcHJvbWlzZTtcblxuICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xuICAgIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG5cbiAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjaGFpbiwgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4pO1xuICAgIGNoYWluID0gY2hhaW4uY29uY2F0KHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbik7XG5cbiAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG5cbiAgdmFyIG5ld0NvbmZpZyA9IGNvbmZpZztcbiAgd2hpbGUgKHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLmxlbmd0aCkge1xuICAgIHZhciBvbkZ1bGZpbGxlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdmFyIG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHRyeSB7XG4gICAgICBuZXdDb25maWcgPSBvbkZ1bGZpbGxlZChuZXdDb25maWcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBvblJlamVjdGVkKGVycm9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRyeSB7XG4gICAgcHJvbWlzZSA9IGRpc3BhdGNoUmVxdWVzdChuZXdDb25maWcpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gIH1cblxuICB3aGlsZSAocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4ocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCksIHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkLCBvcHRpb25zKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkLFxuICAgIHN5bmNocm9ub3VzOiBvcHRpb25zID8gb3B0aW9ucy5zeW5jaHJvbm91cyA6IGZhbHNlLFxuICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdkYXRhJ107XG4gIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5JywgJ3BhcmFtcyddO1xuICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgJ2Jhc2VVUkwnLCAndHJhbnNmb3JtUmVxdWVzdCcsICd0cmFuc2Zvcm1SZXNwb25zZScsICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAndGltZW91dCcsICd0aW1lb3V0TWVzc2FnZScsICd3aXRoQ3JlZGVudGlhbHMnLCAnYWRhcHRlcicsICdyZXNwb25zZVR5cGUnLCAneHNyZkNvb2tpZU5hbWUnLFxuICAgICd4c3JmSGVhZGVyTmFtZScsICdvblVwbG9hZFByb2dyZXNzJywgJ29uRG93bmxvYWRQcm9ncmVzcycsICdkZWNvbXByZXNzJyxcbiAgICAnbWF4Q29udGVudExlbmd0aCcsICdtYXhCb2R5TGVuZ3RoJywgJ21heFJlZGlyZWN0cycsICd0cmFuc3BvcnQnLCAnaHR0cEFnZW50JyxcbiAgICAnaHR0cHNBZ2VudCcsICdjYW5jZWxUb2tlbicsICdzb2NrZXRQYXRoJywgJ3Jlc3BvbnNlRW5jb2RpbmcnXG4gIF07XG4gIHZhciBkaXJlY3RNZXJnZUtleXMgPSBbJ3ZhbGlkYXRlU3RhdHVzJ107XG5cbiAgZnVuY3Rpb24gZ2V0TWVyZ2VkVmFsdWUodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAodXRpbHMuaXNQbGFpbk9iamVjdCh0YXJnZXQpICYmIHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHt9LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKCk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICB1dGlscy5mb3JFYWNoKHZhbHVlRnJvbUNvbmZpZzJLZXlzLCBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgdXRpbHMuZm9yRWFjaChkZWZhdWx0VG9Db25maWcyS2V5cywgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goZGlyZWN0TWVyZ2VLZXlzLCBmdW5jdGlvbiBtZXJnZShwcm9wKSB7XG4gICAgaWYgKHByb3AgaW4gY29uZmlnMikge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmIChwcm9wIGluIGNvbmZpZzEpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAuY29uY2F0KG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzKVxuICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpXG4gICAgLmNvbmNhdChkaXJlY3RNZXJnZUtleXMpO1xuXG4gIHZhciBvdGhlcktleXMgPSBPYmplY3RcbiAgICAua2V5cyhjb25maWcxKVxuICAgIC5jb25jYXQoT2JqZWN0LmtleXMoY29uZmlnMikpXG4gICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIG1lcmdlRGVlcFByb3BlcnRpZXMpO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIHZhciBjb250ZXh0ID0gdGhpcyB8fCBkZWZhdWx0cztcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4uY2FsbChjb250ZXh0LCBkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9jb3JlL2VuaGFuY2VFcnJvcicpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVNhZmVseShyYXdWYWx1ZSwgcGFyc2VyLCBlbmNvZGVyKSB7XG4gIGlmICh1dGlscy5pc1N0cmluZyhyYXdWYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgKHBhcnNlciB8fCBKU09OLnBhcnNlKShyYXdWYWx1ZSk7XG4gICAgICByZXR1cm4gdXRpbHMudHJpbShyYXdWYWx1ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUubmFtZSAhPT0gJ1N5bnRheEVycm9yJykge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAoZW5jb2RlciB8fCBKU09OLnN0cmluZ2lmeSkocmF3VmFsdWUpO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG5cbiAgdHJhbnNpdGlvbmFsOiB7XG4gICAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gICAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXG4gICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogZmFsc2VcbiAgfSxcblxuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdBY2NlcHQnKTtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpIHx8IChoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID09PSAnYXBwbGljYXRpb24vanNvbicpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTYWZlbHkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICB2YXIgdHJhbnNpdGlvbmFsID0gdGhpcy50cmFuc2l0aW9uYWw7XG4gICAgdmFyIHNpbGVudEpTT05QYXJzaW5nID0gdHJhbnNpdGlvbmFsICYmIHRyYW5zaXRpb25hbC5zaWxlbnRKU09OUGFyc2luZztcbiAgICB2YXIgZm9yY2VkSlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLmZvcmNlZEpTT05QYXJzaW5nO1xuICAgIHZhciBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xuXG4gICAgaWYgKHN0cmljdEpTT05QYXJzaW5nIHx8IChmb3JjZWRKU09OUGFyc2luZyAmJiB1dGlscy5pc1N0cmluZyhkYXRhKSAmJiBkYXRhLmxlbmd0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lID09PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBlbmhhbmNlRXJyb3IoZSwgdGhpcywgJ0VfSlNPTl9QQVJTRScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcbiAqXG4gKiBAcGFyYW0geyp9IHBheWxvYWQgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBeGlvc0Vycm9yKHBheWxvYWQpIHtcbiAgcmV0dXJuICh0eXBlb2YgcGF5bG9hZCA9PT0gJ29iamVjdCcpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBwa2cgPSByZXF1aXJlKCcuLy4uLy4uL3BhY2thZ2UuanNvbicpO1xuXG52YXIgdmFsaWRhdG9ycyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuWydvYmplY3QnLCAnYm9vbGVhbicsICdudW1iZXInLCAnZnVuY3Rpb24nLCAnc3RyaW5nJywgJ3N5bWJvbCddLmZvckVhY2goZnVuY3Rpb24odHlwZSwgaSkge1xuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gdHlwZSB8fCAnYScgKyAoaSA8IDEgPyAnbiAnIDogJyAnKSArIHR5cGU7XG4gIH07XG59KTtcblxudmFyIGRlcHJlY2F0ZWRXYXJuaW5ncyA9IHt9O1xudmFyIGN1cnJlbnRWZXJBcnIgPSBwa2cudmVyc2lvbi5zcGxpdCgnLicpO1xuXG4vKipcbiAqIENvbXBhcmUgcGFja2FnZSB2ZXJzaW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nP30gdGhhblZlcnNpb25cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc09sZGVyVmVyc2lvbih2ZXJzaW9uLCB0aGFuVmVyc2lvbikge1xuICB2YXIgcGtnVmVyc2lvbkFyciA9IHRoYW5WZXJzaW9uID8gdGhhblZlcnNpb24uc3BsaXQoJy4nKSA6IGN1cnJlbnRWZXJBcnI7XG4gIHZhciBkZXN0VmVyID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGlmIChwa2dWZXJzaW9uQXJyW2ldID4gZGVzdFZlcltpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChwa2dWZXJzaW9uQXJyW2ldIDwgZGVzdFZlcltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb258Ym9vbGVhbj99IHZhbGlkYXRvclxuICogQHBhcmFtIHtzdHJpbmc/fSB2ZXJzaW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICogQHJldHVybnMge2Z1bmN0aW9ufVxuICovXG52YWxpZGF0b3JzLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcbiAgdmFyIGlzRGVwcmVjYXRlZCA9IHZlcnNpb24gJiYgaXNPbGRlclZlcnNpb24odmVyc2lvbik7XG5cbiAgZnVuY3Rpb24gZm9ybWF0TWVzc2FnZShvcHQsIGRlc2MpIHtcbiAgICByZXR1cm4gJ1tBeGlvcyB2JyArIHBrZy52ZXJzaW9uICsgJ10gVHJhbnNpdGlvbmFsIG9wdGlvbiBcXCcnICsgb3B0ICsgJ1xcJycgKyBkZXNjICsgKG1lc3NhZ2UgPyAnLiAnICsgbWVzc2FnZSA6ICcnKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3B0LCBvcHRzKSB7XG4gICAgaWYgKHZhbGlkYXRvciA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihmb3JtYXRNZXNzYWdlKG9wdCwgJyBoYXMgYmVlbiByZW1vdmVkIGluICcgKyB2ZXJzaW9uKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGVwcmVjYXRlZCAmJiAhZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0pIHtcbiAgICAgIGRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdID0gdHJ1ZTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICAgb3B0LFxuICAgICAgICAgICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2JyArIHZlcnNpb24gKyAnIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlJ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBBc3NlcnQgb2JqZWN0J3MgcHJvcGVydGllcyB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtvYmplY3R9IHNjaGVtYVxuICogQHBhcmFtIHtib29sZWFuP30gYWxsb3dVbmtub3duXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9ucyhvcHRpb25zLCBzY2hlbWEsIGFsbG93VW5rbm93bikge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgdmFyIG9wdCA9IGtleXNbaV07XG4gICAgdmFyIHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbG93VW5rbm93biAhPT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgRXJyb3IoJ1Vua25vd24gb3B0aW9uICcgKyBvcHQpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPbGRlclZlcnNpb246IGlzT2xkZXJWZXJzaW9uLFxuICBhc3NlcnRPcHRpb25zOiBhc3NlcnRPcHRpb25zLFxuICB2YWxpZGF0b3JzOiB2YWxpZGF0b3JzXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbSxcbiAgc3RyaXBCT006IHN0cmlwQk9NXG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJheGlvc1wiLFxuICBcInZlcnNpb25cIjogXCIwLjIxLjRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlByb21pc2UgYmFzZWQgSFRUUCBjbGllbnQgZm9yIHRoZSBicm93c2VyIGFuZCBub2RlLmpzXCIsXG4gIFwibWFpblwiOiBcImluZGV4LmpzXCIsXG4gIFwic2NyaXB0c1wiOiB7XG4gICAgXCJ0ZXN0XCI6IFwiZ3J1bnQgdGVzdFwiLFxuICAgIFwic3RhcnRcIjogXCJub2RlIC4vc2FuZGJveC9zZXJ2ZXIuanNcIixcbiAgICBcImJ1aWxkXCI6IFwiTk9ERV9FTlY9cHJvZHVjdGlvbiBncnVudCBidWlsZFwiLFxuICAgIFwicHJldmVyc2lvblwiOiBcIm5wbSB0ZXN0XCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwibnBtIHJ1biBidWlsZCAmJiBncnVudCB2ZXJzaW9uICYmIGdpdCBhZGQgLUEgZGlzdCAmJiBnaXQgYWRkIENIQU5HRUxPRy5tZCBib3dlci5qc29uIHBhY2thZ2UuanNvblwiLFxuICAgIFwicG9zdHZlcnNpb25cIjogXCJnaXQgcHVzaCAmJiBnaXQgcHVzaCAtLXRhZ3NcIixcbiAgICBcImV4YW1wbGVzXCI6IFwibm9kZSAuL2V4YW1wbGVzL3NlcnZlci5qc1wiLFxuICAgIFwiY292ZXJhbGxzXCI6IFwiY2F0IGNvdmVyYWdlL2xjb3YuaW5mbyB8IC4vbm9kZV9tb2R1bGVzL2NvdmVyYWxscy9iaW4vY292ZXJhbGxzLmpzXCIsXG4gICAgXCJmaXhcIjogXCJlc2xpbnQgLS1maXggbGliLyoqLyouanNcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zLmdpdFwiXG4gIH0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwieGhyXCIsXG4gICAgXCJodHRwXCIsXG4gICAgXCJhamF4XCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJub2RlXCJcbiAgXSxcbiAgXCJhdXRob3JcIjogXCJNYXR0IFphYnJpc2tpZVwiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXNcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9heGlvcy1odHRwLmNvbVwiLFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJjb3ZlcmFsbHNcIjogXCJeMy4wLjBcIixcbiAgICBcImVzNi1wcm9taXNlXCI6IFwiXjQuMi40XCIsXG4gICAgXCJncnVudFwiOiBcIl4xLjMuMFwiLFxuICAgIFwiZ3J1bnQtYmFubmVyXCI6IFwiXjAuNi4wXCIsXG4gICAgXCJncnVudC1jbGlcIjogXCJeMS4yLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItY2xlYW5cIjogXCJeMS4xLjBcIixcbiAgICBcImdydW50LWNvbnRyaWItd2F0Y2hcIjogXCJeMS4wLjBcIixcbiAgICBcImdydW50LWVzbGludFwiOiBcIl4yMy4wLjBcIixcbiAgICBcImdydW50LWthcm1hXCI6IFwiXjQuMC4wXCIsXG4gICAgXCJncnVudC1tb2NoYS10ZXN0XCI6IFwiXjAuMTMuM1wiLFxuICAgIFwiZ3J1bnQtdHNcIjogXCJeNi4wLjAtYmV0YS4xOVwiLFxuICAgIFwiZ3J1bnQtd2VicGFja1wiOiBcIl40LjAuMlwiLFxuICAgIFwiaXN0YW5idWwtaW5zdHJ1bWVudGVyLWxvYWRlclwiOiBcIl4xLjAuMFwiLFxuICAgIFwiamFzbWluZS1jb3JlXCI6IFwiXjIuNC4xXCIsXG4gICAgXCJrYXJtYVwiOiBcIl42LjMuMlwiLFxuICAgIFwia2FybWEtY2hyb21lLWxhdW5jaGVyXCI6IFwiXjMuMS4wXCIsXG4gICAgXCJrYXJtYS1maXJlZm94LWxhdW5jaGVyXCI6IFwiXjIuMS4wXCIsXG4gICAgXCJrYXJtYS1qYXNtaW5lXCI6IFwiXjEuMS4xXCIsXG4gICAgXCJrYXJtYS1qYXNtaW5lLWFqYXhcIjogXCJeMC4xLjEzXCIsXG4gICAgXCJrYXJtYS1zYWZhcmktbGF1bmNoZXJcIjogXCJeMS4wLjBcIixcbiAgICBcImthcm1hLXNhdWNlLWxhdW5jaGVyXCI6IFwiXjQuMy42XCIsXG4gICAgXCJrYXJtYS1zaW5vblwiOiBcIl4xLjAuNVwiLFxuICAgIFwia2FybWEtc291cmNlbWFwLWxvYWRlclwiOiBcIl4wLjMuOFwiLFxuICAgIFwia2FybWEtd2VicGFja1wiOiBcIl40LjAuMlwiLFxuICAgIFwibG9hZC1ncnVudC10YXNrc1wiOiBcIl4zLjUuMlwiLFxuICAgIFwibWluaW1pc3RcIjogXCJeMS4yLjBcIixcbiAgICBcIm1vY2hhXCI6IFwiXjguMi4xXCIsXG4gICAgXCJzaW5vblwiOiBcIl40LjUuMFwiLFxuICAgIFwidGVyc2VyLXdlYnBhY2stcGx1Z2luXCI6IFwiXjQuMi4zXCIsXG4gICAgXCJ0eXBlc2NyaXB0XCI6IFwiXjQuMC41XCIsXG4gICAgXCJ1cmwtc2VhcmNoLXBhcmFtc1wiOiBcIl4wLjEwLjBcIixcbiAgICBcIndlYnBhY2tcIjogXCJeNC40NC4yXCIsXG4gICAgXCJ3ZWJwYWNrLWRldi1zZXJ2ZXJcIjogXCJeMy4xMS4wXCJcbiAgfSxcbiAgXCJicm93c2VyXCI6IHtcbiAgICBcIi4vbGliL2FkYXB0ZXJzL2h0dHAuanNcIjogXCIuL2xpYi9hZGFwdGVycy94aHIuanNcIlxuICB9LFxuICBcImpzZGVsaXZyXCI6IFwiZGlzdC9heGlvcy5taW4uanNcIixcbiAgXCJ1bnBrZ1wiOiBcImRpc3QvYXhpb3MubWluLmpzXCIsXG4gIFwidHlwaW5nc1wiOiBcIi4vaW5kZXguZC50c1wiLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJmb2xsb3ctcmVkaXJlY3RzXCI6IFwiXjEuMTQuMFwiXG4gIH0sXG4gIFwiYnVuZGxlc2l6ZVwiOiBbXG4gICAge1xuICAgICAgXCJwYXRoXCI6IFwiLi9kaXN0L2F4aW9zLm1pbi5qc1wiLFxuICAgICAgXCJ0aHJlc2hvbGRcIjogXCI1a0JcIlxuICAgIH1cbiAgXVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIi8qISBVSWtpdCAzLjIyLjAgfCBodHRwczovL3d3dy5nZXR1aWtpdC5jb20gfCAoYykgMjAxNCAtIDIwMjUgWU9PdGhlbWUgfCBNSVQgTGljZW5zZSAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ3Vpa2l0JywgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5VSWtpdCA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICBjb25zdCB7IGhhc093blByb3BlcnR5LCB0b1N0cmluZyB9ID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgICBmdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgICB9XG4gICAgY29uc3QgaHlwaGVuYXRlUmUgPSAvXFxCKFtBLVpdKS9nO1xuICAgIGNvbnN0IGh5cGhlbmF0ZSA9IG1lbW9pemUoKHN0cikgPT4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUmUsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgIGNvbnN0IGNhbWVsaXplUmUgPSAvLShcXHcpL2c7XG4gICAgY29uc3QgY2FtZWxpemUgPSBtZW1vaXplKFxuICAgICAgKHN0cikgPT4gKHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zbGljZSgxKSkucmVwbGFjZShjYW1lbGl6ZVJlLCAoXywgYykgPT4gYy50b1VwcGVyQ2FzZSgpKVxuICAgICk7XG4gICAgY29uc3QgdWNmaXJzdCA9IG1lbW9pemUoKHN0cikgPT4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpKTtcbiAgICBmdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gc3RyID09IG51bGwgPyB2b2lkIDAgOiBzdHIuc3RhcnRzV2l0aCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RyLCBzZWFyY2gpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IHN0ciA9PSBudWxsID8gdm9pZCAwIDogc3RyLmVuZHNXaXRoKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChzdHIsIHNlYXJjaCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluY2x1ZGVzKG9iaiwgc2VhcmNoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmouaW5jbHVkZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9iaiwgc2VhcmNoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSBhcnJheSA9PSBudWxsID8gdm9pZCAwIDogYXJyYXkuZmluZEluZGV4KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChhcnJheSwgcHJlZGljYXRlKTtcbiAgICB9XG4gICAgY29uc3QgeyBpc0FycmF5LCBmcm9tOiB0b0FycmF5IH0gPSBBcnJheTtcbiAgICBjb25zdCB7IGFzc2lnbiB9ID0gT2JqZWN0O1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzV2luZG93KG9iaikge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgb2JqID09PSBvYmoud2luZG93O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0RvY3VtZW50KG9iaikge1xuICAgICAgcmV0dXJuIG5vZGVUeXBlKG9iaikgPT09IDk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTm9kZShvYmopIHtcbiAgICAgIHJldHVybiBub2RlVHlwZShvYmopID49IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgICAgIHJldHVybiBub2RlVHlwZShvYmopID09PSAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub2RlVHlwZShvYmopIHtcbiAgICAgIHJldHVybiAhaXNXaW5kb3cob2JqKSAmJiBpc09iamVjdChvYmopICYmIG9iai5ub2RlVHlwZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc051bWVyaWModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpICYmICFpc05hTih2YWx1ZSAtIHBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgICAgIHJldHVybiAhKGlzQXJyYXkob2JqKSA/IG9iai5sZW5ndGggOiBpc09iamVjdChvYmopID8gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggOiBmYWxzZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9Cb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNCb29sZWFuKHZhbHVlKSA/IHZhbHVlIDogdmFsdWUgPT09IFwidHJ1ZVwiIHx8IHZhbHVlID09PSBcIjFcIiB8fCB2YWx1ZSA9PT0gXCJcIiA/IHRydWUgOiB2YWx1ZSA9PT0gXCJmYWxzZVwiIHx8IHZhbHVlID09PSBcIjBcIiA/IGZhbHNlIDogdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gICAgICBjb25zdCBudW1iZXIgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgcmV0dXJuIGlzTmFOKG51bWJlcikgPyBmYWxzZSA6IG51bWJlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvTm9kZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudCAmJiB0b05vZGVzKGVsZW1lbnQpWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b05vZGVzKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBpc05vZGUoZWxlbWVudCkgPyBbZWxlbWVudF0gOiBBcnJheS5mcm9tKGVsZW1lbnQgfHwgW10pLmZpbHRlcihpc05vZGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b1dpbmRvdyhlbGVtZW50KSB7XG4gICAgICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBlbGVtZW50ID0gdG9Ob2RlKGVsZW1lbnQpO1xuICAgICAgY29uc3QgZG9jdW1lbnQgPSBpc0RvY3VtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgIHJldHVybiAoZG9jdW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8IGlzT2JqZWN0KHZhbHVlKSAmJiBpc09iamVjdChvdGhlcikgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMob3RoZXIpLmxlbmd0aCAmJiBlYWNoKHZhbHVlLCAodmFsLCBrZXkpID0+IHZhbCA9PT0gb3RoZXJba2V5XSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN3YXAodmFsdWUsIGEsIGIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAoYCR7YX18JHtifWAsIFwiZ1wiKSwgKG1hdGNoKSA9PiBtYXRjaCA9PT0gYSA/IGIgOiBhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlYWNoKG9iaiwgY2IpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoZmFsc2UgPT09IGNiKG9ialtrZXldLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc29ydEJ5KGFycmF5LCBwcm9wKSB7XG4gICAgICByZXR1cm4gYXJyYXkuc2xpY2UoKS5zb3J0KFxuICAgICAgICAoeyBbcHJvcF06IHByb3BBID0gMCB9LCB7IFtwcm9wXTogcHJvcEIgPSAwIH0pID0+IHByb3BBID4gcHJvcEIgPyAxIDogcHJvcEIgPiBwcm9wQSA/IC0xIDogMFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3VtQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYXJyYXkucmVkdWNlKFxuICAgICAgICAoc3VtLCBpdGVtKSA9PiBzdW0gKyB0b0Zsb2F0KGlzRnVuY3Rpb24oaXRlcmF0ZWUpID8gaXRlcmF0ZWUoaXRlbSkgOiBpdGVtW2l0ZXJhdGVlXSksXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuaXF1ZUJ5KGFycmF5LCBwcm9wKSB7XG4gICAgICBjb25zdCBzZWVuID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIHJldHVybiBhcnJheS5maWx0ZXIoKHsgW3Byb3BdOiBjaGVjayB9KSA9PiBzZWVuLmhhcyhjaGVjaykgPyBmYWxzZSA6IHNlZW4uYWRkKGNoZWNrKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBpY2sob2JqLCBwcm9wcykge1xuICAgICAgcmV0dXJuIHByb3BzLnJlZHVjZSgocmVzLCBwcm9wKSA9PiAoeyAuLi5yZXMsIFtwcm9wXTogb2JqW3Byb3BdIH0pLCB7fSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbWluID0gMCwgbWF4ID0gMSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHRvTnVtYmVyKG51bWJlcikgfHwgMCwgbWluKSwgbWF4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0UmVjdCguLi5yZWN0cykge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgW1wiYm90dG9tXCIsIFwidG9wXCJdLFxuICAgICAgICBbXCJyaWdodFwiLCBcImxlZnRcIl1cbiAgICAgIF0uZXZlcnkoXG4gICAgICAgIChbbWluUHJvcCwgbWF4UHJvcF0pID0+IE1hdGgubWluKC4uLnJlY3RzLm1hcCgoeyBbbWluUHJvcF06IG1pbiB9KSA9PiBtaW4pKSAtIE1hdGgubWF4KC4uLnJlY3RzLm1hcCgoeyBbbWF4UHJvcF06IG1heCB9KSA9PiBtYXgpKSA+IDBcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50SW5SZWN0KHBvaW50LCByZWN0KSB7XG4gICAgICByZXR1cm4gcG9pbnQueCA8PSByZWN0LnJpZ2h0ICYmIHBvaW50LnggPj0gcmVjdC5sZWZ0ICYmIHBvaW50LnkgPD0gcmVjdC5ib3R0b20gJiYgcG9pbnQueSA+PSByZWN0LnRvcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmF0aW8oZGltZW5zaW9ucywgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IGFQcm9wID0gcHJvcCA9PT0gXCJ3aWR0aFwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFthUHJvcF06IGRpbWVuc2lvbnNbcHJvcF0gPyBNYXRoLnJvdW5kKHZhbHVlICogZGltZW5zaW9uc1thUHJvcF0gLyBkaW1lbnNpb25zW3Byb3BdKSA6IGRpbWVuc2lvbnNbYVByb3BdLFxuICAgICAgICBbcHJvcF06IHZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb250YWluKGRpbWVuc2lvbnMsIG1heERpbWVuc2lvbnMpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSB7IC4uLmRpbWVuc2lvbnMgfTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBkaW1lbnNpb25zKSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zW3Byb3BdID4gbWF4RGltZW5zaW9uc1twcm9wXSA/IHJhdGlvKGRpbWVuc2lvbnMsIHByb3AsIG1heERpbWVuc2lvbnNbcHJvcF0pIDogZGltZW5zaW9ucztcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb3ZlciQxKGRpbWVuc2lvbnMsIG1heERpbWVuc2lvbnMpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSBjb250YWluKGRpbWVuc2lvbnMsIG1heERpbWVuc2lvbnMpO1xuICAgICAgZm9yIChjb25zdCBwcm9wIGluIGRpbWVuc2lvbnMpIHtcbiAgICAgICAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnNbcHJvcF0gPCBtYXhEaW1lbnNpb25zW3Byb3BdID8gcmF0aW8oZGltZW5zaW9ucywgcHJvcCwgbWF4RGltZW5zaW9uc1twcm9wXSkgOiBkaW1lbnNpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gICAgfVxuICAgIGNvbnN0IERpbWVuc2lvbnMgPSB7IHJhdGlvLCBjb250YWluLCBjb3ZlcjogY292ZXIkMSB9O1xuICAgIGZ1bmN0aW9uIGdldEluZGV4KGksIGVsZW1lbnRzLCBjdXJyZW50ID0gMCwgZmluaXRlID0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnRzID0gdG9Ob2RlcyhlbGVtZW50cyk7XG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gZWxlbWVudHM7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBpID0gaXNOdW1lcmljKGkpID8gdG9OdW1iZXIoaSkgOiBpID09PSBcIm5leHRcIiA/IGN1cnJlbnQgKyAxIDogaSA9PT0gXCJwcmV2aW91c1wiID8gY3VycmVudCAtIDEgOiBpID09PSBcImxhc3RcIiA/IGxlbmd0aCAtIDEgOiBlbGVtZW50cy5pbmRleE9mKHRvTm9kZShpKSk7XG4gICAgICBpZiAoZmluaXRlKSB7XG4gICAgICAgIHJldHVybiBjbGFtcChpLCAwLCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIGkgJT0gbGVuZ3RoO1xuICAgICAgcmV0dXJuIGkgPCAwID8gaSArIGxlbmd0aCA6IGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgICAgIGNvbnN0IGNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXR1cm4gKGtleSwgLi4uYXJncykgPT4gY2FjaGVba2V5XSB8fCAoY2FjaGVba2V5XSA9IGZuKGtleSwgLi4uYXJncykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIC4uLmNsYXNzZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b05vZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGFkZCA9IHRvQ2xhc3NlcyhjbGFzc2VzKS5maWx0ZXIoKGNscykgPT4gIWhhc0NsYXNzKG5vZGUsIGNscykpO1xuICAgICAgICBpZiAoYWRkLmxlbmd0aCkge1xuICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCguLi5hZGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIC4uLmNsYXNzZXMpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b05vZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZSA9IHRvQ2xhc3NlcyhjbGFzc2VzKS5maWx0ZXIoKGNscykgPT4gaGFzQ2xhc3Mobm9kZSwgY2xzKSk7XG4gICAgICAgIGlmIChyZW1vdmUubGVuZ3RoKSB7XG4gICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKC4uLnJlbW92ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVwbGFjZUNsYXNzKGVsZW1lbnQsIG9sZENsYXNzLCBuZXdDbGFzcykge1xuICAgICAgbmV3Q2xhc3MgPSB0b0NsYXNzZXMobmV3Q2xhc3MpO1xuICAgICAgb2xkQ2xhc3MgPSB0b0NsYXNzZXMob2xkQ2xhc3MpLmZpbHRlcigoY2xzKSA9PiAhaW5jbHVkZXMobmV3Q2xhc3MsIGNscykpO1xuICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudCwgb2xkQ2xhc3MpO1xuICAgICAgYWRkQ2xhc3MoZWxlbWVudCwgbmV3Q2xhc3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBjbHMpIHtcbiAgICAgIFtjbHNdID0gdG9DbGFzc2VzKGNscyk7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKChub2RlKSA9PiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbHMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoZWxlbWVudCwgY2xzLCBmb3JjZSkge1xuICAgICAgY29uc3QgY2xhc3NlcyA9IHRvQ2xhc3NlcyhjbHMpO1xuICAgICAgaWYgKCFpc1VuZGVmaW5lZChmb3JjZSkpIHtcbiAgICAgICAgZm9yY2UgPSAhIWZvcmNlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRvTm9kZXMoZWxlbWVudCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBjbHMyIG9mIGNsYXNzZXMpIHtcbiAgICAgICAgICBub2RlLmNsYXNzTGlzdC50b2dnbGUoY2xzMiwgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvQ2xhc3NlcyhzdHIpIHtcbiAgICAgIHJldHVybiBzdHIgPyBpc0FycmF5KHN0cikgPyBzdHIubWFwKHRvQ2xhc3NlcykuZmxhdCgpIDogU3RyaW5nKHN0cikuc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF0dHIoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChpc09iamVjdChuYW1lKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBuYW1lKSB7XG4gICAgICAgICAgYXR0cihlbGVtZW50LCBrZXksIG5hbWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gKF9hID0gdG9Ob2RlKGVsZW1lbnQpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0b05vZGVzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoZWwsIGF0dHIoZWwsIG5hbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzQXR0cihlbGVtZW50LCBuYW1lKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKChlbGVtZW50MikgPT4gZWxlbWVudDIuaGFzQXR0cmlidXRlKG5hbWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQXR0cihlbGVtZW50LCBuYW1lKSB7XG4gICAgICB0b05vZGVzKGVsZW1lbnQpLmZvckVhY2goKGVsZW1lbnQyKSA9PiBlbGVtZW50Mi5yZW1vdmVBdHRyaWJ1dGUobmFtZSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkYXRhKGVsZW1lbnQsIGF0dHJpYnV0ZSkge1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIFthdHRyaWJ1dGUsIGBkYXRhLSR7YXR0cmlidXRlfWBdKSB7XG4gICAgICAgIGlmIChoYXNBdHRyKGVsZW1lbnQsIG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGF0dHIoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIGNvbnN0IGlzUnRsID0gaW5Ccm93c2VyICYmIGRvY3VtZW50LmRpciA9PT0gXCJydGxcIjtcbiAgICBjb25zdCBoYXNUb3VjaCA9IGluQnJvd3NlciAmJiBcIm9udG91Y2hzdGFydFwiIGluIHdpbmRvdztcbiAgICBjb25zdCBoYXNQb2ludGVyRXZlbnRzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5Qb2ludGVyRXZlbnQ7XG4gICAgY29uc3QgcG9pbnRlckRvd24kMSA9IGhhc1BvaW50ZXJFdmVudHMgPyBcInBvaW50ZXJkb3duXCIgOiBoYXNUb3VjaCA/IFwidG91Y2hzdGFydFwiIDogXCJtb3VzZWRvd25cIjtcbiAgICBjb25zdCBwb2ludGVyTW92ZSQxID0gaGFzUG9pbnRlckV2ZW50cyA/IFwicG9pbnRlcm1vdmVcIiA6IGhhc1RvdWNoID8gXCJ0b3VjaG1vdmVcIiA6IFwibW91c2Vtb3ZlXCI7XG4gICAgY29uc3QgcG9pbnRlclVwJDEgPSBoYXNQb2ludGVyRXZlbnRzID8gXCJwb2ludGVydXBcIiA6IGhhc1RvdWNoID8gXCJ0b3VjaGVuZFwiIDogXCJtb3VzZXVwXCI7XG4gICAgY29uc3QgcG9pbnRlckVudGVyID0gaGFzUG9pbnRlckV2ZW50cyA/IFwicG9pbnRlcmVudGVyXCIgOiBoYXNUb3VjaCA/IFwiXCIgOiBcIm1vdXNlZW50ZXJcIjtcbiAgICBjb25zdCBwb2ludGVyTGVhdmUgPSBoYXNQb2ludGVyRXZlbnRzID8gXCJwb2ludGVybGVhdmVcIiA6IGhhc1RvdWNoID8gXCJcIiA6IFwibW91c2VsZWF2ZVwiO1xuICAgIGNvbnN0IHBvaW50ZXJDYW5jZWwgPSBoYXNQb2ludGVyRXZlbnRzID8gXCJwb2ludGVyY2FuY2VsXCIgOiBcInRvdWNoY2FuY2VsXCI7XG5cbiAgICBjb25zdCB2b2lkRWxlbWVudHMgPSB7XG4gICAgICBhcmVhOiB0cnVlLFxuICAgICAgYmFzZTogdHJ1ZSxcbiAgICAgIGJyOiB0cnVlLFxuICAgICAgY29sOiB0cnVlLFxuICAgICAgZW1iZWQ6IHRydWUsXG4gICAgICBocjogdHJ1ZSxcbiAgICAgIGltZzogdHJ1ZSxcbiAgICAgIGlucHV0OiB0cnVlLFxuICAgICAga2V5Z2VuOiB0cnVlLFxuICAgICAgbGluazogdHJ1ZSxcbiAgICAgIG1ldGE6IHRydWUsXG4gICAgICBwYXJhbTogdHJ1ZSxcbiAgICAgIHNvdXJjZTogdHJ1ZSxcbiAgICAgIHRyYWNrOiB0cnVlLFxuICAgICAgd2JyOiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc1ZvaWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQyKSA9PiB2b2lkRWxlbWVudHNbZWxlbWVudDIudGFnTmFtZS50b0xvd2VyQ2FzZSgpXSk7XG4gICAgfVxuICAgIGNvbnN0IGlzVmlzaWJsZUZuID0gaW5Ccm93c2VyICYmIEVsZW1lbnQucHJvdG90eXBlLmNoZWNrVmlzaWJpbGl0eSB8fCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldFdpZHRoIHx8IHRoaXMub2Zmc2V0SGVpZ2h0IHx8IHRoaXMuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc1Zpc2libGUoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoZWxlbWVudCkuc29tZSgoZWxlbWVudDIpID0+IGlzVmlzaWJsZUZuLmNhbGwoZWxlbWVudDIpKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsSW5wdXQgPSBcImlucHV0LHNlbGVjdCx0ZXh0YXJlYSxidXR0b25cIjtcbiAgICBmdW5jdGlvbiBpc0lucHV0KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnQpLnNvbWUoKGVsZW1lbnQyKSA9PiBtYXRjaGVzKGVsZW1lbnQyLCBzZWxJbnB1dCkpO1xuICAgIH1cbiAgICBjb25zdCBzZWxGb2N1c2FibGUgPSBgJHtzZWxJbnB1dH0sYVtocmVmXSxbdGFiaW5kZXhdYDtcbiAgICBmdW5jdGlvbiBpc0ZvY3VzYWJsZShlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcyhlbGVtZW50LCBzZWxGb2N1c2FibGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJlbnQoZWxlbWVudCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IHRvTm9kZShlbGVtZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbHRlciQxKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5maWx0ZXIoKGVsZW1lbnQyKSA9PiBtYXRjaGVzKGVsZW1lbnQyLCBzZWxlY3RvcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdG9Ob2RlcyhlbGVtZW50KS5zb21lKChlbGVtZW50MikgPT4gZWxlbWVudDIubWF0Y2hlcyhzZWxlY3RvcikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJlbnRzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgd2hpbGUgKGVsZW1lbnQgPSBwYXJlbnQoZWxlbWVudCkpIHtcbiAgICAgICAgaWYgKCFzZWxlY3RvciB8fCBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSkge1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICAgIGVsZW1lbnQgPSB0b05vZGUoZWxlbWVudCk7XG4gICAgICBjb25zdCBjaGlsZHJlbjIgPSBlbGVtZW50ID8gdG9BcnJheShlbGVtZW50LmNoaWxkcmVuKSA6IFtdO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gZmlsdGVyJDEoY2hpbGRyZW4yLCBzZWxlY3RvcikgOiBjaGlsZHJlbjI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQsIHJlZikge1xuICAgICAgcmV0dXJuIHJlZiA/IHRvTm9kZXMoZWxlbWVudCkuaW5kZXhPZih0b05vZGUocmVmKSkgOiBjaGlsZHJlbihwYXJlbnQoZWxlbWVudCkpLmluZGV4T2YoZWxlbWVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU2FtZVNpdGVBbmNob3IoZWwpIHtcbiAgICAgIGVsID0gdG9Ob2RlKGVsKTtcbiAgICAgIHJldHVybiBlbCAmJiBbXCJvcmlnaW5cIiwgXCJwYXRobmFtZVwiLCBcInNlYXJjaFwiXS5ldmVyeSgocGFydCkgPT4gZWxbcGFydF0gPT09IGxvY2F0aW9uW3BhcnRdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VGFyZ2V0ZWRFbGVtZW50KGVsKSB7XG4gICAgICBpZiAoaXNTYW1lU2l0ZUFuY2hvcihlbCkpIHtcbiAgICAgICAgY29uc3QgeyBoYXNoLCBvd25lckRvY3VtZW50IH0gPSB0b05vZGUoZWwpO1xuICAgICAgICBjb25zdCBpZCA9IGRlY29kZVVSSUNvbXBvbmVudChoYXNoKS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGlkID8gb3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgfHwgb3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShpZClbMF0gOiBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxdWVyeShzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGZpbmQoc2VsZWN0b3IsIGdldENvbnRleHQoc2VsZWN0b3IsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXVlcnlBbGwoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiBmaW5kQWxsKHNlbGVjdG9yLCBnZXRDb250ZXh0KHNlbGVjdG9yLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0b05vZGUoX3F1ZXJ5KHNlbGVjdG9yLCB0b05vZGUoY29udGV4dCksIFwicXVlcnlTZWxlY3RvclwiKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRBbGwoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKF9xdWVyeShzZWxlY3RvciwgdG9Ob2RlKGNvbnRleHQpLCBcInF1ZXJ5U2VsZWN0b3JBbGxcIikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb250ZXh0KHNlbGVjdG9yLCBjb250ZXh0ID0gZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBpc0RvY3VtZW50KGNvbnRleHQpIHx8IHBhcnNlU2VsZWN0b3Ioc2VsZWN0b3IpLmlzQ29udGV4dFNlbGVjdG9yID8gY29udGV4dCA6IGNvbnRleHQub3duZXJEb2N1bWVudDtcbiAgICB9XG4gICAgY29uc3QgYWRkU3RhclJlID0gLyhbIT4rfi1dKSg/PVxccytbIT4rfi1dfFxccyokKS9nO1xuICAgIGNvbnN0IHNwbGl0U2VsZWN0b3JSZSA9IC8oXFwoW14pXSpcXCl8W14sXSkrL2c7XG4gICAgY29uc3QgcGFyc2VTZWxlY3RvciA9IG1lbW9pemUoKHNlbGVjdG9yKSA9PiB7XG4gICAgICBsZXQgaXNDb250ZXh0U2VsZWN0b3IgPSBmYWxzZTtcbiAgICAgIGlmICghc2VsZWN0b3IgfHwgIWlzU3RyaW5nKHNlbGVjdG9yKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBzZWxlY3RvcnMgPSBbXTtcbiAgICAgIGZvciAobGV0IHNlbCBvZiBzZWxlY3Rvci5tYXRjaChzcGxpdFNlbGVjdG9yUmUpKSB7XG4gICAgICAgIHNlbCA9IHNlbC50cmltKCkucmVwbGFjZShhZGRTdGFyUmUsIFwiJDEgKlwiKTtcbiAgICAgICAgaXNDb250ZXh0U2VsZWN0b3IgfHwgKGlzQ29udGV4dFNlbGVjdG9yID0gW1wiIVwiLCBcIitcIiwgXCJ+XCIsIFwiLVwiLCBcIj5cIl0uaW5jbHVkZXMoc2VsWzBdKSk7XG4gICAgICAgIHNlbGVjdG9ycy5wdXNoKHNlbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3JzLmpvaW4oXCIsXCIpLFxuICAgICAgICBzZWxlY3RvcnMsXG4gICAgICAgIGlzQ29udGV4dFNlbGVjdG9yXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHBvc2l0aW9uUmUgPSAvKFxcKFteKV0qXFwpfFxcUykqLztcbiAgICBjb25zdCBwYXJzZVBvc2l0aW9uU2VsZWN0b3IgPSBtZW1vaXplKChzZWxlY3RvcikgPT4ge1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5zbGljZSgxKS50cmltKCk7XG4gICAgICBjb25zdCBbcG9zaXRpb25dID0gc2VsZWN0b3IubWF0Y2gocG9zaXRpb25SZSk7XG4gICAgICByZXR1cm4gW3Bvc2l0aW9uLCBzZWxlY3Rvci5zbGljZShwb3NpdGlvbi5sZW5ndGggKyAxKV07XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gX3F1ZXJ5KHNlbGVjdG9yLCBjb250ZXh0ID0gZG9jdW1lbnQsIHF1ZXJ5Rm4pIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgaWYgKCFwYXJzZWQuaXNDb250ZXh0U2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlZC5zZWxlY3RvciA/IF9kb1F1ZXJ5KGNvbnRleHQsIHF1ZXJ5Rm4sIHBhcnNlZC5zZWxlY3RvcikgOiBzZWxlY3RvcjtcbiAgICAgIH1cbiAgICAgIHNlbGVjdG9yID0gXCJcIjtcbiAgICAgIGNvbnN0IGlzU2luZ2xlID0gcGFyc2VkLnNlbGVjdG9ycy5sZW5ndGggPT09IDE7XG4gICAgICBmb3IgKGxldCBzZWwgb2YgcGFyc2VkLnNlbGVjdG9ycykge1xuICAgICAgICBsZXQgcG9zaXRpb25TZWw7XG4gICAgICAgIGxldCBjdHggPSBjb250ZXh0O1xuICAgICAgICBpZiAoc2VsWzBdID09PSBcIiFcIikge1xuICAgICAgICAgIFtwb3NpdGlvblNlbCwgc2VsXSA9IHBhcnNlUG9zaXRpb25TZWxlY3RvcihzZWwpO1xuICAgICAgICAgIGN0eCA9IGNvbnRleHQucGFyZW50RWxlbWVudC5jbG9zZXN0KHBvc2l0aW9uU2VsKTtcbiAgICAgICAgICBpZiAoIXNlbCAmJiBpc1NpbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eCAmJiBzZWxbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgICAgW3Bvc2l0aW9uU2VsLCBzZWxdID0gcGFyc2VQb3NpdGlvblNlbGVjdG9yKHNlbCk7XG4gICAgICAgICAgY3R4ID0gY3R4LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgY3R4ID0gbWF0Y2hlcyhjdHgsIHBvc2l0aW9uU2VsKSA/IGN0eCA6IG51bGw7XG4gICAgICAgICAgaWYgKCFzZWwgJiYgaXNTaW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY3R4KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgaWYgKHNlbFswXSA9PT0gXCJ+XCIgfHwgc2VsWzBdID09PSBcIitcIikge1xuICAgICAgICAgICAgc2VsID0gYDpzY29wZSA+IDpudGgtY2hpbGQoJHtpbmRleChjdHgpICsgMX0pICR7c2VsfWA7XG4gICAgICAgICAgICBjdHggPSBjdHgucGFyZW50RWxlbWVudDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNlbFswXSA9PT0gXCI+XCIpIHtcbiAgICAgICAgICAgIHNlbCA9IGA6c2NvcGUgJHtzZWx9YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9kb1F1ZXJ5KGN0eCwgcXVlcnlGbiwgc2VsKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3RvciArPSBgJHtzZWxlY3RvciA/IFwiLFwiIDogXCJcIn0ke2RvbVBhdGgoY3R4KX0gJHtzZWx9YDtcbiAgICAgIH1cbiAgICAgIGlmICghaXNEb2N1bWVudChjb250ZXh0KSkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dC5vd25lckRvY3VtZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9kb1F1ZXJ5KGNvbnRleHQsIHF1ZXJ5Rm4sIHNlbGVjdG9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX2RvUXVlcnkoY29udGV4dCwgcXVlcnlGbiwgc2VsZWN0b3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0W3F1ZXJ5Rm5dKHNlbGVjdG9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvbVBhdGgoZWxlbWVudCkge1xuICAgICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICAgIHdoaWxlIChlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc3QgaWQgPSBhdHRyKGVsZW1lbnQsIFwiaWRcIik7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIG5hbWVzLnVuc2hpZnQoYCMke2VzY2FwZShpZCl9YCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHsgdGFnTmFtZSB9ID0gZWxlbWVudDtcbiAgICAgICAgICBpZiAodGFnTmFtZSAhPT0gXCJIVE1MXCIpIHtcbiAgICAgICAgICAgIHRhZ05hbWUgKz0gYDpudGgtY2hpbGQoJHtpbmRleChlbGVtZW50KSArIDF9KWA7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5hbWVzLnVuc2hpZnQodGFnTmFtZSk7XG4gICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hbWVzLmpvaW4oXCIgPiBcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVzY2FwZShjc3MpIHtcbiAgICAgIHJldHVybiBpc1N0cmluZyhjc3MpID8gQ1NTLmVzY2FwZShjc3MpIDogXCJcIjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbiguLi5hcmdzKSB7XG4gICAgICBsZXQgW3RhcmdldHMsIHR5cGVzLCBzZWxlY3RvciwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZV0gPSBnZXRBcmdzKGFyZ3MpO1xuICAgICAgaWYgKGxpc3RlbmVyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGlzdGVuZXIgPSBkZXRhaWwobGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHVzZUNhcHR1cmUgPT0gbnVsbCA/IHZvaWQgMCA6IHVzZUNhcHR1cmUuc2VsZikge1xuICAgICAgICBsaXN0ZW5lciA9IHNlbGZGaWx0ZXIobGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIGxpc3RlbmVyID0gZGVsZWdhdGUoc2VsZWN0b3IsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4gb2ZmKHRhcmdldHMsIHR5cGVzLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9mZiguLi5hcmdzKSB7XG4gICAgICBsZXQgW3RhcmdldHMsIHR5cGVzLCAsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2VdID0gZ2V0QXJncyhhcmdzKTtcbiAgICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uY2UoLi4uYXJncykge1xuICAgICAgY29uc3QgW2VsZW1lbnQsIHR5cGVzLCBzZWxlY3RvciwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZSwgY29uZGl0aW9uXSA9IGdldEFyZ3MoYXJncyk7XG4gICAgICBjb25zdCBvZmYyID0gb24oXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIHR5cGVzLFxuICAgICAgICBzZWxlY3RvcixcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSAhY29uZGl0aW9uIHx8IGNvbmRpdGlvbihlKTtcbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICBvZmYyKCk7XG4gICAgICAgICAgICBsaXN0ZW5lcihlLCByZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXNlQ2FwdHVyZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBvZmYyO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmlnZ2VyKHRhcmdldHMsIGV2ZW50LCBkZXRhaWwyKSB7XG4gICAgICByZXR1cm4gdG9FdmVudFRhcmdldHModGFyZ2V0cykuZXZlcnkoXG4gICAgICAgICh0YXJnZXQpID0+IHRhcmdldC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlLCBkZXRhaWwyKSlcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGUsIGJ1YmJsZXMgPSB0cnVlLCBjYW5jZWxhYmxlID0gZmFsc2UsIGRldGFpbDIpIHtcbiAgICAgIGlmIChpc1N0cmluZyhlKSkge1xuICAgICAgICBlID0gbmV3IEN1c3RvbUV2ZW50KGUsIHsgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsOiBkZXRhaWwyIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEFyZ3MoYXJncykge1xuICAgICAgYXJnc1swXSA9IHRvRXZlbnRUYXJnZXRzKGFyZ3NbMF0pO1xuICAgICAgaWYgKGlzU3RyaW5nKGFyZ3NbMV0pKSB7XG4gICAgICAgIGFyZ3NbMV0gPSBhcmdzWzFdLnNwbGl0KFwiIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZ3NbMl0pKSB7XG4gICAgICAgIGFyZ3Muc3BsaWNlKDIsIDAsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWxlZ2F0ZShzZWxlY3RvciwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gc2VsZWN0b3JbMF0gPT09IFwiPlwiID8gZmluZEFsbChzZWxlY3RvciwgZS5jdXJyZW50VGFyZ2V0KS5yZXZlcnNlKCkuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudC5jb250YWlucyhlLnRhcmdldCkpIDogZS50YXJnZXQuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgZS5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgIGRlbGV0ZSBlLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRldGFpbChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIChlKSA9PiBpc0FycmF5KGUuZGV0YWlsKSA/IGxpc3RlbmVyKGUsIC4uLmUuZGV0YWlsKSA6IGxpc3RlbmVyKGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZWxmRmlsdGVyKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fCBlLnRhcmdldCA9PT0gZS5jdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmNhbGwobnVsbCwgZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQodGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0ICYmIFwiYWRkRXZlbnRMaXN0ZW5lclwiIGluIHRhcmdldDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9FdmVudFRhcmdldCh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBpc0V2ZW50VGFyZ2V0KHRhcmdldCkgPyB0YXJnZXQgOiB0b05vZGUodGFyZ2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9FdmVudFRhcmdldHModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheSh0YXJnZXQpID8gdGFyZ2V0Lm1hcCh0b0V2ZW50VGFyZ2V0KS5maWx0ZXIoQm9vbGVhbikgOiBpc1N0cmluZyh0YXJnZXQpID8gZmluZEFsbCh0YXJnZXQpIDogaXNFdmVudFRhcmdldCh0YXJnZXQpID8gW3RhcmdldF0gOiB0b05vZGVzKHRhcmdldCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVG91Y2goZSkge1xuICAgICAgcmV0dXJuIGUucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCAhIWUudG91Y2hlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0RXZlbnRQb3MoZSkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHsgY2xpZW50WDogeCwgY2xpZW50WTogeSB9ID0gKChfYSA9IGUudG91Y2hlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzBdKSB8fCAoKF9iID0gZS5jaGFuZ2VkVG91Y2hlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iWzBdKSB8fCBlO1xuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH1cblxuICAgIGNvbnN0IGNzc051bWJlciA9IHtcbiAgICAgIFwiYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudFwiOiB0cnVlLFxuICAgICAgXCJjb2x1bW4tY291bnRcIjogdHJ1ZSxcbiAgICAgIFwiZmlsbC1vcGFjaXR5XCI6IHRydWUsXG4gICAgICBcImZsZXgtZ3Jvd1wiOiB0cnVlLFxuICAgICAgXCJmbGV4LXNocmlua1wiOiB0cnVlLFxuICAgICAgXCJmb250LXdlaWdodFwiOiB0cnVlLFxuICAgICAgXCJsaW5lLWhlaWdodFwiOiB0cnVlLFxuICAgICAgb3BhY2l0eTogdHJ1ZSxcbiAgICAgIG9yZGVyOiB0cnVlLFxuICAgICAgb3JwaGFuczogdHJ1ZSxcbiAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiOiB0cnVlLFxuICAgICAgXCJzdHJva2UtZGFzaG9mZnNldFwiOiB0cnVlLFxuICAgICAgd2lkb3dzOiB0cnVlLFxuICAgICAgXCJ6LWluZGV4XCI6IHRydWUsXG4gICAgICB6b29tOiB0cnVlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBjc3MoZWxlbWVudCwgcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eSkge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSB0b05vZGVzKGVsZW1lbnQpO1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50MiBvZiBlbGVtZW50cykge1xuICAgICAgICBpZiAoaXNTdHJpbmcocHJvcGVydHkpKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBwcm9wTmFtZShwcm9wZXJ0eSk7XG4gICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudDIpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50Mi5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgIGlzTnVtZXJpYyh2YWx1ZSkgJiYgIWNzc051bWJlcltwcm9wZXJ0eV0gPyBgJHt2YWx1ZX1weGAgOiB2YWx1ZSB8fCBpc051bWJlcih2YWx1ZSkgPyB2YWx1ZSA6IFwiXCIsXG4gICAgICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHByb3BlcnR5KSkge1xuICAgICAgICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICBwcm9wc1twcm9wXSA9IGNzcyhlbGVtZW50MiwgcHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9wcztcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydHkpIHtcbiAgICAgICAgICAgIGNzcyhlbGVtZW50MiwgcHJvcCwgcHJvcGVydHlbcHJvcF0sIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50c1swXTtcbiAgICB9XG4gICAgY29uc3QgcHJvcE5hbWUgPSBtZW1vaXplKChuYW1lKSA9PiB7XG4gICAgICBpZiAoc3RhcnRzV2l0aChuYW1lLCBcIi0tXCIpKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgICAgbmFtZSA9IGh5cGhlbmF0ZShuYW1lKTtcbiAgICAgIGNvbnN0IHsgc3R5bGUgfSA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIGlmIChuYW1lIGluIHN0eWxlKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBwcmVmaXggb2YgW1wid2Via2l0XCIsIFwibW96XCJdKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeGVkTmFtZSA9IGAtJHtwcmVmaXh9LSR7bmFtZX1gO1xuICAgICAgICBpZiAocHJlZml4ZWROYW1lIGluIHN0eWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHByZWZpeGVkTmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgY2xzVHJhbnNpdGlvbiA9IFwidWstdHJhbnNpdGlvblwiO1xuICAgIGNvbnN0IHRyYW5zaXRpb25FbmQgPSBcInRyYW5zaXRpb25lbmRcIjtcbiAgICBjb25zdCB0cmFuc2l0aW9uQ2FuY2VsZWQgPSBcInRyYW5zaXRpb25jYW5jZWxlZFwiO1xuICAgIGZ1bmN0aW9uIHRyYW5zaXRpb24kMShlbGVtZW50LCBwcm9wcywgZHVyYXRpb24gPSA0MDAsIHRpbWluZyA9IFwibGluZWFyXCIpIHtcbiAgICAgIGR1cmF0aW9uID0gTWF0aC5yb3VuZChkdXJhdGlvbik7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKFxuICAgICAgICAgIChlbGVtZW50MikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgICAgIGNzcyhlbGVtZW50MiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdHJpZ2dlcihlbGVtZW50MiwgdHJhbnNpdGlvbkVuZCksIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgICAgIGVsZW1lbnQyLFxuICAgICAgICAgICAgICBbdHJhbnNpdGlvbkVuZCwgdHJhbnNpdGlvbkNhbmNlbGVkXSxcbiAgICAgICAgICAgICAgKHsgdHlwZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtZW50MiwgY2xzVHJhbnNpdGlvbik7XG4gICAgICAgICAgICAgICAgY3NzKGVsZW1lbnQyLCB7XG4gICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IFwiXCIsXG4gICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IFwiXCIsXG4gICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IFwiXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0eXBlID09PSB0cmFuc2l0aW9uQ2FuY2VsZWQgPyByZWplY3QoKSA6IHJlc29sdmUoZWxlbWVudDIpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7IHNlbGY6IHRydWUgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFkZENsYXNzKGVsZW1lbnQyLCBjbHNUcmFuc2l0aW9uKTtcbiAgICAgICAgICAgIGNzcyhlbGVtZW50Miwge1xuICAgICAgICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKHByb3BzKS5tYXAocHJvcE5hbWUpLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2R1cmF0aW9ufW1zYCxcbiAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiB0aW1pbmcsXG4gICAgICAgICAgICAgIC4uLnByb3BzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBUcmFuc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IHRyYW5zaXRpb24kMSxcbiAgICAgIGFzeW5jIHN0b3AoZWxlbWVudCkge1xuICAgICAgICB0cmlnZ2VyKGVsZW1lbnQsIHRyYW5zaXRpb25FbmQpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBjYW5jZWwoZWxlbWVudCkge1xuICAgICAgICB0cmlnZ2VyKGVsZW1lbnQsIHRyYW5zaXRpb25DYW5jZWxlZCk7XG4gICAgICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfSxcbiAgICAgIGluUHJvZ3Jlc3MoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gaGFzQ2xhc3MoZWxlbWVudCwgY2xzVHJhbnNpdGlvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbHNBbmltYXRpb24gPSBcInVrLWFuaW1hdGlvblwiO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuZCA9IFwiYW5pbWF0aW9uZW5kXCI7XG4gICAgY29uc3QgYW5pbWF0aW9uQ2FuY2VsZWQgPSBcImFuaW1hdGlvbmNhbmNlbGVkXCI7XG4gICAgZnVuY3Rpb24gYW5pbWF0ZSQyKGVsZW1lbnQsIGFuaW1hdGlvbiwgZHVyYXRpb24gPSAyMDAsIG9yaWdpbiwgb3V0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKFxuICAgICAgICAgIChlbGVtZW50MikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhhc0NsYXNzKGVsZW1lbnQyLCBjbHNBbmltYXRpb24pKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXIoZWxlbWVudDIsIGFuaW1hdGlvbkNhbmNlbGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbXG4gICAgICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgY2xzQW5pbWF0aW9uLFxuICAgICAgICAgICAgICBgJHtjbHNBbmltYXRpb259LSR7b3V0ID8gXCJsZWF2ZVwiIDogXCJlbnRlclwifWAsXG4gICAgICAgICAgICAgIG9yaWdpbiAmJiBgdWstdHJhbnNmb3JtLW9yaWdpbi0ke29yaWdpbn1gLFxuICAgICAgICAgICAgICBvdXQgJiYgYCR7Y2xzQW5pbWF0aW9ufS1yZXZlcnNlYFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0cmlnZ2VyKGVsZW1lbnQyLCBhbmltYXRpb25FbmQpLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgICBlbGVtZW50MixcbiAgICAgICAgICAgICAgW2FuaW1hdGlvbkVuZCwgYW5pbWF0aW9uQ2FuY2VsZWRdLFxuICAgICAgICAgICAgICAoeyB0eXBlIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHR5cGUgPT09IGFuaW1hdGlvbkNhbmNlbGVkID8gcmVqZWN0KCkgOiByZXNvbHZlKGVsZW1lbnQyKTtcbiAgICAgICAgICAgICAgICBjc3MoZWxlbWVudDIsIFwiYW5pbWF0aW9uRHVyYXRpb25cIiwgXCJcIik7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxlbWVudDIsIGNsYXNzZXMpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7IHNlbGY6IHRydWUgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNzcyhlbGVtZW50MiwgXCJhbmltYXRpb25EdXJhdGlvblwiLCBgJHtkdXJhdGlvbn1tc2ApO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZWxlbWVudDIsIGNsYXNzZXMpO1xuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IEFuaW1hdGlvbiA9IHtcbiAgICAgIGluOiBhbmltYXRlJDIsXG4gICAgICBvdXQoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRlJDIoZWxlbWVudCwgYW5pbWF0aW9uLCBkdXJhdGlvbiwgb3JpZ2luLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBpblByb2dyZXNzKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGhhc0NsYXNzKGVsZW1lbnQsIGNsc0FuaW1hdGlvbik7XG4gICAgICB9LFxuICAgICAgY2FuY2VsKGVsZW1lbnQpIHtcbiAgICAgICAgdHJpZ2dlcihlbGVtZW50LCBhbmltYXRpb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlYWR5KGZuKSB7XG4gICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb25jZShkb2N1bWVudCwgXCJET01Db250ZW50TG9hZGVkXCIsIGZuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNUYWcoZWxlbWVudCwgLi4udGFnTmFtZXMpIHtcbiAgICAgIHJldHVybiB0YWdOYW1lcy5zb21lKCh0YWdOYW1lKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBlbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBlbGVtZW50LnRhZ05hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSA9PT0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5KGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh0bWwocGFyZW50MiwgaHRtbDIpIHtcbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZChodG1sMikgPyAkKHBhcmVudDIpLmlubmVySFRNTCA6IGFwcGVuZChlbXB0eShwYXJlbnQyKSwgaHRtbDIpO1xuICAgIH1cbiAgICBjb25zdCBwcmVwZW5kID0gYXBwbHlGbihcInByZXBlbmRcIik7XG4gICAgY29uc3QgYXBwZW5kID0gYXBwbHlGbihcImFwcGVuZFwiKTtcbiAgICBjb25zdCBiZWZvcmUgPSBhcHBseUZuKFwiYmVmb3JlXCIpO1xuICAgIGNvbnN0IGFmdGVyID0gYXBwbHlGbihcImFmdGVyXCIpO1xuICAgIGZ1bmN0aW9uIGFwcGx5Rm4oZm4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihyZWYsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBub2RlcyA9IHRvTm9kZXMoaXNTdHJpbmcoZWxlbWVudCkgPyBmcmFnbWVudChlbGVtZW50KSA6IGVsZW1lbnQpO1xuICAgICAgICAoX2EgPSAkKHJlZikpID09IG51bGwgPyB2b2lkIDAgOiBfYVtmbl0oLi4ubm9kZXMpO1xuICAgICAgICByZXR1cm4gdW53cmFwU2luZ2xlKG5vZGVzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZSQxKGVsZW1lbnQpIHtcbiAgICAgIHRvTm9kZXMoZWxlbWVudCkuZm9yRWFjaCgoZWxlbWVudDIpID0+IGVsZW1lbnQyLnJlbW92ZSgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JhcEFsbChlbGVtZW50LCBzdHJ1Y3R1cmUpIHtcbiAgICAgIHN0cnVjdHVyZSA9IHRvTm9kZShiZWZvcmUoZWxlbWVudCwgc3RydWN0dXJlKSk7XG4gICAgICB3aGlsZSAoc3RydWN0dXJlLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgIHN0cnVjdHVyZSA9IHN0cnVjdHVyZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIH1cbiAgICAgIGFwcGVuZChzdHJ1Y3R1cmUsIGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd3JhcElubmVyKGVsZW1lbnQsIHN0cnVjdHVyZSkge1xuICAgICAgcmV0dXJuIHRvTm9kZXMoXG4gICAgICAgIHRvTm9kZXMoZWxlbWVudCkubWFwKFxuICAgICAgICAgIChlbGVtZW50MikgPT4gZWxlbWVudDIuaGFzQ2hpbGROb2RlcygpID8gd3JhcEFsbCh0b0FycmF5KGVsZW1lbnQyLmNoaWxkTm9kZXMpLCBzdHJ1Y3R1cmUpIDogYXBwZW5kKGVsZW1lbnQyLCBzdHJ1Y3R1cmUpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud3JhcChlbGVtZW50KSB7XG4gICAgICB0b05vZGVzKGVsZW1lbnQpLm1hcChwYXJlbnQpLmZpbHRlcigodmFsdWUsIGluZGV4LCBzZWxmKSA9PiBzZWxmLmluZGV4T2YodmFsdWUpID09PSBpbmRleCkuZm9yRWFjaCgocGFyZW50MikgPT4gcGFyZW50Mi5yZXBsYWNlV2l0aCguLi5wYXJlbnQyLmNoaWxkTm9kZXMpKTtcbiAgICB9XG4gICAgY29uc3Qgc2luZ2xlVGFnUmUgPSAvXjwoXFx3KylcXHMqXFwvPz4oPzo8XFwvXFwxPik/JC87XG4gICAgZnVuY3Rpb24gZnJhZ21lbnQoaHRtbDIpIHtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBzaW5nbGVUYWdSZS5leGVjKGh0bWwyKTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG1hdGNoZXNbMV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGh0bWwyLnRyaW0oKTtcbiAgICAgIHJldHVybiB1bndyYXBTaW5nbGUoY29udGFpbmVyLmNvbnRlbnQuY2hpbGROb2Rlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVud3JhcFNpbmdsZShub2Rlcykge1xuICAgICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDEgPyBub2RlcyA6IG5vZGVzWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseShub2RlLCBmbikge1xuICAgICAgaWYgKCFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm4obm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGFwcGx5KG5vZGUsIGZuKTtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiAkKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gaXNIdG1sKHNlbGVjdG9yKSA/IHRvTm9kZShmcmFnbWVudChzZWxlY3RvcikpIDogZmluZChzZWxlY3RvciwgY29udGV4dCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uICQkKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gaXNIdG1sKHNlbGVjdG9yKSA/IHRvTm9kZXMoZnJhZ21lbnQoc2VsZWN0b3IpKSA6IGZpbmRBbGwoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0h0bWwoc3RyKSB7XG4gICAgICByZXR1cm4gaXNTdHJpbmcoc3RyKSAmJiBzdGFydHNXaXRoKHN0ci50cmltKCksIFwiPFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJzJDEgPSB7XG4gICAgICB3aWR0aDogW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICAgICAgaGVpZ2h0OiBbXCJ0b3BcIiwgXCJib3R0b21cIl1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGRpbWVuc2lvbnMkMShlbGVtZW50KSB7XG4gICAgICBjb25zdCByZWN0ID0gaXNFbGVtZW50KGVsZW1lbnQpID8gdG9Ob2RlKGVsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogeyBoZWlnaHQ6IGhlaWdodChlbGVtZW50KSwgd2lkdGg6IHdpZHRoKGVsZW1lbnQpLCB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICAgIGJvdHRvbTogcmVjdC50b3AgKyByZWN0LmhlaWdodCxcbiAgICAgICAgcmlnaHQ6IHJlY3QubGVmdCArIHJlY3Qud2lkdGhcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9mZnNldChlbGVtZW50LCBjb29yZGluYXRlcykge1xuICAgICAgaWYgKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIGNzcyhlbGVtZW50LCB7IGxlZnQ6IDAsIHRvcDogMCB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnJlbnRPZmZzZXQgPSBkaW1lbnNpb25zJDEoZWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBjb25zdCB7IHNjcm9sbFksIHNjcm9sbFggfSA9IHRvV2luZG93KGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBvZmZzZXRCeSA9IHsgaGVpZ2h0OiBzY3JvbGxZLCB3aWR0aDogc2Nyb2xsWCB9O1xuICAgICAgICBmb3IgKGNvbnN0IGRpciBpbiBkaXJzJDEpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgZGlycyQxW2Rpcl0pIHtcbiAgICAgICAgICAgIGN1cnJlbnRPZmZzZXRbcHJvcF0gKz0gb2Zmc2V0QnlbZGlyXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPZmZzZXQ7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgW1wibGVmdFwiLCBcInRvcFwiXSkge1xuICAgICAgICBjc3MoZWxlbWVudCwgcHJvcCwgY29vcmRpbmF0ZXNbcHJvcF0gLSBjdXJyZW50T2Zmc2V0W3Byb3BdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9zaXRpb24oZWxlbWVudCkge1xuICAgICAgbGV0IHsgdG9wLCBsZWZ0IH0gPSBvZmZzZXQoZWxlbWVudCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bmVyRG9jdW1lbnQ6IHsgYm9keSwgZG9jdW1lbnRFbGVtZW50IH0sXG4gICAgICAgIG9mZnNldFBhcmVudFxuICAgICAgfSA9IHRvTm9kZShlbGVtZW50KTtcbiAgICAgIGxldCBwYXJlbnQgPSBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuICAgICAgd2hpbGUgKHBhcmVudCAmJiAocGFyZW50ID09PSBib2R5IHx8IHBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50KSAmJiBjc3MocGFyZW50LCBcInBvc2l0aW9uXCIpID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgaWYgKGlzRWxlbWVudChwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE9mZnNldCA9IG9mZnNldChwYXJlbnQpO1xuICAgICAgICB0b3AgLT0gcGFyZW50T2Zmc2V0LnRvcCArIHRvRmxvYXQoY3NzKHBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiKSk7XG4gICAgICAgIGxlZnQgLT0gcGFyZW50T2Zmc2V0LmxlZnQgKyB0b0Zsb2F0KGNzcyhwYXJlbnQsIFwiYm9yZGVyTGVmdFdpZHRoXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wIC0gdG9GbG9hdChjc3MoZWxlbWVudCwgXCJtYXJnaW5Ub3BcIikpLFxuICAgICAgICBsZWZ0OiBsZWZ0IC0gdG9GbG9hdChjc3MoZWxlbWVudCwgXCJtYXJnaW5MZWZ0XCIpKVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2Zmc2V0UG9zaXRpb24oZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgICAgIGNvbnN0IG9mZnNldDIgPSBbZWxlbWVudC5vZmZzZXRUb3AsIGVsZW1lbnQub2Zmc2V0TGVmdF07XG4gICAgICB3aGlsZSAoZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgIG9mZnNldDJbMF0gKz0gZWxlbWVudC5vZmZzZXRUb3AgKyB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcImJvcmRlclRvcFdpZHRoXCIpKTtcbiAgICAgICAgb2Zmc2V0MlsxXSArPSBlbGVtZW50Lm9mZnNldExlZnQgKyB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcImJvcmRlckxlZnRXaWR0aFwiKSk7XG4gICAgICAgIGlmIChjc3MoZWxlbWVudCwgXCJwb3NpdGlvblwiKSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgY29uc3Qgd2luID0gdG9XaW5kb3coZWxlbWVudCk7XG4gICAgICAgICAgb2Zmc2V0MlswXSArPSB3aW4uc2Nyb2xsWTtcbiAgICAgICAgICBvZmZzZXQyWzFdICs9IHdpbi5zY3JvbGxYO1xuICAgICAgICAgIHJldHVybiBvZmZzZXQyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0MjtcbiAgICB9XG4gICAgY29uc3QgaGVpZ2h0ID0gZGltZW5zaW9uKFwiaGVpZ2h0XCIpO1xuICAgIGNvbnN0IHdpZHRoID0gZGltZW5zaW9uKFwid2lkdGhcIik7XG4gICAgZnVuY3Rpb24gZGltZW5zaW9uKHByb3ApIHtcbiAgICAgIGNvbnN0IHByb3BOYW1lID0gdWNmaXJzdChwcm9wKTtcbiAgICAgIHJldHVybiAoZWxlbWVudCwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgIGlmIChpc1dpbmRvdyhlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRbYGlubmVyJHtwcm9wTmFtZX1gXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRG9jdW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGVsZW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGRvY1tgb2Zmc2V0JHtwcm9wTmFtZX1gXSwgZG9jW2BzY3JvbGwke3Byb3BOYW1lfWBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudCA9IHRvTm9kZShlbGVtZW50KTtcbiAgICAgICAgICB2YWx1ZSA9IGNzcyhlbGVtZW50LCBwcm9wKTtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID09PSBcImF1dG9cIiA/IGVsZW1lbnRbYG9mZnNldCR7cHJvcE5hbWV9YF0gOiB0b0Zsb2F0KHZhbHVlKSB8fCAwO1xuICAgICAgICAgIHJldHVybiB2YWx1ZSAtIGJveE1vZGVsQWRqdXN0KGVsZW1lbnQsIHByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjc3MoXG4gICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgcHJvcCxcbiAgICAgICAgICAgICF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCA/IFwiXCIgOiArdmFsdWUgKyBib3hNb2RlbEFkanVzdChlbGVtZW50LCBwcm9wKSArIFwicHhcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0KGVsZW1lbnQsIHByb3AsIHNpemluZyA9IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgICByZXR1cm4gY3NzKGVsZW1lbnQsIFwiYm94U2l6aW5nXCIpID09PSBzaXppbmcgPyBzdW1CeShcbiAgICAgICAgZGlycyQxW3Byb3BdLFxuICAgICAgICAocHJvcDIpID0+IHRvRmxvYXQoY3NzKGVsZW1lbnQsIGBwYWRkaW5nLSR7cHJvcDJ9YCkpICsgdG9GbG9hdChjc3MoZWxlbWVudCwgYGJvcmRlci0ke3Byb3AyfS13aWR0aGApKVxuICAgICAgKSA6IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsaXBQb3NpdGlvbihwb3MpIHtcbiAgICAgIGZvciAoY29uc3QgZGlyIGluIGRpcnMkMSkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gZGlycyQxW2Rpcl0pIHtcbiAgICAgICAgICBpZiAoZGlycyQxW2Rpcl1baV0gPT09IHBvcykge1xuICAgICAgICAgICAgcmV0dXJuIGRpcnMkMVtkaXJdWzEgLSBpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvUHgodmFsdWUsIHByb3BlcnR5ID0gXCJ3aWR0aFwiLCBlbGVtZW50ID0gd2luZG93LCBvZmZzZXREaW0gPSBmYWxzZSkge1xuICAgICAgaWYgKCFpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRvRmxvYXQodmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN1bUJ5KHBhcnNlQ2FsYyh2YWx1ZSksICh2YWx1ZTIpID0+IHtcbiAgICAgICAgY29uc3QgdW5pdCA9IHBhcnNlVW5pdCh2YWx1ZTIpO1xuICAgICAgICByZXR1cm4gdW5pdCA/IHBlcmNlbnQoXG4gICAgICAgICAgdW5pdCA9PT0gXCJ2aFwiID8gZ2V0Vmlld3BvcnRIZWlnaHQoKSA6IHVuaXQgPT09IFwidndcIiA/IHdpZHRoKHRvV2luZG93KGVsZW1lbnQpKSA6IG9mZnNldERpbSA/IGVsZW1lbnRbYG9mZnNldCR7dWNmaXJzdChwcm9wZXJ0eSl9YF0gOiBkaW1lbnNpb25zJDEoZWxlbWVudClbcHJvcGVydHldLFxuICAgICAgICAgIHZhbHVlMlxuICAgICAgICApIDogdmFsdWUyO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNhbGNSZSA9IC8tP1xcZCsoPzpcXC5cXGQrKT8oPzp2W3doXXwlfHB4KT8vZztcbiAgICBjb25zdCBwYXJzZUNhbGMgPSBtZW1vaXplKChjYWxjKSA9PiBjYWxjLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzL2csIFwiXCIpLm1hdGNoKGNhbGNSZSkgfHwgW10pO1xuICAgIGNvbnN0IHVuaXRSZSQxID0gLyg/OnZbaHddfCUpJC87XG4gICAgY29uc3QgcGFyc2VVbml0ID0gbWVtb2l6ZSgoc3RyKSA9PiAoc3RyLm1hdGNoKHVuaXRSZSQxKSB8fCBbXSlbMF0pO1xuICAgIGZ1bmN0aW9uIHBlcmNlbnQoYmFzZSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBiYXNlICogdG9GbG9hdCh2YWx1ZSkgLyAxMDA7XG4gICAgfVxuICAgIGxldCB2aDtcbiAgICBsZXQgdmhFbDtcbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydEhlaWdodCgpIHtcbiAgICAgIGlmICh2aCkge1xuICAgICAgICByZXR1cm4gdmg7XG4gICAgICB9XG4gICAgICBpZiAoIXZoRWwpIHtcbiAgICAgICAgdmhFbCA9ICQoXCI8ZGl2PlwiKTtcbiAgICAgICAgY3NzKHZoRWwsIHtcbiAgICAgICAgICBoZWlnaHQ6IFwiMTAwdmhcIixcbiAgICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiXG4gICAgICAgIH0pO1xuICAgICAgICBvbih3aW5kb3csIFwicmVzaXplXCIsICgpID0+IHZoID0gbnVsbCk7XG4gICAgICB9XG4gICAgICBhcHBlbmQoZG9jdW1lbnQuYm9keSwgdmhFbCk7XG4gICAgICB2aCA9IHZoRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgcmVtb3ZlJDEodmhFbCk7XG4gICAgICByZXR1cm4gdmg7XG4gICAgfVxuXG4gICAgY29uc3QgZmFzdGRvbSA9IHsgcmVhZCwgd3JpdGUsIGNsZWFyLCBmbHVzaCB9O1xuICAgIGNvbnN0IHJlYWRzID0gW107XG4gICAgY29uc3Qgd3JpdGVzID0gW107XG4gICAgZnVuY3Rpb24gcmVhZCh0YXNrKSB7XG4gICAgICByZWFkcy5wdXNoKHRhc2spO1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyaXRlKHRhc2spIHtcbiAgICAgIHdyaXRlcy5wdXNoKHRhc2spO1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyKHRhc2spIHtcbiAgICAgIHJlbW92ZShyZWFkcywgdGFzayk7XG4gICAgICByZW1vdmUod3JpdGVzLCB0YXNrKTtcbiAgICB9XG4gICAgbGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgcnVuVGFza3MocmVhZHMpO1xuICAgICAgcnVuVGFza3Mod3JpdGVzLnNwbGljZSgwKSk7XG4gICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIGlmIChyZWFkcy5sZW5ndGggfHwgd3JpdGVzLmxlbmd0aCkge1xuICAgICAgICBzY2hlZHVsZUZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjaGVkdWxlRmx1c2goKSB7XG4gICAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhmbHVzaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJ1blRhc2tzKHRhc2tzKSB7XG4gICAgICBsZXQgdGFzaztcbiAgICAgIHdoaWxlICh0YXNrID0gdGFza3Muc2hpZnQoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBpdGVtKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGFycmF5LmluZGV4T2YoaXRlbSk7XG4gICAgICByZXR1cm4gfmluZGV4ICYmIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgY2xhc3MgTW91c2VUcmFja2VyIHtcbiAgICAgIGluaXQoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gW107XG4gICAgICAgIGxldCBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy51bmJpbmQgPSBvbihkb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgKGUpID0+IHBvc2l0aW9uID0gZ2V0RXZlbnRQb3MoZSkpO1xuICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wb3NpdGlvbnMucHVzaChwb3NpdGlvbik7XG4gICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25zLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCA1MCk7XG4gICAgICB9XG4gICAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy51bmJpbmQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgICAgbW92ZXNUbyh0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBvc2l0aW9ucyB8fCB0aGlzLnBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSBkaW1lbnNpb25zJDEodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgeyBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20gfSA9IHA7XG4gICAgICAgIGNvbnN0IFtwcmV2UG9zaXRpb25dID0gdGhpcy5wb3NpdGlvbnM7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbGFzdCh0aGlzLnBvc2l0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBbcHJldlBvc2l0aW9uLCBwb3NpdGlvbl07XG4gICAgICAgIGlmIChwb2ludEluUmVjdChwb3NpdGlvbiwgcCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlhZ29uYWxzID0gW1xuICAgICAgICAgIFtcbiAgICAgICAgICAgIHsgeDogbGVmdCwgeTogdG9wIH0sXG4gICAgICAgICAgICB7IHg6IHJpZ2h0LCB5OiBib3R0b20gfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgeyB4OiBsZWZ0LCB5OiBib3R0b20gfSxcbiAgICAgICAgICAgIHsgeDogcmlnaHQsIHk6IHRvcCB9XG4gICAgICAgICAgXVxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gZGlhZ29uYWxzLnNvbWUoKGRpYWdvbmFsKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0KHBhdGgsIGRpYWdvbmFsKTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uICYmIHBvaW50SW5SZWN0KGludGVyc2VjdGlvbiwgcCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3QoW3sgeDogeDEsIHk6IHkxIH0sIHsgeDogeDIsIHk6IHkyIH1dLCBbeyB4OiB4MywgeTogeTMgfSwgeyB4OiB4NCwgeTogeTQgfV0pIHtcbiAgICAgIGNvbnN0IGRlbm9taW5hdG9yID0gKHk0IC0geTMpICogKHgyIC0geDEpIC0gKHg0IC0geDMpICogKHkyIC0geTEpO1xuICAgICAgaWYgKGRlbm9taW5hdG9yID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVhID0gKCh4NCAtIHgzKSAqICh5MSAtIHkzKSAtICh5NCAtIHkzKSAqICh4MSAtIHgzKSkgLyBkZW5vbWluYXRvcjtcbiAgICAgIGlmICh1YSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgeDogeDEgKyB1YSAqICh4MiAtIHgxKSwgeTogeTEgKyB1YSAqICh5MiAtIHkxKSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9ic2VydmVJbnRlcnNlY3Rpb24odGFyZ2V0cywgY2IsIG9wdGlvbnMgPSB7fSwgeyBpbnRlcnNlY3RpbmcgPSB0cnVlIH0gPSB7fSkge1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgIGludGVyc2VjdGluZyA/IChlbnRyaWVzLCBvYnNlcnZlcjIpID0+IHtcbiAgICAgICAgICBpZiAoZW50cmllcy5zb21lKChlbnRyeSkgPT4gZW50cnkuaXNJbnRlcnNlY3RpbmcpKSB7XG4gICAgICAgICAgICBjYihlbnRyaWVzLCBvYnNlcnZlcjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSA6IGNiLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBlbCBvZiB0b05vZGVzKHRhcmdldHMpKSB7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ic2VydmVyO1xuICAgIH1cbiAgICBjb25zdCBoYXNSZXNpemVPYnNlcnZlciA9IGluQnJvd3NlciAmJiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXI7XG4gICAgZnVuY3Rpb24gb2JzZXJ2ZVJlc2l6ZSh0YXJnZXRzLCBjYiwgb3B0aW9ucyA9IHsgYm94OiBcImJvcmRlci1ib3hcIiB9KSB7XG4gICAgICBpZiAoaGFzUmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmUkMShSZXNpemVPYnNlcnZlciwgdGFyZ2V0cywgY2IsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2ZmID0gW29uKHdpbmRvdywgXCJsb2FkIHJlc2l6ZVwiLCBjYiksIG9uKGRvY3VtZW50LCBcImxvYWRlZG1ldGFkYXRhIGxvYWRcIiwgY2IsIHRydWUpXTtcbiAgICAgIHJldHVybiB7IGRpc2Nvbm5lY3Q6ICgpID0+IG9mZi5tYXAoKGNiMikgPT4gY2IyKCkpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9ic2VydmVWaWV3cG9ydFJlc2l6ZShjYikge1xuICAgICAgcmV0dXJuIHsgZGlzY29ubmVjdDogb24oW3dpbmRvdywgd2luZG93LnZpc3VhbFZpZXdwb3J0XSwgXCJyZXNpemVcIiwgY2IpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9ic2VydmVNdXRhdGlvbih0YXJnZXRzLCBjYiwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9ic2VydmUkMShNdXRhdGlvbk9ic2VydmVyLCB0YXJnZXRzLCBjYiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9ic2VydmUkMShPYnNlcnZlciwgdGFyZ2V0cywgY2IsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE9ic2VydmVyKGNiKTtcbiAgICAgIGZvciAoY29uc3QgZWwgb2YgdG9Ob2Rlcyh0YXJnZXRzKSkge1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYnNlcnZlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwbGF5KGVsKSB7XG4gICAgICBpZiAoaXNJRnJhbWUoZWwpKSB7XG4gICAgICAgIGNhbGwoZWwsIHsgZnVuYzogXCJwbGF5VmlkZW9cIiwgbWV0aG9kOiBcInBsYXlcIiB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0hUTUw1KGVsKSkge1xuICAgICAgICBlbC5wbGF5KCkuY2F0Y2gobm9vcCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdXNlKGVsKSB7XG4gICAgICBpZiAoaXNJRnJhbWUoZWwpKSB7XG4gICAgICAgIGNhbGwoZWwsIHsgZnVuYzogXCJwYXVzZVZpZGVvXCIsIG1ldGhvZDogXCJwYXVzZVwiIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzSFRNTDUoZWwpKSB7XG4gICAgICAgIGVsLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11dGUoZWwpIHtcbiAgICAgIGlmIChpc0lGcmFtZShlbCkpIHtcbiAgICAgICAgY2FsbChlbCwgeyBmdW5jOiBcIm11dGVcIiwgbWV0aG9kOiBcInNldFZvbHVtZVwiLCB2YWx1ZTogMCB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0hUTUw1KGVsKSkge1xuICAgICAgICBlbC5tdXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSFRNTDUoZWwpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgXCJ2aWRlb1wiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNJRnJhbWUoZWwpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgXCJpZnJhbWVcIikgJiYgKGlzWW91dHViZShlbCkgfHwgaXNWaW1lbyhlbCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1lvdXR1YmUoZWwpIHtcbiAgICAgIHJldHVybiAhIWVsLnNyYy5tYXRjaChcbiAgICAgICAgL1xcL1xcLy4qP3lvdXR1YmUoLW5vY29va2llKT9cXC5bYS16XStcXC8od2F0Y2hcXD92PVteJlxcc10rfGVtYmVkKXx5b3V0dVxcLmJlXFwvLiovXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZpbWVvKGVsKSB7XG4gICAgICByZXR1cm4gISFlbC5zcmMubWF0Y2goL3ZpbWVvXFwuY29tXFwvdmlkZW9cXC8uKi8pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBjYWxsKGVsLCBjbWQpIHtcbiAgICAgIGF3YWl0IGVuYWJsZUFwaShlbCk7XG4gICAgICBwb3N0KGVsLCBjbWQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb3N0KGVsLCBjbWQpIHtcbiAgICAgIGVsLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoeyBldmVudDogXCJjb21tYW5kXCIsIC4uLmNtZCB9KSwgXCIqXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0ZUtleSA9IFwiX3VrUGxheWVyXCI7XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGZ1bmN0aW9uIGVuYWJsZUFwaShlbCkge1xuICAgICAgaWYgKGVsW3N0YXRlS2V5XSkge1xuICAgICAgICByZXR1cm4gZWxbc3RhdGVLZXldO1xuICAgICAgfVxuICAgICAgY29uc3QgeW91dHViZSA9IGlzWW91dHViZShlbCk7XG4gICAgICBjb25zdCB2aW1lbyA9IGlzVmltZW8oZWwpO1xuICAgICAgY29uc3QgaWQgPSArK2NvdW50ZXI7XG4gICAgICBsZXQgcG9sbGVyO1xuICAgICAgcmV0dXJuIGVsW3N0YXRlS2V5XSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHlvdXR1YmUgJiYgb25jZShlbCwgXCJsb2FkXCIsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHBvc3QoZWwsIHsgZXZlbnQ6IFwibGlzdGVuaW5nXCIsIGlkIH0pO1xuICAgICAgICAgIHBvbGxlciA9IHNldEludGVydmFsKGxpc3RlbmVyLCAxMDApO1xuICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbmNlKHdpbmRvdywgXCJtZXNzYWdlXCIsIHJlc29sdmUsIGZhbHNlLCAoeyBkYXRhIH0pID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4geW91dHViZSAmJiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5pZCkgPT09IGlkICYmIGRhdGEuZXZlbnQgPT09IFwib25SZWFkeVwiIHx8IHZpbWVvICYmIE51bWJlcihkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLnBsYXllcl9pZCkgPT09IGlkO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBlbC5zcmMgPSBgJHtlbC5zcmN9JHtpbmNsdWRlcyhlbC5zcmMsIFwiP1wiKSA/IFwiJlwiIDogXCI/XCJ9JHt5b3V0dWJlID8gXCJlbmFibGVqc2FwaT0xXCIgOiBgYXBpPTEmcGxheWVyX2lkPSR7aWR9YH1gO1xuICAgICAgfSkudGhlbigoKSA9PiBjbGVhckludGVydmFsKHBvbGxlcikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzSW5WaWV3KGVsZW1lbnQsIG9mZnNldFRvcCA9IDAsIG9mZnNldExlZnQgPSAwKSB7XG4gICAgICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50ZXJzZWN0UmVjdChcbiAgICAgICAgLi4ub3ZlcmZsb3dQYXJlbnRzKGVsZW1lbnQpLm1hcCgocGFyZW50MikgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0gPSBvZmZzZXRWaWV3cG9ydChwYXJlbnQyKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiB0b3AgLSBvZmZzZXRUb3AsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0IC0gb2Zmc2V0TGVmdCxcbiAgICAgICAgICAgIGJvdHRvbTogYm90dG9tICsgb2Zmc2V0VG9wLFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0ICsgb2Zmc2V0TGVmdFxuICAgICAgICAgIH07XG4gICAgICAgIH0pLmNvbmNhdChvZmZzZXQoZWxlbWVudCkpXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldyhlbGVtZW50LCB7IG9mZnNldDogb2Zmc2V0QnkgPSAwIH0gPSB7fSkge1xuICAgICAgY29uc3QgcGFyZW50czIgPSBpc1Zpc2libGUoZWxlbWVudCkgPyBzY3JvbGxQYXJlbnRzKGVsZW1lbnQsIGZhbHNlLCBbXCJoaWRkZW5cIl0pIDogW107XG4gICAgICByZXR1cm4gcGFyZW50czIucmVkdWNlKFxuICAgICAgICAoZm4sIHNjcm9sbEVsZW1lbnQsIGkpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KTtcbiAgICAgICAgICBjb25zdCBtYXhTY3JvbGwgPSBzY3JvbGxIZWlnaHQgLSB2aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgY29uc3QgeyBoZWlnaHQ6IGVsSGVpZ2h0LCB0b3A6IGVsVG9wIH0gPSBwYXJlbnRzMltpIC0gMV0gPyBvZmZzZXRWaWV3cG9ydChwYXJlbnRzMltpIC0gMV0pIDogb2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICAgIGxldCB0b3AgPSBNYXRoLmNlaWwoZWxUb3AgLSB2aWV3cG9ydC50b3AgLSBvZmZzZXRCeSArIHNjcm9sbFRvcCk7XG4gICAgICAgICAgaWYgKG9mZnNldEJ5ID4gMCAmJiBvZmZzZXRIZWlnaHQgPCBlbEhlaWdodCArIG9mZnNldEJ5KSB7XG4gICAgICAgICAgICB0b3AgKz0gb2Zmc2V0Qnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldEJ5ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvcCA+IG1heFNjcm9sbCkge1xuICAgICAgICAgICAgb2Zmc2V0QnkgLT0gdG9wIC0gbWF4U2Nyb2xsO1xuICAgICAgICAgICAgdG9wID0gbWF4U2Nyb2xsO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9wIDwgMCkge1xuICAgICAgICAgICAgb2Zmc2V0QnkgLT0gdG9wO1xuICAgICAgICAgICAgdG9wID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICgpID0+IHNjcm9sbFRvKHNjcm9sbEVsZW1lbnQsIHRvcCAtIHNjcm9sbFRvcCwgZWxlbWVudCwgbWF4U2Nyb2xsKS50aGVuKGZuKTtcbiAgICAgICAgfSxcbiAgICAgICAgKCkgPT4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICkoKTtcbiAgICAgIGZ1bmN0aW9uIHNjcm9sbFRvKGVsZW1lbnQyLCB0b3AsIHRhcmdldEVsLCBtYXhTY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsID0gZWxlbWVudDIuc2Nyb2xsVG9wO1xuICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gZ2V0RHVyYXRpb24oTWF0aC5hYnModG9wKSk7XG4gICAgICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIGNvbnN0IGlzU2Nyb2xsaW5nRWxlbWVudCA9IHNjcm9sbGluZ0VsZW1lbnQoZWxlbWVudDIpID09PSBlbGVtZW50MjtcbiAgICAgICAgICBjb25zdCB0YXJnZXRUb3AgPSBvZmZzZXQodGFyZ2V0RWwpLnRvcCArIChpc1Njcm9sbGluZ0VsZW1lbnQgPyAwIDogc2Nyb2xsKTtcbiAgICAgICAgICBsZXQgcHJldiA9IDA7XG4gICAgICAgICAgbGV0IGZyYW1lcyA9IDE1O1xuICAgICAgICAgIChmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IGVhc2UoY2xhbXAoKERhdGUubm93KCkgLSBzdGFydCkgLyBkdXJhdGlvbikpO1xuICAgICAgICAgICAgbGV0IGRpZmYgPSAwO1xuICAgICAgICAgICAgaWYgKHBhcmVudHMyWzBdID09PSBlbGVtZW50MiAmJiBzY3JvbGwgKyB0b3AgPCBtYXhTY3JvbGwpIHtcbiAgICAgICAgICAgICAgZGlmZiA9IG9mZnNldCh0YXJnZXRFbCkudG9wICsgKGlzU2Nyb2xsaW5nRWxlbWVudCA/IDAgOiBlbGVtZW50Mi5zY3JvbGxUb3ApIC0gdGFyZ2V0VG9wIC0gZGltZW5zaW9ucyQxKGdldENvdmVyaW5nRWxlbWVudCh0YXJnZXRFbCkpLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjc3MoZWxlbWVudDIsIFwic2Nyb2xsQmVoYXZpb3JcIikgIT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICAgIGNzcyhlbGVtZW50MiwgXCJzY3JvbGxCZWhhdmlvclwiLCBcImF1dG9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50Mi5zY3JvbGxUb3AgPSBzY3JvbGwgKyAodG9wICsgZGlmZikgKiBwZXJjZW50O1xuICAgICAgICAgICAgY3NzKGVsZW1lbnQyLCBcInNjcm9sbEJlaGF2aW9yXCIsIFwiXCIpO1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQgPT09IDEgJiYgKHByZXYgPT09IGRpZmYgfHwgIWZyYW1lcy0tKSkge1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcmV2ID0gZGlmZjtcbiAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0RHVyYXRpb24oZGlzdCkge1xuICAgICAgICByZXR1cm4gNDAgKiBNYXRoLnBvdyhkaXN0LCAwLjM3NSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgICAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGspKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nyb2xsZWRPdmVyKGVsZW1lbnQsIHN0YXJ0T2Zmc2V0ID0gMCwgZW5kT2Zmc2V0ID0gMCkge1xuICAgICAgaWYgKCFpc1Zpc2libGUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gc2Nyb2xsUGFyZW50KGVsZW1lbnQsIHRydWUpO1xuICAgICAgY29uc3QgeyBzY3JvbGxIZWlnaHQsIHNjcm9sbFRvcCB9ID0gc2Nyb2xsRWxlbWVudDtcbiAgICAgIGNvbnN0IHsgaGVpZ2h0OiB2aWV3cG9ydEhlaWdodCB9ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICBjb25zdCBtYXhTY3JvbGwgPSBzY3JvbGxIZWlnaHQgLSB2aWV3cG9ydEhlaWdodDtcbiAgICAgIGNvbnN0IGVsZW1lbnRPZmZzZXRUb3AgPSBvZmZzZXRQb3NpdGlvbihlbGVtZW50KVswXSAtIG9mZnNldFBvc2l0aW9uKHNjcm9sbEVsZW1lbnQpWzBdO1xuICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBlbGVtZW50T2Zmc2V0VG9wIC0gdmlld3BvcnRIZWlnaHQgKyBzdGFydE9mZnNldCk7XG4gICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihtYXhTY3JvbGwsIGVsZW1lbnRPZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGVuZE9mZnNldCk7XG4gICAgICByZXR1cm4gc3RhcnQgPCBlbmQgPyBjbGFtcCgoc2Nyb2xsVG9wIC0gc3RhcnQpIC8gKGVuZCAtIHN0YXJ0KSkgOiAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY3JvbGxQYXJlbnRzKGVsZW1lbnQsIHNjcm9sbGFibGUgPSBmYWxzZSwgcHJvcHMgPSBbXSkge1xuICAgICAgY29uc3Qgc2Nyb2xsRWwgPSBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgbGV0IGFuY2VzdG9ycyA9IHBhcmVudHMoZWxlbWVudCkucmV2ZXJzZSgpO1xuICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLnNsaWNlKGFuY2VzdG9ycy5pbmRleE9mKHNjcm9sbEVsKSArIDEpO1xuICAgICAgY29uc3QgZml4ZWRJbmRleCA9IGZpbmRJbmRleChhbmNlc3RvcnMsIChlbCkgPT4gY3NzKGVsLCBcInBvc2l0aW9uXCIpID09PSBcImZpeGVkXCIpO1xuICAgICAgaWYgKH5maXhlZEluZGV4KSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5zbGljZShmaXhlZEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbc2Nyb2xsRWxdLmNvbmNhdChcbiAgICAgICAgYW5jZXN0b3JzLmZpbHRlcihcbiAgICAgICAgICAocGFyZW50MikgPT4gY3NzKHBhcmVudDIsIFwib3ZlcmZsb3dcIikuc3BsaXQoXCIgXCIpLnNvbWUoKHByb3ApID0+IGluY2x1ZGVzKFtcImF1dG9cIiwgXCJzY3JvbGxcIiwgLi4ucHJvcHNdLCBwcm9wKSkgJiYgKCFzY3JvbGxhYmxlIHx8IHBhcmVudDIuc2Nyb2xsSGVpZ2h0ID4gb2Zmc2V0Vmlld3BvcnQocGFyZW50MikuaGVpZ2h0KVxuICAgICAgICApXG4gICAgICApLnJldmVyc2UoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nyb2xsUGFyZW50KC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzKC4uLmFyZ3MpWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvdmVyZmxvd1BhcmVudHMoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHMoZWxlbWVudCwgZmFsc2UsIFtcImhpZGRlblwiLCBcImNsaXBcIl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSB0b1dpbmRvdyhzY3JvbGxFbGVtZW50KTtcbiAgICAgIGNvbnN0IGRvY3VtZW50U2Nyb2xsaW5nRWxlbWVudCA9IHNjcm9sbGluZ0VsZW1lbnQoc2Nyb2xsRWxlbWVudCk7XG4gICAgICBjb25zdCB1c2VXaW5kb3cgPSAhaXNOb2RlKHNjcm9sbEVsZW1lbnQpIHx8IHNjcm9sbEVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50KTtcbiAgICAgIGlmICh1c2VXaW5kb3cgJiYgd2luZG93LnZpc3VhbFZpZXdwb3J0KSB7XG4gICAgICAgIGxldCB7IGhlaWdodCwgd2lkdGgsIHNjYWxlLCBwYWdlVG9wOiB0b3AsIHBhZ2VMZWZ0OiBsZWZ0IH0gPSB3aW5kb3cudmlzdWFsVmlld3BvcnQ7XG4gICAgICAgIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0ICogc2NhbGUpO1xuICAgICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGggKiBzY2FsZSk7XG4gICAgICAgIHJldHVybiB7IGhlaWdodCwgd2lkdGgsIHRvcCwgbGVmdCwgYm90dG9tOiB0b3AgKyBoZWlnaHQsIHJpZ2h0OiBsZWZ0ICsgd2lkdGggfTtcbiAgICAgIH1cbiAgICAgIGxldCByZWN0ID0gb2Zmc2V0KHVzZVdpbmRvdyA/IHdpbmRvdyA6IHNjcm9sbEVsZW1lbnQpO1xuICAgICAgaWYgKGNzcyhzY3JvbGxFbGVtZW50LCBcImRpc3BsYXlcIikgPT09IFwiaW5saW5lXCIpIHtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGJvZHksIGRvY3VtZW50RWxlbWVudCB9ID0gd2luZG93LmRvY3VtZW50O1xuICAgICAgY29uc3Qgdmlld3BvcnRFbGVtZW50ID0gdXNlV2luZG93ID8gZG9jdW1lbnRTY3JvbGxpbmdFbGVtZW50ID09PSBkb2N1bWVudEVsZW1lbnQgfHwgLy8gSW4gcXVpcmtzIG1vZGUgdGhlIHNjcm9sbGluZyBlbGVtZW50IGlzIGJvZHksIGV2ZW4gdGhvdWdoIHRoZSB2aWV3cG9ydCBpcyBodG1sXG4gICAgICBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQuY2xpZW50SGVpZ2h0IDwgYm9keS5jbGllbnRIZWlnaHQgPyBkb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQgOiBib2R5IDogc2Nyb2xsRWxlbWVudDtcbiAgICAgIGZvciAobGV0IFtwcm9wLCBkaXIsIHN0YXJ0LCBlbmRdIG9mIFtcbiAgICAgICAgW1wid2lkdGhcIiwgXCJ4XCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdLFxuICAgICAgICBbXCJoZWlnaHRcIiwgXCJ5XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdXG4gICAgICBdKSB7XG4gICAgICAgIGNvbnN0IHN1YnBpeGVsID0gcmVjdFtwcm9wXSAlIDE7XG4gICAgICAgIHJlY3Rbc3RhcnRdICs9IHRvRmxvYXQoY3NzKHZpZXdwb3J0RWxlbWVudCwgYGJvcmRlci0ke3N0YXJ0fS13aWR0aGApKTtcbiAgICAgICAgcmVjdFtwcm9wXSA9IHJlY3RbZGlyXSA9IHZpZXdwb3J0RWxlbWVudFtgY2xpZW50JHt1Y2ZpcnN0KHByb3ApfWBdIC0gKHN1YnBpeGVsID8gc3VicGl4ZWwgPCAwLjUgPyAtc3VicGl4ZWwgOiAxIC0gc3VicGl4ZWwgOiAwKTtcbiAgICAgICAgcmVjdFtlbmRdID0gcmVjdFtwcm9wXSArIHJlY3Rbc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvdmVyaW5nRWxlbWVudCh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IHsgbGVmdCwgd2lkdGgsIHRvcCB9ID0gZGltZW5zaW9ucyQxKHRhcmdldCk7XG4gICAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIHRvcCA/IFswLCB0b3BdIDogWzBdKSB7XG4gICAgICAgIGxldCBjb3ZlckVsO1xuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRvV2luZG93KHRhcmdldCkuZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQobGVmdCArIHdpZHRoIC8gMiwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgaWYgKCFlbC5jb250YWlucyh0YXJnZXQpICYmIC8vIElmIGUuZy4gT2ZmY2FudmFzIGlzIG5vdCB5ZXQgY2xvc2VkXG4gICAgICAgICAgIWhhc0NsYXNzKGVsLCBcInVrLXRvZ2dsYWJsZS1sZWF2ZVwiKSAmJiAoaGFzUG9zaXRpb24oZWwsIFwiZml4ZWRcIikgJiYgekluZGV4KFxuICAgICAgICAgICAgcGFyZW50cyh0YXJnZXQpLnJldmVyc2UoKS5maW5kKFxuICAgICAgICAgICAgICAocGFyZW50MikgPT4gIXBhcmVudDIuY29udGFpbnMoZWwpICYmICFoYXNQb3NpdGlvbihwYXJlbnQyLCBcInN0YXRpY1wiKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICkgPCB6SW5kZXgoZWwpIHx8IGhhc1Bvc2l0aW9uKGVsLCBcInN0aWNreVwiKSAmJiBwYXJlbnQoZWwpLmNvbnRhaW5zKHRhcmdldCkpICYmICghY292ZXJFbCB8fCBkaW1lbnNpb25zJDEoY292ZXJFbCkuaGVpZ2h0IDwgZGltZW5zaW9ucyQxKGVsKS5oZWlnaHQpKSB7XG4gICAgICAgICAgICBjb3ZlckVsID0gZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb3ZlckVsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvdmVyRWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gekluZGV4KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b0Zsb2F0KGNzcyhlbGVtZW50LCBcInpJbmRleFwiKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1Bvc2l0aW9uKGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4gY3NzKGVsZW1lbnQsIFwicG9zaXRpb25cIikgPT09IHBvc2l0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY3JvbGxpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0b1dpbmRvdyhlbGVtZW50KS5kb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuICAgIH1cblxuICAgIGNvbnN0IGRpcnMgPSBbXG4gICAgICBbXCJ3aWR0aFwiLCBcInhcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gICAgICBbXCJoZWlnaHRcIiwgXCJ5XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdXG4gICAgXTtcbiAgICBmdW5jdGlvbiBwb3NpdGlvbkF0KGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgYXR0YWNoOiB7XG4gICAgICAgICAgZWxlbWVudDogW1wibGVmdFwiLCBcInRvcFwiXSxcbiAgICAgICAgICB0YXJnZXQ6IFtcImxlZnRcIiwgXCJ0b3BcIl0sXG4gICAgICAgICAgLi4ub3B0aW9ucy5hdHRhY2hcbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0OiBbMCwgMF0sXG4gICAgICAgIHBsYWNlbWVudDogW10sXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH07XG4gICAgICBpZiAoIWlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICB0YXJnZXQgPSBbdGFyZ2V0LCB0YXJnZXRdO1xuICAgICAgfVxuICAgICAgb2Zmc2V0KGVsZW1lbnQsIGdldFBvc2l0aW9uKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQb3NpdGlvbihlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYXR0YWNoVG8oZWxlbWVudCwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHsgYm91bmRhcnksIHZpZXdwb3J0T2Zmc2V0ID0gMCwgcGxhY2VtZW50IH0gPSBvcHRpb25zO1xuICAgICAgbGV0IG9mZnNldFBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICBmb3IgKGNvbnN0IFtpLCBbcHJvcCwgLCBzdGFydCwgZW5kXV0gb2YgT2JqZWN0LmVudHJpZXMoZGlycykpIHtcbiAgICAgICAgY29uc3Qgdmlld3BvcnQgPSBnZXRWaWV3cG9ydCQyKGVsZW1lbnQsIHRhcmdldFtpXSwgdmlld3BvcnRPZmZzZXQsIGJvdW5kYXJ5LCBpKTtcbiAgICAgICAgaWYgKGlzV2l0aGluKHBvc2l0aW9uLCB2aWV3cG9ydCwgaSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0QnkgPSAwO1xuICAgICAgICBpZiAocGxhY2VtZW50W2ldID09PSBcImZsaXBcIikge1xuICAgICAgICAgIGNvbnN0IGF0dGFjaCA9IG9wdGlvbnMuYXR0YWNoLnRhcmdldFtpXTtcbiAgICAgICAgICBpZiAoYXR0YWNoID09PSBlbmQgJiYgcG9zaXRpb25bZW5kXSA8PSB2aWV3cG9ydFtlbmRdIHx8IGF0dGFjaCA9PT0gc3RhcnQgJiYgcG9zaXRpb25bc3RhcnRdID49IHZpZXdwb3J0W3N0YXJ0XSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZnNldEJ5ID0gZmxpcChlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMsIGkpW3N0YXJ0XSAtIHBvc2l0aW9uW3N0YXJ0XTtcbiAgICAgICAgICBjb25zdCBzY3JvbGxBcmVhID0gZ2V0U2Nyb2xsQXJlYShlbGVtZW50LCB0YXJnZXRbaV0sIHZpZXdwb3J0T2Zmc2V0LCBpKTtcbiAgICAgICAgICBpZiAoIWlzV2l0aGluKGFwcGx5T2Zmc2V0KHBvc2l0aW9uLCBvZmZzZXRCeSwgaSksIHNjcm9sbEFyZWEsIGkpKSB7XG4gICAgICAgICAgICBpZiAoaXNXaXRoaW4ocG9zaXRpb24sIHNjcm9sbEFyZWEsIGkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVjdXJzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IGZsaXBBeGlzKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobmV3UG9zICYmIGlzV2l0aGluKG5ld1Bvcywgc2Nyb2xsQXJlYSwgMSAtIGkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXdQb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGxhY2VtZW50W2ldID09PSBcInNoaWZ0XCIpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXREaW0gPSBvZmZzZXQodGFyZ2V0W2ldKTtcbiAgICAgICAgICBjb25zdCB7IG9mZnNldDogZWxPZmZzZXQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgb2Zmc2V0QnkgPSBjbGFtcChcbiAgICAgICAgICAgIGNsYW1wKHBvc2l0aW9uW3N0YXJ0XSwgdmlld3BvcnRbc3RhcnRdLCB2aWV3cG9ydFtlbmRdIC0gcG9zaXRpb25bcHJvcF0pLFxuICAgICAgICAgICAgdGFyZ2V0RGltW3N0YXJ0XSAtIHBvc2l0aW9uW3Byb3BdICsgZWxPZmZzZXRbaV0sXG4gICAgICAgICAgICB0YXJnZXREaW1bZW5kXSAtIGVsT2Zmc2V0W2ldXG4gICAgICAgICAgKSAtIHBvc2l0aW9uW3N0YXJ0XTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXRQb3NpdGlvbiA9IGFwcGx5T2Zmc2V0KG9mZnNldFBvc2l0aW9uLCBvZmZzZXRCeSwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0UG9zaXRpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF0dGFjaFRvKGVsZW1lbnQsIHRhcmdldCwgb3B0aW9ucykge1xuICAgICAgbGV0IHsgYXR0YWNoLCBvZmZzZXQ6IG9mZnNldEJ5IH0gPSB7XG4gICAgICAgIGF0dGFjaDoge1xuICAgICAgICAgIGVsZW1lbnQ6IFtcImxlZnRcIiwgXCJ0b3BcIl0sXG4gICAgICAgICAgdGFyZ2V0OiBbXCJsZWZ0XCIsIFwidG9wXCJdLFxuICAgICAgICAgIC4uLm9wdGlvbnMuYXR0YWNoXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDogWzAsIDBdLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgbGV0IGVsT2Zmc2V0ID0gb2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgZm9yIChjb25zdCBbaSwgW3Byb3AsICwgc3RhcnQsIGVuZF1dIG9mIE9iamVjdC5lbnRyaWVzKGRpcnMpKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldE9mZnNldCA9IGF0dGFjaC50YXJnZXRbaV0gPT09IGF0dGFjaC5lbGVtZW50W2ldID8gb2Zmc2V0Vmlld3BvcnQodGFyZ2V0W2ldKSA6IG9mZnNldCh0YXJnZXRbaV0pO1xuICAgICAgICBlbE9mZnNldCA9IGFwcGx5T2Zmc2V0KFxuICAgICAgICAgIGVsT2Zmc2V0LFxuICAgICAgICAgIHRhcmdldE9mZnNldFtzdGFydF0gLSBlbE9mZnNldFtzdGFydF0gKyBtb3ZlQnkoYXR0YWNoLnRhcmdldFtpXSwgZW5kLCB0YXJnZXRPZmZzZXRbcHJvcF0pIC0gbW92ZUJ5KGF0dGFjaC5lbGVtZW50W2ldLCBlbmQsIGVsT2Zmc2V0W3Byb3BdKSArICtvZmZzZXRCeVtpXSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxPZmZzZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5T2Zmc2V0KHBvc2l0aW9uLCBvZmZzZXQyLCBpKSB7XG4gICAgICBjb25zdCBbLCBkaXIsIHN0YXJ0LCBlbmRdID0gZGlyc1tpXTtcbiAgICAgIGNvbnN0IG5ld1BvcyA9IHsgLi4ucG9zaXRpb24gfTtcbiAgICAgIG5ld1Bvc1tzdGFydF0gPSBwb3NpdGlvbltkaXJdID0gcG9zaXRpb25bc3RhcnRdICsgb2Zmc2V0MjtcbiAgICAgIG5ld1Bvc1tlbmRdICs9IG9mZnNldDI7XG4gICAgICByZXR1cm4gbmV3UG9zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlQnkoYXR0YWNoLCBlbmQsIGRpbSkge1xuICAgICAgcmV0dXJuIGF0dGFjaCA9PT0gXCJjZW50ZXJcIiA/IGRpbSAvIDIgOiBhdHRhY2ggPT09IGVuZCA/IGRpbSA6IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZpZXdwb3J0JDIoZWxlbWVudCwgdGFyZ2V0LCB2aWV3cG9ydE9mZnNldCwgYm91bmRhcnksIGkpIHtcbiAgICAgIGxldCB2aWV3cG9ydCA9IGdldEludGVyc2VjdGlvbkFyZWEoLi4uY29tbW9uU2Nyb2xsUGFyZW50cyhlbGVtZW50LCB0YXJnZXQpLm1hcChvZmZzZXRWaWV3cG9ydCkpO1xuICAgICAgaWYgKHZpZXdwb3J0T2Zmc2V0KSB7XG4gICAgICAgIHZpZXdwb3J0W2RpcnNbaV1bMl1dICs9IHZpZXdwb3J0T2Zmc2V0O1xuICAgICAgICB2aWV3cG9ydFtkaXJzW2ldWzNdXSAtPSB2aWV3cG9ydE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChib3VuZGFyeSkge1xuICAgICAgICB2aWV3cG9ydCA9IGdldEludGVyc2VjdGlvbkFyZWEoXG4gICAgICAgICAgdmlld3BvcnQsXG4gICAgICAgICAgb2Zmc2V0KGlzQXJyYXkoYm91bmRhcnkpID8gYm91bmRhcnlbaV0gOiBib3VuZGFyeSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2aWV3cG9ydDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2Nyb2xsQXJlYShlbGVtZW50LCB0YXJnZXQsIHZpZXdwb3J0T2Zmc2V0LCBpKSB7XG4gICAgICBjb25zdCBbcHJvcCwgYXhpcywgc3RhcnQsIGVuZF0gPSBkaXJzW2ldO1xuICAgICAgY29uc3QgW3Njcm9sbEVsZW1lbnRdID0gY29tbW9uU2Nyb2xsUGFyZW50cyhlbGVtZW50LCB0YXJnZXQpO1xuICAgICAgY29uc3Qgdmlld3BvcnQgPSBvZmZzZXRWaWV3cG9ydChzY3JvbGxFbGVtZW50KTtcbiAgICAgIGlmIChbXCJhdXRvXCIsIFwic2Nyb2xsXCJdLmluY2x1ZGVzKGNzcyhzY3JvbGxFbGVtZW50LCBgb3ZlcmZsb3ctJHtheGlzfWApKSkge1xuICAgICAgICB2aWV3cG9ydFtzdGFydF0gLT0gc2Nyb2xsRWxlbWVudFtgc2Nyb2xsJHt1Y2ZpcnN0KHN0YXJ0KX1gXTtcbiAgICAgICAgdmlld3BvcnRbZW5kXSA9IHZpZXdwb3J0W3N0YXJ0XSArIHNjcm9sbEVsZW1lbnRbYHNjcm9sbCR7dWNmaXJzdChwcm9wKX1gXTtcbiAgICAgIH1cbiAgICAgIHZpZXdwb3J0W3N0YXJ0XSArPSB2aWV3cG9ydE9mZnNldDtcbiAgICAgIHZpZXdwb3J0W2VuZF0gLT0gdmlld3BvcnRPZmZzZXQ7XG4gICAgICByZXR1cm4gdmlld3BvcnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbW1vblNjcm9sbFBhcmVudHMoZWxlbWVudCwgdGFyZ2V0KSB7XG4gICAgICByZXR1cm4gb3ZlcmZsb3dQYXJlbnRzKHRhcmdldCkuZmlsdGVyKChwYXJlbnQpID0+IHBhcmVudC5jb250YWlucyhlbGVtZW50KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbkFyZWEoLi4ucmVjdHMpIHtcbiAgICAgIGxldCBhcmVhID0ge307XG4gICAgICBmb3IgKGNvbnN0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBbLCAsIHN0YXJ0LCBlbmRdIG9mIGRpcnMpIHtcbiAgICAgICAgICBhcmVhW3N0YXJ0XSA9IE1hdGgubWF4KGFyZWFbc3RhcnRdIHx8IDAsIHJlY3Rbc3RhcnRdKTtcbiAgICAgICAgICBhcmVhW2VuZF0gPSBNYXRoLm1pbiguLi5bYXJlYVtlbmRdLCByZWN0W2VuZF1dLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmVhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1dpdGhpbihwb3NpdGlvbkEsIHBvc2l0aW9uQiwgaSkge1xuICAgICAgY29uc3QgWywgLCBzdGFydCwgZW5kXSA9IGRpcnNbaV07XG4gICAgICByZXR1cm4gcG9zaXRpb25BW3N0YXJ0XSA+PSBwb3NpdGlvbkJbc3RhcnRdICYmIHBvc2l0aW9uQVtlbmRdIDw9IHBvc2l0aW9uQltlbmRdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbGlwKGVsZW1lbnQsIHRhcmdldCwgeyBvZmZzZXQ6IG9mZnNldDIsIGF0dGFjaCB9LCBpKSB7XG4gICAgICByZXR1cm4gYXR0YWNoVG8oZWxlbWVudCwgdGFyZ2V0LCB7XG4gICAgICAgIGF0dGFjaDoge1xuICAgICAgICAgIGVsZW1lbnQ6IGZsaXBBdHRhY2goYXR0YWNoLmVsZW1lbnQsIGkpLFxuICAgICAgICAgIHRhcmdldDogZmxpcEF0dGFjaChhdHRhY2gudGFyZ2V0LCBpKVxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IGZsaXBPZmZzZXQob2Zmc2V0MiwgaSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmbGlwQXhpcyhlbGVtZW50LCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbihlbGVtZW50LCB0YXJnZXQsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgYXR0YWNoOiB7XG4gICAgICAgICAgZWxlbWVudDogb3B0aW9ucy5hdHRhY2guZWxlbWVudC5tYXAoZmxpcEF0dGFjaEF4aXMpLnJldmVyc2UoKSxcbiAgICAgICAgICB0YXJnZXQ6IG9wdGlvbnMuYXR0YWNoLnRhcmdldC5tYXAoZmxpcEF0dGFjaEF4aXMpLnJldmVyc2UoKVxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IG9wdGlvbnMub2Zmc2V0LnJldmVyc2UoKSxcbiAgICAgICAgcGxhY2VtZW50OiBvcHRpb25zLnBsYWNlbWVudC5yZXZlcnNlKCksXG4gICAgICAgIHJlY3Vyc2lvbjogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsaXBBdHRhY2goYXR0YWNoLCBpKSB7XG4gICAgICBjb25zdCBuZXdBdHRhY2ggPSBbLi4uYXR0YWNoXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gZGlyc1tpXS5pbmRleE9mKGF0dGFjaFtpXSk7XG4gICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgIG5ld0F0dGFjaFtpXSA9IGRpcnNbaV1bMSAtIGluZGV4ICUgMiArIDJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0F0dGFjaDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmxpcEF0dGFjaEF4aXMocHJvcCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGlyc1tpXS5pbmRleE9mKHByb3ApO1xuICAgICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGRpcnNbMSAtIGldW2luZGV4ICUgMiArIDJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZsaXBPZmZzZXQob2Zmc2V0MiwgaSkge1xuICAgICAgb2Zmc2V0MiA9IFsuLi5vZmZzZXQyXTtcbiAgICAgIG9mZnNldDJbaV0gKj0gLTE7XG4gICAgICByZXR1cm4gb2Zmc2V0MjtcbiAgICB9XG5cbiAgICB2YXIgdXRpbCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICAkOiAkLFxuICAgICAgICAkJDogJCQsXG4gICAgICAgIEFuaW1hdGlvbjogQW5pbWF0aW9uLFxuICAgICAgICBEaW1lbnNpb25zOiBEaW1lbnNpb25zLFxuICAgICAgICBNb3VzZVRyYWNrZXI6IE1vdXNlVHJhY2tlcixcbiAgICAgICAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgICAgICAgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgICAgICBhZnRlcjogYWZ0ZXIsXG4gICAgICAgIGFwcGVuZDogYXBwZW5kLFxuICAgICAgICBhcHBseTogYXBwbHksXG4gICAgICAgIGFzc2lnbjogYXNzaWduLFxuICAgICAgICBhdHRyOiBhdHRyLFxuICAgICAgICBiZWZvcmU6IGJlZm9yZSxcbiAgICAgICAgYm94TW9kZWxBZGp1c3Q6IGJveE1vZGVsQWRqdXN0LFxuICAgICAgICBjYW1lbGl6ZTogY2FtZWxpemUsXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgY2xhbXA6IGNsYW1wLFxuICAgICAgICBjcmVhdGVFdmVudDogY3JlYXRlRXZlbnQsXG4gICAgICAgIGNzczogY3NzLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBkaW1lbnNpb25zOiBkaW1lbnNpb25zJDEsXG4gICAgICAgIGVhY2g6IGVhY2gsXG4gICAgICAgIGVtcHR5OiBlbXB0eSxcbiAgICAgICAgZW5kc1dpdGg6IGVuZHNXaXRoLFxuICAgICAgICBlc2NhcGU6IGVzY2FwZSxcbiAgICAgICAgZmFzdGRvbTogZmFzdGRvbSxcbiAgICAgICAgZmlsdGVyOiBmaWx0ZXIkMSxcbiAgICAgICAgZmluZDogZmluZCxcbiAgICAgICAgZmluZEFsbDogZmluZEFsbCxcbiAgICAgICAgZmluZEluZGV4OiBmaW5kSW5kZXgsXG4gICAgICAgIGZsaXBQb3NpdGlvbjogZmxpcFBvc2l0aW9uLFxuICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgIGdldENvdmVyaW5nRWxlbWVudDogZ2V0Q292ZXJpbmdFbGVtZW50LFxuICAgICAgICBnZXRFdmVudFBvczogZ2V0RXZlbnRQb3MsXG4gICAgICAgIGdldEluZGV4OiBnZXRJbmRleCxcbiAgICAgICAgZ2V0VGFyZ2V0ZWRFbGVtZW50OiBnZXRUYXJnZXRlZEVsZW1lbnQsXG4gICAgICAgIGhhc0F0dHI6IGhhc0F0dHIsXG4gICAgICAgIGhhc0NsYXNzOiBoYXNDbGFzcyxcbiAgICAgICAgaGFzT3duOiBoYXNPd24sXG4gICAgICAgIGhhc1RvdWNoOiBoYXNUb3VjaCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGh0bWw6IGh0bWwsXG4gICAgICAgIGh5cGhlbmF0ZTogaHlwaGVuYXRlLFxuICAgICAgICBpbkJyb3dzZXI6IGluQnJvd3NlcixcbiAgICAgICAgaW5jbHVkZXM6IGluY2x1ZGVzLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGludGVyc2VjdFJlY3Q6IGludGVyc2VjdFJlY3QsXG4gICAgICAgIGlzQXJyYXk6IGlzQXJyYXksXG4gICAgICAgIGlzQm9vbGVhbjogaXNCb29sZWFuLFxuICAgICAgICBpc0RvY3VtZW50OiBpc0RvY3VtZW50LFxuICAgICAgICBpc0VsZW1lbnQ6IGlzRWxlbWVudCxcbiAgICAgICAgaXNFbXB0eTogaXNFbXB0eSxcbiAgICAgICAgaXNFcXVhbDogaXNFcXVhbCxcbiAgICAgICAgaXNGb2N1c2FibGU6IGlzRm9jdXNhYmxlLFxuICAgICAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgICAgICBpc0luVmlldzogaXNJblZpZXcsXG4gICAgICAgIGlzSW5wdXQ6IGlzSW5wdXQsXG4gICAgICAgIGlzTm9kZTogaXNOb2RlLFxuICAgICAgICBpc051bWJlcjogaXNOdW1iZXIsXG4gICAgICAgIGlzTnVtZXJpYzogaXNOdW1lcmljLFxuICAgICAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgICAgIGlzUGxhaW5PYmplY3Q6IGlzUGxhaW5PYmplY3QsXG4gICAgICAgIGlzUnRsOiBpc1J0bCxcbiAgICAgICAgaXNTYW1lU2l0ZUFuY2hvcjogaXNTYW1lU2l0ZUFuY2hvcixcbiAgICAgICAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICAgICAgICBpc1RhZzogaXNUYWcsXG4gICAgICAgIGlzVG91Y2g6IGlzVG91Y2gsXG4gICAgICAgIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgICAgICAgaXNWaXNpYmxlOiBpc1Zpc2libGUsXG4gICAgICAgIGlzVm9pZEVsZW1lbnQ6IGlzVm9pZEVsZW1lbnQsXG4gICAgICAgIGlzV2luZG93OiBpc1dpbmRvdyxcbiAgICAgICAgbGFzdDogbGFzdCxcbiAgICAgICAgbWF0Y2hlczogbWF0Y2hlcyxcbiAgICAgICAgbWVtb2l6ZTogbWVtb2l6ZSxcbiAgICAgICAgbXV0ZTogbXV0ZSxcbiAgICAgICAgbm9vcDogbm9vcCxcbiAgICAgICAgb2JzZXJ2ZUludGVyc2VjdGlvbjogb2JzZXJ2ZUludGVyc2VjdGlvbixcbiAgICAgICAgb2JzZXJ2ZU11dGF0aW9uOiBvYnNlcnZlTXV0YXRpb24sXG4gICAgICAgIG9ic2VydmVSZXNpemU6IG9ic2VydmVSZXNpemUsXG4gICAgICAgIG9ic2VydmVWaWV3cG9ydFJlc2l6ZTogb2JzZXJ2ZVZpZXdwb3J0UmVzaXplLFxuICAgICAgICBvZmY6IG9mZixcbiAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICAgIG9mZnNldFBvc2l0aW9uOiBvZmZzZXRQb3NpdGlvbixcbiAgICAgICAgb2Zmc2V0Vmlld3BvcnQ6IG9mZnNldFZpZXdwb3J0LFxuICAgICAgICBvbjogb24sXG4gICAgICAgIG9uY2U6IG9uY2UsXG4gICAgICAgIG92ZXJmbG93UGFyZW50czogb3ZlcmZsb3dQYXJlbnRzLFxuICAgICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgICAgcGFyZW50czogcGFyZW50cyxcbiAgICAgICAgcGF1c2U6IHBhdXNlLFxuICAgICAgICBwaWNrOiBwaWNrLFxuICAgICAgICBwbGF5OiBwbGF5LFxuICAgICAgICBwb2ludEluUmVjdDogcG9pbnRJblJlY3QsXG4gICAgICAgIHBvaW50ZXJDYW5jZWw6IHBvaW50ZXJDYW5jZWwsXG4gICAgICAgIHBvaW50ZXJEb3duOiBwb2ludGVyRG93biQxLFxuICAgICAgICBwb2ludGVyRW50ZXI6IHBvaW50ZXJFbnRlcixcbiAgICAgICAgcG9pbnRlckxlYXZlOiBwb2ludGVyTGVhdmUsXG4gICAgICAgIHBvaW50ZXJNb3ZlOiBwb2ludGVyTW92ZSQxLFxuICAgICAgICBwb2ludGVyVXA6IHBvaW50ZXJVcCQxLFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgIHBvc2l0aW9uQXQ6IHBvc2l0aW9uQXQsXG4gICAgICAgIHByZXBlbmQ6IHByZXBlbmQsXG4gICAgICAgIHByb3BOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICBxdWVyeUFsbDogcXVlcnlBbGwsXG4gICAgICAgIHJlYWR5OiByZWFkeSxcbiAgICAgICAgcmVtb3ZlOiByZW1vdmUkMSxcbiAgICAgICAgcmVtb3ZlQXR0cjogcmVtb3ZlQXR0cixcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzLFxuICAgICAgICByZXBsYWNlQ2xhc3M6IHJlcGxhY2VDbGFzcyxcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHNjcm9sbEludG9WaWV3LFxuICAgICAgICBzY3JvbGxQYXJlbnQ6IHNjcm9sbFBhcmVudCxcbiAgICAgICAgc2Nyb2xsUGFyZW50czogc2Nyb2xsUGFyZW50cyxcbiAgICAgICAgc2Nyb2xsZWRPdmVyOiBzY3JvbGxlZE92ZXIsXG4gICAgICAgIHNlbEZvY3VzYWJsZTogc2VsRm9jdXNhYmxlLFxuICAgICAgICBzZWxJbnB1dDogc2VsSW5wdXQsXG4gICAgICAgIHNvcnRCeTogc29ydEJ5LFxuICAgICAgICBzdGFydHNXaXRoOiBzdGFydHNXaXRoLFxuICAgICAgICBzdW1CeTogc3VtQnksXG4gICAgICAgIHN3YXA6IHN3YXAsXG4gICAgICAgIHRvQXJyYXk6IHRvQXJyYXksXG4gICAgICAgIHRvQm9vbGVhbjogdG9Cb29sZWFuLFxuICAgICAgICB0b0V2ZW50VGFyZ2V0czogdG9FdmVudFRhcmdldHMsXG4gICAgICAgIHRvRmxvYXQ6IHRvRmxvYXQsXG4gICAgICAgIHRvTm9kZTogdG9Ob2RlLFxuICAgICAgICB0b05vZGVzOiB0b05vZGVzLFxuICAgICAgICB0b051bWJlcjogdG9OdW1iZXIsXG4gICAgICAgIHRvUHg6IHRvUHgsXG4gICAgICAgIHRvV2luZG93OiB0b1dpbmRvdyxcbiAgICAgICAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICAgICAgICB0cmlnZ2VyOiB0cmlnZ2VyLFxuICAgICAgICB1Y2ZpcnN0OiB1Y2ZpcnN0LFxuICAgICAgICB1bmlxdWVCeTogdW5pcXVlQnksXG4gICAgICAgIHVud3JhcDogdW53cmFwLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIHdyYXBBbGw6IHdyYXBBbGwsXG4gICAgICAgIHdyYXBJbm5lcjogd3JhcElubmVyXG4gICAgfSk7XG5cbiAgICB2YXIgQ2xhc3MgPSB7XG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLiRvcHRpb25zLmlkKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgdW5pdHMgPSBbXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiXTtcbiAgICB2YXIgY291bnRkb3duID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3NdLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGF0ZTogU3RyaW5nLFxuICAgICAgICBjbHNXcmFwcGVyOiBTdHJpbmcsXG4gICAgICAgIHJvbGU6IFN0cmluZyxcbiAgICAgICAgcmVsb2FkOiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRlOiBcIlwiLFxuICAgICAgICBjbHNXcmFwcGVyOiBcIi51ay1jb3VudGRvd24tJXVuaXQlXCIsXG4gICAgICAgIHJvbGU6IFwidGltZXJcIixcbiAgICAgICAgcmVsb2FkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgYXR0cih0aGlzLiRlbCwgXCJyb2xlXCIsIHRoaXMucm9sZSk7XG4gICAgICAgIHRoaXMuZGF0ZSA9IHRvRmxvYXQoRGF0ZS5wYXJzZSh0aGlzLiRwcm9wcy5kYXRlKSk7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRoaXMuZW5kID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgIH0sXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBuYW1lOiBcInZpc2liaWxpdHljaGFuZ2VcIixcbiAgICAgICAgZWw6ICgpID0+IGRvY3VtZW50LFxuICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wKCkge1xuICAgICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgXCJjb3VudGRvd25zdG9wXCIpO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGUoKSB7XG4gICAgICAgICAgY29uc3QgdGltZXNwYW4gPSBnZXRUaW1lU3Bhbih0aGlzLmRhdGUpO1xuICAgICAgICAgIGlmICghdGltZXNwYW4udG90YWwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVuZCkge1xuICAgICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCBcImNvdW50ZG93bmVuZFwiKTtcbiAgICAgICAgICAgICAgdGhpcy5lbmQgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAodGhpcy5yZWxvYWQgJiYgdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsIFwiY291bnRkb3duc3RhcnRcIik7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gc2V0SW50ZXJ2YWwodGhpcy51cGRhdGUsIDFlMyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgdW5pdCBvZiB1bml0cykge1xuICAgICAgICAgICAgY29uc3QgZWwgPSAkKHRoaXMuY2xzV3JhcHBlci5yZXBsYWNlKFwiJXVuaXQlXCIsIHVuaXQpLCB0aGlzLiRlbCk7XG4gICAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZ2l0cyA9IE1hdGgudHJ1bmModGltZXNwYW5bdW5pdF0pLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ICE9PSBkaWdpdHMpIHtcbiAgICAgICAgICAgICAgZGlnaXRzID0gZGlnaXRzLnNwbGl0KFwiXCIpO1xuICAgICAgICAgICAgICBpZiAoZGlnaXRzLmxlbmd0aCAhPT0gZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaHRtbChlbCwgZGlnaXRzLm1hcCgoKSA9PiBcIjxzcGFuPjwvc3Bhbj5cIikuam9pbihcIlwiKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGlnaXRzLmZvckVhY2goKGRpZ2l0LCBpKSA9PiBlbC5jaGlsZHJlbltpXS50ZXh0Q29udGVudCA9IGRpZ2l0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldFRpbWVTcGFuKGRhdGUpIHtcbiAgICAgIGNvbnN0IHRvdGFsID0gTWF0aC5tYXgoMCwgZGF0ZSAtIERhdGUubm93KCkpIC8gMWUzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG90YWwsXG4gICAgICAgIHNlY29uZHM6IHRvdGFsICUgNjAsXG4gICAgICAgIG1pbnV0ZXM6IHRvdGFsIC8gNjAgJSA2MCxcbiAgICAgICAgaG91cnM6IHRvdGFsIC8gNjAgLyA2MCAlIDI0LFxuICAgICAgICBkYXlzOiB0b3RhbCAvIDYwIC8gNjAgLyAyNFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHJhdHMgPSB7fTtcbiAgICBzdHJhdHMuZXZlbnRzID0gc3RyYXRzLndhdGNoID0gc3RyYXRzLm9ic2VydmUgPSBzdHJhdHMuY3JlYXRlZCA9IHN0cmF0cy5iZWZvcmVDb25uZWN0ID0gc3RyYXRzLmNvbm5lY3RlZCA9IHN0cmF0cy5iZWZvcmVEaXNjb25uZWN0ID0gc3RyYXRzLmRpc2Nvbm5lY3RlZCA9IHN0cmF0cy5kZXN0cm95ID0gY29uY2F0U3RyYXQ7XG4gICAgc3RyYXRzLmFyZ3MgPSBmdW5jdGlvbihwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWwgIT09IGZhbHNlICYmIGNvbmNhdFN0cmF0KGNoaWxkVmFsIHx8IHBhcmVudFZhbCk7XG4gICAgfTtcbiAgICBzdHJhdHMudXBkYXRlID0gZnVuY3Rpb24ocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHNvcnRCeShcbiAgICAgICAgY29uY2F0U3RyYXQocGFyZW50VmFsLCBpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IHsgcmVhZDogY2hpbGRWYWwgfSA6IGNoaWxkVmFsKSxcbiAgICAgICAgXCJvcmRlclwiXG4gICAgICApO1xuICAgIH07XG4gICAgc3RyYXRzLnByb3BzID0gZnVuY3Rpb24ocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgaWYgKGlzQXJyYXkoY2hpbGRWYWwpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGNoaWxkVmFsKSB7XG4gICAgICAgICAgdmFsdWVba2V5XSA9IFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFZhbCA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmF0cy5tZXRob2RzKHBhcmVudFZhbCwgY2hpbGRWYWwpO1xuICAgIH07XG4gICAgc3RyYXRzLmNvbXB1dGVkID0gc3RyYXRzLm1ldGhvZHMgPSBmdW5jdGlvbihwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gY2hpbGRWYWwgPyBwYXJlbnRWYWwgPyB7IC4uLnBhcmVudFZhbCwgLi4uY2hpbGRWYWwgfSA6IGNoaWxkVmFsIDogcGFyZW50VmFsO1xuICAgIH07XG4gICAgc3RyYXRzLmkxOG4gPSBzdHJhdHMuZGF0YSA9IGZ1bmN0aW9uKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gICAgICBpZiAoIXZtKSB7XG4gICAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50VmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkVmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2bTIpIHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2VGbkRhdGEocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0yKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZUZuRGF0YShwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtZXJnZUZuRGF0YShwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSkge1xuICAgICAgcmV0dXJuIHN0cmF0cy5jb21wdXRlZChcbiAgICAgICAgaXNGdW5jdGlvbihwYXJlbnRWYWwpID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKSA6IHBhcmVudFZhbCxcbiAgICAgICAgaXNGdW5jdGlvbihjaGlsZFZhbCkgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSkgOiBjaGlsZFZhbFxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29uY2F0U3RyYXQocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgICAgcGFyZW50VmFsID0gcGFyZW50VmFsICYmICFpc0FycmF5KHBhcmVudFZhbCkgPyBbcGFyZW50VmFsXSA6IHBhcmVudFZhbDtcbiAgICAgIHJldHVybiBjaGlsZFZhbCA/IHBhcmVudFZhbCA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpIDogaXNBcnJheShjaGlsZFZhbCkgPyBjaGlsZFZhbCA6IFtjaGlsZFZhbF0gOiBwYXJlbnRWYWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTdHJhdChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgICByZXR1cm4gaXNVbmRlZmluZWQoY2hpbGRWYWwpID8gcGFyZW50VmFsIDogY2hpbGRWYWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLCB2bSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgaWYgKGlzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBtaXhpbiBvZiBjaGlsZC5taXhpbnMpIHtcbiAgICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBtaXhpbiwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJlbnQpIHtcbiAgICAgICAgbWVyZ2VLZXkoa2V5KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkKSB7XG4gICAgICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgICAgIG1lcmdlS2V5KGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG1lcmdlS2V5KGtleSkge1xuICAgICAgICBvcHRpb25zW2tleV0gPSAoc3RyYXRzW2tleV0gfHwgZGVmYXVsdFN0cmF0KShwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRpb25zLCBhcmdzID0gW10pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zID8gc3RhcnRzV2l0aChvcHRpb25zLCBcIntcIikgPyBKU09OLnBhcnNlKG9wdGlvbnMpIDogYXJncy5sZW5ndGggJiYgIWluY2x1ZGVzKG9wdGlvbnMsIFwiOlwiKSA/IHsgW2FyZ3NbMF1dOiBvcHRpb25zIH0gOiBvcHRpb25zLnNwbGl0KFwiO1wiKS5yZWR1Y2UoKG9wdGlvbnMyLCBvcHRpb24pID0+IHtcbiAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBvcHRpb24uc3BsaXQoLzooLiopLyk7XG4gICAgICAgICAgaWYgKGtleSAmJiAhaXNVbmRlZmluZWQodmFsdWUpKSB7XG4gICAgICAgICAgICBvcHRpb25zMltrZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMyO1xuICAgICAgICB9LCB7fSkgOiB7fTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb2VyY2UkMSh0eXBlLCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGUgPT09IEJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuIHRvQm9vbGVhbih2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IE51bWJlcikge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImxpc3RcIikge1xuICAgICAgICByZXR1cm4gdG9MaXN0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gT2JqZWN0ICYmIGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VPcHRpb25zKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlID8gdHlwZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgbGlzdFJlID0gLywoPyFbXihdKlxcKSkvO1xuICAgIGZ1bmN0aW9uIHRvTGlzdCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBpc1N0cmluZyh2YWx1ZSkgPyB2YWx1ZS5zcGxpdChsaXN0UmUpLm1hcCgodmFsdWUyKSA9PiBpc051bWVyaWModmFsdWUyKSA/IHRvTnVtYmVyKHZhbHVlMikgOiB0b0Jvb2xlYW4odmFsdWUyLnRyaW0oKSkpIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0VXBkYXRlcyhpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuX2RhdGEgPSB7fTtcbiAgICAgIGluc3RhbmNlLl91cGRhdGVzID0gWy4uLmluc3RhbmNlLiRvcHRpb25zLnVwZGF0ZSB8fCBbXV07XG4gICAgICBpbnN0YW5jZS5fZGlzY29ubmVjdC5wdXNoKCgpID0+IGluc3RhbmNlLl91cGRhdGVzID0gaW5zdGFuY2UuX2RhdGEgPSBudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGVuZFVwZGF0ZShpbnN0YW5jZSwgdXBkYXRlKSB7XG4gICAgICBpbnN0YW5jZS5fdXBkYXRlcy51bnNoaWZ0KHVwZGF0ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxVcGRhdGUoaW5zdGFuY2UsIGUgPSBcInVwZGF0ZVwiKSB7XG4gICAgICBpZiAoIWluc3RhbmNlLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpbnN0YW5jZS5fdXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFpbnN0YW5jZS5fcXVldWVkKSB7XG4gICAgICAgIGluc3RhbmNlLl9xdWV1ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgIGlmIChpbnN0YW5jZS5fY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBydW5VcGRhdGVzKGluc3RhbmNlLCBpbnN0YW5jZS5fcXVldWVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zdGFuY2UuX3F1ZXVlZCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UuX3F1ZXVlZC5hZGQoZS50eXBlIHx8IGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBydW5VcGRhdGVzKGluc3RhbmNlLCB0eXBlcykge1xuICAgICAgZm9yIChjb25zdCB7IHJlYWQsIHdyaXRlLCBldmVudHMgPSBbXSB9IG9mIGluc3RhbmNlLl91cGRhdGVzKSB7XG4gICAgICAgIGlmICghdHlwZXMuaGFzKFwidXBkYXRlXCIpICYmICFldmVudHMuc29tZSgodHlwZSkgPT4gdHlwZXMuaGFzKHR5cGUpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChyZWFkKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcmVhZC5jYWxsKGluc3RhbmNlLCBpbnN0YW5jZS5fZGF0YSwgdHlwZXMpO1xuICAgICAgICAgIGlmIChyZXN1bHQgJiYgaXNQbGFpbk9iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBhc3NpZ24oaW5zdGFuY2UuX2RhdGEsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3cml0ZSAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICB3cml0ZS5jYWxsKGluc3RhbmNlLCBpbnN0YW5jZS5fZGF0YSwgdHlwZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlKG9ic2VydmVSZXNpemUsIG9wdGlvbnMsIFwicmVzaXplXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9ic2VydmUob2JzZXJ2ZUludGVyc2VjdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11dGF0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlKG9ic2VydmVNdXRhdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxhenlsb2FkKG9wdGlvbnMgPSB7fSkge1xuICAgICAgcmV0dXJuIGludGVyc2VjdGlvbih7XG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uKGVudHJpZXMsIG9ic2VydmVyKSB7XG4gICAgICAgICAgY29uc3QgeyB0YXJnZXRzID0gdGhpcy4kZWwsIHByZWxvYWQgPSA1IH0gPSBvcHRpb25zO1xuICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdG9Ob2Rlcyhpc0Z1bmN0aW9uKHRhcmdldHMpID8gdGFyZ2V0cyh0aGlzKSA6IHRhcmdldHMpKSB7XG4gICAgICAgICAgICAkJCgnW2xvYWRpbmc9XCJsYXp5XCJdJywgZWwpLnNsaWNlKDAsIHByZWxvYWQgLSAxKS5mb3JFYWNoKChlbDIpID0+IHJlbW92ZUF0dHIoZWwyLCBcImxvYWRpbmdcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGVudHJpZXMuZmlsdGVyKCh7IGlzSW50ZXJzZWN0aW5nIH0pID0+IGlzSW50ZXJzZWN0aW5nKS5tYXAoKHsgdGFyZ2V0IH0pID0+IHRhcmdldCkpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmlld3BvcnQob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9ic2VydmUoKHRhcmdldCwgaGFuZGxlcikgPT4gb2JzZXJ2ZVZpZXdwb3J0UmVzaXplKGhhbmRsZXIpLCBvcHRpb25zLCBcInJlc2l6ZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2Nyb2xsJDEob3B0aW9ucykge1xuICAgICAgcmV0dXJuIG9ic2VydmUoXG4gICAgICAgICh0YXJnZXQsIGhhbmRsZXIpID0+ICh7XG4gICAgICAgICAgZGlzY29ubmVjdDogb24odG9TY3JvbGxUYXJnZXRzKHRhcmdldCksIFwic2Nyb2xsXCIsIGhhbmRsZXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KVxuICAgICAgICB9KSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgXCJzY3JvbGxcIlxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpcGUob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2JzZXJ2ZSh0YXJnZXQsIGhhbmRsZXIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2JzZXJ2ZTogbm9vcCxcbiAgICAgICAgICAgIHVub2JzZXJ2ZTogbm9vcCxcbiAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IG9uKHRhcmdldCwgcG9pbnRlckRvd24kMSwgaGFuZGxlciwgeyBwYXNzaXZlOiB0cnVlIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKCFpc1RvdWNoKGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEV2ZW50UG9zKGUpO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IFwidGFnTmFtZVwiIGluIGUudGFyZ2V0ID8gZS50YXJnZXQgOiBwYXJlbnQoZS50YXJnZXQpO1xuICAgICAgICAgIG9uY2UoZG9jdW1lbnQsIGAke3BvaW50ZXJVcCQxfSAke3BvaW50ZXJDYW5jZWx9IHNjcm9sbGAsIChlMikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvcyhlMik7XG4gICAgICAgICAgICBpZiAoZTIudHlwZSAhPT0gXCJzY3JvbGxcIiAmJiB0YXJnZXQgJiYgeCAmJiBNYXRoLmFicyhwb3MueCAtIHgpID4gMTAwIHx8IHkgJiYgTWF0aC5hYnMocG9zLnkgLSB5KSA+IDEwMCkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzd2lwZVwiKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRhcmdldCwgYHN3aXBlJHtzd2lwZURpcmVjdGlvbihwb3MueCwgcG9zLnksIHgsIHkpfWApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb2JzZXJ2ZShvYnNlcnZlMiwgb3B0aW9ucywgZW1pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2JzZXJ2ZTogb2JzZXJ2ZTIsXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgY2FsbFVwZGF0ZSh0aGlzLCBlbWl0KTtcbiAgICAgICAgfSxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3dpcGVEaXJlY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA+PSBNYXRoLmFicyh5MSAtIHkyKSA/IHgxIC0geDIgPiAwID8gXCJMZWZ0XCIgOiBcIlJpZ2h0XCIgOiB5MSAtIHkyID4gMCA/IFwiVXBcIiA6IFwiRG93blwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b1Njcm9sbFRhcmdldHMoZWxlbWVudHMpIHtcbiAgICAgIHJldHVybiB0b05vZGVzKGVsZW1lbnRzKS5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBvd25lckRvY3VtZW50IH0gPSBub2RlO1xuICAgICAgICBjb25zdCBwYXJlbnQyID0gc2Nyb2xsUGFyZW50KG5vZGUsIHRydWUpO1xuICAgICAgICByZXR1cm4gcGFyZW50MiA9PT0gb3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50ID8gb3duZXJEb2N1bWVudCA6IHBhcmVudDI7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgTWFyZ2luID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbWFyZ2luOiBTdHJpbmcsXG4gICAgICAgIGZpcnN0Q29sdW1uOiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBtYXJnaW46IFwidWstbWFyZ2luLXNtYWxsLXRvcFwiLFxuICAgICAgICBmaXJzdENvbHVtbjogXCJ1ay1maXJzdC1jb2x1bW5cIlxuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IFtcbiAgICAgICAgbXV0YXRpb24oe1xuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG11dGF0aW9uKHtcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJzdHlsZVwiXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0OiAoeyAkZWwgfSkgPT4gWyRlbCwgLi4uY2hpbGRyZW4oJGVsKV1cbiAgICAgICAgfSksXG4gICAgICAgIHJlc2l6ZSh7XG4gICAgICAgICAgdGFyZ2V0OiAoeyAkZWwgfSkgPT4gWyRlbCwgLi4uY2hpbGRyZW4oJGVsKV1cbiAgICAgICAgfSlcbiAgICAgIF0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm93czogZ2V0Um93cyhjaGlsZHJlbih0aGlzLiRlbCkpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGUoeyByb3dzIH0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHJvdykge1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5tYXJnaW4sIHJvd3NbMF0gIT09IHJvdyk7XG4gICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsLCB0aGlzLmZpcnN0Q29sdW1uLCByb3dbaXNSdGwgPyByb3cubGVuZ3RoIC0gMSA6IDBdID09PSBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IFtcInJlc2l6ZVwiXVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0Um93cyhlbGVtZW50cykge1xuICAgICAgY29uc3Qgc29ydGVkID0gW1tdXTtcbiAgICAgIGNvbnN0IHdpdGhPZmZzZXQgPSBlbGVtZW50cy5zb21lKFxuICAgICAgICAoZWwsIGkpID0+IGkgJiYgZWxlbWVudHNbaSAtIDFdLm9mZnNldFBhcmVudCAhPT0gZWwub2Zmc2V0UGFyZW50XG4gICAgICApO1xuICAgICAgZm9yIChjb25zdCBlbCBvZiBlbGVtZW50cykge1xuICAgICAgICBpZiAoIWlzVmlzaWJsZShlbCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSBnZXRPZmZzZXQoZWwsIHdpdGhPZmZzZXQpO1xuICAgICAgICBmb3IgKGxldCBpID0gc29ydGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IHNvcnRlZFtpXTtcbiAgICAgICAgICBpZiAoIWN1cnJlbnRbMF0pIHtcbiAgICAgICAgICAgIGN1cnJlbnQucHVzaChlbCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0Q3VycmVudCA9IGdldE9mZnNldChjdXJyZW50WzBdLCB3aXRoT2Zmc2V0KTtcbiAgICAgICAgICBpZiAob2Zmc2V0LnRvcCA+PSBvZmZzZXRDdXJyZW50LmJvdHRvbSAtIDEgJiYgb2Zmc2V0LnRvcCAhPT0gb2Zmc2V0Q3VycmVudC50b3ApIHtcbiAgICAgICAgICAgIHNvcnRlZC5wdXNoKFtlbF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvZmZzZXQuYm90dG9tIC0gMSA+IG9mZnNldEN1cnJlbnQudG9wIHx8IG9mZnNldC50b3AgPT09IG9mZnNldEN1cnJlbnQudG9wKSB7XG4gICAgICAgICAgICBsZXQgaiA9IGN1cnJlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICBjb25zdCBvZmZzZXRDdXJyZW50MiA9IGdldE9mZnNldChjdXJyZW50W2pdLCB3aXRoT2Zmc2V0KTtcbiAgICAgICAgICAgICAgaWYgKG9mZnNldC5sZWZ0ID49IG9mZnNldEN1cnJlbnQyLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudC5zcGxpY2UoaiArIDEsIDAsIGVsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgc29ydGVkLnVuc2hpZnQoW2VsXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3J0ZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE9mZnNldChlbGVtZW50LCBvZmZzZXQgPSBmYWxzZSkge1xuICAgICAgbGV0IHsgb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0LCBvZmZzZXRIZWlnaHQsIG9mZnNldFdpZHRoIH0gPSBlbGVtZW50O1xuICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICBbb2Zmc2V0VG9wLCBvZmZzZXRMZWZ0XSA9IG9mZnNldFBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBvZmZzZXRUb3AsXG4gICAgICAgIGxlZnQ6IG9mZnNldExlZnQsXG4gICAgICAgIGJvdHRvbTogb2Zmc2V0VG9wICsgb2Zmc2V0SGVpZ2h0LFxuICAgICAgICByaWdodDogb2Zmc2V0TGVmdCArIG9mZnNldFdpZHRoXG4gICAgICB9O1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIHNsaWRlKGFjdGlvbiwgdGFyZ2V0LCBkdXJhdGlvbikge1xuICAgICAgYXdhaXQgYXdhaXRGcmFtZSgpO1xuICAgICAgbGV0IG5vZGVzID0gY2hpbGRyZW4odGFyZ2V0KTtcbiAgICAgIGNvbnN0IGN1cnJlbnRQcm9wcyA9IG5vZGVzLm1hcCgoZWwpID0+IGdldFByb3BzJDEoZWwsIHRydWUpKTtcbiAgICAgIGNvbnN0IHRhcmdldFByb3BzID0geyAuLi5jc3ModGFyZ2V0LCBbXCJoZWlnaHRcIiwgXCJwYWRkaW5nXCJdKSwgZGlzcGxheTogXCJibG9ja1wiIH07XG4gICAgICBjb25zdCB0YXJnZXRzID0gbm9kZXMuY29uY2F0KHRhcmdldCk7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh0YXJnZXRzLm1hcChUcmFuc2l0aW9uLmNhbmNlbCkpO1xuICAgICAgY3NzKHRhcmdldHMsIFwidHJhbnNpdGlvblByb3BlcnR5XCIsIFwibm9uZVwiKTtcbiAgICAgIGF3YWl0IGFjdGlvbigpO1xuICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY2hpbGRyZW4odGFyZ2V0KS5maWx0ZXIoKGVsKSA9PiAhaW5jbHVkZXMobm9kZXMsIGVsKSkpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBjc3ModGFyZ2V0cywgXCJ0cmFuc2l0aW9uUHJvcGVydHlcIiwgXCJcIik7XG4gICAgICBjb25zdCB0YXJnZXRTdHlsZSA9IGF0dHIodGFyZ2V0LCBcInN0eWxlXCIpO1xuICAgICAgY29uc3QgdGFyZ2V0UHJvcHNUbyA9IGNzcyh0YXJnZXQsIFtcImhlaWdodFwiLCBcInBhZGRpbmdcIl0pO1xuICAgICAgY29uc3QgW3Byb3BzVG8sIHByb3BzRnJvbV0gPSBnZXRUcmFuc2l0aW9uUHJvcHModGFyZ2V0LCBub2RlcywgY3VycmVudFByb3BzKTtcbiAgICAgIGNvbnN0IGF0dHJzVG8gPSBub2Rlcy5tYXAoKGVsKSA9PiAoeyBzdHlsZTogYXR0cihlbCwgXCJzdHlsZVwiKSB9KSk7XG4gICAgICBub2Rlcy5mb3JFYWNoKChlbCwgaSkgPT4gcHJvcHNGcm9tW2ldICYmIGNzcyhlbCwgcHJvcHNGcm9tW2ldKSk7XG4gICAgICBjc3ModGFyZ2V0LCB0YXJnZXRQcm9wcyk7XG4gICAgICB0cmlnZ2VyKHRhcmdldCwgXCJzY3JvbGxcIik7XG4gICAgICBhd2FpdCBhd2FpdEZyYW1lKCk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9ucyA9IG5vZGVzLm1hcCgoZWwsIGkpID0+IHBhcmVudChlbCkgPT09IHRhcmdldCAmJiBUcmFuc2l0aW9uLnN0YXJ0KGVsLCBwcm9wc1RvW2ldLCBkdXJhdGlvbiwgXCJlYXNlXCIpKS5jb25jYXQoVHJhbnNpdGlvbi5zdGFydCh0YXJnZXQsIHRhcmdldFByb3BzVG8sIGR1cmF0aW9uLCBcImVhc2VcIikpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwodHJhbnNpdGlvbnMpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKChlbCwgaSkgPT4ge1xuICAgICAgICAgIGF0dHIoZWwsIGF0dHJzVG9baV0pO1xuICAgICAgICAgIGlmIChwYXJlbnQoZWwpID09PSB0YXJnZXQpIHtcbiAgICAgICAgICAgIGNzcyhlbCwgXCJkaXNwbGF5XCIsIHByb3BzVG9baV0ub3BhY2l0eSA9PT0gMCA/IFwibm9uZVwiIDogXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYXR0cih0YXJnZXQsIFwic3R5bGVcIiwgdGFyZ2V0U3R5bGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhdHRyKG5vZGVzLCBcInN0eWxlXCIsIFwiXCIpO1xuICAgICAgICByZXNldFByb3BzKHRhcmdldCwgdGFyZ2V0UHJvcHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQcm9wcyQxKGVsLCBvcGFjaXR5KSB7XG4gICAgICBjb25zdCB6SW5kZXggPSBjc3MoZWwsIFwiekluZGV4XCIpO1xuICAgICAgcmV0dXJuIGlzVmlzaWJsZShlbCkgPyB7XG4gICAgICAgIGRpc3BsYXk6IFwiXCIsXG4gICAgICAgIG9wYWNpdHk6IG9wYWNpdHkgPyBjc3MoZWwsIFwib3BhY2l0eVwiKSA6IFwiMFwiLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIixcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgekluZGV4OiB6SW5kZXggPT09IFwiYXV0b1wiID8gaW5kZXgoZWwpIDogekluZGV4LFxuICAgICAgICAuLi5nZXRQb3NpdGlvbldpdGhNYXJnaW4oZWwpXG4gICAgICB9IDogZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRyYW5zaXRpb25Qcm9wcyh0YXJnZXQsIG5vZGVzLCBjdXJyZW50UHJvcHMpIHtcbiAgICAgIGNvbnN0IHByb3BzVG8gPSBub2Rlcy5tYXAoXG4gICAgICAgIChlbCwgaSkgPT4gcGFyZW50KGVsKSAmJiBpIGluIGN1cnJlbnRQcm9wcyA/IGN1cnJlbnRQcm9wc1tpXSA/IGlzVmlzaWJsZShlbCkgPyBnZXRQb3NpdGlvbldpdGhNYXJnaW4oZWwpIDogeyBvcGFjaXR5OiAwIH0gOiB7IG9wYWNpdHk6IGlzVmlzaWJsZShlbCkgPyAxIDogMCB9IDogZmFsc2VcbiAgICAgICk7XG4gICAgICBjb25zdCBwcm9wc0Zyb20gPSBwcm9wc1RvLm1hcCgocHJvcHMsIGkpID0+IHtcbiAgICAgICAgY29uc3QgZnJvbSA9IHBhcmVudChub2Rlc1tpXSkgPT09IHRhcmdldCAmJiAoY3VycmVudFByb3BzW2ldIHx8IGdldFByb3BzJDEobm9kZXNbaV0pKTtcbiAgICAgICAgaWYgKCFmcm9tKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICBkZWxldGUgZnJvbS5vcGFjaXR5O1xuICAgICAgICB9IGVsc2UgaWYgKCEoXCJvcGFjaXR5XCIgaW4gcHJvcHMpKSB7XG4gICAgICAgICAgY29uc3QgeyBvcGFjaXR5IH0gPSBmcm9tO1xuICAgICAgICAgIGlmIChvcGFjaXR5ICUgMSkge1xuICAgICAgICAgICAgcHJvcHMub3BhY2l0eSA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBmcm9tLm9wYWNpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Byb3BzVG8sIHByb3BzRnJvbV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0UHJvcHMoZWwsIHByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgY3NzKGVsLCBwcm9wLCBcIlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25XaXRoTWFyZ2luKGVsKSB7XG4gICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IGRpbWVuc2lvbnMkMShlbCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICB0cmFuc2Zvcm06IFwiXCIsXG4gICAgICAgIC4uLnBvc2l0aW9uKGVsKSxcbiAgICAgICAgLi4uY3NzKGVsLCBbXCJtYXJnaW5Ub3BcIiwgXCJtYXJnaW5MZWZ0XCJdKVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXdhaXRGcmFtZSgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpKTtcbiAgICB9XG5cbiAgICBjb25zdCBjbHNMZWF2ZSA9IFwidWstdHJhbnNpdGlvbi1sZWF2ZVwiO1xuICAgIGNvbnN0IGNsc0VudGVyID0gXCJ1ay10cmFuc2l0aW9uLWVudGVyXCI7XG4gICAgZnVuY3Rpb24gZmFkZShhY3Rpb24sIHRhcmdldCwgZHVyYXRpb24sIHN0YWdnZXIgPSAwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRyYW5zaXRpb25JbmRleCh0YXJnZXQsIHRydWUpO1xuICAgICAgY29uc3QgcHJvcHNJbiA9IHsgb3BhY2l0eTogMSB9O1xuICAgICAgY29uc3QgcHJvcHNPdXQgPSB7IG9wYWNpdHk6IDAgfTtcbiAgICAgIGNvbnN0IHdyYXBJbmRleEZuID0gKGZuKSA9PiAoKSA9PiBpbmRleCA9PT0gdHJhbnNpdGlvbkluZGV4KHRhcmdldCkgPyBmbigpIDogUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgIGNvbnN0IGxlYXZlRm4gPSB3cmFwSW5kZXhGbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGFkZENsYXNzKHRhcmdldCwgY2xzTGVhdmUpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBnZXRUcmFuc2l0aW9uTm9kZXModGFyZ2V0KS5tYXAoXG4gICAgICAgICAgICAoY2hpbGQsIGkpID0+IG5ldyBQcm9taXNlKFxuICAgICAgICAgICAgICAocmVzb2x2ZSkgPT4gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAoKSA9PiBUcmFuc2l0aW9uLnN0YXJ0KGNoaWxkLCBwcm9wc091dCwgZHVyYXRpb24gLyAyLCBcImVhc2VcIikudGhlbihcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGkgKiBzdGFnZ2VyXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIHJlbW92ZUNsYXNzKHRhcmdldCwgY2xzTGVhdmUpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBlbnRlckZuID0gd3JhcEluZGV4Rm4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBvbGRIZWlnaHQgPSBoZWlnaHQodGFyZ2V0KTtcbiAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCBjbHNFbnRlcik7XG4gICAgICAgIGFjdGlvbigpO1xuICAgICAgICBjc3MoY2hpbGRyZW4odGFyZ2V0KSwgeyBvcGFjaXR5OiAwIH0pO1xuICAgICAgICBhd2FpdCBhd2FpdEZyYW1lKCk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGRyZW4odGFyZ2V0KTtcbiAgICAgICAgY29uc3QgbmV3SGVpZ2h0ID0gaGVpZ2h0KHRhcmdldCk7XG4gICAgICAgIGNzcyh0YXJnZXQsIFwiYWxpZ25Db250ZW50XCIsIFwiZmxleC1zdGFydFwiKTtcbiAgICAgICAgaGVpZ2h0KHRhcmdldCwgb2xkSGVpZ2h0KTtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbk5vZGVzID0gZ2V0VHJhbnNpdGlvbk5vZGVzKHRhcmdldCk7XG4gICAgICAgIGNzcyhub2RlcywgcHJvcHNPdXQpO1xuICAgICAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25Ob2Rlcy5tYXAoYXN5bmMgKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgICAgYXdhaXQgYXdhaXRUaW1lb3V0KGkgKiBzdGFnZ2VyKTtcbiAgICAgICAgICBhd2FpdCBUcmFuc2l0aW9uLnN0YXJ0KGNoaWxkLCBwcm9wc0luLCBkdXJhdGlvbiAvIDIsIFwiZWFzZVwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvbGRIZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgIHRyYW5zaXRpb25zLnB1c2goXG4gICAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KFxuICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgIHsgaGVpZ2h0OiBuZXdIZWlnaHQgfSxcbiAgICAgICAgICAgICAgZHVyYXRpb24gLyAyICsgdHJhbnNpdGlvbk5vZGVzLmxlbmd0aCAqIHN0YWdnZXIsXG4gICAgICAgICAgICAgIFwiZWFzZVwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbCh0cmFuc2l0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGFyZ2V0LCBjbHNFbnRlcik7XG4gICAgICAgICAgaWYgKGluZGV4ID09PSB0cmFuc2l0aW9uSW5kZXgodGFyZ2V0KSkge1xuICAgICAgICAgICAgY3NzKHRhcmdldCwgeyBoZWlnaHQ6IFwiXCIsIGFsaWduQ29udGVudDogXCJcIiB9KTtcbiAgICAgICAgICAgIGNzcyhub2RlcywgeyBvcGFjaXR5OiBcIlwiIH0pO1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldC5kYXRhc2V0LnRyYW5zaXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhhc0NsYXNzKHRhcmdldCwgY2xzTGVhdmUpID8gd2FpdFRyYW5zaXRpb25lbmQodGFyZ2V0KS50aGVuKGVudGVyRm4pIDogaGFzQ2xhc3ModGFyZ2V0LCBjbHNFbnRlcikgPyB3YWl0VHJhbnNpdGlvbmVuZCh0YXJnZXQpLnRoZW4obGVhdmVGbikudGhlbihlbnRlckZuKSA6IGxlYXZlRm4oKS50aGVuKGVudGVyRm4pO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2l0aW9uSW5kZXgodGFyZ2V0LCBuZXh0KSB7XG4gICAgICBpZiAobmV4dCkge1xuICAgICAgICB0YXJnZXQuZGF0YXNldC50cmFuc2l0aW9uID0gMSArIHRyYW5zaXRpb25JbmRleCh0YXJnZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvTnVtYmVyKHRhcmdldC5kYXRhc2V0LnRyYW5zaXRpb24pIHx8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhaXRUcmFuc2l0aW9uZW5kKHRhcmdldCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICBjaGlsZHJlbih0YXJnZXQpLmZpbHRlcihUcmFuc2l0aW9uLmluUHJvZ3Jlc3MpLm1hcChcbiAgICAgICAgICAoZWwpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBvbmNlKGVsLCBcInRyYW5zaXRpb25lbmQgdHJhbnNpdGlvbmNhbmNlbGVkXCIsIHJlc29sdmUpKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uTm9kZXModGFyZ2V0KSB7XG4gICAgICByZXR1cm4gZ2V0Um93cyhjaGlsZHJlbih0YXJnZXQpKS5mbGF0KCkuZmlsdGVyKGlzVmlzaWJsZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF3YWl0VGltZW91dCh0aW1lb3V0KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCkpO1xuICAgIH1cblxuICAgIHZhciBBbmltYXRlID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZHVyYXRpb246IE51bWJlcixcbiAgICAgICAgYW5pbWF0aW9uOiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBkdXJhdGlvbjogMTUwLFxuICAgICAgICBhbmltYXRpb246IFwic2xpZGVcIlxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYW5pbWF0ZShhY3Rpb24sIHRhcmdldCA9IHRoaXMuJGVsKSB7XG4gICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkZuID0gbmFtZSA9PT0gXCJmYWRlXCIgPyBmYWRlIDogbmFtZSA9PT0gXCJkZWxheWVkLWZhZGVcIiA/ICguLi5hcmdzKSA9PiBmYWRlKC4uLmFyZ3MsIDQwKSA6IG5hbWUgPyBzbGlkZSA6ICgpID0+IHtcbiAgICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkZuKGFjdGlvbiwgdGFyZ2V0LCB0aGlzLmR1cmF0aW9uKS5jYXRjaChub29wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBrZXlNYXAgPSB7XG4gICAgICBUQUI6IDksXG4gICAgICBFU0M6IDI3LFxuICAgICAgU1BBQ0U6IDMyLFxuICAgICAgRU5EOiAzNSxcbiAgICAgIEhPTUU6IDM2LFxuICAgICAgTEVGVDogMzcsXG4gICAgICBVUDogMzgsXG4gICAgICBSSUdIVDogMzksXG4gICAgICBET1dOOiA0MFxuICAgIH07XG5cbiAgICB2YXIgZmlsdGVyID0ge1xuICAgICAgbWl4aW5zOiBbQW5pbWF0ZV0sXG4gICAgICBhcmdzOiBcInRhcmdldFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIHNlbEFjdGl2ZTogQm9vbGVhblxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiBcIlwiLFxuICAgICAgICBzZWxBY3RpdmU6IGZhbHNlLFxuICAgICAgICBhdHRySXRlbTogXCJ1ay1maWx0ZXItY29udHJvbFwiLFxuICAgICAgICBjbHM6IFwidWstYWN0aXZlXCIsXG4gICAgICAgIGR1cmF0aW9uOiAyNTBcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjaGlsZHJlbjogKHsgdGFyZ2V0IH0sICRlbCkgPT4gJCQoYCR7dGFyZ2V0fSA+ICpgLCAkZWwpLFxuICAgICAgICB0b2dnbGVzOiAoeyBhdHRySXRlbSB9LCAkZWwpID0+ICQkKGBbJHthdHRySXRlbX1dLFtkYXRhLSR7YXR0ckl0ZW19XWAsICRlbClcbiAgICAgIH0sXG4gICAgICB3YXRjaDoge1xuICAgICAgICB0b2dnbGVzKHRvZ2dsZXMpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgYWN0aXZlcyA9ICQkKHRoaXMuc2VsQWN0aXZlLCB0aGlzLiRlbCk7XG4gICAgICAgICAgZm9yIChjb25zdCB0b2dnbGUgb2YgdG9nZ2xlcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsQWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyh0b2dnbGUsIHRoaXMuY2xzLCBpbmNsdWRlcyhhY3RpdmVzLCB0b2dnbGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGZpbmRCdXR0b24odG9nZ2xlKTtcbiAgICAgICAgICAgIGlmIChpc1RhZyhidXR0b24sIFwiYVwiKSkge1xuICAgICAgICAgICAgICBhdHRyKGJ1dHRvbiwgXCJyb2xlXCIsIFwiYnV0dG9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW4obGlzdCwgcHJldikge1xuICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIG5hbWU6IFwiY2xpY2sga2V5ZG93blwiLFxuICAgICAgICBkZWxlZ2F0ZTogKHsgYXR0ckl0ZW0gfSkgPT4gYFske2F0dHJJdGVtfV0sW2RhdGEtJHthdHRySXRlbX1dYCxcbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKGUudHlwZSA9PT0gXCJrZXlkb3duXCIgJiYgZS5rZXlDb2RlICE9PSBrZXlNYXAuU1BBQ0UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUudGFyZ2V0LmNsb3Nlc3QoXCJhLGJ1dHRvblwiKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5hcHBseShlLmN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXBwbHkoZWwpIHtcbiAgICAgICAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBtZXJnZVN0YXRlKGVsLCB0aGlzLmF0dHJJdGVtLCB0aGlzLmdldFN0YXRlKCkpO1xuICAgICAgICAgIGlmICghaXNFcXVhbFN0YXRlKHByZXZTdGF0ZSwgbmV3U3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldFN0YXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZXMuZmlsdGVyKChpdGVtKSA9PiBoYXNDbGFzcyhpdGVtLCB0aGlzLmNscykpLnJlZHVjZSgoc3RhdGUsIGVsKSA9PiBtZXJnZVN0YXRlKGVsLCB0aGlzLmF0dHJJdGVtLCBzdGF0ZSksIHtcbiAgICAgICAgICAgIGZpbHRlcjogeyBcIlwiOiBcIlwiIH0sXG4gICAgICAgICAgICBzb3J0OiBbXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBzZXRTdGF0ZShzdGF0ZSwgYW5pbWF0ZSA9IHRydWUpIHtcbiAgICAgICAgICBzdGF0ZSA9IHsgZmlsdGVyOiB7IFwiXCI6IFwiXCIgfSwgc29ydDogW10sIC4uLnN0YXRlIH07XG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgXCJiZWZvcmVGaWx0ZXJcIiwgW3RoaXMsIHN0YXRlXSk7XG4gICAgICAgICAgZm9yIChjb25zdCB0b2dnbGUgb2YgdGhpcy50b2dnbGVzKSB7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyh0b2dnbGUsIHRoaXMuY2xzLCBtYXRjaEZpbHRlcih0b2dnbGUsIHRoaXMuYXR0ckl0ZW0sIHN0YXRlKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgJCQodGhpcy50YXJnZXQsIHRoaXMuJGVsKS5tYXAoKHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJGbiA9ICgpID0+IGFwcGx5U3RhdGUoc3RhdGUsIHRhcmdldCwgY2hpbGRyZW4odGFyZ2V0KSk7XG4gICAgICAgICAgICAgIHJldHVybiBhbmltYXRlID8gdGhpcy5hbmltYXRlKGZpbHRlckZuLCB0YXJnZXQpIDogZmlsdGVyRm4oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCBcImFmdGVyRmlsdGVyXCIsIFt0aGlzXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICAgIGZhc3Rkb20ud3JpdGUoKCkgPT4gdGhpcy5zZXRTdGF0ZSh0aGlzLmdldFN0YXRlKCksIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldEZpbHRlcihlbCwgYXR0cjIpIHtcbiAgICAgIHJldHVybiBwYXJzZU9wdGlvbnMoZGF0YShlbCwgYXR0cjIpLCBbXCJmaWx0ZXJcIl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0VxdWFsU3RhdGUoc3RhdGVBLCBzdGF0ZUIpIHtcbiAgICAgIHJldHVybiBbXCJmaWx0ZXJcIiwgXCJzb3J0XCJdLmV2ZXJ5KChwcm9wKSA9PiBpc0VxdWFsKHN0YXRlQVtwcm9wXSwgc3RhdGVCW3Byb3BdKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5U3RhdGUoc3RhdGUsIHRhcmdldCwgY2hpbGRyZW4pIHtcbiAgICAgIGZvciAoY29uc3QgZWwgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY3NzKFxuICAgICAgICAgIGVsLFxuICAgICAgICAgIFwiZGlzcGxheVwiLFxuICAgICAgICAgIE9iamVjdC52YWx1ZXMoc3RhdGUuZmlsdGVyKS5ldmVyeSgoc2VsZWN0b3IpID0+ICFzZWxlY3RvciB8fCBtYXRjaGVzKGVsLCBzZWxlY3RvcikpID8gXCJcIiA6IFwibm9uZVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBbc29ydCwgb3JkZXJdID0gc3RhdGUuc29ydDtcbiAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IHNvcnRJdGVtcyhjaGlsZHJlbiwgc29ydCwgb3JkZXIpO1xuICAgICAgICBpZiAoIWlzRXF1YWwoc29ydGVkLCBjaGlsZHJlbikpIHtcbiAgICAgICAgICBhcHBlbmQodGFyZ2V0LCBzb3J0ZWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmdlU3RhdGUoZWwsIGF0dHIyLCBzdGF0ZSkge1xuICAgICAgY29uc3QgeyBmaWx0ZXIsIGdyb3VwLCBzb3J0LCBvcmRlciA9IFwiYXNjXCIgfSA9IGdldEZpbHRlcihlbCwgYXR0cjIpO1xuICAgICAgaWYgKGZpbHRlciB8fCBpc1VuZGVmaW5lZChzb3J0KSkge1xuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICBpZiAoZmlsdGVyKSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuZmlsdGVyW1wiXCJdO1xuICAgICAgICAgICAgc3RhdGUuZmlsdGVyW2dyb3VwXSA9IGZpbHRlcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLmZpbHRlcltncm91cF07XG4gICAgICAgICAgICBpZiAoaXNFbXB0eShzdGF0ZS5maWx0ZXIpIHx8IFwiXCIgaW4gc3RhdGUuZmlsdGVyKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmZpbHRlciA9IHsgXCJcIjogZmlsdGVyIHx8IFwiXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUuZmlsdGVyID0geyBcIlwiOiBmaWx0ZXIgfHwgXCJcIiB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHNvcnQpKSB7XG4gICAgICAgIHN0YXRlLnNvcnQgPSBbc29ydCwgb3JkZXJdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXRjaEZpbHRlcihlbCwgYXR0cjIsIHsgZmlsdGVyOiBzdGF0ZUZpbHRlciA9IHsgXCJcIjogXCJcIiB9LCBzb3J0OiBbc3RhdGVTb3J0LCBzdGF0ZU9yZGVyXSB9KSB7XG4gICAgICBjb25zdCB7IGZpbHRlciA9IFwiXCIsIGdyb3VwID0gXCJcIiwgc29ydCwgb3JkZXIgPSBcImFzY1wiIH0gPSBnZXRGaWx0ZXIoZWwsIGF0dHIyKTtcbiAgICAgIHJldHVybiBpc1VuZGVmaW5lZChzb3J0KSA/IGdyb3VwIGluIHN0YXRlRmlsdGVyICYmIGZpbHRlciA9PT0gc3RhdGVGaWx0ZXJbZ3JvdXBdIHx8ICFmaWx0ZXIgJiYgZ3JvdXAgJiYgIShncm91cCBpbiBzdGF0ZUZpbHRlcikgJiYgIXN0YXRlRmlsdGVyW1wiXCJdIDogc3RhdGVTb3J0ID09PSBzb3J0ICYmIHN0YXRlT3JkZXIgPT09IG9yZGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzb3J0SXRlbXMobm9kZXMsIHNvcnQsIG9yZGVyKSB7XG4gICAgICByZXR1cm4gWy4uLm5vZGVzXS5zb3J0KFxuICAgICAgICAoYSwgYikgPT4gZGF0YShhLCBzb3J0KS5sb2NhbGVDb21wYXJlKGRhdGEoYiwgc29ydCksIHZvaWQgMCwgeyBudW1lcmljOiB0cnVlIH0pICogKG9yZGVyID09PSBcImFzY1wiIHx8IC0xKVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZEJ1dHRvbihlbCkge1xuICAgICAgcmV0dXJuICQoXCJhLGJ1dHRvblwiLCBlbCkgfHwgZWw7XG4gICAgfVxuXG4gICAgdmFyIGltZyA9IHtcbiAgICAgIGFyZ3M6IFwiZGF0YVNyY1wiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZGF0YVNyYzogU3RyaW5nLFxuICAgICAgICBzb3VyY2VzOiBTdHJpbmcsXG4gICAgICAgIG1hcmdpbjogU3RyaW5nLFxuICAgICAgICB0YXJnZXQ6IFN0cmluZyxcbiAgICAgICAgbG9hZGluZzogU3RyaW5nXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBkYXRhU3JjOiBcIlwiLFxuICAgICAgICBzb3VyY2VzOiBmYWxzZSxcbiAgICAgICAgbWFyZ2luOiBcIjUwJVwiLFxuICAgICAgICB0YXJnZXQ6IGZhbHNlLFxuICAgICAgICBsb2FkaW5nOiBcImxhenlcIlxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZGluZyAhPT0gXCJsYXp5XCIpIHtcbiAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0ltZyh0aGlzLiRlbCkpIHtcbiAgICAgICAgICB0aGlzLiRlbC5sb2FkaW5nID0gXCJsYXp5XCI7XG4gICAgICAgICAgc2V0U3JjQXR0cnModGhpcy4kZWwpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5pbWcpIHtcbiAgICAgICAgICB0aGlzLmltZy5vbmxvYWQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmltZztcbiAgICAgIH0sXG4gICAgICBvYnNlcnZlOiBpbnRlcnNlY3Rpb24oe1xuICAgICAgICBoYW5kbGVyKGVudHJpZXMsIG9ic2VydmVyKSB7XG4gICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zOiAoeyBtYXJnaW4gfSkgPT4gKHsgcm9vdE1hcmdpbjogbWFyZ2luIH0pLFxuICAgICAgICBmaWx0ZXI6ICh7IGxvYWRpbmcgfSkgPT4gbG9hZGluZyA9PT0gXCJsYXp5XCIsXG4gICAgICAgIHRhcmdldDogKHsgJGVsLCAkcHJvcHMgfSkgPT4gJHByb3BzLnRhcmdldCA/IFskZWwsIC4uLnF1ZXJ5QWxsKCRwcm9wcy50YXJnZXQsICRlbCldIDogJGVsXG4gICAgICB9KSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgbG9hZCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pbWcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmltZztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW1hZ2UgPSBpc0ltZyh0aGlzLiRlbCkgPyB0aGlzLiRlbCA6IGdldEltYWdlRnJvbUVsZW1lbnQodGhpcy4kZWwsIHRoaXMuZGF0YVNyYywgdGhpcy5zb3VyY2VzKTtcbiAgICAgICAgICByZW1vdmVBdHRyKGltYWdlLCBcImxvYWRpbmdcIik7XG4gICAgICAgICAgc2V0U3JjQXR0cnModGhpcy4kZWwsIGltYWdlLmN1cnJlbnRTcmMpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmltZyA9IGltYWdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzZXRTcmNBdHRycyhlbCwgc3JjKSB7XG4gICAgICBpZiAoaXNJbWcoZWwpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBwYXJlbnQoZWwpO1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGlzVGFnKHBhcmVudE5vZGUsIFwicGljdHVyZVwiKSA/IGNoaWxkcmVuKHBhcmVudE5vZGUpIDogW2VsXTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaCgoZWwyKSA9PiBzZXRTb3VyY2VQcm9wcyhlbDIsIGVsMikpO1xuICAgICAgfSBlbHNlIGlmIChzcmMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlID0gIWluY2x1ZGVzKGVsLnN0eWxlLmJhY2tncm91bmRJbWFnZSwgc3JjKTtcbiAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgIGNzcyhlbCwgXCJiYWNrZ3JvdW5kSW1hZ2VcIiwgYHVybCgke2VzY2FwZShzcmMpfSlgKTtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCBjcmVhdGVFdmVudChcImxvYWRcIiwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzcmNQcm9wcyA9IFtcImRhdGEtc3JjXCIsIFwiZGF0YS1zcmNzZXRcIiwgXCJzaXplc1wiXTtcbiAgICBmdW5jdGlvbiBzZXRTb3VyY2VQcm9wcyhzb3VyY2VFbCwgdGFyZ2V0RWwpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzcmNQcm9wcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGRhdGEoc291cmNlRWwsIHByb3ApO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICBhdHRyKHRhcmdldEVsLCBwcm9wLnJlcGxhY2UoL2RhdGEtL2csIFwiXCIpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0SW1hZ2VGcm9tRWxlbWVudChlbCwgc3JjLCBzb3VyY2VzKSB7XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIHdyYXBJblBpY3R1cmUoaW1nLCBzb3VyY2VzKTtcbiAgICAgIHNldFNvdXJjZVByb3BzKGVsLCBpbWcpO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHNldFNyY0F0dHJzKGVsLCBpbWcuY3VycmVudFNyYyk7XG4gICAgICBhdHRyKGltZywgXCJzcmNcIiwgc3JjKTtcbiAgICAgIHJldHVybiBpbWc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdyYXBJblBpY3R1cmUoaW1nLCBzb3VyY2VzKSB7XG4gICAgICBzb3VyY2VzID0gcGFyc2VTb3VyY2VzKHNvdXJjZXMpO1xuICAgICAgaWYgKHNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBpY3R1cmUgPSBmcmFnbWVudChcIjxwaWN0dXJlPlwiKTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRycyBvZiBzb3VyY2VzKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlID0gZnJhZ21lbnQoXCI8c291cmNlPlwiKTtcbiAgICAgICAgICBhdHRyKHNvdXJjZSwgYXR0cnMpO1xuICAgICAgICAgIGFwcGVuZChwaWN0dXJlLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZChwaWN0dXJlLCBpbWcpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVNvdXJjZXMoc291cmNlcykge1xuICAgICAgaWYgKCFzb3VyY2VzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydHNXaXRoKHNvdXJjZXMsIFwiW1wiKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNvdXJjZXMgPSBKU09OLnBhcnNlKHNvdXJjZXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgc291cmNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb3VyY2VzID0gcGFyc2VPcHRpb25zKHNvdXJjZXMpO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KHNvdXJjZXMpKSB7XG4gICAgICAgIHNvdXJjZXMgPSBbc291cmNlc107XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlcy5maWx0ZXIoKHNvdXJjZSkgPT4gIWlzRW1wdHkoc291cmNlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSW1nKGVsKSB7XG4gICAgICByZXR1cm4gaXNUYWcoZWwsIFwiaW1nXCIpO1xuICAgIH1cblxuICAgIGxldCBwcmV2ZW50ZWQ7XG4gICAgZnVuY3Rpb24gcHJldmVudEJhY2tncm91bmRTY3JvbGwoZWwpIHtcbiAgICAgIGNvbnN0IG9mZiA9IG9uKFxuICAgICAgICBlbCxcbiAgICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggIT09IDEgfHwgbWF0Y2hlcyhlLnRhcmdldCwgJ2lucHV0W3R5cGU9XCJyYW5nZVwiJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHByZXYgPSBnZXRFdmVudFBvcyhlKS55O1xuICAgICAgICAgIGNvbnN0IG9mZk1vdmUgPSBvbihcbiAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgXCJ0b3VjaG1vdmVcIixcbiAgICAgICAgICAgIChlMikgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFdmVudFBvcyhlMikueTtcbiAgICAgICAgICAgICAgaWYgKHBvcyA9PT0gcHJldikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwcmV2ID0gcG9zO1xuICAgICAgICAgICAgICBpZiAoIXNjcm9sbFBhcmVudHMoZTIudGFyZ2V0KS5zb21lKChzY3JvbGxQYXJlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmNvbnRhaW5zKHNjcm9sbFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHsgc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgfSA9IHNjcm9sbFBhcmVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50SGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIGUyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IHBhc3NpdmU6IGZhbHNlIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIG9uY2UoZWwsIFwic2Nyb2xsIHRvdWNoZW5kIHRvdWNoY2FuZWxcIiwgb2ZmTW92ZSwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB9LFxuICAgICAgICB7IHBhc3NpdmU6IHRydWUgfVxuICAgICAgKTtcbiAgICAgIGlmIChwcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuIG9mZjtcbiAgICAgIH1cbiAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICBjb25zdCB7IHNjcm9sbGluZ0VsZW1lbnQgfSA9IGRvY3VtZW50O1xuICAgICAgY3NzKHNjcm9sbGluZ0VsZW1lbnQsIHtcbiAgICAgICAgb3ZlcmZsb3dZOiBDU1Muc3VwcG9ydHMoXCJvdmVyZmxvd1wiLCBcImNsaXBcIikgPyBcImNsaXBcIiA6IFwiaGlkZGVuXCIsXG4gICAgICAgIHRvdWNoQWN0aW9uOiBcIm5vbmVcIixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiB3aWR0aCh3aW5kb3cpIC0gc2Nyb2xsaW5nRWxlbWVudC5jbGllbnRXaWR0aCB8fCBcIlwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHByZXZlbnRlZCA9IGZhbHNlO1xuICAgICAgICBvZmYoKTtcbiAgICAgICAgY3NzKHNjcm9sbGluZ0VsZW1lbnQsIHsgb3ZlcmZsb3dZOiBcIlwiLCB0b3VjaEFjdGlvbjogXCJcIiwgcGFkZGluZ1JpZ2h0OiBcIlwiIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgQ29udGFpbmVyID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29udGFpbmVyOiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBjb250YWluZXI6IHRydWVcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBjb250YWluZXIoeyBjb250YWluZXIgfSkge1xuICAgICAgICAgIHJldHVybiBjb250YWluZXIgPT09IHRydWUgJiYgdGhpcy4kY29udGFpbmVyIHx8IGNvbnRhaW5lciAmJiAkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFBvc2l0aW9uID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcG9zOiBTdHJpbmcsXG4gICAgICAgIG9mZnNldDogQm9vbGVhbixcbiAgICAgICAgZmxpcDogQm9vbGVhbixcbiAgICAgICAgc2hpZnQ6IEJvb2xlYW4sXG4gICAgICAgIGluc2V0OiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBwb3M6IGBib3R0b20tJHtpc1J0bCA/IFwicmlnaHRcIiA6IFwibGVmdFwifWAsXG4gICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgIGZsaXA6IHRydWUsXG4gICAgICAgIHNoaWZ0OiB0cnVlLFxuICAgICAgICBpbnNldDogZmFsc2VcbiAgICAgIH0sXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy4kcHJvcHMucG9zLnNwbGl0KFwiLVwiKS5jb25jYXQoXCJjZW50ZXJcIikuc2xpY2UoMCwgMik7XG4gICAgICAgIFt0aGlzLmRpciwgdGhpcy5hbGlnbl0gPSB0aGlzLnBvcztcbiAgICAgICAgdGhpcy5heGlzID0gaW5jbHVkZXMoW1widG9wXCIsIFwiYm90dG9tXCJdLCB0aGlzLmRpcikgPyBcInlcIiA6IFwieFwiO1xuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgcG9zaXRpb25BdChlbGVtZW50LCB0YXJnZXQsIGJvdW5kYXJ5KSB7XG4gICAgICAgICAgbGV0IG9mZnNldCA9IFt0aGlzLmdldFBvc2l0aW9uT2Zmc2V0KGVsZW1lbnQpLCB0aGlzLmdldFNoaWZ0T2Zmc2V0KGVsZW1lbnQpXTtcbiAgICAgICAgICBjb25zdCBwbGFjZW1lbnQgPSBbdGhpcy5mbGlwICYmIFwiZmxpcFwiLCB0aGlzLnNoaWZ0ICYmIFwic2hpZnRcIl07XG4gICAgICAgICAgY29uc3QgYXR0YWNoID0ge1xuICAgICAgICAgICAgZWxlbWVudDogW3RoaXMuaW5zZXQgPyB0aGlzLmRpciA6IGZsaXBQb3NpdGlvbih0aGlzLmRpciksIHRoaXMuYWxpZ25dLFxuICAgICAgICAgICAgdGFyZ2V0OiBbdGhpcy5kaXIsIHRoaXMuYWxpZ25dXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAodGhpcy5heGlzID09PSBcInlcIikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGF0dGFjaCkge1xuICAgICAgICAgICAgICBhdHRhY2hbcHJvcF0ucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIHBsYWNlbWVudC5yZXZlcnNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiA9IHN0b3JlU2Nyb2xsUG9zaXRpb24oZWxlbWVudCk7XG4gICAgICAgICAgY29uc3QgZWxEaW0gPSBkaW1lbnNpb25zJDEoZWxlbWVudCk7XG4gICAgICAgICAgY3NzKGVsZW1lbnQsIHsgdG9wOiAtZWxEaW0uaGVpZ2h0LCBsZWZ0OiAtZWxEaW0ud2lkdGggfSk7XG4gICAgICAgICAgcG9zaXRpb25BdChlbGVtZW50LCB0YXJnZXQsIHtcbiAgICAgICAgICAgIGF0dGFjaCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIGJvdW5kYXJ5LFxuICAgICAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICAgICAgdmlld3BvcnRPZmZzZXQ6IHRoaXMuZ2V0Vmlld3BvcnRPZmZzZXQoZWxlbWVudClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UG9zaXRpb25PZmZzZXQoZWxlbWVudCA9IHRoaXMuJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRvUHgoXG4gICAgICAgICAgICB0aGlzLm9mZnNldCA9PT0gZmFsc2UgPyBjc3MoZWxlbWVudCwgXCItLXVrLXBvc2l0aW9uLW9mZnNldFwiKSA6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgdGhpcy5heGlzID09PSBcInhcIiA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCIsXG4gICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgKSAqIChpbmNsdWRlcyhbXCJsZWZ0XCIsIFwidG9wXCJdLCB0aGlzLmRpcikgPyAtMSA6IDEpICogKHRoaXMuaW5zZXQgPyAtMSA6IDEpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRTaGlmdE9mZnNldChlbGVtZW50ID0gdGhpcy4kZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbiA9PT0gXCJjZW50ZXJcIiA/IDAgOiB0b1B4KFxuICAgICAgICAgICAgY3NzKGVsZW1lbnQsIFwiLS11ay1wb3NpdGlvbi1zaGlmdC1vZmZzZXRcIiksXG4gICAgICAgICAgICB0aGlzLmF4aXMgPT09IFwieVwiID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIixcbiAgICAgICAgICAgIGVsZW1lbnRcbiAgICAgICAgICApICogKGluY2x1ZGVzKFtcImxlZnRcIiwgXCJ0b3BcIl0sIHRoaXMuYWxpZ24pID8gMSA6IC0xKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Vmlld3BvcnRPZmZzZXQoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0b1B4KGNzcyhlbGVtZW50LCBcIi0tdWstcG9zaXRpb24tdmlld3BvcnQtb2Zmc2V0XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gc3RvcmVTY3JvbGxQb3NpdGlvbihlbGVtZW50KSB7XG4gICAgICBjb25zdCBzY3JvbGxFbGVtZW50ID0gc2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xuICAgICAgY29uc3QgeyBzY3JvbGxUb3AgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAoc2Nyb2xsVG9wICE9PSBzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCkge1xuICAgICAgICAgIHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBUb2dnbGFibGUgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBjbHM6IEJvb2xlYW4sXG4gICAgICAgIGFuaW1hdGlvbjogXCJsaXN0XCIsXG4gICAgICAgIGR1cmF0aW9uOiBOdW1iZXIsXG4gICAgICAgIHZlbG9jaXR5OiBOdW1iZXIsXG4gICAgICAgIG9yaWdpbjogU3RyaW5nLFxuICAgICAgICB0cmFuc2l0aW9uOiBTdHJpbmdcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsczogZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvbjogW2ZhbHNlXSxcbiAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgdmVsb2NpdHk6IDAuMixcbiAgICAgICAgb3JpZ2luOiBmYWxzZSxcbiAgICAgICAgdHJhbnNpdGlvbjogXCJlYXNlXCIsXG4gICAgICAgIGNsc0VudGVyOiBcInVrLXRvZ2dsYWJsZS1lbnRlclwiLFxuICAgICAgICBjbHNMZWF2ZTogXCJ1ay10b2dnbGFibGUtbGVhdmVcIlxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGhhc0FuaW1hdGlvbjogKHsgYW5pbWF0aW9uIH0pID0+ICEhYW5pbWF0aW9uWzBdLFxuICAgICAgICBoYXNUcmFuc2l0aW9uOiAoeyBhbmltYXRpb24gfSkgPT4gW1wic2xpZGVcIiwgXCJyZXZlYWxcIl0uc29tZSgodHJhbnNpdGlvbikgPT4gc3RhcnRzV2l0aChhbmltYXRpb25bMF0sIHRyYW5zaXRpb24pKVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgdG9nZ2xlRWxlbWVudCh0YXJnZXRzLCB0b2dnbGUsIGFuaW1hdGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgIHRvTm9kZXModGFyZ2V0cykubWFwKChlbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3cgPSBpc0Jvb2xlYW4odG9nZ2xlKSA/IHRvZ2dsZSA6ICF0aGlzLmlzVG9nZ2xlZChlbCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmlnZ2VyKGVsLCBgYmVmb3JlJHtzaG93ID8gXCJzaG93XCIgOiBcImhpZGVcIn1gLCBbdGhpc10pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IChpc0Z1bmN0aW9uKGFuaW1hdGUpID8gYW5pbWF0ZSA6IGFuaW1hdGUgPT09IGZhbHNlIHx8ICF0aGlzLmhhc0FuaW1hdGlvbiA/IHRvZ2dsZUluc3RhbnQgOiB0aGlzLmhhc1RyYW5zaXRpb24gPyB0b2dnbGVUcmFuc2l0aW9uIDogdG9nZ2xlQW5pbWF0aW9uKShlbCwgc2hvdywgdGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xzID0gc2hvdyA/IHRoaXMuY2xzRW50ZXIgOiB0aGlzLmNsc0xlYXZlO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICAgICAgICAgICAgICAgIHRyaWdnZXIoZWwsIHNob3cgPyBcInNob3dcIiA6IFwiaGlkZVwiLCBbdGhpc10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbiAgICAgICAgICAgICAgICAgIHRyaWdnZXIoZWwsIHNob3cgPyBcInNob3duXCIgOiBcImhpZGRlblwiLCBbdGhpc10pO1xuICAgICAgICAgICAgICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID0gc3RvcmVTY3JvbGxQb3NpdGlvbihlbCk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9ICQkKFwiW2F1dG9mb2N1c11cIiwgZWwpLmZpbmQoaXNWaXNpYmxlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2UgPyBwcm9taXNlLnRoZW4oZG9uZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9KSA6IGRvbmUoKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpc1RvZ2dsZWQoZWwgPSB0aGlzLiRlbCkge1xuICAgICAgICAgIGVsID0gdG9Ob2RlKGVsKTtcbiAgICAgICAgICByZXR1cm4gaGFzQ2xhc3MoZWwsIHRoaXMuY2xzRW50ZXIpID8gdHJ1ZSA6IGhhc0NsYXNzKGVsLCB0aGlzLmNsc0xlYXZlKSA/IGZhbHNlIDogdGhpcy5jbHMgPyBoYXNDbGFzcyhlbCwgdGhpcy5jbHMuc3BsaXQoXCIgXCIpWzBdKSA6IGlzVmlzaWJsZShlbCk7XG4gICAgICAgIH0sXG4gICAgICAgIF90b2dnbGUoZWwsIHRvZ2dsZWQpIHtcbiAgICAgICAgICBpZiAoIWVsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvZ2dsZWQgPSBCb29sZWFuKHRvZ2dsZWQpO1xuICAgICAgICAgIGxldCBjaGFuZ2VkO1xuICAgICAgICAgIGlmICh0aGlzLmNscykge1xuICAgICAgICAgICAgY2hhbmdlZCA9IGluY2x1ZGVzKHRoaXMuY2xzLCBcIiBcIikgfHwgdG9nZ2xlZCAhPT0gaGFzQ2xhc3MoZWwsIHRoaXMuY2xzKTtcbiAgICAgICAgICAgIGNoYW5nZWQgJiYgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMuY2xzLCBpbmNsdWRlcyh0aGlzLmNscywgXCIgXCIpID8gdm9pZCAwIDogdG9nZ2xlZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0b2dnbGVkID09PSBlbC5oaWRkZW47XG4gICAgICAgICAgICBjaGFuZ2VkICYmIChlbC5oaWRkZW4gPSAhdG9nZ2xlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCBcInRvZ2dsZWRcIiwgW3RvZ2dsZWQsIHRoaXNdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRvZ2dsZUluc3RhbnQoZWwsIHNob3csIHsgX3RvZ2dsZSB9KSB7XG4gICAgICBBbmltYXRpb24uY2FuY2VsKGVsKTtcbiAgICAgIFRyYW5zaXRpb24uY2FuY2VsKGVsKTtcbiAgICAgIHJldHVybiBfdG9nZ2xlKGVsLCBzaG93KTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gdG9nZ2xlVHJhbnNpdGlvbihlbCwgc2hvdywgeyBhbmltYXRpb24sIGR1cmF0aW9uLCB2ZWxvY2l0eSwgdHJhbnNpdGlvbiwgX3RvZ2dsZSB9KSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBbbW9kZSA9IFwicmV2ZWFsXCIsIHN0YXJ0UHJvcCA9IFwidG9wXCJdID0gKChfYSA9IGFuaW1hdGlvblswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiLVwiKSkgfHwgW107XG4gICAgICBjb25zdCBkaXJzID0gW1xuICAgICAgICBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gICAgICAgIFtcInRvcFwiLCBcImJvdHRvbVwiXVxuICAgICAgXTtcbiAgICAgIGNvbnN0IGRpciA9IGRpcnNbaW5jbHVkZXMoZGlyc1swXSwgc3RhcnRQcm9wKSA/IDAgOiAxXTtcbiAgICAgIGNvbnN0IGVuZCA9IGRpclsxXSA9PT0gc3RhcnRQcm9wO1xuICAgICAgY29uc3QgcHJvcHMgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiXTtcbiAgICAgIGNvbnN0IGRpbVByb3AgPSBwcm9wc1tkaXJzLmluZGV4T2YoZGlyKV07XG4gICAgICBjb25zdCBtYXJnaW5Qcm9wID0gYG1hcmdpbi0ke2RpclswXX1gO1xuICAgICAgY29uc3QgbWFyZ2luU3RhcnRQcm9wID0gYG1hcmdpbi0ke3N0YXJ0UHJvcH1gO1xuICAgICAgbGV0IGN1cnJlbnREaW0gPSBkaW1lbnNpb25zJDEoZWwpW2RpbVByb3BdO1xuICAgICAgY29uc3QgaW5Qcm9ncmVzcyA9IFRyYW5zaXRpb24uaW5Qcm9ncmVzcyhlbCk7XG4gICAgICBhd2FpdCBUcmFuc2l0aW9uLmNhbmNlbChlbCk7XG4gICAgICBpZiAoc2hvdykge1xuICAgICAgICBfdG9nZ2xlKGVsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZQcm9wcyA9IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgW1xuICAgICAgICAgIFwicGFkZGluZ1wiLFxuICAgICAgICAgIFwiYm9yZGVyXCIsXG4gICAgICAgICAgXCJ3aWR0aFwiLFxuICAgICAgICAgIFwiaGVpZ2h0XCIsXG4gICAgICAgICAgXCJtaW5XaWR0aFwiLFxuICAgICAgICAgIFwibWluSGVpZ2h0XCIsXG4gICAgICAgICAgXCJvdmVyZmxvd1lcIixcbiAgICAgICAgICBcIm92ZXJmbG93WFwiLFxuICAgICAgICAgIG1hcmdpblByb3AsXG4gICAgICAgICAgbWFyZ2luU3RhcnRQcm9wXG4gICAgICAgIF0ubWFwKChrZXkpID0+IFtrZXksIGVsLnN0eWxlW2tleV1dKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRpbSA9IGRpbWVuc2lvbnMkMShlbCk7XG4gICAgICBjb25zdCBjdXJyZW50TWFyZ2luID0gdG9GbG9hdChjc3MoZWwsIG1hcmdpblByb3ApKTtcbiAgICAgIGNvbnN0IG1hcmdpblN0YXJ0ID0gdG9GbG9hdChjc3MoZWwsIG1hcmdpblN0YXJ0UHJvcCkpO1xuICAgICAgY29uc3QgZW5kRGltID0gZGltW2RpbVByb3BdICsgbWFyZ2luU3RhcnQ7XG4gICAgICBpZiAoIWluUHJvZ3Jlc3MgJiYgIXNob3cpIHtcbiAgICAgICAgY3VycmVudERpbSArPSBtYXJnaW5TdGFydDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt3cmFwcGVyXSA9IHdyYXBJbm5lcihlbCwgXCI8ZGl2PlwiKTtcbiAgICAgIGNzcyh3cmFwcGVyLCB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIGhlaWdodDogZGltLmhlaWdodCxcbiAgICAgICAgd2lkdGg6IGRpbS53aWR0aCxcbiAgICAgICAgLi4uY3NzKGVsLCBbXG4gICAgICAgICAgXCJvdmVyZmxvd1wiLFxuICAgICAgICAgIFwicGFkZGluZ1wiLFxuICAgICAgICAgIFwiYm9yZGVyVG9wXCIsXG4gICAgICAgICAgXCJib3JkZXJSaWdodFwiLFxuICAgICAgICAgIFwiYm9yZGVyQm90dG9tXCIsXG4gICAgICAgICAgXCJib3JkZXJMZWZ0XCIsXG4gICAgICAgICAgXCJib3JkZXJJbWFnZVwiLFxuICAgICAgICAgIG1hcmdpblN0YXJ0UHJvcFxuICAgICAgICBdKVxuICAgICAgfSk7XG4gICAgICBjc3MoZWwsIHtcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtaW5XaWR0aDogMCxcbiAgICAgICAgbWluSGVpZ2h0OiAwLFxuICAgICAgICBbbWFyZ2luU3RhcnRQcm9wXTogMCxcbiAgICAgICAgd2lkdGg6IGRpbS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkaW0uaGVpZ2h0LFxuICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgW2RpbVByb3BdOiBjdXJyZW50RGltXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHBlcmNlbnQgPSBjdXJyZW50RGltIC8gZW5kRGltO1xuICAgICAgZHVyYXRpb24gPSAodmVsb2NpdHkgKiBlbmREaW0gKyBkdXJhdGlvbikgKiAoc2hvdyA/IDEgLSBwZXJjZW50IDogcGVyY2VudCk7XG4gICAgICBjb25zdCBlbmRQcm9wcyA9IHsgW2RpbVByb3BdOiBzaG93ID8gZW5kRGltIDogMCB9O1xuICAgICAgaWYgKGVuZCkge1xuICAgICAgICBjc3MoZWwsIG1hcmdpblByb3AsIGVuZERpbSAtIGN1cnJlbnREaW0gKyBjdXJyZW50TWFyZ2luKTtcbiAgICAgICAgZW5kUHJvcHNbbWFyZ2luUHJvcF0gPSBzaG93ID8gY3VycmVudE1hcmdpbiA6IGVuZERpbSArIGN1cnJlbnRNYXJnaW47XG4gICAgICB9XG4gICAgICBpZiAoIWVuZCBeIG1vZGUgPT09IFwicmV2ZWFsXCIpIHtcbiAgICAgICAgY3NzKHdyYXBwZXIsIG1hcmdpblByb3AsIC1lbmREaW0gKyBjdXJyZW50RGltKTtcbiAgICAgICAgVHJhbnNpdGlvbi5zdGFydCh3cmFwcGVyLCB7IFttYXJnaW5Qcm9wXTogc2hvdyA/IDAgOiAtZW5kRGltIH0sIGR1cmF0aW9uLCB0cmFuc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IFRyYW5zaXRpb24uc3RhcnQoZWwsIGVuZFByb3BzLCBkdXJhdGlvbiwgdHJhbnNpdGlvbik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjc3MoZWwsIHByZXZQcm9wcyk7XG4gICAgICAgIHVud3JhcCh3cmFwcGVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAoIXNob3cpIHtcbiAgICAgICAgICBfdG9nZ2xlKGVsLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdG9nZ2xlQW5pbWF0aW9uKGVsLCBzaG93LCBjbXApIHtcbiAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBkdXJhdGlvbiwgX3RvZ2dsZSB9ID0gY21wO1xuICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgX3RvZ2dsZShlbCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBBbmltYXRpb24uaW4oZWwsIGFuaW1hdGlvblswXSwgZHVyYXRpb24sIGNtcC5vcmlnaW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFuaW1hdGlvbi5vdXQoZWwsIGFuaW1hdGlvblsxXSB8fCBhbmltYXRpb25bMF0sIGR1cmF0aW9uLCBjbXAub3JpZ2luKS50aGVuKFxuICAgICAgICAoKSA9PiBfdG9nZ2xlKGVsLCBmYWxzZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlJDEgPSBbXTtcbiAgICB2YXIgTW9kYWwgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgQ29udGFpbmVyLCBUb2dnbGFibGVdLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc2VsUGFuZWw6IFN0cmluZyxcbiAgICAgICAgc2VsQ2xvc2U6IFN0cmluZyxcbiAgICAgICAgZXNjQ2xvc2U6IEJvb2xlYW4sXG4gICAgICAgIGJnQ2xvc2U6IEJvb2xlYW4sXG4gICAgICAgIHN0YWNrOiBCb29sZWFuLFxuICAgICAgICByb2xlOiBTdHJpbmdcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsczogXCJ1ay1vcGVuXCIsXG4gICAgICAgIGVzY0Nsb3NlOiB0cnVlLFxuICAgICAgICBiZ0Nsb3NlOiB0cnVlLFxuICAgICAgICBvdmVybGF5OiB0cnVlLFxuICAgICAgICBzdGFjazogZmFsc2UsXG4gICAgICAgIHJvbGU6IFwiZGlhbG9nXCJcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBwYW5lbDogKHsgc2VsUGFuZWwgfSwgJGVsKSA9PiAkKHNlbFBhbmVsLCAkZWwpLFxuICAgICAgICB0cmFuc2l0aW9uRWxlbWVudCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYW5lbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgYXR0cih0aGlzLnBhbmVsIHx8IHRoaXMuJGVsLCBcInJvbGVcIiwgdGhpcy5yb2xlKTtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheSkge1xuICAgICAgICAgIGF0dHIodGhpcy5wYW5lbCB8fCB0aGlzLiRlbCwgXCJhcmlhLW1vZGFsXCIsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmVmb3JlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzKGFjdGl2ZSQxLCB0aGlzKSkge1xuICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJjbGlja1wiLFxuICAgICAgICAgIGRlbGVnYXRlOiAoeyBzZWxDbG9zZSB9KSA9PiBgJHtzZWxDbG9zZX0sYVtocmVmKj1cIiNcIl1gLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50LCBkZWZhdWx0UHJldmVudGVkIH0gPSBlO1xuICAgICAgICAgICAgY29uc3QgeyBoYXNoIH0gPSBjdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkICYmIGhhc2ggJiYgaXNTYW1lU2l0ZUFuY2hvcihjdXJyZW50KSAmJiAhdGhpcy4kZWwuY29udGFpbnMoJChoYXNoKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMoY3VycmVudCwgdGhpcy5zZWxDbG9zZSkpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInRvZ2dsZVwiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpID09PSBpbmNsdWRlcyhhY3RpdmUkMSwgdGhpcykpIHtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImJlZm9yZXNob3dcIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzKGFjdGl2ZSQxLCB0aGlzKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhY2sgJiYgYWN0aXZlJDEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIFByb21pc2UuYWxsKGFjdGl2ZSQxLm1hcCgobW9kYWwpID0+IG1vZGFsLmhpZGUoKSkpLnRoZW4odGhpcy5zaG93KTtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWN0aXZlJDEucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgICAgICAgICBjc3ModGhpcy4kZWwsIFwiekluZGV4XCIsIHRvRmxvYXQoY3NzKHRoaXMuJGVsLCBcInpJbmRleFwiKSkgKyBhY3RpdmUkMS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXG4gICAgICAgICAgICAgIHRoaXMub3ZlcmxheSAmJiBwcmV2ZW50QmFja2dyb3VuZEZvY3VzKHRoaXMpLFxuICAgICAgICAgICAgICB0aGlzLm92ZXJsYXkgJiYgcHJldmVudEJhY2tncm91bmRTY3JvbGwodGhpcy4kZWwpLFxuICAgICAgICAgICAgICB0aGlzLmJnQ2xvc2UgJiYgbGlzdGVuRm9yQmFja2dyb3VuZENsb3NlJDEodGhpcyksXG4gICAgICAgICAgICAgIHRoaXMuZXNjQ2xvc2UgJiYgbGlzdGVuRm9yRXNjQ2xvc2UkMSh0aGlzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgICAgIHRoaXMuJGVsLFxuICAgICAgICAgICAgICBcImhpZGRlblwiLFxuICAgICAgICAgICAgICAoKSA9PiBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiBoYW5kbGVyICYmIGhhbmRsZXIoKSksXG4gICAgICAgICAgICAgIHsgc2VsZjogdHJ1ZSB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWRkQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmNsc1BhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2hvd25cIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAoIWlzRm9jdXNhYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgICBhdHRyKHRoaXMuJGVsLCBcInRhYmluZGV4XCIsIFwiLTFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXModGhpcy4kZWwsIFwiOmZvY3VzLXdpdGhpblwiKSkge1xuICAgICAgICAgICAgICB0aGlzLiRlbC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgc2VsZjogdHJ1ZSxcbiAgICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzKGFjdGl2ZSQxLCB0aGlzKSkge1xuICAgICAgICAgICAgICBhY3RpdmUkMS5zcGxpY2UoYWN0aXZlJDEuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsIFwiekluZGV4XCIsIFwiXCIpO1xuICAgICAgICAgICAgaWYgKCFhY3RpdmUkMS5zb21lKChtb2RhbCkgPT4gbW9kYWwuY2xzUGFnZSA9PT0gdGhpcy5jbHNQYWdlKSkge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzUGFnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXNUb2dnbGVkKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICAgICAgICB9LFxuICAgICAgICBzaG93KCkge1xuICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5lciAmJiBwYXJlbnQodGhpcy4kZWwpICE9PSB0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgYXBwZW5kKHRoaXMuY29udGFpbmVyLCB0aGlzLiRlbCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoXG4gICAgICAgICAgICAgIChyZXNvbHZlKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5zaG93KCkudGhlbihyZXNvbHZlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIHRydWUsIGFuaW1hdGUkMSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGFuaW1hdGUkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGFuaW1hdGUkMShlbCwgc2hvdywgeyB0cmFuc2l0aW9uRWxlbWVudCwgX3RvZ2dsZSB9KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoXG4gICAgICAgIChyZXNvbHZlLCByZWplY3QpID0+IG9uY2UoZWwsIFwic2hvdyBoaWRlXCIsICgpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgKF9hID0gZWwuX3JlamVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZWwpO1xuICAgICAgICAgIGVsLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgICAgX3RvZ2dsZShlbCwgc2hvdyk7XG4gICAgICAgICAgY29uc3Qgb2ZmID0gb25jZShcbiAgICAgICAgICAgIHRyYW5zaXRpb25FbGVtZW50LFxuICAgICAgICAgICAgXCJ0cmFuc2l0aW9uc3RhcnRcIixcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgb25jZSh0cmFuc2l0aW9uRWxlbWVudCwgXCJ0cmFuc2l0aW9uZW5kIHRyYW5zaXRpb25jYW5jZWxcIiwgcmVzb2x2ZSwge1xuICAgICAgICAgICAgICAgIHNlbGY6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBzZWxmOiB0cnVlIH1cbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgb2ZmKCk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b01zKGNzcyh0cmFuc2l0aW9uRWxlbWVudCwgXCJ0cmFuc2l0aW9uRHVyYXRpb25cIikpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgICkudGhlbigoKSA9PiBkZWxldGUgZWwuX3JlamVjdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvTXModGltZSkge1xuICAgICAgcmV0dXJuIHRpbWUgPyBlbmRzV2l0aCh0aW1lLCBcIm1zXCIpID8gdG9GbG9hdCh0aW1lKSA6IHRvRmxvYXQodGltZSkgKiAxZTMgOiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmV2ZW50QmFja2dyb3VuZEZvY3VzKG1vZGFsKSB7XG4gICAgICByZXR1cm4gb24oZG9jdW1lbnQsIFwiZm9jdXNpblwiLCAoZSkgPT4ge1xuICAgICAgICBpZiAobGFzdChhY3RpdmUkMSkgPT09IG1vZGFsICYmICFtb2RhbC4kZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgbW9kYWwuJGVsLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaXN0ZW5Gb3JCYWNrZ3JvdW5kQ2xvc2UkMShtb2RhbCkge1xuICAgICAgcmV0dXJuIG9uKGRvY3VtZW50LCBwb2ludGVyRG93biQxLCAoeyB0YXJnZXQgfSkgPT4ge1xuICAgICAgICBpZiAobGFzdChhY3RpdmUkMSkgIT09IG1vZGFsIHx8IG1vZGFsLm92ZXJsYXkgJiYgIW1vZGFsLiRlbC5jb250YWlucyh0YXJnZXQpIHx8ICFtb2RhbC5wYW5lbCB8fCBtb2RhbC5wYW5lbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uY2UoXG4gICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgYCR7cG9pbnRlclVwJDF9ICR7cG9pbnRlckNhbmNlbH0gc2Nyb2xsYCxcbiAgICAgICAgICAoeyBkZWZhdWx0UHJldmVudGVkLCB0eXBlLCB0YXJnZXQ6IG5ld1RhcmdldCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRQcmV2ZW50ZWQgJiYgdHlwZSA9PT0gcG9pbnRlclVwJDEgJiYgdGFyZ2V0ID09PSBuZXdUYXJnZXQpIHtcbiAgICAgICAgICAgICAgbW9kYWwuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpc3RlbkZvckVzY0Nsb3NlJDEobW9kYWwpIHtcbiAgICAgIHJldHVybiBvbihkb2N1bWVudCwgXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDI3ICYmIGxhc3QoYWN0aXZlJDEpID09PSBtb2RhbCkge1xuICAgICAgICAgIG1vZGFsLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIEFuaW1hdGlvbnMkMiA9IHtcbiAgICAgIHNsaWRlOiB7XG4gICAgICAgIHNob3coZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IHRyYW5zZm9ybTogdHJhbnNsYXRlKGRpciAqIC0xMDApIH0sIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoKSB9XTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVyY2VudChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zbGF0ZWQoY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZShkaXIgKiAtMTAwICogcGVyY2VudCkgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoZGlyICogMTAwICogKDEgLSBwZXJjZW50KSkgfVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZWQoZWwpIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyhuZXcgRE9NTWF0cml4KGNzcyhlbCwgXCJ0cmFuc2Zvcm1cIikpLm00MSAvIGVsLm9mZnNldFdpZHRoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlID0gMCwgdW5pdCA9IFwiJVwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBgdHJhbnNsYXRlM2QoJHt2YWx1ZSArIHVuaXR9LCAwLCAwKWAgOiBcIlwiO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25lciQxKHByZXYsIG5leHQsIGRpciwgeyBhbmltYXRpb24sIGVhc2luZyB9KSB7XG4gICAgICBjb25zdCB7IHBlcmNlbnQsIHRyYW5zbGF0ZSwgc2hvdyA9IG5vb3AgfSA9IGFuaW1hdGlvbjtcbiAgICAgIGNvbnN0IHByb3BzID0gc2hvdyhkaXIpO1xuICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSB3aXRoUmVzb2x2ZXJzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXIsXG4gICAgICAgIHNob3coZHVyYXRpb24sIHBlcmNlbnQyID0gMCwgbGluZWFyKSB7XG4gICAgICAgICAgY29uc3QgdGltaW5nID0gbGluZWFyID8gXCJsaW5lYXJcIiA6IGVhc2luZztcbiAgICAgICAgICBkdXJhdGlvbiAtPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogY2xhbXAocGVyY2VudDIsIC0xLCAxKSk7XG4gICAgICAgICAgdGhpcy50cmFuc2xhdGUocGVyY2VudDIpO1xuICAgICAgICAgIHRyaWdnZXJVcGRhdGUobmV4dCwgXCJpdGVtaW5cIiwgeyBwZXJjZW50OiBwZXJjZW50MiwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0pO1xuICAgICAgICAgIHRyaWdnZXJVcGRhdGUocHJldiwgXCJpdGVtb3V0XCIsIHsgcGVyY2VudDogMSAtIHBlcmNlbnQyLCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSk7XG4gICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgVHJhbnNpdGlvbi5zdGFydChuZXh0LCBwcm9wc1sxXSwgZHVyYXRpb24sIHRpbWluZyksXG4gICAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KHByZXYsIHByb3BzWzBdLCBkdXJhdGlvbiwgdGltaW5nKVxuICAgICAgICAgIF0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sIG5vb3ApO1xuICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgcmV0dXJuIFRyYW5zaXRpb24uY2FuY2VsKFtuZXh0LCBwcmV2XSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wc1swXSkge1xuICAgICAgICAgICAgY3NzKFtuZXh0LCBwcmV2XSwgcHJvcCwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhc3luYyBmb3J3YXJkKGR1cmF0aW9uLCBwZXJjZW50MiA9IHRoaXMucGVyY2VudCgpKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaG93KGR1cmF0aW9uLCBwZXJjZW50MiwgdHJ1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50Mikge1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICBjb25zdCBwcm9wczIgPSB0cmFuc2xhdGUocGVyY2VudDIsIGRpcik7XG4gICAgICAgICAgY3NzKG5leHQsIHByb3BzMlsxXSk7XG4gICAgICAgICAgY3NzKHByZXYsIHByb3BzMlswXSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZShuZXh0LCBcIml0ZW10cmFuc2xhdGVpblwiLCB7IHBlcmNlbnQ6IHBlcmNlbnQyLCBkaXIgfSk7XG4gICAgICAgICAgdHJpZ2dlclVwZGF0ZShwcmV2LCBcIml0ZW10cmFuc2xhdGVvdXRcIiwgeyBwZXJjZW50OiAxIC0gcGVyY2VudDIsIGRpciB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVyY2VudCgpIHtcbiAgICAgICAgICByZXR1cm4gcGVyY2VudChwcmV2IHx8IG5leHQsIG5leHQsIGRpcik7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERpc3RhbmNlKCkge1xuICAgICAgICAgIHJldHVybiBwcmV2ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmlnZ2VyVXBkYXRlKGVsLCB0eXBlLCBkYXRhKSB7XG4gICAgICB0cmlnZ2VyKGVsLCBjcmVhdGVFdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIGRhdGEpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd2l0aFJlc29sdmVycygpIHtcbiAgICAgIGxldCByZXNvbHZlO1xuICAgICAgcmV0dXJuIHsgcHJvbWlzZTogbmV3IFByb21pc2UoKHJlcykgPT4gcmVzb2x2ZSA9IHJlcyksIHJlc29sdmUgfTtcbiAgICB9XG5cbiAgICB2YXIgSTE4biA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGkxOG46IE9iamVjdFxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgaTE4bjogbnVsbFxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdChrZXksIC4uLnBhcmFtcykge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICByZXR1cm4gKChfYyA9ICgoX2EgPSB0aGlzLmkxOG4pID09IG51bGwgPyB2b2lkIDAgOiBfYVtrZXldKSB8fCAoKF9iID0gdGhpcy4kb3B0aW9ucy5pMThuKSA9PSBudWxsID8gdm9pZCAwIDogX2Jba2V5XSkpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yZXBsYWNlKFxuICAgICAgICAgICAgLyVzL2csXG4gICAgICAgICAgICAoKSA9PiBwYXJhbXNbaSsrXSB8fCBcIlwiXG4gICAgICAgICAgKSkgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgU2xpZGVyQXV0b3BsYXkgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBhdXRvcGxheTogQm9vbGVhbixcbiAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogTnVtYmVyLFxuICAgICAgICBwYXVzZU9uSG92ZXI6IEJvb2xlYW5cbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dG9wbGF5OiBmYWxzZSxcbiAgICAgICAgYXV0b3BsYXlJbnRlcnZhbDogN2UzLFxuICAgICAgICBwYXVzZU9uSG92ZXI6IHRydWVcbiAgICAgIH0sXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGF0dHIodGhpcy5saXN0LCBcImFyaWEtbGl2ZVwiLCB0aGlzLmF1dG9wbGF5ID8gXCJvZmZcIiA6IFwicG9saXRlXCIpO1xuICAgICAgICB0aGlzLmF1dG9wbGF5ICYmIHRoaXMuc3RhcnRBdXRvcGxheSgpO1xuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5zdG9wQXV0b3BsYXkoKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGUoKSB7XG4gICAgICAgIGF0dHIodGhpcy5zbGlkZXMsIFwidGFiaW5kZXhcIiwgXCItMVwiKTtcbiAgICAgIH0sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwidmlzaWJpbGl0eWNoYW5nZVwiLFxuICAgICAgICAgIGVsOiAoKSA9PiBkb2N1bWVudCxcbiAgICAgICAgICBmaWx0ZXI6ICh7IGF1dG9wbGF5IH0pID0+IGF1dG9wbGF5LFxuICAgICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcEF1dG9wbGF5KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0QXV0b3BsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHN0YXJ0QXV0b3BsYXkoKSB7XG4gICAgICAgICAgdGhpcy5zdG9wQXV0b3BsYXkoKTtcbiAgICAgICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5zdGFjay5sZW5ndGggfHwgdGhpcy5kcmFnZ2FibGUgJiYgbWF0Y2hlcyh0aGlzLiRlbCwgXCI6Zm9jdXMtd2l0aGluXCIpICYmICFtYXRjaGVzKHRoaXMuJGVsLCBcIjpmb2N1c1wiKSB8fCB0aGlzLnBhdXNlT25Ib3ZlciAmJiBtYXRjaGVzKHRoaXMuJGVsLCBcIjpob3ZlclwiKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaG93KFwibmV4dFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzLmF1dG9wbGF5SW50ZXJ2YWwpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wQXV0b3BsYXkoKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBwb2ludGVyT3B0aW9ucyA9IHsgcGFzc2l2ZTogZmFsc2UsIGNhcHR1cmU6IHRydWUgfTtcbiAgICBjb25zdCBwb2ludGVyVXBPcHRpb25zID0geyBwYXNzaXZlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH07XG4gICAgY29uc3QgcG9pbnRlckRvd24gPSBcInRvdWNoc3RhcnQgbW91c2Vkb3duXCI7XG4gICAgY29uc3QgcG9pbnRlck1vdmUgPSBcInRvdWNobW92ZSBtb3VzZW1vdmVcIjtcbiAgICBjb25zdCBwb2ludGVyVXAgPSBcInRvdWNoZW5kIHRvdWNoY2FuY2VsIG1vdXNldXAgY2xpY2sgaW5wdXQgc2Nyb2xsXCI7XG4gICAgdmFyIFNsaWRlckRyYWcgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBkcmFnZ2FibGU6IEJvb2xlYW5cbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgdGhyZXNob2xkOiAxMFxuICAgICAgfSxcbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFtcInN0YXJ0XCIsIFwibW92ZVwiLCBcImVuZFwiXSkge1xuICAgICAgICAgIGNvbnN0IGZuID0gdGhpc1trZXldO1xuICAgICAgICAgIHRoaXNba2V5XSA9IChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBnZXRFdmVudFBvcyhlKS54ICogKGlzUnRsID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHRoaXMucHJldlBvcyA9IHBvcyA9PT0gdGhpcy5wb3MgPyB0aGlzLnByZXZQb3MgOiB0aGlzLnBvcztcbiAgICAgICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICAgICAgZm4oZSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogcG9pbnRlckRvd24sXG4gICAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgICBkZWxlZ2F0ZTogKHsgc2VsTGlzdCB9KSA9PiBgJHtzZWxMaXN0fSA+ICpgLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRyYWdnYWJsZSB8fCB0aGlzLnBhcmFsbGF4IHx8ICFpc1RvdWNoKGUpICYmIGhhc1NlbGVjdGFibGVUZXh0KGUudGFyZ2V0KSB8fCBlLnRhcmdldC5jbG9zZXN0KHNlbElucHV0KSB8fCBlLmJ1dHRvbiA+IDAgfHwgdGhpcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhcnQoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJkcmFnc3RhcnRcIixcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBpT1Mgd29ya2Fyb3VuZCBmb3Igc2xpZGVyIHN0b3BwaW5nIGlmIHN3aXBpbmcgZmFzdFxuICAgICAgICAgIG5hbWU6IHBvaW50ZXJNb3ZlLFxuICAgICAgICAgIGVsOiAoeyBsaXN0IH0pID0+IGxpc3QsXG4gICAgICAgICAgaGFuZGxlcjogbm9vcCxcbiAgICAgICAgICAuLi5wb2ludGVyT3B0aW9uc1xuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICB0aGlzLmRyYWcgPSB0aGlzLnBvcztcbiAgICAgICAgICBpZiAodGhpcy5fdHJhbnNpdGlvbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmNlbnQgPSB0aGlzLl90cmFuc2l0aW9uZXIucGVyY2VudCgpO1xuICAgICAgICAgICAgdGhpcy5kcmFnICs9IHRoaXMuX3RyYW5zaXRpb25lci5nZXREaXN0YW5jZSgpICogdGhpcy5wZXJjZW50ICogdGhpcy5kaXI7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIudHJhbnNsYXRlKHRoaXMucGVyY2VudCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSwgcG9pbnRlck9wdGlvbnMpO1xuICAgICAgICAgIG9uKGRvY3VtZW50LCBwb2ludGVyVXAsIHRoaXMuZW5kLCBwb2ludGVyVXBPcHRpb25zKTtcbiAgICAgICAgICBjc3ModGhpcy5saXN0LCBcInVzZXJTZWxlY3RcIiwgXCJub25lXCIpO1xuICAgICAgICB9LFxuICAgICAgICBtb3ZlKGUpIHtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHRoaXMucG9zIC0gdGhpcy5kcmFnO1xuICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCB8fCB0aGlzLnByZXZQb3MgPT09IHRoaXMucG9zIHx8ICF0aGlzLmRyYWdnaW5nICYmIE1hdGguYWJzKGRpc3RhbmNlKSA8IHRoaXMudGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGUuY2FuY2VsYWJsZSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgdGhpcy5kaXIgPSBkaXN0YW5jZSA8IDAgPyAxIDogLTE7XG4gICAgICAgICAgbGV0IHsgc2xpZGVzLCBwcmV2SW5kZXggfSA9IHRoaXM7XG4gICAgICAgICAgbGV0IGRpcyA9IE1hdGguYWJzKGRpc3RhbmNlKTtcbiAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gdGhpcy5nZXRJbmRleChwcmV2SW5kZXggKyB0aGlzLmRpcik7XG4gICAgICAgICAgbGV0IHdpZHRoID0gZ2V0RGlzdGFuY2UuY2FsbCh0aGlzLCBwcmV2SW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgd2hpbGUgKG5leHRJbmRleCAhPT0gcHJldkluZGV4ICYmIGRpcyA+IHdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWcgLT0gd2lkdGggKiB0aGlzLmRpcjtcbiAgICAgICAgICAgIHByZXZJbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICAgIGRpcyAtPSB3aWR0aDtcbiAgICAgICAgICAgIG5leHRJbmRleCA9IHRoaXMuZ2V0SW5kZXgocHJldkluZGV4ICsgdGhpcy5kaXIpO1xuICAgICAgICAgICAgd2lkdGggPSBnZXREaXN0YW5jZS5jYWxsKHRoaXMsIHByZXZJbmRleCwgbmV4dEluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wZXJjZW50ID0gZGlzIC8gd2lkdGg7XG4gICAgICAgICAgY29uc3QgcHJldiA9IHNsaWRlc1twcmV2SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBzbGlkZXNbbmV4dEluZGV4XTtcbiAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5pbmRleCAhPT0gbmV4dEluZGV4O1xuICAgICAgICAgIGNvbnN0IGVkZ2UgPSBwcmV2SW5kZXggPT09IG5leHRJbmRleDtcbiAgICAgICAgICBsZXQgaXRlbVNob3duO1xuICAgICAgICAgIGZvciAoY29uc3QgaSBvZiBbdGhpcy5pbmRleCwgdGhpcy5wcmV2SW5kZXhdKSB7XG4gICAgICAgICAgICBpZiAoIWluY2x1ZGVzKFtuZXh0SW5kZXgsIHByZXZJbmRleF0sIGkpKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXIoc2xpZGVzW2ldLCBcIml0ZW1oaWRkZW5cIiwgW3RoaXNdKTtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UpIHtcbiAgICAgICAgICAgICAgICBpdGVtU2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucHJldkluZGV4ID0gcHJldkluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSBwcmV2SW5kZXggJiYgdGhpcy5wcmV2SW5kZXggIT09IHByZXZJbmRleCB8fCBpdGVtU2hvd24pIHtcbiAgICAgICAgICAgIHRyaWdnZXIoc2xpZGVzW3RoaXMuaW5kZXhdLCBcIml0ZW1zaG93blwiLCBbdGhpc10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgaWYgKCFlZGdlKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXIocHJldiwgXCJiZWZvcmVpdGVtaGlkZVwiLCBbdGhpc10pO1xuICAgICAgICAgICAgICB0cmlnZ2VyKHByZXYsIFwiaXRlbWhpZGVcIiwgW3RoaXNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyaWdnZXIobmV4dCwgXCJiZWZvcmVpdGVtc2hvd1wiLCBbdGhpc10pO1xuICAgICAgICAgICAgdHJpZ2dlcihuZXh0LCBcIml0ZW1zaG93XCIsIFt0aGlzXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lciA9IHRoaXMuX3RyYW5zbGF0ZShNYXRoLmFicyh0aGlzLnBlcmNlbnQpLCBwcmV2LCAhZWRnZSAmJiBuZXh0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlck1vdmUsIHRoaXMubW92ZSwgcG9pbnRlck9wdGlvbnMpO1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlclVwLCB0aGlzLmVuZCwgcG9pbnRlclVwT3B0aW9ucyk7XG4gICAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQob24odGhpcy5saXN0LCBcImNsaWNrXCIsIChlKSA9PiBlLnByZXZlbnREZWZhdWx0KCksIHBvaW50ZXJPcHRpb25zKSk7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSB0aGlzLnByZXZJbmRleCkge1xuICAgICAgICAgICAgICB0aGlzLnBlcmNlbnQgPSAxIC0gdGhpcy5wZXJjZW50O1xuICAgICAgICAgICAgICB0aGlzLmRpciAqPSAtMTtcbiAgICAgICAgICAgICAgdGhpcy5fc2hvdyhmYWxzZSwgdGhpcy5pbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25lciA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBkaXJDaGFuZ2UgPSAoaXNSdGwgPyB0aGlzLmRpciAqIChpc1J0bCA/IDEgOiAtMSkgOiB0aGlzLmRpcikgPCAwID09PSB0aGlzLnByZXZQb3MgPiB0aGlzLnBvcztcbiAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGRpckNoYW5nZSA/IHRoaXMuaW5kZXggOiB0aGlzLnByZXZJbmRleDtcbiAgICAgICAgICAgICAgaWYgKGRpckNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXIodGhpcy5zbGlkZXNbdGhpcy5wcmV2SW5kZXhdLCBcIml0ZW1oaWRkZW5cIiwgW3RoaXNdKTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyKHRoaXMuc2xpZGVzW3RoaXMuaW5kZXhdLCBcIml0ZW1zaG93blwiLCBbdGhpc10pO1xuICAgICAgICAgICAgICAgIHRoaXMucGVyY2VudCA9IDEgLSB0aGlzLnBlcmNlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5zaG93KFxuICAgICAgICAgICAgICAgIHRoaXMuZGlyID4gMCAmJiAhZGlyQ2hhbmdlIHx8IHRoaXMuZGlyIDwgMCAmJiBkaXJDaGFuZ2UgPyBcIm5leHRcIiA6IFwicHJldmlvdXNcIixcbiAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzcyh0aGlzLmxpc3QsIHsgdXNlclNlbGVjdDogXCJcIiB9KTtcbiAgICAgICAgICB0aGlzLmRyYWcgPSB0aGlzLnBlcmNlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZXREaXN0YW5jZShwcmV2LCBuZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VHJhbnNpdGlvbmVyKHByZXYsIHByZXYgIT09IG5leHQgJiYgbmV4dCkuZ2V0RGlzdGFuY2UoKSB8fCB0aGlzLnNsaWRlc1twcmV2XS5vZmZzZXRXaWR0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzU2VsZWN0YWJsZVRleHQoZWwpIHtcbiAgICAgIHJldHVybiBjc3MoZWwsIFwidXNlclNlbGVjdFwiKSAhPT0gXCJub25lXCIgJiYgdG9BcnJheShlbC5jaGlsZE5vZGVzKS5zb21lKChlbDIpID0+IGVsMi5ub2RlVHlwZSA9PT0gMyAmJiBlbDIudGV4dENvbnRlbnQudHJpbSgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0V2F0Y2hlcyhpbnN0YW5jZSkge1xuICAgICAgaW5zdGFuY2UuX3dhdGNoZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgd2F0Y2hlcyBvZiBpbnN0YW5jZS4kb3B0aW9ucy53YXRjaCB8fCBbXSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB3YXRjaF0gb2YgT2JqZWN0LmVudHJpZXMod2F0Y2hlcykpIHtcbiAgICAgICAgICByZWdpc3RlcldhdGNoKGluc3RhbmNlLCB3YXRjaCwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLl9pbml0aWFsID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJXYXRjaChpbnN0YW5jZSwgd2F0Y2gsIG5hbWUpIHtcbiAgICAgIGluc3RhbmNlLl93YXRjaGVzLnB1c2goe1xuICAgICAgICBuYW1lLFxuICAgICAgICAuLi5pc1BsYWluT2JqZWN0KHdhdGNoKSA/IHdhdGNoIDogeyBoYW5kbGVyOiB3YXRjaCB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcnVuV2F0Y2hlcyhpbnN0YW5jZSwgdmFsdWVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgbmFtZSwgaGFuZGxlciwgaW1tZWRpYXRlID0gdHJ1ZSB9IG9mIGluc3RhbmNlLl93YXRjaGVzKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5faW5pdGlhbCAmJiBpbW1lZGlhdGUgfHwgaGFzT3duKHZhbHVlcywgbmFtZSkgJiYgIWlzRXF1YWwodmFsdWVzW25hbWVdLCBpbnN0YW5jZVtuYW1lXSkpIHtcbiAgICAgICAgICBoYW5kbGVyLmNhbGwoaW5zdGFuY2UsIGluc3RhbmNlW25hbWVdLCB2YWx1ZXNbbmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5faW5pdGlhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRDb21wdXRlZChpbnN0YW5jZSkge1xuICAgICAgY29uc3QgeyBjb21wdXRlZCB9ID0gaW5zdGFuY2UuJG9wdGlvbnM7XG4gICAgICBpbnN0YW5jZS5fY29tcHV0ZWQgPSB7fTtcbiAgICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICAgIHJlZ2lzdGVyQ29tcHV0ZWQoaW5zdGFuY2UsIGtleSwgY29tcHV0ZWRba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbXV0YXRpb25PcHRpb25zID0geyBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfTtcbiAgICBmdW5jdGlvbiByZWdpc3RlckNvbXB1dGVkKGluc3RhbmNlLCBrZXksIGNiKSB7XG4gICAgICBpbnN0YW5jZS5faGFzQ29tcHV0ZWQgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3RhbmNlLCBrZXksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IHsgX2NvbXB1dGVkLCAkcHJvcHMsICRlbCB9ID0gaW5zdGFuY2U7XG4gICAgICAgICAgaWYgKCFoYXNPd24oX2NvbXB1dGVkLCBrZXkpKSB7XG4gICAgICAgICAgICBfY29tcHV0ZWRba2V5XSA9IChjYi5nZXQgfHwgY2IpLmNhbGwoaW5zdGFuY2UsICRwcm9wcywgJGVsKTtcbiAgICAgICAgICAgIGlmIChjYi5vYnNlcnZlICYmIGluc3RhbmNlLl9jb21wdXRlZE9ic2VydmVyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gY2Iub2JzZXJ2ZS5jYWxsKGluc3RhbmNlLCAkcHJvcHMpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5fY29tcHV0ZWRPYnNlcnZlci5vYnNlcnZlKFxuICAgICAgICAgICAgICAgIFtcIn5cIiwgXCIrXCIsIFwiLVwiXS5pbmNsdWRlcyhzZWxlY3RvclswXSkgPyAkZWwucGFyZW50RWxlbWVudCA6ICRlbC5nZXRSb290Tm9kZSgpLFxuICAgICAgICAgICAgICAgIG11dGF0aW9uT3B0aW9uc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX2NvbXB1dGVkW2tleV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgX2NvbXB1dGVkIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgICBfY29tcHV0ZWRba2V5XSA9IGNiLnNldCA/IGNiLnNldC5jYWxsKGluc3RhbmNlLCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoX2NvbXB1dGVkW2tleV0pKSB7XG4gICAgICAgICAgICBkZWxldGUgX2NvbXB1dGVkW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdENvbXB1dGVkVXBkYXRlcyhpbnN0YW5jZSkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5faGFzQ29tcHV0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcHJlcGVuZFVwZGF0ZShpbnN0YW5jZSwge1xuICAgICAgICByZWFkOiAoKSA9PiBydW5XYXRjaGVzKGluc3RhbmNlLCByZXNldENvbXB1dGVkKGluc3RhbmNlKSksXG4gICAgICAgIGV2ZW50czogW1wicmVzaXplXCIsIFwiY29tcHV0ZWRcIl1cbiAgICAgIH0pO1xuICAgICAgaW5zdGFuY2UuX2NvbXB1dGVkT2JzZXJ2ZXIgPSBvYnNlcnZlTXV0YXRpb24oXG4gICAgICAgIGluc3RhbmNlLiRlbCxcbiAgICAgICAgKCkgPT4gY2FsbFVwZGF0ZShpbnN0YW5jZSwgXCJjb21wdXRlZFwiKSxcbiAgICAgICAgbXV0YXRpb25PcHRpb25zXG4gICAgICApO1xuICAgICAgaW5zdGFuY2UuX2Rpc2Nvbm5lY3QucHVzaCgoKSA9PiB7XG4gICAgICAgIGluc3RhbmNlLl9jb21wdXRlZE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgaW5zdGFuY2UuX2NvbXB1dGVkT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICByZXNldENvbXB1dGVkKGluc3RhbmNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXNldENvbXB1dGVkKGluc3RhbmNlKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB7IC4uLmluc3RhbmNlLl9jb21wdXRlZCB9O1xuICAgICAgaW5zdGFuY2UuX2NvbXB1dGVkID0ge307XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRFdmVudHMoaW5zdGFuY2UpIHtcbiAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgaW5zdGFuY2UuJG9wdGlvbnMuZXZlbnRzIHx8IFtdKSB7XG4gICAgICAgIGlmIChoYXNPd24oZXZlbnQsIFwiaGFuZGxlclwiKSkge1xuICAgICAgICAgIHJlZ2lzdGVyRXZlbnQoaW5zdGFuY2UsIGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudCkge1xuICAgICAgICAgICAgcmVnaXN0ZXJFdmVudChpbnN0YW5jZSwgeyBuYW1lOiBrZXksIGhhbmRsZXI6IGV2ZW50W2tleV0gfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyRXZlbnQoaW5zdGFuY2UsIHsgbmFtZSwgZWwsIGhhbmRsZXIsIGNhcHR1cmUsIHBhc3NpdmUsIGRlbGVnYXRlLCBmaWx0ZXIsIHNlbGYgfSkge1xuICAgICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyLmNhbGwoaW5zdGFuY2UsIGluc3RhbmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5fZGlzY29ubmVjdC5wdXNoKFxuICAgICAgICBvbihcbiAgICAgICAgICBlbCA/IGVsLmNhbGwoaW5zdGFuY2UsIGluc3RhbmNlKSA6IGluc3RhbmNlLiRlbCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRlbGVnYXRlID09IG51bGwgPyB2b2lkIDAgOiBkZWxlZ2F0ZS5jYWxsKGluc3RhbmNlLCBpbnN0YW5jZSksXG4gICAgICAgICAgaGFuZGxlci5iaW5kKGluc3RhbmNlKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwYXNzaXZlLFxuICAgICAgICAgICAgY2FwdHVyZSxcbiAgICAgICAgICAgIHNlbGZcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdE9ic2VydmVycyhpbnN0YW5jZSkge1xuICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBpbnN0YW5jZS4kb3B0aW9ucy5vYnNlcnZlIHx8IFtdKSB7XG4gICAgICAgIHJlZ2lzdGVyT2JzZXJ2YWJsZShpbnN0YW5jZSwgb2JzZXJ2ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3Rlck9ic2VydmFibGUoaW5zdGFuY2UsIG9ic2VydmFibGUpIHtcbiAgICAgIGxldCB7IG9ic2VydmUsIHRhcmdldCA9IGluc3RhbmNlLiRlbCwgaGFuZGxlciwgb3B0aW9ucywgZmlsdGVyLCBhcmdzIH0gPSBvYnNlcnZhYmxlO1xuICAgICAgaWYgKGZpbHRlciAmJiAhZmlsdGVyLmNhbGwoaW5zdGFuY2UsIGluc3RhbmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSBgX29ic2VydmUke2luc3RhbmNlLl9kaXNjb25uZWN0Lmxlbmd0aH1gO1xuICAgICAgaWYgKGlzRnVuY3Rpb24odGFyZ2V0KSAmJiAhaGFzT3duKGluc3RhbmNlLCBrZXkpKSB7XG4gICAgICAgIHJlZ2lzdGVyQ29tcHV0ZWQoaW5zdGFuY2UsIGtleSwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldHMyID0gdGFyZ2V0LmNhbGwoaW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgICByZXR1cm4gaXNBcnJheSh0YXJnZXRzMikgPyB0b05vZGVzKHRhcmdldHMyKSA6IHRhcmdldHMyO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGhhbmRsZXIgPSBpc1N0cmluZyhoYW5kbGVyKSA/IGluc3RhbmNlW2hhbmRsZXJdIDogaGFuZGxlci5iaW5kKGluc3RhbmNlKTtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoaW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldHMgPSBoYXNPd24oaW5zdGFuY2UsIGtleSkgPyBpbnN0YW5jZVtrZXldIDogdGFyZ2V0O1xuICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBvYnNlcnZlKHRhcmdldHMsIGhhbmRsZXIsIG9wdGlvbnMsIGFyZ3MpO1xuICAgICAgaWYgKGlzRnVuY3Rpb24odGFyZ2V0KSAmJiBpc0FycmF5KGluc3RhbmNlW2tleV0pKSB7XG4gICAgICAgIHJlZ2lzdGVyV2F0Y2goXG4gICAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgICAgeyBoYW5kbGVyOiB1cGRhdGVUYXJnZXRzKG9ic2VydmVyLCBvcHRpb25zKSwgaW1tZWRpYXRlOiBmYWxzZSB9LFxuICAgICAgICAgIGtleVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UuX2Rpc2Nvbm5lY3QucHVzaCgoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVUYXJnZXRzKG9ic2VydmVyLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gKHRhcmdldHMsIHByZXYpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgcHJldikge1xuICAgICAgICAgIGlmICghaW5jbHVkZXModGFyZ2V0cywgdGFyZ2V0KSkge1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyLnVub2JzZXJ2ZSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JzZXJ2ZXIub2JzZXJ2ZSkge1xuICAgICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICAgICAgICBpZiAoIWluY2x1ZGVzKHByZXYsIHRhcmdldCkgfHwgIW9ic2VydmVyLnVub2JzZXJ2ZSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0UHJvcHMoaW5zdGFuY2UpIHtcbiAgICAgIGNvbnN0IHsgJG9wdGlvbnMsICRwcm9wcyB9ID0gaW5zdGFuY2U7XG4gICAgICBjb25zdCBwcm9wcyA9IGdldFByb3BzKCRvcHRpb25zKTtcbiAgICAgIGFzc2lnbigkcHJvcHMsIHByb3BzKTtcbiAgICAgIGNvbnN0IHsgY29tcHV0ZWQsIG1ldGhvZHMgfSA9ICRvcHRpb25zO1xuICAgICAgZm9yIChsZXQga2V5IGluICRwcm9wcykge1xuICAgICAgICBpZiAoa2V5IGluIHByb3BzICYmICghY29tcHV0ZWQgfHwgIWhhc093bihjb21wdXRlZCwga2V5KSkgJiYgKCFtZXRob2RzIHx8ICFoYXNPd24obWV0aG9kcywga2V5KSkpIHtcbiAgICAgICAgICBpbnN0YW5jZVtrZXldID0gJHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UHJvcHMob3B0cykge1xuICAgICAgY29uc3QgZGF0YSQxID0ge307XG4gICAgICBjb25zdCB7IGFyZ3MgPSBbXSwgcHJvcHMgPSB7fSwgZWwsIGlkIH0gPSBvcHRzO1xuICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICByZXR1cm4gZGF0YSQxO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICBsZXQgdmFsdWUgPSBkYXRhKGVsLCBwcm9wKTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gcHJvcHNba2V5XSA9PT0gQm9vbGVhbiAmJiB2YWx1ZSA9PT0gXCJcIiA/IHRydWUgOiBjb2VyY2UkMShwcm9wc1trZXldLCB2YWx1ZSk7XG4gICAgICAgIGlmIChwcm9wID09PSBcInRhcmdldFwiICYmIHN0YXJ0c1dpdGgodmFsdWUsIFwiX1wiKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEkMVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gcGFyc2VPcHRpb25zKGRhdGEoZWwsIGlkKSwgYXJncyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHByb3AgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHByb3BzW3Byb3BdKSkge1xuICAgICAgICAgIGRhdGEkMVtwcm9wXSA9IGNvZXJjZSQxKHByb3BzW3Byb3BdLCBvcHRpb25zW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YSQxO1xuICAgIH1cbiAgICBjb25zdCBnZXRBdHRyaWJ1dGVzID0gbWVtb2l6ZSgoaWQsIHByb3BzKSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgICAgY29uc3QgZmlsdGVyID0gYXR0cmlidXRlcy5jb25jYXQoaWQpLm1hcCgoa2V5KSA9PiBbaHlwaGVuYXRlKGtleSksIGBkYXRhLSR7aHlwaGVuYXRlKGtleSl9YF0pLmZsYXQoKTtcbiAgICAgIHJldHVybiB7IGF0dHJpYnV0ZXMsIGZpbHRlciB9O1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGluaXRQcm9wc09ic2VydmVyKGluc3RhbmNlKSB7XG4gICAgICBjb25zdCB7ICRvcHRpb25zLCAkcHJvcHMgfSA9IGluc3RhbmNlO1xuICAgICAgY29uc3QgeyBpZCwgcHJvcHMsIGVsIH0gPSAkb3B0aW9ucztcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBhdHRyaWJ1dGVzLCBmaWx0ZXIgfSA9IGdldEF0dHJpYnV0ZXMoaWQsIHByb3BzKTtcbiAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldFByb3BzKCRvcHRpb25zKTtcbiAgICAgICAgaWYgKHJlY29yZHMuc29tZSgoeyBhdHRyaWJ1dGVOYW1lIH0pID0+IHtcbiAgICAgICAgICBjb25zdCBwcm9wID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKFwiZGF0YS1cIiwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIChwcm9wID09PSBpZCA/IGF0dHJpYnV0ZXMgOiBbY2FtZWxpemUocHJvcCksIGNhbWVsaXplKGF0dHJpYnV0ZU5hbWUpXSkuc29tZShcbiAgICAgICAgICAgIChwcm9wMikgPT4gIWlzVW5kZWZpbmVkKGRhdGFbcHJvcDJdKSAmJiBkYXRhW3Byb3AyXSAhPT0gJHByb3BzW3Byb3AyXVxuICAgICAgICAgICk7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgaW5zdGFuY2UuJHJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IGZpbHRlclxuICAgICAgfSk7XG4gICAgICBpbnN0YW5jZS5fZGlzY29ubmVjdC5wdXNoKCgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbEhvb2soaW5zdGFuY2UsIGhvb2spIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IGluc3RhbmNlLiRvcHRpb25zW2hvb2tdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoaGFuZGxlcikgPT4gaGFuZGxlci5jYWxsKGluc3RhbmNlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxDb25uZWN0ZWQoaW5zdGFuY2UpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5fY29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGluaXRQcm9wcyhpbnN0YW5jZSk7XG4gICAgICBjYWxsSG9vayhpbnN0YW5jZSwgXCJiZWZvcmVDb25uZWN0XCIpO1xuICAgICAgaW5zdGFuY2UuX2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICBpbnN0YW5jZS5fZGlzY29ubmVjdCA9IFtdO1xuICAgICAgaW5pdEV2ZW50cyhpbnN0YW5jZSk7XG4gICAgICBpbml0VXBkYXRlcyhpbnN0YW5jZSk7XG4gICAgICBpbml0V2F0Y2hlcyhpbnN0YW5jZSk7XG4gICAgICBpbml0T2JzZXJ2ZXJzKGluc3RhbmNlKTtcbiAgICAgIGluaXRQcm9wc09ic2VydmVyKGluc3RhbmNlKTtcbiAgICAgIGluaXRDb21wdXRlZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgICAgY2FsbEhvb2soaW5zdGFuY2UsIFwiY29ubmVjdGVkXCIpO1xuICAgICAgY2FsbFVwZGF0ZShpbnN0YW5jZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNhbGxEaXNjb25uZWN0ZWQoaW5zdGFuY2UpIHtcbiAgICAgIGlmICghaW5zdGFuY2UuX2Nvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsSG9vayhpbnN0YW5jZSwgXCJiZWZvcmVEaXNjb25uZWN0XCIpO1xuICAgICAgaW5zdGFuY2UuX2Rpc2Nvbm5lY3QuZm9yRWFjaCgob2ZmKSA9PiBvZmYoKSk7XG4gICAgICBpbnN0YW5jZS5fZGlzY29ubmVjdCA9IG51bGw7XG4gICAgICBjYWxsSG9vayhpbnN0YW5jZSwgXCJkaXNjb25uZWN0ZWRcIik7XG4gICAgICBpbnN0YW5jZS5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHVpZCA9IDA7XG4gICAgZnVuY3Rpb24gaW5pdCQxKGluc3RhbmNlLCBvcHRpb25zID0ge30pIHtcbiAgICAgIG9wdGlvbnMuZGF0YSA9IG5vcm1hbGl6ZURhdGEob3B0aW9ucywgaW5zdGFuY2UuY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gICAgICBpbnN0YW5jZS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhpbnN0YW5jZS5jb25zdHJ1Y3Rvci5vcHRpb25zLCBvcHRpb25zLCBpbnN0YW5jZSk7XG4gICAgICBpbnN0YW5jZS4kcHJvcHMgPSB7fTtcbiAgICAgIGluc3RhbmNlLl91aWQgPSB1aWQrKztcbiAgICAgIGluaXREYXRhKGluc3RhbmNlKTtcbiAgICAgIGluaXRNZXRob2RzKGluc3RhbmNlKTtcbiAgICAgIGluaXRDb21wdXRlZChpbnN0YW5jZSk7XG4gICAgICBjYWxsSG9vayhpbnN0YW5jZSwgXCJjcmVhdGVkXCIpO1xuICAgICAgaWYgKG9wdGlvbnMuZWwpIHtcbiAgICAgICAgaW5zdGFuY2UuJG1vdW50KG9wdGlvbnMuZWwpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0RGF0YShpbnN0YW5jZSkge1xuICAgICAgY29uc3QgeyBkYXRhID0ge30gfSA9IGluc3RhbmNlLiRvcHRpb25zO1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpbnN0YW5jZS4kcHJvcHNba2V5XSA9IGluc3RhbmNlW2tleV0gPSBkYXRhW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRNZXRob2RzKGluc3RhbmNlKSB7XG4gICAgICBjb25zdCB7IG1ldGhvZHMgfSA9IGluc3RhbmNlLiRvcHRpb25zO1xuICAgICAgaWYgKG1ldGhvZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWV0aG9kcykge1xuICAgICAgICAgIGluc3RhbmNlW2tleV0gPSBtZXRob2RzW2tleV0uYmluZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YSh7IGRhdGEgPSB7fSB9LCB7IGFyZ3MgPSBbXSwgcHJvcHMgPSB7fSB9KSB7XG4gICAgICBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgICBkYXRhID0gZGF0YS5zbGljZSgwLCBhcmdzLmxlbmd0aCkucmVkdWNlKChkYXRhMiwgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBhc3NpZ24oZGF0YTIsIHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YTJbYXJnc1tpbmRleF1dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkYXRhMjtcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoZGF0YVtrZXldKSkge1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcHNba2V5XSkge1xuICAgICAgICAgIGRhdGFba2V5XSA9IGNvZXJjZSQxKHByb3BzW2tleV0sIGRhdGFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGNvbnN0IEFwcCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGluaXQkMSh0aGlzLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEFwcC51dGlsID0gdXRpbDtcbiAgICBBcHAub3B0aW9ucyA9IHt9O1xuICAgIEFwcC52ZXJzaW9uID0gXCIzLjIyLjBcIjtcblxuICAgIGNvbnN0IFBSRUZJWCA9IFwidWstXCI7XG4gICAgY29uc3QgREFUQSA9IFwiX191aWtpdF9fXCI7XG4gICAgY29uc3QgY29tcG9uZW50cyQyID0ge307XG4gICAgZnVuY3Rpb24gY29tcG9uZW50KG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBpZCA9IFBSRUZJWCArIGh5cGhlbmF0ZShuYW1lKTtcbiAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICBpZiAoIWNvbXBvbmVudHMkMltpZF0ub3B0aW9ucykge1xuICAgICAgICAgIGNvbXBvbmVudHMkMltpZF0gPSBBcHAuZXh0ZW5kKGNvbXBvbmVudHMkMltpZF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRzJDJbaWRdO1xuICAgICAgfVxuICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgQXBwW25hbWVdID0gKGVsZW1lbnQsIGRhdGEpID0+IGNyZWF0ZUNvbXBvbmVudChuYW1lLCBlbGVtZW50LCBkYXRhKTtcbiAgICAgIGNvbnN0IG9wdCA9IChfYSA9IG9wdGlvbnMub3B0aW9ucykgIT0gbnVsbCA/IF9hIDogeyAuLi5vcHRpb25zIH07XG4gICAgICBvcHQuaWQgPSBpZDtcbiAgICAgIG9wdC5uYW1lID0gbmFtZTtcbiAgICAgIChfYiA9IG9wdC5pbnN0YWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHQsIEFwcCwgb3B0LCBuYW1lKTtcbiAgICAgIGlmIChBcHAuX2luaXRpYWxpemVkICYmICFvcHQuZnVuY3Rpb25hbCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gY3JlYXRlQ29tcG9uZW50KG5hbWUsIGBbJHtpZH1dLFtkYXRhLSR7aWR9XWApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb21wb25lbnRzJDJbaWRdID0gb3B0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQobmFtZSwgZWxlbWVudCwgZGF0YSwgLi4uYXJncykge1xuICAgICAgY29uc3QgQ29tcG9uZW50ID0gY29tcG9uZW50KG5hbWUpO1xuICAgICAgcmV0dXJuIENvbXBvbmVudC5vcHRpb25zLmZ1bmN0aW9uYWwgPyBuZXcgQ29tcG9uZW50KHsgZGF0YTogaXNQbGFpbk9iamVjdChlbGVtZW50KSA/IGVsZW1lbnQgOiBbZWxlbWVudCwgZGF0YSwgLi4uYXJnc10gfSkgOiBlbGVtZW50ID8gJCQoZWxlbWVudCkubWFwKGluaXQpWzBdIDogaW5pdCgpO1xuICAgICAgZnVuY3Rpb24gaW5pdChlbGVtZW50Mikge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGdldENvbXBvbmVudChlbGVtZW50MiwgbmFtZSk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KHsgZWw6IGVsZW1lbnQyLCBkYXRhIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnRzKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAoZWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogZWxlbWVudFtEQVRBXSkgfHwge307XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbXBvbmVudChlbGVtZW50LCBuYW1lKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50cyhlbGVtZW50KVtuYW1lXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXR0YWNoVG9FbGVtZW50KGVsZW1lbnQsIGluc3RhbmNlKSB7XG4gICAgICBpZiAoIWVsZW1lbnRbREFUQV0pIHtcbiAgICAgICAgZWxlbWVudFtEQVRBXSA9IHt9O1xuICAgICAgfVxuICAgICAgZWxlbWVudFtEQVRBXVtpbnN0YW5jZS4kb3B0aW9ucy5uYW1lXSA9IGluc3RhbmNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXRhY2hGcm9tRWxlbWVudChlbGVtZW50LCBpbnN0YW5jZSkge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gZWxlbWVudFtEQVRBXSkgPT0gbnVsbCA/IHRydWUgOiBkZWxldGUgX2FbaW5zdGFuY2UuJG9wdGlvbnMubmFtZV07XG4gICAgICBpZiAoaXNFbXB0eShlbGVtZW50W0RBVEFdKSkge1xuICAgICAgICBkZWxldGUgZWxlbWVudFtEQVRBXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnbG9iYWxBcGkoQXBwKSB7XG4gICAgICBBcHAuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgQXBwLmdldENvbXBvbmVudHMgPSBnZXRDb21wb25lbnRzO1xuICAgICAgQXBwLmdldENvbXBvbmVudCA9IGdldENvbXBvbmVudDtcbiAgICAgIEFwcC51cGRhdGUgPSB1cGRhdGU7XG4gICAgICBBcHAudXNlID0gZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgIGlmIChwbHVnaW4uaW5zdGFsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBsdWdpbi5jYWxsKG51bGwsIHRoaXMpO1xuICAgICAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgICAgQXBwLm1peGluID0gZnVuY3Rpb24obWl4aW4sIGNvbXBvbmVudDIpIHtcbiAgICAgICAgY29tcG9uZW50MiA9IChpc1N0cmluZyhjb21wb25lbnQyKSA/IHRoaXMuY29tcG9uZW50KGNvbXBvbmVudDIpIDogY29tcG9uZW50MikgfHwgdGhpcztcbiAgICAgICAgY29tcG9uZW50Mi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKGNvbXBvbmVudDIub3B0aW9ucywgbWl4aW4pO1xuICAgICAgfTtcbiAgICAgIEFwcC5leHRlbmQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gICAgICAgIGNvbnN0IFN1cGVyID0gdGhpcztcbiAgICAgICAgY29uc3QgU3ViID0gZnVuY3Rpb24gVUlraXRDb21wb25lbnQob3B0aW9uczIpIHtcbiAgICAgICAgICBpbml0JDEodGhpcywgb3B0aW9uczIpO1xuICAgICAgICB9O1xuICAgICAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgICAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgU3ViLnN1cGVyID0gU3VwZXI7XG4gICAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgICAgIHJldHVybiBTdWI7XG4gICAgICB9O1xuICAgICAgbGV0IGNvbnRhaW5lcjtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHAsIFwiY29udGFpbmVyXCIsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBjb250YWluZXIgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KGVsZW1lbnQpIHtcbiAgICAgICAgICBjb250YWluZXIgPSAkKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlKGVsZW1lbnQsIGUpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50ID8gdG9Ob2RlKGVsZW1lbnQpIDogZG9jdW1lbnQuYm9keTtcbiAgICAgIGZvciAoY29uc3QgcGFyZW50RWwgb2YgcGFyZW50cyhlbGVtZW50KS5yZXZlcnNlKCkpIHtcbiAgICAgICAgdXBkYXRlRWxlbWVudChwYXJlbnRFbCwgZSk7XG4gICAgICB9XG4gICAgICBhcHBseShlbGVtZW50LCAoZWxlbWVudDIpID0+IHVwZGF0ZUVsZW1lbnQoZWxlbWVudDIsIGUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChlbGVtZW50LCBlKSB7XG4gICAgICBjb25zdCBjb21wb25lbnRzID0gZ2V0Q29tcG9uZW50cyhlbGVtZW50KTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBjb21wb25lbnRzKSB7XG4gICAgICAgIGNhbGxVcGRhdGUoY29tcG9uZW50c1tuYW1lXSwgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFuY2VBcGkoQXBwKSB7XG4gICAgICBBcHAucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcztcbiAgICAgICAgYXR0YWNoVG9FbGVtZW50KGVsLCBpbnN0YW5jZSk7XG4gICAgICAgIGluc3RhbmNlLiRvcHRpb25zLmVsID0gZWw7XG4gICAgICAgIGlmIChlbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgIGNhbGxDb25uZWN0ZWQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgQXBwLnByb3RvdHlwZS4kZGVzdHJveSA9IGZ1bmN0aW9uKHJlbW92ZUVsID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGVsIH0gPSBpbnN0YW5jZS4kb3B0aW9ucztcbiAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgY2FsbERpc2Nvbm5lY3RlZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbEhvb2soaW5zdGFuY2UsIFwiZGVzdHJveVwiKTtcbiAgICAgICAgZGV0YWNoRnJvbUVsZW1lbnQoZWwsIGluc3RhbmNlKTtcbiAgICAgICAgaWYgKHJlbW92ZUVsKSB7XG4gICAgICAgICAgcmVtb3ZlJDEoaW5zdGFuY2UuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIEFwcC5wcm90b3R5cGUuJGNyZWF0ZSA9IGNyZWF0ZUNvbXBvbmVudDtcbiAgICAgIEFwcC5wcm90b3R5cGUuJGVtaXQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNhbGxVcGRhdGUodGhpcywgZSk7XG4gICAgICB9O1xuICAgICAgQXBwLnByb3RvdHlwZS4kdXBkYXRlID0gZnVuY3Rpb24oZWxlbWVudCA9IHRoaXMuJGVsLCBlKSB7XG4gICAgICAgIHVwZGF0ZShlbGVtZW50LCBlKTtcbiAgICAgIH07XG4gICAgICBBcHAucHJvdG90eXBlLiRyZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjYWxsRGlzY29ubmVjdGVkKHRoaXMpO1xuICAgICAgICBjYWxsQ29ubmVjdGVkKHRoaXMpO1xuICAgICAgfTtcbiAgICAgIEFwcC5wcm90b3R5cGUuJGdldENvbXBvbmVudCA9IGdldENvbXBvbmVudDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFwcC5wcm90b3R5cGUsIHtcbiAgICAgICAgJGVsOiB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG9wdGlvbnMuZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAkY29udGFpbmVyOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEFwcCwgXCJjb250YWluZXJcIilcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgaWQgPSAxO1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlSWQoaW5zdGFuY2UsIGVsID0gbnVsbCkge1xuICAgICAgcmV0dXJuIChlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuaWQpIHx8IGAke2luc3RhbmNlLiRvcHRpb25zLmlkfS0ke2lkKyt9YDtcbiAgICB9XG5cbiAgICB2YXIgU2xpZGVyTmF2ID0ge1xuICAgICAgaTE4bjoge1xuICAgICAgICBuZXh0OiBcIk5leHQgc2xpZGVcIixcbiAgICAgICAgcHJldmlvdXM6IFwiUHJldmlvdXMgc2xpZGVcIixcbiAgICAgICAgc2xpZGVYOiBcIlNsaWRlICVzXCIsXG4gICAgICAgIHNsaWRlTGFiZWw6IFwiJXMgb2YgJXNcIixcbiAgICAgICAgcm9sZTogXCJTdHJpbmdcIlxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc2VsTmF2OiBmYWxzZSxcbiAgICAgICAgcm9sZTogXCJyZWdpb25cIlxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIG5hdjogKHsgc2VsTmF2IH0sICRlbCkgPT4gJChzZWxOYXYsICRlbCksXG4gICAgICAgIG5hdkNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbih0aGlzLm5hdik7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbE5hdkl0ZW06ICh7IGF0dHJJdGVtIH0pID0+IGBbJHthdHRySXRlbX1dLFtkYXRhLSR7YXR0ckl0ZW19XWAsXG4gICAgICAgIG5hdkl0ZW1zKF8sICRlbCkge1xuICAgICAgICAgIHJldHVybiAkJCh0aGlzLnNlbE5hdkl0ZW0sICRlbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3YXRjaDoge1xuICAgICAgICBuYXYobmF2LCBwcmV2KSB7XG4gICAgICAgICAgYXR0cihuYXYsIFwicm9sZVwiLCBcInRhYmxpc3RcIik7XG4gICAgICAgICAgdGhpcy5wYWROYXZpdGVtcygpO1xuICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsaXN0KGxpc3QpIHtcbiAgICAgICAgICBpZiAoaXNUYWcobGlzdCwgXCJ1bFwiKSkge1xuICAgICAgICAgICAgYXR0cihsaXN0LCBcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBuYXZDaGlsZHJlbihjaGlsZHJlbjIpIHtcbiAgICAgICAgICBhdHRyKGNoaWxkcmVuMiwgXCJyb2xlXCIsIFwicHJlc2VudGF0aW9uXCIpO1xuICAgICAgICAgIHRoaXMucGFkTmF2aXRlbXMoKTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZU5hdigpO1xuICAgICAgICB9LFxuICAgICAgICBuYXZJdGVtcyhpdGVtcykge1xuICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGRhdGEoZWwsIHRoaXMuYXR0ckl0ZW0pO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9uID0gJChcImEsYnV0dG9uXCIsIGVsKSB8fCBlbDtcbiAgICAgICAgICAgIGxldCBhcmlhTGFiZWw7XG4gICAgICAgICAgICBsZXQgYXJpYUNvbnRyb2xzID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc051bWVyaWMoY21kKSkge1xuICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdG9OdW1iZXIoY21kKTtcbiAgICAgICAgICAgICAgY29uc3Qgc2xpZGUgPSB0aGlzLnNsaWRlc1tpdGVtXTtcbiAgICAgICAgICAgICAgaWYgKHNsaWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzbGlkZS5pZCkge1xuICAgICAgICAgICAgICAgICAgc2xpZGUuaWQgPSBnZW5lcmF0ZUlkKHRoaXMsIHNsaWRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXJpYUNvbnRyb2xzID0gc2xpZGUuaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJpYUxhYmVsID0gdGhpcy50KFwic2xpZGVYXCIsIHRvRmxvYXQoY21kKSArIDEpO1xuICAgICAgICAgICAgICBhdHRyKGJ1dHRvbiwgXCJyb2xlXCIsIFwidGFiXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5saXN0LmlkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxpc3QuaWQgPSBnZW5lcmF0ZUlkKHRoaXMsIHRoaXMubGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyaWFDb250cm9scyA9IHRoaXMubGlzdC5pZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmlhTGFiZWwgPSB0aGlzLnQoY21kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dHIoYnV0dG9uLCB7XG4gICAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBhcmlhQ29udHJvbHMsXG4gICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBhdHRyKGJ1dHRvbiwgXCJhcmlhLWxhYmVsXCIpIHx8IGFyaWFMYWJlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzbGlkZXMoc2xpZGVzKSB7XG4gICAgICAgICAgc2xpZGVzLmZvckVhY2goXG4gICAgICAgICAgICAoc2xpZGUsIGkpID0+IGF0dHIoc2xpZGUsIHtcbiAgICAgICAgICAgICAgcm9sZTogdGhpcy5uYXYgPyBcInRhYnBhbmVsXCIgOiBcImdyb3VwXCIsXG4gICAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnQoXCJzbGlkZUxhYmVsXCIsIGkgKyAxLCB0aGlzLmxlbmd0aCksXG4gICAgICAgICAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogdGhpcy5uYXYgPyBudWxsIDogXCJzbGlkZVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGhpcy5wYWROYXZpdGVtcygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBhdHRyKHRoaXMuJGVsLCB7XG4gICAgICAgICAgcm9sZTogdGhpcy5yb2xlLFxuICAgICAgICAgIFwiYXJpYS1yb2xlZGVzY3JpcHRpb25cIjogXCJjYXJvdXNlbFwiXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHVwZGF0ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgd3JpdGUoKSB7XG4gICAgICAgICAgICB0aGlzLm5hdkl0ZW1zLmNvbmNhdCh0aGlzLm5hdikuZm9yRWFjaCgoZWwpID0+IGVsICYmIChlbC5oaWRkZW4gPSAhdGhpcy5tYXhJbmRleCkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOYXYoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV2ZW50czogW1wicmVzaXplXCJdXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiY2xpY2sga2V5ZG93blwiLFxuICAgICAgICAgIGRlbGVnYXRlOiAoeyBzZWxOYXZJdGVtIH0pID0+IHNlbE5hdkl0ZW0sXG4gICAgICAgICAgZmlsdGVyOiAoeyBwYXJhbGxheCB9KSA9PiAhcGFyYWxsYXgsXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY2xvc2VzdChcImEsYnV0dG9uXCIpICYmIChlLnR5cGUgPT09IFwiY2xpY2tcIiB8fCBlLmtleUNvZGUgPT09IGtleU1hcC5TUEFDRSkpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICB0aGlzLnNob3coZGF0YShlLmN1cnJlbnQsIHRoaXMuYXR0ckl0ZW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIml0ZW1zaG93XCIsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTmF2KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJrZXlkb3duXCIsXG4gICAgICAgICAgZGVsZWdhdGU6ICh7IHNlbE5hdkl0ZW0gfSkgPT4gc2VsTmF2SXRlbSxcbiAgICAgICAgICBmaWx0ZXI6ICh7IHBhcmFsbGF4IH0pID0+ICFwYXJhbGxheCxcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudCwga2V5Q29kZSB9ID0gZTtcbiAgICAgICAgICAgIGNvbnN0IGNtZCA9IGRhdGEoY3VycmVudCwgdGhpcy5hdHRySXRlbSk7XG4gICAgICAgICAgICBpZiAoIWlzTnVtZXJpYyhjbWQpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpID0ga2V5Q29kZSA9PT0ga2V5TWFwLkhPTUUgPyAwIDoga2V5Q29kZSA9PT0ga2V5TWFwLkVORCA/IFwibGFzdFwiIDoga2V5Q29kZSA9PT0ga2V5TWFwLkxFRlQgPyBcInByZXZpb3VzXCIgOiBrZXlDb2RlID09PSBrZXlNYXAuUklHSFQgPyBcIm5leHRcIiA6IC0xO1xuICAgICAgICAgICAgaWYgKH5pKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgdGhpcy5zaG93KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgdXBkYXRlTmF2KCkge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRWYWxpZEluZGV4KCk7XG4gICAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLm5hdkl0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBjbWQgPSBkYXRhKGVsLCB0aGlzLmF0dHJJdGVtKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9ICQoXCJhLGJ1dHRvblwiLCBlbCkgfHwgZWw7XG4gICAgICAgICAgICBpZiAoaXNOdW1lcmljKGNtZCkpIHtcbiAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRvTnVtYmVyKGNtZCk7XG4gICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IGl0ZW0gPT09IGluZGV4O1xuICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgdGhpcy5jbHNBY3RpdmUsIGFjdGl2ZSk7XG4gICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGJ1dHRvbiwgXCJ1ay1kaXNhYmxlZFwiLCAhIXRoaXMucGFyYWxsYXgpO1xuICAgICAgICAgICAgICBhdHRyKGJ1dHRvbiwge1xuICAgICAgICAgICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBhY3RpdmUsXG4gICAgICAgICAgICAgICAgdGFiaW5kZXg6IGFjdGl2ZSAmJiAhdGhpcy5wYXJhbGxheCA/IG51bGwgOiAtMVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKGFjdGl2ZSAmJiBidXR0b24gJiYgbWF0Y2hlcyhwYXJlbnQoZWwpLCBcIjpmb2N1cy13aXRoaW5cIikpIHtcbiAgICAgICAgICAgICAgICBidXR0b24uZm9jdXMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgXCJ1ay1pbnZpc2libGVcIixcbiAgICAgICAgICAgICAgICB0aGlzLmZpbml0ZSAmJiAoY21kID09PSBcInByZXZpb3VzXCIgJiYgaW5kZXggPT09IDAgfHwgY21kID09PSBcIm5leHRcIiAmJiBpbmRleCA+PSB0aGlzLm1heEluZGV4KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGFkTmF2aXRlbXMoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLm5hdikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBjaGlsZHJlbjIgPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHIyID0gYCR7dGhpcy5hdHRySXRlbX09XCIke2l9XCJgO1xuICAgICAgICAgICAgY2hpbGRyZW4yW2ldID0gdGhpcy5uYXZDaGlsZHJlbi5maW5kTGFzdCgoZWwpID0+IGVsLm1hdGNoZXMoYFske2F0dHIyfV1gKSkgfHwgJChgPGxpICR7YXR0cjJ9PjxhIGhyZWY+PC9hPjwvbGk+YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXNFcXVhbChjaGlsZHJlbjIsIHRoaXMubmF2Q2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBodG1sKHRoaXMubmF2LCBjaGlsZHJlbjIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBlYXNlT3V0UXVhZCA9IFwiY3ViaWMtYmV6aWVyKDAuMjUsIDAuNDYsIDAuNDUsIDAuOTQpXCI7XG4gICAgY29uc3QgZWFzZU91dFF1YXJ0ID0gXCJjdWJpYy1iZXppZXIoMC4xNjUsIDAuODQsIDAuNDQsIDEpXCI7XG4gICAgdmFyIFNsaWRlciA9IHtcbiAgICAgIG1peGluczogW1NsaWRlckF1dG9wbGF5LCBTbGlkZXJEcmFnLCBTbGlkZXJOYXYsIEkxOG5dLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xzQWN0aXZhdGVkOiBTdHJpbmcsXG4gICAgICAgIGVhc2luZzogU3RyaW5nLFxuICAgICAgICBpbmRleDogTnVtYmVyLFxuICAgICAgICBmaW5pdGU6IEJvb2xlYW4sXG4gICAgICAgIHZlbG9jaXR5OiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBkYXRhOiAoKSA9PiAoe1xuICAgICAgICBlYXNpbmc6IFwiZWFzZVwiLFxuICAgICAgICBmaW5pdGU6IGZhbHNlLFxuICAgICAgICB2ZWxvY2l0eTogMSxcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIHByZXZJbmRleDogLTEsXG4gICAgICAgIHN0YWNrOiBbXSxcbiAgICAgICAgcGVyY2VudDogMCxcbiAgICAgICAgY2xzQWN0aXZlOiBcInVrLWFjdGl2ZVwiLFxuICAgICAgICBjbHNBY3RpdmF0ZWQ6IFwiXCIsXG4gICAgICAgIGNsc0VudGVyOiBcInVrLXNsaWRlLWVudGVyXCIsXG4gICAgICAgIGNsc0xlYXZlOiBcInVrLXNsaWRlLWxlYXZlXCIsXG4gICAgICAgIGNsc1NsaWRlQWN0aXZlOiBcInVrLXNsaWRlLWFjdGl2ZVwiLFxuICAgICAgICBUcmFuc2l0aW9uZXI6IGZhbHNlLFxuICAgICAgICB0cmFuc2l0aW9uT3B0aW9uczoge31cbiAgICAgIH0pLFxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnByZXZJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5nZXRWYWxpZEluZGV4KHRoaXMuJHByb3BzLmluZGV4KTtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5zbGlkZXMsIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBkdXJhdGlvbjogKHsgdmVsb2NpdHkgfSwgJGVsKSA9PiBzcGVlZFVwKCRlbC5vZmZzZXRXaWR0aCAvIHZlbG9jaXR5KSxcbiAgICAgICAgbGlzdDogKHsgc2VsTGlzdCB9LCAkZWwpID0+ICQoc2VsTGlzdCwgJGVsKSxcbiAgICAgICAgbWF4SW5kZXgoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgc2xpZGVzKCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbih0aGlzLmxpc3QpO1xuICAgICAgICB9LFxuICAgICAgICBsZW5ndGgoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdhdGNoOiB7XG4gICAgICAgIHNsaWRlcyhzbGlkZXMsIHByZXYpIHtcbiAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBpdGVtc2hvdyh7IHRhcmdldCB9KSB7XG4gICAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCB0aGlzLmNsc0VudGVyLCB0aGlzLmNsc1NsaWRlQWN0aXZlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbXNob3duKHsgdGFyZ2V0IH0pIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0YXJnZXQsIHRoaXMuY2xzRW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBpdGVtaGlkZSh7IHRhcmdldCB9KSB7XG4gICAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCB0aGlzLmNsc0xlYXZlKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXRlbWhpZGRlbih7IHRhcmdldCB9KSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGFyZ2V0LCB0aGlzLmNsc0xlYXZlLCB0aGlzLmNsc1NsaWRlQWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgYXN5bmMgc2hvdyhpbmRleCwgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZyB8fCAhdGhpcy5sZW5ndGggfHwgdGhpcy5wYXJhbGxheCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IHN0YWNrIH0gPSB0aGlzO1xuICAgICAgICAgIGNvbnN0IHF1ZXVlSW5kZXggPSBmb3JjZSA/IDAgOiBzdGFjay5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGFjay5zcGxpY2UocXVldWVJbmRleCwgMSk7XG4gICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2hvdyhzdGFjay5zaGlmdCgpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHN0YWNrW2ZvcmNlID8gXCJ1bnNoaWZ0XCIgOiBcInB1c2hcIl0oaW5kZXgpO1xuICAgICAgICAgIGlmICghZm9yY2UgJiYgc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAoX2EgPSB0aGlzLl90cmFuc2l0aW9uZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYS5mb3J3YXJkKE1hdGgubWluKHRoaXMuZHVyYXRpb24sIDIwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwcmV2SW5kZXggPSB0aGlzLmdldEluZGV4KHRoaXMuaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IHByZXYgPSBoYXNDbGFzcyh0aGlzLnNsaWRlcywgdGhpcy5jbHNBY3RpdmUpICYmIHRoaXMuc2xpZGVzW3ByZXZJbmRleF07XG4gICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5nZXRJbmRleChpbmRleCwgdGhpcy5pbmRleCk7XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuc2xpZGVzW25leHRJbmRleF07XG4gICAgICAgICAgaWYgKHByZXYgPT09IG5leHQpIHtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZGlyID0gZ2V0RGlyZWN0aW9uKGluZGV4LCBwcmV2SW5kZXgpO1xuICAgICAgICAgIHRoaXMucHJldkluZGV4ID0gcHJldkluZGV4O1xuICAgICAgICAgIHRoaXMuaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgICAgaWYgKHByZXYgJiYgIXRyaWdnZXIocHJldiwgXCJiZWZvcmVpdGVtaGlkZVwiLCBbdGhpc10pIHx8ICF0cmlnZ2VyKG5leHQsIFwiYmVmb3JlaXRlbXNob3dcIiwgW3RoaXMsIHByZXZdKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMucHJldkluZGV4O1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiAmJiB0cmlnZ2VyKHByZXYsIFwiaXRlbWhpZGVcIiwgW3RoaXNdKTtcbiAgICAgICAgICB0cmlnZ2VyKG5leHQsIFwiaXRlbXNob3dcIiwgW3RoaXNdKTtcbiAgICAgICAgICBhd2FpdCB0aGlzLl9zaG93KHByZXYsIG5leHQsIGZvcmNlKTtcbiAgICAgICAgICBwcmV2ICYmIHRyaWdnZXIocHJldiwgXCJpdGVtaGlkZGVuXCIsIFt0aGlzXSk7XG4gICAgICAgICAgdHJpZ2dlcihuZXh0LCBcIml0ZW1zaG93blwiLCBbdGhpc10pO1xuICAgICAgICAgIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgdGhpcy5fdHJhbnNpdGlvbmVyID0gbnVsbDtcbiAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gc3RhY2subGVuZ3RoICYmIHRoaXMuc2hvdyhzdGFjay5zaGlmdCgpLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRJbmRleChpbmRleCA9IHRoaXMuaW5kZXgsIHByZXYgPSB0aGlzLmluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIGNsYW1wKFxuICAgICAgICAgICAgZ2V0SW5kZXgoaW5kZXgsIHRoaXMuc2xpZGVzLCBwcmV2LCB0aGlzLmZpbml0ZSksXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgTWF0aC5tYXgoMCwgdGhpcy5tYXhJbmRleClcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBnZXRWYWxpZEluZGV4KGluZGV4ID0gdGhpcy5pbmRleCwgcHJldkluZGV4ID0gdGhpcy5wcmV2SW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRJbmRleChpbmRleCwgcHJldkluZGV4KTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgX3Nob3cocHJldiwgbmV4dCwgZm9yY2UpIHtcbiAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uZXIgPSB0aGlzLl9nZXRUcmFuc2l0aW9uZXIocHJldiwgbmV4dCwgdGhpcy5kaXIsIHtcbiAgICAgICAgICAgIGVhc2luZzogZm9yY2UgPyBuZXh0Lm9mZnNldFdpZHRoIDwgNjAwID8gZWFzZU91dFF1YWQgOiBlYXNlT3V0UXVhcnQgOiB0aGlzLmVhc2luZyxcbiAgICAgICAgICAgIC4uLnRoaXMudHJhbnNpdGlvbk9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWZvcmNlICYmICFwcmV2KSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGUoMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB0aGlzLnN0YWNrO1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2l0aW9uZXJbbGVuZ3RoID4gMSA/IFwiZm9yd2FyZFwiIDogXCJzaG93XCJdKFxuICAgICAgICAgICAgbGVuZ3RoID4gMSA/IE1hdGgubWluKHRoaXMuZHVyYXRpb24sIDc1ICsgNzUgLyAobGVuZ3RoIC0gMSkpIDogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHRoaXMucGVyY2VudFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIF90cmFuc2xhdGUocGVyY2VudCwgcHJldiA9IHRoaXMucHJldkluZGV4LCBuZXh0ID0gdGhpcy5pbmRleCkge1xuICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25lciA9IHRoaXMuX2dldFRyYW5zaXRpb25lcihwcmV2ID09PSBuZXh0ID8gZmFsc2UgOiBwcmV2LCBuZXh0KTtcbiAgICAgICAgICB0cmFuc2l0aW9uZXIudHJhbnNsYXRlKHBlcmNlbnQpO1xuICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uZXI7XG4gICAgICAgIH0sXG4gICAgICAgIF9nZXRUcmFuc2l0aW9uZXIocHJldiA9IHRoaXMucHJldkluZGV4LCBuZXh0ID0gdGhpcy5pbmRleCwgZGlyID0gdGhpcy5kaXIgfHwgMSwgb3B0aW9ucyA9IHRoaXMudHJhbnNpdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IHRoaXMuVHJhbnNpdGlvbmVyKFxuICAgICAgICAgICAgaXNOdW1iZXIocHJldikgPyB0aGlzLnNsaWRlc1twcmV2XSA6IHByZXYsXG4gICAgICAgICAgICBpc051bWJlcihuZXh0KSA/IHRoaXMuc2xpZGVzW25leHRdIDogbmV4dCxcbiAgICAgICAgICAgIGRpciAqIChpc1J0bCA/IC0xIDogMSksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKGluZGV4LCBwcmV2SW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCA9PT0gXCJuZXh0XCIgPyAxIDogaW5kZXggPT09IFwicHJldmlvdXNcIiA/IC0xIDogaW5kZXggPCBwcmV2SW5kZXggPyAtMSA6IDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwZWVkVXAoeCkge1xuICAgICAgcmV0dXJuIDAuNSAqIHggKyAzMDA7XG4gICAgfVxuXG4gICAgdmFyIFNsaWRlc2hvdyA9IHtcbiAgICAgIG1peGluczogW1NsaWRlcl0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBhbmltYXRpb246IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBcInNsaWRlXCIsXG4gICAgICAgIGNsc0FjdGl2YXRlZDogXCJ1ay10cmFuc2l0aW9uLWFjdGl2ZVwiLFxuICAgICAgICBBbmltYXRpb25zOiBBbmltYXRpb25zJDIsXG4gICAgICAgIFRyYW5zaXRpb25lcjogVHJhbnNpdGlvbmVyJDFcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBhbmltYXRpb24oeyBhbmltYXRpb24sIEFuaW1hdGlvbnM6IEFuaW1hdGlvbnMyIH0pIHtcbiAgICAgICAgICByZXR1cm4geyAuLi5BbmltYXRpb25zMlthbmltYXRpb25dIHx8IEFuaW1hdGlvbnMyLnNsaWRlLCBuYW1lOiBhbmltYXRpb24gfTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNpdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgYW5pbWF0aW9uOiB0aGlzLmFuaW1hdGlvbiB9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb2JzZXJ2ZTogcmVzaXplKCksXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgaXRlbXNob3coeyB0YXJnZXQgfSkge1xuICAgICAgICAgIGFkZENsYXNzKHRhcmdldCwgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICB9LFxuICAgICAgICBpdGVtc2hvd24oeyB0YXJnZXQgfSkge1xuICAgICAgICAgIGFkZENsYXNzKHRhcmdldCwgdGhpcy5jbHNBY3RpdmF0ZWQpO1xuICAgICAgICB9LFxuICAgICAgICBpdGVtaGlkZGVuKHsgdGFyZ2V0IH0pIHtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0YXJnZXQsIHRoaXMuY2xzQWN0aXZlLCB0aGlzLmNsc0FjdGl2YXRlZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIEFuaW1hdGlvbnMkMSA9IHtcbiAgICAgIC4uLkFuaW1hdGlvbnMkMixcbiAgICAgIGZhZGU6IHtcbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICByZXR1cm4gW3sgb3BhY2l0eTogMCwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVyY2VudChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSBjc3MoY3VycmVudCwgXCJvcGFjaXR5XCIpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBbeyBvcGFjaXR5OiAxIC0gcGVyY2VudCwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAsIHRyYW5zZm9ybTogc2NhbGUzZCgxICsgMC41KSwgekluZGV4OiAwIH0sIHsgekluZGV4OiAtMSB9XTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVyY2VudChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSBjc3MoY3VycmVudCwgXCJvcGFjaXR5XCIpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSArIDAuNSAqIHBlcmNlbnQpLCB6SW5kZXg6IDAgfSxcbiAgICAgICAgICAgIHsgekluZGV4OiAtMSB9XG4gICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHB1bGw6IHtcbiAgICAgICAgc2hvdyhkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IFtcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMzApLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKCksIHpJbmRleDogMCB9XG4gICAgICAgICAgXSA6IFtcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpLCB6SW5kZXg6IC0xIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBwZXJjZW50KGN1cnJlbnQsIG5leHQsIGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID8gMSAtIHRyYW5zbGF0ZWQobmV4dCkgOiB0cmFuc2xhdGVkKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCwgZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgPyBbXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDMwICogcGVyY2VudCksIHpJbmRleDogLTEgfSxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwMCAqICgxIC0gcGVyY2VudCkpLCB6SW5kZXg6IDAgfVxuICAgICAgICAgIF0gOiBbXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC1wZXJjZW50ICogMTAwKSwgekluZGV4OiAwIH0sXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDMwICogKDEgLSBwZXJjZW50KSksIHpJbmRleDogLTEgfVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdXNoOiB7XG4gICAgICAgIHNob3coZGlyKSB7XG4gICAgICAgICAgcmV0dXJuIGRpciA8IDAgPyBbXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwMCksIHpJbmRleDogMCB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgpLCB6SW5kZXg6IC0xIH1cbiAgICAgICAgICBdIDogW1xuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMzApLCB6SW5kZXg6IC0xIH0sXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKCksIHpJbmRleDogMCB9XG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVyY2VudChjdXJyZW50LCBuZXh0LCBkaXIpIHtcbiAgICAgICAgICByZXR1cm4gZGlyID4gMCA/IDEgLSB0cmFuc2xhdGVkKG5leHQpIDogdHJhbnNsYXRlZChjdXJyZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQsIGRpcikge1xuICAgICAgICAgIHJldHVybiBkaXIgPCAwID8gW1xuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZShwZXJjZW50ICogMTAwKSwgekluZGV4OiAwIH0sXG4gICAgICAgICAgICB7IHRyYW5zZm9ybTogdHJhbnNsYXRlKC0zMCAqICgxIC0gcGVyY2VudCkpLCB6SW5kZXg6IC0xIH1cbiAgICAgICAgICBdIDogW1xuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtMzAgKiBwZXJjZW50KSwgekluZGV4OiAtMSB9LFxuICAgICAgICAgICAgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxMDAgKiAoMSAtIHBlcmNlbnQpKSwgekluZGV4OiAwIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzY2FsZTNkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gYHNjYWxlM2QoJHt2YWx1ZX0sICR7dmFsdWV9LCAxKWA7XG4gICAgfVxuXG4gICAgdmFyIEFuaW1hdGlvbnMgPSB7XG4gICAgICAuLi5BbmltYXRpb25zJDIsXG4gICAgICBmYWRlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDAgfSwgeyBvcGFjaXR5OiAxIH1dO1xuICAgICAgICB9LFxuICAgICAgICBwZXJjZW50KGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gMSAtIGNzcyhjdXJyZW50LCBcIm9wYWNpdHlcIik7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zbGF0ZShwZXJjZW50KSB7XG4gICAgICAgICAgcmV0dXJuIFt7IG9wYWNpdHk6IDEgLSBwZXJjZW50IH0sIHsgb3BhY2l0eTogcGVyY2VudCB9XTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNjYWxlOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgb3BhY2l0eTogMCwgdHJhbnNmb3JtOiBzY2FsZTNkKDEgLSAwLjIpIH0sXG4gICAgICAgICAgICB7IG9wYWNpdHk6IDEsIHRyYW5zZm9ybTogc2NhbGUzZCgxKSB9XG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgcGVyY2VudChjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIDEgLSBjc3MoY3VycmVudCwgXCJvcGFjaXR5XCIpO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGUocGVyY2VudCkge1xuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IG9wYWNpdHk6IDEgLSBwZXJjZW50LCB0cmFuc2Zvcm06IHNjYWxlM2QoMSAtIDAuMiAqIHBlcmNlbnQpIH0sXG4gICAgICAgICAgICB7IG9wYWNpdHk6IHBlcmNlbnQsIHRyYW5zZm9ybTogc2NhbGUzZCgxIC0gMC4yICsgMC4yICogcGVyY2VudCkgfVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIExpZ2h0Ym94UGFuZWwgPSB7XG4gICAgICBpMThuOiB7XG4gICAgICAgIGNvdW50ZXI6IFwiJXMgLyAlc1wiXG4gICAgICB9LFxuICAgICAgbWl4aW5zOiBbTW9kYWwsIFNsaWRlc2hvd10sXG4gICAgICBmdW5jdGlvbmFsOiB0cnVlLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY291bnRlcjogQm9vbGVhbixcbiAgICAgICAgcHJlbG9hZDogTnVtYmVyLFxuICAgICAgICBuYXY6IEJvb2xlYW4sXG4gICAgICAgIHNsaWRlbmF2OiBCb29sZWFuLFxuICAgICAgICBkZWxheUNvbnRyb2xzOiBOdW1iZXIsXG4gICAgICAgIHZpZGVvQXV0b3BsYXk6IEJvb2xlYW4sXG4gICAgICAgIHRlbXBsYXRlOiBTdHJpbmdcbiAgICAgIH0sXG4gICAgICBkYXRhOiAoKSA9PiAoe1xuICAgICAgICBjb3VudGVyOiBmYWxzZSxcbiAgICAgICAgcHJlbG9hZDogMSxcbiAgICAgICAgbmF2OiBmYWxzZSxcbiAgICAgICAgc2xpZGVuYXY6IHRydWUsXG4gICAgICAgIGRlbGF5Q29udHJvbHM6IDNlMyxcbiAgICAgICAgdmlkZW9BdXRvcGxheTogZmFsc2UsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgY2xzOiBcInVrLW9wZW5cIixcbiAgICAgICAgY2xzUGFnZTogXCJ1ay1saWdodGJveC1wYWdlXCIsXG4gICAgICAgIGNsc0ZpdDogXCJ1ay1saWdodGJveC1pdGVtcy1maXRcIixcbiAgICAgICAgY2xzWm9vbTogXCJ1ay1saWdodGJveC16b29tXCIsXG4gICAgICAgIGF0dHJJdGVtOiBcInVrLWxpZ2h0Ym94LWl0ZW1cIixcbiAgICAgICAgc2VsTGlzdDogXCIudWstbGlnaHRib3gtaXRlbXNcIixcbiAgICAgICAgc2VsQ2xvc2U6IFwiLnVrLWNsb3NlLWxhcmdlXCIsXG4gICAgICAgIHNlbE5hdjogXCIudWstbGlnaHRib3gtdGh1bWJuYXYsIC51ay1saWdodGJveC1kb3RuYXZcIixcbiAgICAgICAgc2VsQ2FwdGlvbjogXCIudWstbGlnaHRib3gtY2FwdGlvblwiLFxuICAgICAgICBzZWxDb3VudGVyOiBcIi51ay1saWdodGJveC1jb3VudGVyXCIsXG4gICAgICAgIHBhdXNlT25Ib3ZlcjogZmFsc2UsXG4gICAgICAgIHZlbG9jaXR5OiAyLFxuICAgICAgICBBbmltYXRpb25zLFxuICAgICAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1ay1saWdodGJveCB1ay1vdmVyZmxvdy1oaWRkZW5cIj4gPGRpdiBjbGFzcz1cInVrLWxpZ2h0Ym94LWl0ZW1zXCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJ1ay1wb3NpdGlvbi10b3AtcmlnaHQgdWstcG9zaXRpb24tc21hbGwgdWstdHJhbnNpdGlvbi1mYWRlXCIgdWstaW52ZXJzZT4gPGJ1dHRvbiBjbGFzcz1cInVrLWxpZ2h0Ym94LWNsb3NlIHVrLWNsb3NlLWxhcmdlXCIgdHlwZT1cImJ1dHRvblwiIHVrLWNsb3NlPjwvYnV0dG9uPiA8L2Rpdj4gPGRpdiBjbGFzcz1cInVrLWxpZ2h0Ym94LXNsaWRlbmF2IHVrLXBvc2l0aW9uLWNlbnRlci1sZWZ0IHVrLXBvc2l0aW9uLW1lZGl1bSB1ay10cmFuc2l0aW9uLWZhZGVcIiB1ay1pbnZlcnNlPiA8YSBocmVmIHVrLXNsaWRlbmF2LXByZXZpb3VzIHVrLWxpZ2h0Ym94LWl0ZW09XCJwcmV2aW91c1wiPjwvYT4gPC9kaXY+IDxkaXYgY2xhc3M9XCJ1ay1saWdodGJveC1zbGlkZW5hdiB1ay1wb3NpdGlvbi1jZW50ZXItcmlnaHQgdWstcG9zaXRpb24tbWVkaXVtIHVrLXRyYW5zaXRpb24tZmFkZVwiIHVrLWludmVyc2U+IDxhIGhyZWYgdWstc2xpZGVuYXYtbmV4dCB1ay1saWdodGJveC1pdGVtPVwibmV4dFwiPjwvYT4gPC9kaXY+IDxkaXYgY2xhc3M9XCJ1ay1wb3NpdGlvbi1jZW50ZXItcmlnaHQgdWstcG9zaXRpb24tbWVkaXVtIHVrLXRyYW5zaXRpb24tZmFkZVwiIHVrLWludmVyc2Ugc3R5bGU9XCJtYXgtaGVpZ2h0OiA5MHZoOyBvdmVyZmxvdzogYXV0bztcIj4gPHVsIGNsYXNzPVwidWstbGlnaHRib3gtdGh1bWJuYXYgdWstbGlnaHRib3gtdGh1bWJuYXYtdmVydGljYWwgdWstdGh1bWJuYXYgdWstdGh1bWJuYXYtdmVydGljYWxcIj48L3VsPiA8dWwgY2xhc3M9XCJ1ay1saWdodGJveC1kb3RuYXYgdWstZG90bmF2IHVrLWRvdG5hdi12ZXJ0aWNhbFwiPjwvdWw+IDwvZGl2PiA8ZGl2IGNsYXNzPVwidWstbGlnaHRib3gtY291bnRlciB1ay10ZXh0LWxhcmdlIHVrLXBvc2l0aW9uLXRvcC1sZWZ0IHVrLXBvc2l0aW9uLXNtYWxsIHVrLXRyYW5zaXRpb24tZmFkZVwiIHVrLWludmVyc2U+PC9kaXY+IDxkaXYgY2xhc3M9XCJ1ay1saWdodGJveC1jYXB0aW9uIHVrLXBvc2l0aW9uLWJvdHRvbSB1ay10ZXh0LWNlbnRlciB1ay10cmFuc2l0aW9uLXNsaWRlLWJvdHRvbSB1ay10cmFuc2l0aW9uLW9wYXF1ZVwiPjwvZGl2PiA8L2Rpdj5gXG4gICAgICB9KSxcbiAgICAgIGNyZWF0ZWQoKSB7XG4gICAgICAgIGxldCAkZWwgPSAkKHRoaXMudGVtcGxhdGUpO1xuICAgICAgICBpZiAoaXNUYWcoJGVsLCBcInRlbXBsYXRlXCIpKSB7XG4gICAgICAgICAgJGVsID0gZnJhZ21lbnQoaHRtbCgkZWwpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ID0gJCh0aGlzLnNlbExpc3QsICRlbCk7XG4gICAgICAgIGNvbnN0IG5hdlR5cGUgPSB0aGlzLiRwcm9wcy5uYXY7XG4gICAgICAgIHJlbW92ZSQxKCQkKHRoaXMuc2VsTmF2LCAkZWwpLmZpbHRlcigoZWwpID0+ICFtYXRjaGVzKGVsLCBgLnVrLSR7bmF2VHlwZX1gKSkpO1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCBpdGVtXSBvZiB0aGlzLml0ZW1zLmVudHJpZXMoKSkge1xuICAgICAgICAgIGFwcGVuZChsaXN0LCBcIjxkaXY+XCIpO1xuICAgICAgICAgIGlmIChuYXZUeXBlID09PSBcInRodW1ibmF2XCIpIHtcbiAgICAgICAgICAgIHdyYXBBbGwoXG4gICAgICAgICAgICAgIHRvVGh1bWJuYXZJdGVtKGl0ZW0sIHRoaXMudmlkZW9BdXRvcGxheSksXG4gICAgICAgICAgICAgIGFwcGVuZCgkKHRoaXMuc2VsTmF2LCAkZWwpLCBgPGxpIHVrLWxpZ2h0Ym94LWl0ZW09XCIke2l9XCI+PGEgaHJlZj48L2E+PC9saT5gKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNsaWRlbmF2KSB7XG4gICAgICAgICAgcmVtb3ZlJDEoJCQoXCIudWstbGlnaHRib3gtc2xpZGVuYXZcIiwgJGVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNvdW50ZXIpIHtcbiAgICAgICAgICByZW1vdmUkMSgkKHRoaXMuc2VsQ291bnRlciwgJGVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkQ2xhc3MobGlzdCwgdGhpcy5jbHNGaXQpO1xuICAgICAgICBjb25zdCBjbG9zZSA9ICQoXCJbdWstY2xvc2VdXCIsICRlbCk7XG4gICAgICAgIGNvbnN0IGNsb3NlTGFiZWwgPSB0aGlzLnQoXCJjbG9zZVwiKTtcbiAgICAgICAgaWYgKGNsb3NlICYmIGNsb3NlTGFiZWwpIHtcbiAgICAgICAgICBjbG9zZS5kYXRhc2V0LmkxOG4gPSBKU09OLnN0cmluZ2lmeSh7IGxhYmVsOiBjbG9zZUxhYmVsIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJG1vdW50KGFwcGVuZCh0aGlzLmNvbnRhaW5lciwgJGVsKSk7XG4gICAgICB9LFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImNsaWNrXCIsXG4gICAgICAgICAgc2VsZjogdHJ1ZSxcbiAgICAgICAgICBmaWx0ZXI6ICh7IGJnQ2xvc2UgfSkgPT4gYmdDbG9zZSxcbiAgICAgICAgICBkZWxlZ2F0ZTogKHsgc2VsTGlzdCB9KSA9PiBgJHtzZWxMaXN0fSA+ICpgLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKCFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJjbGlja1wiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgZGVsZWdhdGU6ICh7IGNsc1pvb20gfSkgPT4gYC4ke2Nsc1pvb219YCxcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMubGlzdCwgdGhpcy5jbHNGaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IGAke3BvaW50ZXJNb3ZlJDF9ICR7cG9pbnRlckRvd24kMX0ga2V5ZG93bmAsXG4gICAgICAgICAgZmlsdGVyOiAoeyBkZWxheUNvbnRyb2xzIH0pID0+IGRlbGF5Q29udHJvbHMsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRyb2xzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJzaG93blwiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0NvbnRyb2xzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJoaWRlXCIsXG4gICAgICAgICAgc2VsZjogdHJ1ZSxcbiAgICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlQ29udHJvbHMoKTtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuc2xpZGVzLCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICAgICAgICBUcmFuc2l0aW9uLnN0b3AodGhpcy5zbGlkZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgc2VsZjogdHJ1ZSxcbiAgICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImtleXVwXCIsXG4gICAgICAgICAgZWw6ICgpID0+IGRvY3VtZW50LFxuICAgICAgICAgIGhhbmRsZXIoeyBrZXlDb2RlIH0pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RvZ2dsZWQodGhpcy4kZWwpIHx8ICF0aGlzLmRyYWdnYWJsZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5MRUZUKSB7XG4gICAgICAgICAgICAgIGkgPSBcInByZXZpb3VzXCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IGtleU1hcC5SSUdIVCkge1xuICAgICAgICAgICAgICBpID0gXCJuZXh0XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IGtleU1hcC5IT01FKSB7XG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBrZXlNYXAuRU5EKSB7XG4gICAgICAgICAgICAgIGkgPSBcImxhc3RcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh+aSkge1xuICAgICAgICAgICAgICB0aGlzLnNob3coaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJiZWZvcmVpdGVtc2hvd1wiLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaHRtbCgkKHRoaXMuc2VsQ2FwdGlvbiwgdGhpcy4kZWwpLCB0aGlzLmdldEl0ZW0oKS5jYXB0aW9uIHx8IFwiXCIpO1xuICAgICAgICAgICAgaHRtbChcbiAgICAgICAgICAgICAgJCh0aGlzLnNlbENvdW50ZXIsIHRoaXMuJGVsKSxcbiAgICAgICAgICAgICAgdGhpcy50KFwiY291bnRlclwiLCB0aGlzLmluZGV4ICsgMSwgdGhpcy5zbGlkZXMubGVuZ3RoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAtdGhpcy5wcmVsb2FkOyBqIDw9IHRoaXMucHJlbG9hZDsgaisrKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9hZEl0ZW0odGhpcy5pbmRleCArIGopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBBbmltYXRpb25zLnNjYWxlO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZS50YXJnZXQsIHRoaXMuY2xzQWN0aXZlKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2suc3BsaWNlKDEsIDAsIHRoaXMuaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaXRlbXNob3duXCIsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dhYmxlID0gdGhpcy4kcHJvcHMuZHJhZ2dhYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaXRlbWxvYWRcIixcbiAgICAgICAgICBhc3luYyBoYW5kbGVyKF8sIGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlOiBzcmMsIHR5cGUsIGF0dHJzID0ge30gfSA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLnNldEl0ZW0oaXRlbSwgXCI8c3BhbiB1ay1zcGlubmVyIHVrLWludmVyc2U+PC9zcGFuPlwiKTtcbiAgICAgICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBtYXRjaGVzMjtcbiAgICAgICAgICAgIGNvbnN0IGlmcmFtZUF0dHJzID0ge1xuICAgICAgICAgICAgICBhbGxvd2Z1bGxzY3JlZW46IFwiXCIsXG4gICAgICAgICAgICAgIHN0eWxlOiBcIm1heC13aWR0aDogMTAwJTsgYm94LXNpemluZzogYm9yZGVyLWJveDtcIixcbiAgICAgICAgICAgICAgXCJ1ay1yZXNwb25zaXZlXCI6IFwiXCIsXG4gICAgICAgICAgICAgIFwidWstdmlkZW9cIjogYCR7Qm9vbGVhbih0aGlzLnZpZGVvQXV0b3BsYXkpfWBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJpbWFnZVwiIHx8IGlzSW1hZ2Uoc3JjKSkge1xuICAgICAgICAgICAgICBjb25zdCBpbWcgPSBjcmVhdGVFbChcImltZ1wiKTtcbiAgICAgICAgICAgICAgd3JhcEluUGljdHVyZShpbWcsIGl0ZW0uc291cmNlcyk7XG4gICAgICAgICAgICAgIGF0dHIoaW1nLCB7XG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIC4uLnBpY2soaXRlbSwgW1wiYWx0XCIsIFwic3Jjc2V0XCIsIFwic2l6ZXNcIl0pLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBvbihpbWcsIFwibG9hZFwiLCAoKSA9PiB0aGlzLnNldEl0ZW0oaXRlbSwgcGFyZW50KGltZykgfHwgaW1nKSk7XG4gICAgICAgICAgICAgIG9uKGltZywgXCJlcnJvclwiLCAoKSA9PiB0aGlzLnNldEVycm9yKGl0ZW0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2aWRlb1wiIHx8IGlzVmlkZW8oc3JjKSkge1xuICAgICAgICAgICAgICBjb25zdCBpbmxpbmUgPSB0aGlzLnZpZGVvQXV0b3BsYXkgPT09IFwiaW5saW5lXCI7XG4gICAgICAgICAgICAgIGNvbnN0IHZpZGVvID0gY3JlYXRlRWwoXCJ2aWRlb1wiLCB7XG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHBsYXlzaW5saW5lOiBcIlwiLFxuICAgICAgICAgICAgICAgIGNvbnRyb2xzOiBpbmxpbmUgPyBudWxsIDogXCJcIixcbiAgICAgICAgICAgICAgICBsb29wOiBpbmxpbmUgPyBcIlwiIDogbnVsbCxcbiAgICAgICAgICAgICAgICBwb3N0ZXI6IHRoaXMudmlkZW9BdXRvcGxheSA/IG51bGwgOiBpdGVtLnBvc3RlcixcbiAgICAgICAgICAgICAgICBcInVrLXZpZGVvXCI6IGlubGluZSA/IFwiYXV0b211dGU6IHRydWVcIiA6IEJvb2xlYW4odGhpcy52aWRlb0F1dG9wbGF5KSxcbiAgICAgICAgICAgICAgICAuLi5hdHRyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgb24odmlkZW8sIFwibG9hZGVkbWV0YWRhdGFcIiwgKCkgPT4gdGhpcy5zZXRJdGVtKGl0ZW0sIHZpZGVvKSk7XG4gICAgICAgICAgICAgIG9uKHZpZGVvLCBcImVycm9yXCIsICgpID0+IHRoaXMuc2V0RXJyb3IoaXRlbSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImlmcmFtZVwiIHx8IHNyYy5tYXRjaCgvXFwuKGh0bWx8cGhwKSgkfFxcPykvaSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWwoXCJpZnJhbWVcIiwge1xuICAgICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgICAgYWxsb3dmdWxsc2NyZWVuOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgY2xhc3M6IFwidWstbGlnaHRib3gtaWZyYW1lXCIsXG4gICAgICAgICAgICAgICAgICAuLi5hdHRyc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoZXMyID0gc3JjLm1hdGNoKFxuICAgICAgICAgICAgICAvXFwvXFwvKD86Lio/eW91dHViZSgtbm9jb29raWUpP1xcLi4qPyg/Ols/Jl12PXxcXC9zaG9ydHNcXC8pfHlvdXR1XFwuYmVcXC8pKFtcXHctXXsxMX0pWyY/XT8oLiopPy9cbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXRJdGVtKFxuICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWwoXCJpZnJhbWVcIiwge1xuICAgICAgICAgICAgICAgICAgc3JjOiBgaHR0cHM6Ly93d3cueW91dHViZSR7bWF0Y2hlczJbMV0gfHwgXCJcIn0uY29tL2VtYmVkLyR7bWF0Y2hlczJbMl19JHttYXRjaGVzMlszXSA/IGA/JHttYXRjaGVzMlszXX1gIDogXCJcIn1gLFxuICAgICAgICAgICAgICAgICAgd2lkdGg6IDE5MjAsXG4gICAgICAgICAgICAgICAgICBoZWlnaHQ6IDEwODAsXG4gICAgICAgICAgICAgICAgICAuLi5pZnJhbWVBdHRycyxcbiAgICAgICAgICAgICAgICAgIC4uLmF0dHJzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hlczIgPSBzcmMubWF0Y2goL1xcL1xcLy4qP3ZpbWVvXFwuW2Etel0rXFwvKFxcZCspWyY/XT8oLiopPy8pKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBhd2FpdCAoYXdhaXQgZmV0Y2goXG4gICAgICAgICAgICAgICAgICBgaHR0cHM6Ly92aW1lby5jb20vYXBpL29lbWJlZC5qc29uP21heHdpZHRoPTE5MjAmdXJsPSR7ZW5jb2RlVVJJKFxuICAgICAgICAgICAgICAgIHNyY1xuICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICAgICAgICB7IGNyZWRlbnRpYWxzOiBcIm9taXRcIiB9XG4gICAgICAgICAgICAgICAgKSkuanNvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SXRlbShcbiAgICAgICAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICAgICAgICBjcmVhdGVFbChcImlmcmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHNyYzogYGh0dHBzOi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8ke21hdGNoZXMyWzFdfSR7bWF0Y2hlczJbMl0gPyBgPyR7bWF0Y2hlczJbMl19YCA6IFwiXCJ9YCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgLi4uaWZyYW1lQXR0cnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLmF0dHJzXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEVycm9yKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJpdGVtbG9hZGVkXCIsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoXCJyZXNpemVcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBtZWRpYSBvZiAkJChgJHt0aGlzLnNlbExpc3R9IDpub3QoW2NvbnRyb2xzXSk6aXMoaW1nLHZpZGVvKWAsIHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgdG9nZ2xlQ2xhc3MoXG4gICAgICAgICAgICAgIG1lZGlhLFxuICAgICAgICAgICAgICB0aGlzLmNsc1pvb20sXG4gICAgICAgICAgICAgIChtZWRpYS5uYXR1cmFsSGVpZ2h0IHx8IG1lZGlhLnZpZGVvSGVpZ2h0KSAtIHRoaXMuJGVsLm9mZnNldEhlaWdodCA+IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgKG1lZGlhLm5hdHVyYWxXaWR0aCB8fCBtZWRpYS52aWRlb1dpZHRoKSAtIHRoaXMuJGVsLm9mZnNldFdpZHRoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IFtcInJlc2l6ZVwiXVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgbG9hZEl0ZW0oaW5kZXggPSB0aGlzLmluZGV4KSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZ2V0SXRlbShpbmRleCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmdldFNsaWRlKGl0ZW0pLmNoaWxkRWxlbWVudENvdW50KSB7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCBcIml0ZW1sb2FkXCIsIFtpdGVtXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRJdGVtKGluZGV4ID0gdGhpcy5pbmRleCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zW2dldEluZGV4KGluZGV4LCB0aGlzLnNsaWRlcyldO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJdGVtKGl0ZW0sIGNvbnRlbnQpIHtcbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCBcIml0ZW1sb2FkZWRcIiwgW3RoaXMsIGh0bWwodGhpcy5nZXRTbGlkZShpdGVtKSwgY29udGVudCldKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2xpZGUoaXRlbSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWRlc1t0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSldO1xuICAgICAgICB9LFxuICAgICAgICBzZXRFcnJvcihpdGVtKSB7XG4gICAgICAgICAgdGhpcy5zZXRJdGVtKGl0ZW0sICc8c3BhbiB1ay1pY29uPVwiaWNvbjogYm9sdDsgcmF0aW86IDJcIiB1ay1pbnZlcnNlPjwvc3Bhbj4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd0NvbnRyb2xzKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbnRyb2xzVGltZXIpO1xuICAgICAgICAgIHRoaXMuY29udHJvbHNUaW1lciA9IHRoaXMuZGVsYXlDb250cm9scyAmJiBzZXRUaW1lb3V0KHRoaXMuaGlkZUNvbnRyb2xzLCB0aGlzLmRlbGF5Q29udHJvbHMpO1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCBcInVrLWFjdGl2ZVwiLCBcInVrLXRyYW5zaXRpb24tYWN0aXZlXCIpO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlQ29udHJvbHMoKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIFwidWstYWN0aXZlXCIsIFwidWstdHJhbnNpdGlvbi1hY3RpdmVcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsKHRhZywgYXR0cnMpIHtcbiAgICAgIGNvbnN0IGVsID0gZnJhZ21lbnQoYDwke3RhZ30+YCk7XG4gICAgICBhdHRyKGVsLCBhdHRycyk7XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvVGh1bWJuYXZJdGVtKGl0ZW0sIHZpZGVvQXV0b3BsYXkpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbS5wb3N0ZXIgfHwgaXRlbS50aHVtYiAmJiAoaXRlbS50eXBlID09PSBcImltYWdlXCIgfHwgaXNJbWFnZShpdGVtLnRodW1iKSkgPyBjcmVhdGVFbChcImltZ1wiLCB7IHNyYzogaXRlbS5wb3N0ZXIgfHwgaXRlbS50aHVtYiwgYWx0OiBcIlwiIH0pIDogaXRlbS50aHVtYiAmJiAoaXRlbS50eXBlID09PSBcInZpZGVvXCIgfHwgaXNWaWRlbyhpdGVtLnRodW1iKSkgPyBjcmVhdGVFbChcInZpZGVvXCIsIHtcbiAgICAgICAgc3JjOiBpdGVtLnRodW1iLFxuICAgICAgICBsb29wOiBcIlwiLFxuICAgICAgICBwbGF5c2lubGluZTogXCJcIixcbiAgICAgICAgXCJ1ay12aWRlb1wiOiBgYXV0b3BsYXk6ICR7Qm9vbGVhbih2aWRlb0F1dG9wbGF5KX07IGF1dG9tdXRlOiB0cnVlYFxuICAgICAgfSkgOiBjcmVhdGVFbChcImNhbnZhc1wiKTtcbiAgICAgIGlmIChpdGVtLnRodW1iUmF0aW8pIHtcbiAgICAgICAgZWwuc3R5bGUuYXNwZWN0UmF0aW8gPSBpdGVtLnRodW1iUmF0aW87XG4gICAgICB9XG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSW1hZ2Uoc3JjKSB7XG4gICAgICByZXR1cm4gc3JjID09IG51bGwgPyB2b2lkIDAgOiBzcmMubWF0Y2goL1xcLihhdmlmfGpwZT9nfGpmaWZ8YT9wbmd8Z2lmfHN2Z3x3ZWJwKSgkfFxcPykvaSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmlkZW8oc3JjKSB7XG4gICAgICByZXR1cm4gc3JjID09IG51bGwgPyB2b2lkIDAgOiBzcmMubWF0Y2goL1xcLihtcDR8d2VibXxvZ3YpKCR8XFw/KS9pKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxEaXNhYmxlZCQxID0gXCIudWstZGlzYWJsZWQgKiwgLnVrLWRpc2FibGVkLCBbZGlzYWJsZWRdXCI7XG4gICAgdmFyIGxpZ2h0Ym94ID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCQzLFxuICAgICAgcHJvcHM6IHsgdG9nZ2xlOiBTdHJpbmcgfSxcbiAgICAgIGRhdGE6IHsgdG9nZ2xlOiBcImFcIiB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdG9nZ2xlczogKHsgdG9nZ2xlIH0sICRlbCkgPT4gJCQodG9nZ2xlLCAkZWwpXG4gICAgICB9LFxuICAgICAgd2F0Y2g6IHtcbiAgICAgICAgdG9nZ2xlcyh0b2dnbGVzKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgZm9yIChjb25zdCB0b2dnbGUgb2YgdG9nZ2xlcykge1xuICAgICAgICAgICAgaWYgKGlzVGFnKHRvZ2dsZSwgXCJhXCIpKSB7XG4gICAgICAgICAgICAgIGF0dHIodG9nZ2xlLCBcInJvbGVcIiwgXCJidXR0b25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0sXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgbmFtZTogXCJjbGlja1wiLFxuICAgICAgICBkZWxlZ2F0ZTogKHsgdG9nZ2xlIH0pID0+IHRvZ2dsZSxcbiAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgaWYgKCFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcyhlLmN1cnJlbnQsIHNlbERpc2FibGVkJDEpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2hvdyhlLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgc2hvdyhpbmRleCkge1xuICAgICAgICAgIGxldCBpdGVtcyA9IHRoaXMudG9nZ2xlcy5tYXAodG9JdGVtKTtcbiAgICAgICAgICBpZiAodGhpcy5uYXYgPT09IFwidGh1bWJuYXZcIikge1xuICAgICAgICAgICAgZW5zdXJlVGh1bWIuY2FsbCh0aGlzLCB0aGlzLnRvZ2dsZXMsIGl0ZW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbXMgPSB1bmlxdWVCeShpdGVtcywgXCJzb3VyY2VcIik7XG4gICAgICAgICAgaWYgKGlzRWxlbWVudChpbmRleCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlIH0gPSB0b0l0ZW0oaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggPSBmaW5kSW5kZXgoaXRlbXMsICh7IHNvdXJjZTogc3JjIH0pID0+IHNvdXJjZSA9PT0gc3JjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wYW5lbCA9IHRoaXMucGFuZWwgfHwgdGhpcy4kY3JlYXRlKFwibGlnaHRib3hQYW5lbFwiLCB7IC4uLnRoaXMuJHByb3BzLCBpdGVtcyB9KTtcbiAgICAgICAgICBvbih0aGlzLnBhbmVsLiRlbCwgXCJoaWRkZW5cIiwgKCkgPT4gdGhpcy5wYW5lbCA9IG51bGwpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhbmVsLnNob3coaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBoaWRlKCkge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5wYW5lbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaW5zdGFsbCQzKFVJa2l0LCBMaWdodGJveCkge1xuICAgICAgaWYgKCFVSWtpdC5saWdodGJveFBhbmVsKSB7XG4gICAgICAgIFVJa2l0LmNvbXBvbmVudChcImxpZ2h0Ym94UGFuZWxcIiwgTGlnaHRib3hQYW5lbCk7XG4gICAgICB9XG4gICAgICBhc3NpZ24oTGlnaHRib3gucHJvcHMsIFVJa2l0LmNvbXBvbmVudChcImxpZ2h0Ym94UGFuZWxcIikub3B0aW9ucy5wcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuc3VyZVRodW1iKHRvZ2dsZXMsIGl0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IFtpLCB0b2dnbGVdIG9mIE9iamVjdC5lbnRyaWVzKHRvZ2dsZXMpKSB7XG4gICAgICAgIGlmIChpdGVtc1tpXS50aHVtYikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHBhcmVudHModG9nZ2xlKS5yZXZlcnNlKCkuY29uY2F0KHRvZ2dsZSkuZmluZChcbiAgICAgICAgICAocGFyZW50MikgPT4gdGhpcy4kZWwuY29udGFpbnMocGFyZW50MikgJiYgKHBhcmVudDIgPT09IHRvZ2dsZSB8fCAkJCh0aGlzLnRvZ2dsZSwgcGFyZW50MikubGVuZ3RoID09PSAxKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lZGlhID0gJChcImltZyx2aWRlb1wiLCBwYXJlbnQpO1xuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICBpdGVtc1tpXS50aHVtYiA9IG1lZGlhLmN1cnJlbnRTcmMgfHwgbWVkaWEucG9zdGVyIHx8IG1lZGlhLnNyYztcbiAgICAgICAgICBpdGVtc1tpXS50aHVtYlJhdGlvID0gKG1lZGlhLm5hdHVyYWxXaWR0aCB8fCBtZWRpYS52aWRlb1dpZHRoKSAvIChtZWRpYS5uYXR1cmFsSGVpZ2h0IHx8IG1lZGlhLnZpZGVvSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b0l0ZW0oZWwpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB7fTtcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGVsLmdldEF0dHJpYnV0ZU5hbWVzKCkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXR0cmlidXRlLnJlcGxhY2UoL15kYXRhLS8sIFwiXCIpO1xuICAgICAgICBpdGVtW2tleSA9PT0gXCJocmVmXCIgPyBcInNvdXJjZVwiIDoga2V5XSA9IGVsLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgICAgaXRlbS5hdHRycyA9IHBhcnNlT3B0aW9ucyhpdGVtLmF0dHJzKTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIHZhciBub3RpZmljYXRpb24gPSB7XG4gICAgICBtaXhpbnM6IFtDb250YWluZXJdLFxuICAgICAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgICAgIGFyZ3M6IFtcIm1lc3NhZ2VcIiwgXCJzdGF0dXNcIl0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1lc3NhZ2U6IFwiXCIsXG4gICAgICAgIHN0YXR1czogXCJcIixcbiAgICAgICAgdGltZW91dDogNWUzLFxuICAgICAgICBncm91cDogXCJcIixcbiAgICAgICAgcG9zOiBcInRvcC1jZW50ZXJcIixcbiAgICAgICAgY2xzQ29udGFpbmVyOiBcInVrLW5vdGlmaWNhdGlvblwiLFxuICAgICAgICBjbHNDbG9zZTogXCJ1ay1ub3RpZmljYXRpb24tY2xvc2VcIixcbiAgICAgICAgY2xzTXNnOiBcInVrLW5vdGlmaWNhdGlvbi1tZXNzYWdlXCJcbiAgICAgIH0sXG4gICAgICBpbnN0YWxsOiBpbnN0YWxsJDIsXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBtYXJnaW5Qcm9wOiAoeyBwb3MgfSkgPT4gYG1hcmdpbi0ke3Bvcy5tYXRjaCgvW2Etel0rKD89LSkvKVswXX1gLFxuICAgICAgICBzdGFydFByb3BzKCkge1xuICAgICAgICAgIHJldHVybiB7IG9wYWNpdHk6IDAsIFt0aGlzLm1hcmdpblByb3BdOiAtdGhpcy4kZWwub2Zmc2V0SGVpZ2h0IH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICBjb25zdCBwb3NDbGFzcyA9IGAke3RoaXMuY2xzQ29udGFpbmVyfS0ke3RoaXMucG9zfWA7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckF0dHIgPSBgZGF0YS0ke3RoaXMuY2xzQ29udGFpbmVyfS1jb250YWluZXJgO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSAkKGAuJHtwb3NDbGFzc31bJHtjb250YWluZXJBdHRyfV1gLCB0aGlzLmNvbnRhaW5lcikgfHwgYXBwZW5kKFxuICAgICAgICAgIHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgIGA8ZGl2IGNsYXNzPVwiJHt0aGlzLmNsc0NvbnRhaW5lcn0gJHtwb3NDbGFzc31cIiAke2NvbnRhaW5lckF0dHJ9PjwvZGl2PmBcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy4kbW91bnQoXG4gICAgICAgICAgYXBwZW5kKFxuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgYDxkaXYgY2xhc3M9XCIke3RoaXMuY2xzTXNnfSR7dGhpcy5zdGF0dXMgPyBgICR7dGhpcy5jbHNNc2d9LSR7dGhpcy5zdGF0dXN9YCA6IFwiXCJ9XCIgcm9sZT1cImFsZXJ0XCI+IDxhIGhyZWYgY2xhc3M9XCIke3RoaXMuY2xzQ2xvc2V9XCIgZGF0YS11ay1jbG9zZT48L2E+IDxkaXY+JHt0aGlzLm1lc3NhZ2V9PC9kaXY+IDwvZGl2PmBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgY29ubmVjdGVkKCkge1xuICAgICAgICBjb25zdCBtYXJnaW4gPSB0b0Zsb2F0KGNzcyh0aGlzLiRlbCwgdGhpcy5tYXJnaW5Qcm9wKSk7XG4gICAgICAgIGF3YWl0IFRyYW5zaXRpb24uc3RhcnQoY3NzKHRoaXMuJGVsLCB0aGlzLnN0YXJ0UHJvcHMpLCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICBbdGhpcy5tYXJnaW5Qcm9wXTogbWFyZ2luXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5jbG9zZSwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjbGljayhlKSB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0LmNsb3Nlc3QoJ2FbaHJlZj1cIiNcIl0sYVtocmVmPVwiXCJdJykpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9LFxuICAgICAgICBbcG9pbnRlckVudGVyXSgpIHtcbiAgICAgICAgICBpZiAodGhpcy50aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgW3BvaW50ZXJMZWF2ZV0oKSB7XG4gICAgICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5jbG9zZSwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGNsb3NlKGltbWVkaWF0ZSkge1xuICAgICAgICAgIGNvbnN0IHJlbW92ZUZuID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBwYXJlbnQoZWwpO1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgXCJjbG9zZVwiLCBbdGhpc10pO1xuICAgICAgICAgICAgcmVtb3ZlJDEoZWwpO1xuICAgICAgICAgICAgaWYgKCEoY29udGFpbmVyID09IG51bGwgPyB2b2lkIDAgOiBjb250YWluZXIuaGFzQ2hpbGROb2RlcygpKSkge1xuICAgICAgICAgICAgICByZW1vdmUkMShjb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIGF3YWl0IFRyYW5zaXRpb24uc3RhcnQodGhpcy4kZWwsIHRoaXMuc3RhcnRQcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlbW92ZUZuKHRoaXMuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaW5zdGFsbCQyKFVJa2l0KSB7XG4gICAgICBVSWtpdC5ub3RpZmljYXRpb24uY2xvc2VBbGwgPSBmdW5jdGlvbihncm91cCwgaW1tZWRpYXRlKSB7XG4gICAgICAgIGFwcGx5KGRvY3VtZW50LmJvZHksIChlbCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IFVJa2l0LmdldENvbXBvbmVudChlbCwgXCJub3RpZmljYXRpb25cIik7XG4gICAgICAgICAgaWYgKG5vdGlmaWNhdGlvbiAmJiAoIWdyb3VwIHx8IGdyb3VwID09PSBub3RpZmljYXRpb24uZ3JvdXApKSB7XG4gICAgICAgICAgICBub3RpZmljYXRpb24uY2xvc2UoaW1tZWRpYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgTWVkaWEgPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBtZWRpYTogQm9vbGVhblxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWVkaWE6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBjb25zdCBtZWRpYSA9IHRvTWVkaWEodGhpcy5tZWRpYSwgdGhpcy4kZWwpO1xuICAgICAgICB0aGlzLm1hdGNoTWVkaWEgPSB0cnVlO1xuICAgICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgICB0aGlzLm1lZGlhT2JqID0gd2luZG93Lm1hdGNoTWVkaWEobWVkaWEpO1xuICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoTWVkaWEgPSB0aGlzLm1lZGlhT2JqLm1hdGNoZXM7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCBjcmVhdGVFdmVudChcIm1lZGlhY2hhbmdlXCIsIGZhbHNlLCB0cnVlLCBbdGhpcy5tZWRpYU9ial0pKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMub2ZmTWVkaWFPYmogPSBvbih0aGlzLm1lZGlhT2JqLCBcImNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KFwicmVzaXplXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLm9mZk1lZGlhT2JqKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRvTWVkaWEodmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgodmFsdWUsIFwiQFwiKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9GbG9hdChjc3MoZWxlbWVudCwgYC0tdWstYnJlYWtwb2ludC0ke3ZhbHVlLnNsaWNlKDEpfWApKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSAmJiBpc051bWVyaWModmFsdWUpID8gYChtaW4td2lkdGg6ICR7dmFsdWV9cHgpYCA6IFwiXCI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWF4UGF0aExlbmd0aChlbCkge1xuICAgICAgcmV0dXJuIGlzVmlzaWJsZShlbCkgPyBNYXRoLmNlaWwoXG4gICAgICAgIE1hdGgubWF4KDAsIC4uLiQkKFwiW3N0cm9rZV1cIiwgZWwpLm1hcCgoc3Ryb2tlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoKF9hID0gc3Ryb2tlLmdldFRvdGFsTGVuZ3RoKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChzdHJva2UpKSB8fCAwO1xuICAgICAgICB9KSlcbiAgICAgICkgOiAwO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgeDogdHJhbnNmb3JtRm4sXG4gICAgICB5OiB0cmFuc2Zvcm1GbixcbiAgICAgIHJvdGF0ZTogdHJhbnNmb3JtRm4sXG4gICAgICBzY2FsZTogdHJhbnNmb3JtRm4sXG4gICAgICBjb2xvcjogY29sb3JGbixcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JGbixcbiAgICAgIGJvcmRlckNvbG9yOiBjb2xvckZuLFxuICAgICAgYmx1cjogZmlsdGVyRm4sXG4gICAgICBodWU6IGZpbHRlckZuLFxuICAgICAgZm9wYWNpdHk6IGZpbHRlckZuLFxuICAgICAgZ3JheXNjYWxlOiBmaWx0ZXJGbixcbiAgICAgIGludmVydDogZmlsdGVyRm4sXG4gICAgICBzYXR1cmF0ZTogZmlsdGVyRm4sXG4gICAgICBzZXBpYTogZmlsdGVyRm4sXG4gICAgICBvcGFjaXR5OiBjc3NQcm9wRm4sXG4gICAgICBzdHJva2U6IHN0cm9rZUZuLFxuICAgICAgYmd4OiBiYWNrZ3JvdW5kRm4sXG4gICAgICBiZ3k6IGJhY2tncm91bmRGblxuICAgIH07XG4gICAgY29uc3QgeyBrZXlzIH0gPSBPYmplY3Q7XG4gICAgdmFyIFBhcmFsbGF4ID0ge1xuICAgICAgbWl4aW5zOiBbTWVkaWFdLFxuICAgICAgcHJvcHM6IGZpbGxPYmplY3Qoa2V5cyhwcm9wcyksIFwibGlzdFwiKSxcbiAgICAgIGRhdGE6IGZpbGxPYmplY3Qoa2V5cyhwcm9wcyksIHZvaWQgMCksXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBwcm9wcyhwcm9wZXJ0aWVzLCAkZWwpIHtcbiAgICAgICAgICBjb25zdCBzdG9wcyA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiBwcm9wcyAmJiAhaXNVbmRlZmluZWQocHJvcGVydGllc1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgc3RvcHNbcHJvcF0gPSBwcm9wZXJ0aWVzW3Byb3BdLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBzdG9wcykge1xuICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gcHJvcHNbcHJvcF0ocHJvcCwgJGVsLCBzdG9wc1twcm9wXSwgc3RvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGxvYWQoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICByZXNldCgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdGhpcy5nZXRDc3MoMCkpIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgcHJvcCwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRDc3MocGVyY2VudCkge1xuICAgICAgICAgIGNvbnN0IGNzczIgPSB7fTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdGhpcy5wcm9wcykge1xuICAgICAgICAgICAgdGhpcy5wcm9wc1twcm9wXShjc3MyLCBjbGFtcChwZXJjZW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzczIud2lsbENoYW5nZSA9IE9iamVjdC5rZXlzKGNzczIpLm1hcChwcm9wTmFtZSkuam9pbihcIixcIik7XG4gICAgICAgICAgcmV0dXJuIGNzczI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgbGV0IHVuaXQgPSBnZXRVbml0KHN0b3BzKSB8fCB7IHg6IFwicHhcIiwgeTogXCJweFwiLCByb3RhdGU6IFwiZGVnXCIgfVtwcm9wXSB8fCBcIlwiO1xuICAgICAgbGV0IHRyYW5zZm9ybUZuMjtcbiAgICAgIGlmIChwcm9wID09PSBcInhcIiB8fCBwcm9wID09PSBcInlcIikge1xuICAgICAgICBwcm9wID0gYHRyYW5zbGF0ZSR7dWNmaXJzdChwcm9wKX1gO1xuICAgICAgICB0cmFuc2Zvcm1GbjIgPSAoc3RvcCkgPT4gdG9GbG9hdCh0b0Zsb2F0KHN0b3ApLnRvRml4ZWQodW5pdCA9PT0gXCJweFwiID8gMCA6IDYpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgIHVuaXQgPSBcIlwiO1xuICAgICAgICB0cmFuc2Zvcm1GbjIgPSAoc3RvcCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gZ2V0VW5pdChbc3RvcF0pID8gdG9QeChzdG9wLCBcIndpZHRoXCIsIGVsLCB0cnVlKSAvIGVsW2BvZmZzZXQkeygoX2EgPSBzdG9wLmVuZHNXaXRoKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChzdG9wLCBcInZoXCIpKSA/IFwiSGVpZ2h0XCIgOiBcIldpZHRoXCJ9YF0gOiB0b0Zsb2F0KHN0b3ApO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KHByb3AgPT09IFwic2NhbGVcIiA/IDEgOiAwKTtcbiAgICAgIH1cbiAgICAgIHN0b3BzID0gcGFyc2VTdG9wcyhzdG9wcywgdHJhbnNmb3JtRm4yKTtcbiAgICAgIHJldHVybiAoY3NzMiwgcGVyY2VudCkgPT4ge1xuICAgICAgICBjc3MyLnRyYW5zZm9ybSA9IGAke2NzczIudHJhbnNmb3JtIHx8IFwiXCJ9ICR7cHJvcH0oJHtnZXRWYWx1ZShzdG9wcywgcGVyY2VudCl9JHt1bml0fSlgO1xuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29sb3JGbihwcm9wLCBlbCwgc3RvcHMpIHtcbiAgICAgIGlmIChzdG9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgc3RvcHMudW5zaGlmdChnZXRDc3NWYWx1ZShlbCwgcHJvcCwgXCJcIikpO1xuICAgICAgfVxuICAgICAgc3RvcHMgPSBwYXJzZVN0b3BzKHN0b3BzLCAoc3RvcCkgPT4gcGFyc2VDb2xvcihlbCwgc3RvcCkpO1xuICAgICAgcmV0dXJuIChjc3MyLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IFtzdGFydCwgZW5kLCBwXSA9IGdldFN0b3Aoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0YXJ0Lm1hcCgodmFsdWUyLCBpKSA9PiB7XG4gICAgICAgICAgdmFsdWUyICs9IHAgKiAoZW5kW2ldIC0gdmFsdWUyKTtcbiAgICAgICAgICByZXR1cm4gaSA9PT0gMyA/IHRvRmxvYXQodmFsdWUyKSA6IHBhcnNlSW50KHZhbHVlMiwgMTApO1xuICAgICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICAgICAgY3NzMltwcm9wXSA9IGByZ2JhKCR7dmFsdWV9KWA7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNvbG9yKGVsLCBjb2xvcikge1xuICAgICAgcmV0dXJuIGdldENzc1ZhbHVlKGVsLCBcImNvbG9yXCIsIGNvbG9yKS5zcGxpdCgvWygpLF0vZykuc2xpY2UoMSwgLTEpLmNvbmNhdCgxKS5zbGljZSgwLCA0KS5tYXAodG9GbG9hdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbHRlckZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KDApO1xuICAgICAgfVxuICAgICAgY29uc3QgdW5pdCA9IGdldFVuaXQoc3RvcHMpIHx8IHsgYmx1cjogXCJweFwiLCBodWU6IFwiZGVnXCIgfVtwcm9wXSB8fCBcIiVcIjtcbiAgICAgIHByb3AgPSB7IGZvcGFjaXR5OiBcIm9wYWNpdHlcIiwgaHVlOiBcImh1ZS1yb3RhdGVcIiB9W3Byb3BdIHx8IHByb3A7XG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMpO1xuICAgICAgcmV0dXJuIChjc3MyLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VmFsdWUoc3RvcHMsIHBlcmNlbnQpO1xuICAgICAgICBjc3MyLmZpbHRlciA9IGAke2NzczIuZmlsdGVyIHx8IFwiXCJ9ICR7cHJvcH0oJHt2YWx1ZSArIHVuaXR9KWA7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjc3NQcm9wRm4ocHJvcCwgZWwsIHN0b3BzKSB7XG4gICAgICBpZiAoc3RvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0b3BzLnVuc2hpZnQoZ2V0Q3NzVmFsdWUoZWwsIHByb3AsIFwiXCIpKTtcbiAgICAgIH1cbiAgICAgIHN0b3BzID0gcGFyc2VTdG9wcyhzdG9wcyk7XG4gICAgICByZXR1cm4gKGNzczIsIHBlcmNlbnQpID0+IHtcbiAgICAgICAgY3NzMltwcm9wXSA9IGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cm9rZUZuKHByb3AsIGVsLCBzdG9wcykge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KDApO1xuICAgICAgfVxuICAgICAgY29uc3QgdW5pdCA9IGdldFVuaXQoc3RvcHMpO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TWF4UGF0aExlbmd0aChlbCk7XG4gICAgICBzdG9wcyA9IHBhcnNlU3RvcHMoc3RvcHMucmV2ZXJzZSgpLCAoc3RvcCkgPT4ge1xuICAgICAgICBzdG9wID0gdG9GbG9hdChzdG9wKTtcbiAgICAgICAgcmV0dXJuIHVuaXQgPT09IFwiJVwiID8gc3RvcCAqIGxlbmd0aCAvIDEwMCA6IHN0b3A7XG4gICAgICB9KTtcbiAgICAgIGlmICghc3RvcHMuc29tZSgoW3ZhbHVlXSkgPT4gdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuICAgICAgY3NzKGVsLCBcInN0cm9rZURhc2hhcnJheVwiLCBsZW5ndGgpO1xuICAgICAgcmV0dXJuIChjc3MyLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGNzczIuc3Ryb2tlRGFzaG9mZnNldCA9IGdldFZhbHVlKHN0b3BzLCBwZXJjZW50KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhY2tncm91bmRGbihwcm9wLCBlbCwgc3RvcHMsIHByb3BzMikge1xuICAgICAgaWYgKHN0b3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdG9wcy51bnNoaWZ0KDApO1xuICAgICAgfVxuICAgICAgY29uc3QgYXR0ciA9IHByb3AgPT09IFwiYmd5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICAgICAgcHJvcHMyW3Byb3BdID0gcGFyc2VTdG9wcyhzdG9wcywgKHN0b3ApID0+IHRvUHgoc3RvcCwgYXR0ciwgZWwpKTtcbiAgICAgIGNvbnN0IGJnUHJvcHMgPSBbXCJiZ3hcIiwgXCJiZ3lcIl0uZmlsdGVyKChwcm9wMikgPT4gcHJvcDIgaW4gcHJvcHMyKTtcbiAgICAgIGlmIChiZ1Byb3BzLmxlbmd0aCA9PT0gMiAmJiBwcm9wID09PSBcImJneFwiKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuICAgICAgaWYgKGdldENzc1ZhbHVlKGVsLCBcImJhY2tncm91bmRTaXplXCIsIFwiXCIpID09PSBcImNvdmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGJhY2tncm91bmRDb3ZlckZuKHByb3AsIGVsLCBzdG9wcywgcHJvcHMyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBwcm9wMiBvZiBiZ1Byb3BzKSB7XG4gICAgICAgIHBvc2l0aW9uc1twcm9wMl0gPSBnZXRCYWNrZ3JvdW5kUG9zKGVsLCBwcm9wMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2V0QmFja2dyb3VuZFBvc0ZuKGJnUHJvcHMsIHBvc2l0aW9ucywgcHJvcHMyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFja2dyb3VuZENvdmVyRm4ocHJvcCwgZWwsIHN0b3BzLCBwcm9wczIpIHtcbiAgICAgIGNvbnN0IGRpbUltYWdlID0gZ2V0QmFja2dyb3VuZEltYWdlRGltZW5zaW9ucyhlbCk7XG4gICAgICBpZiAoIWRpbUltYWdlLndpZHRoKSB7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuICAgICAgY29uc3QgZGltRWwgPSB7XG4gICAgICAgIHdpZHRoOiBlbC5vZmZzZXRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBlbC5vZmZzZXRIZWlnaHRcbiAgICAgIH07XG4gICAgICBjb25zdCBiZ1Byb3BzID0gW1wiYmd4XCIsIFwiYmd5XCJdLmZpbHRlcigocHJvcDIpID0+IHByb3AyIGluIHByb3BzMik7XG4gICAgICBjb25zdCBwb3NpdGlvbnMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgcHJvcDIgb2YgYmdQcm9wcykge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBwcm9wczJbcHJvcDJdLm1hcCgoW3ZhbHVlXSkgPT4gdmFsdWUpO1xuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heCguLi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBkb3duID0gdmFsdWVzLmluZGV4T2YobWluKSA8IHZhbHVlcy5pbmRleE9mKG1heCk7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBtYXggLSBtaW47XG4gICAgICAgIHBvc2l0aW9uc1twcm9wMl0gPSBgJHsoZG93biA/IC1kaWZmIDogMCkgLSAoZG93biA/IG1pbiA6IG1heCl9cHhgO1xuICAgICAgICBkaW1FbFtwcm9wMiA9PT0gXCJiZ3lcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCJdICs9IGRpZmY7XG4gICAgICB9XG4gICAgICBjb25zdCBkaW0gPSBEaW1lbnNpb25zLmNvdmVyKGRpbUltYWdlLCBkaW1FbCk7XG4gICAgICBmb3IgKGNvbnN0IHByb3AyIG9mIGJnUHJvcHMpIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IHByb3AyID09PSBcImJneVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBkaW1bYXR0cl0gLSBkaW1FbFthdHRyXTtcbiAgICAgICAgcG9zaXRpb25zW3Byb3AyXSA9IGBtYXgoJHtnZXRCYWNrZ3JvdW5kUG9zKGVsLCBwcm9wMil9LC0ke292ZXJmbG93fXB4KSArICR7cG9zaXRpb25zW3Byb3AyXX1gO1xuICAgICAgfVxuICAgICAgY29uc3QgZm4gPSBzZXRCYWNrZ3JvdW5kUG9zRm4oYmdQcm9wcywgcG9zaXRpb25zLCBwcm9wczIpO1xuICAgICAgcmV0dXJuIChjc3MyLCBwZXJjZW50KSA9PiB7XG4gICAgICAgIGZuKGNzczIsIHBlcmNlbnQpO1xuICAgICAgICBjc3MyLmJhY2tncm91bmRTaXplID0gYCR7ZGltLndpZHRofXB4ICR7ZGltLmhlaWdodH1weGA7XG4gICAgICAgIGNzczIuYmFja2dyb3VuZFJlcGVhdCA9IFwibm8tcmVwZWF0XCI7XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9zKGVsLCBwcm9wKSB7XG4gICAgICByZXR1cm4gZ2V0Q3NzVmFsdWUoZWwsIGBiYWNrZ3JvdW5kLXBvc2l0aW9uLSR7cHJvcC5zbGljZSgtMSl9YCwgXCJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEJhY2tncm91bmRQb3NGbihiZ1Byb3BzLCBwb3NpdGlvbnMsIHByb3BzMikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNzczIsIHBlcmNlbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIGJnUHJvcHMpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldFZhbHVlKHByb3BzMltwcm9wXSwgcGVyY2VudCk7XG4gICAgICAgICAgY3NzMltgYmFja2dyb3VuZC1wb3NpdGlvbi0ke3Byb3Auc2xpY2UoLTEpfWBdID0gYGNhbGMoJHtwb3NpdGlvbnNbcHJvcF19ICsgJHt2YWx1ZX1weClgO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBsb2FkaW5nID0ge307XG4gICAgY29uc3QgZGltZW5zaW9ucyA9IHt9O1xuICAgIGZ1bmN0aW9uIGdldEJhY2tncm91bmRJbWFnZURpbWVuc2lvbnMoZWwpIHtcbiAgICAgIGNvbnN0IHNyYyA9IGNzcyhlbCwgXCJiYWNrZ3JvdW5kSW1hZ2VcIikucmVwbGFjZSgvXm5vbmV8dXJsXFwoW1wiJ10/KC4rPylbXCInXT9cXCkkLywgXCIkMVwiKTtcbiAgICAgIGlmIChkaW1lbnNpb25zW3NyY10pIHtcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbnNbc3JjXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICBpZiAoc3JjKSB7XG4gICAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICAgICAgaWYgKCFpbWFnZS5uYXR1cmFsV2lkdGggJiYgIWxvYWRpbmdbc3JjXSkge1xuICAgICAgICAgIG9uY2UoaW1hZ2UsIFwiZXJyb3IgbG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBkaW1lbnNpb25zW3NyY10gPSB0b0RpbWVuc2lvbnMoaW1hZ2UpO1xuICAgICAgICAgICAgdHJpZ2dlcihlbCwgY3JlYXRlRXZlbnQoXCJsb2FkXCIsIGZhbHNlKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbG9hZGluZ1tzcmNdID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdG9EaW1lbnNpb25zKGltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRpbWVuc2lvbnNbc3JjXSA9IHRvRGltZW5zaW9ucyhpbWFnZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvRGltZW5zaW9ucyhpbWFnZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGltYWdlLm5hdHVyYWxXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBpbWFnZS5uYXR1cmFsSGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVN0b3BzKHN0b3BzLCBmbiA9IHRvRmxvYXQpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHN0b3BzO1xuICAgICAgbGV0IG51bGxJbmRleCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBbdmFsdWUsIHBlcmNlbnRdID0gaXNTdHJpbmcoc3RvcHNbaV0pID8gc3RvcHNbaV0udHJpbSgpLnNwbGl0KC8gKD8hW14oXSpcXCkpLykgOiBbc3RvcHNbaV1dO1xuICAgICAgICB2YWx1ZSA9IGZuKHZhbHVlKTtcbiAgICAgICAgcGVyY2VudCA9IHBlcmNlbnQgPyB0b0Zsb2F0KHBlcmNlbnQpIC8gMTAwIDogbnVsbDtcbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBpZiAocGVyY2VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbdmFsdWUsIDBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGlmIChwZXJjZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgIT09IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFt2YWx1ZSwgcGVyY2VudF0pO1xuICAgICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKFt2YWx1ZSwgcGVyY2VudF0pO1xuICAgICAgICBpZiAocGVyY2VudCA9PT0gbnVsbCkge1xuICAgICAgICAgIG51bGxJbmRleCsrO1xuICAgICAgICB9IGVsc2UgaWYgKG51bGxJbmRleCkge1xuICAgICAgICAgIGNvbnN0IGxlZnRQZXJjZW50ID0gcmVzdWx0W2kgLSBudWxsSW5kZXggLSAxXVsxXTtcbiAgICAgICAgICBjb25zdCBwID0gKHBlcmNlbnQgLSBsZWZ0UGVyY2VudCkgLyAobnVsbEluZGV4ICsgMSk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IG51bGxJbmRleDsgaiA+IDA7IGotLSkge1xuICAgICAgICAgICAgcmVzdWx0W2kgLSBqXVsxXSA9IGxlZnRQZXJjZW50ICsgcCAqIChudWxsSW5kZXggLSBqICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGxJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFN0b3Aoc3RvcHMsIHBlcmNlbnQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KHN0b3BzLnNsaWNlKDEpLCAoWywgdGFyZ2V0UGVyY2VudF0pID0+IHBlcmNlbnQgPD0gdGFyZ2V0UGVyY2VudCkgKyAxO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgc3RvcHNbaW5kZXggLSAxXVswXSxcbiAgICAgICAgc3RvcHNbaW5kZXhdWzBdLFxuICAgICAgICAocGVyY2VudCAtIHN0b3BzW2luZGV4IC0gMV1bMV0pIC8gKHN0b3BzW2luZGV4XVsxXSAtIHN0b3BzW2luZGV4IC0gMV1bMV0pXG4gICAgICBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZShzdG9wcywgcGVyY2VudCkge1xuICAgICAgY29uc3QgW3N0YXJ0LCBlbmQsIHBdID0gZ2V0U3RvcChzdG9wcywgcGVyY2VudCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBNYXRoLmFicyhzdGFydCAtIGVuZCkgKiBwICogKHN0YXJ0IDwgZW5kID8gMSA6IC0xKTtcbiAgICB9XG4gICAgY29uc3QgdW5pdFJlID0gL14tP1xcZCsoPzpcXC5cXGQrKT8oXFxTKyk/LztcbiAgICBmdW5jdGlvbiBnZXRVbml0KHN0b3BzLCBkZWZhdWx0VW5pdCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgZm9yIChjb25zdCBzdG9wIG9mIHN0b3BzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gKF9hID0gc3RvcC5tYXRjaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoc3RvcCwgdW5pdFJlKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmYXVsdFVuaXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENzc1ZhbHVlKGVsLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgY29uc3QgcHJldiA9IGVsLnN0eWxlW3Byb3BdO1xuICAgICAgY29uc3QgdmFsID0gY3NzKGNzcyhlbCwgcHJvcCwgdmFsdWUpLCBwcm9wKTtcbiAgICAgIGVsLnN0eWxlW3Byb3BdID0gcHJldjtcbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbGxPYmplY3Qoa2V5czIsIHZhbHVlKSB7XG4gICAgICByZXR1cm4ga2V5czIucmVkdWNlKChkYXRhLCBwcm9wKSA9PiB7XG4gICAgICAgIGRhdGFbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9LCB7fSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVhc2UocGVyY2VudCwgZWFzaW5nKSB7XG4gICAgICByZXR1cm4gZWFzaW5nID49IDAgPyBNYXRoLnBvdyhwZXJjZW50LCBlYXNpbmcgKyAxKSA6IDEgLSBNYXRoLnBvdygxIC0gcGVyY2VudCwgMSAtIGVhc2luZyk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFsbGF4ID0ge1xuICAgICAgbWl4aW5zOiBbUGFyYWxsYXhdLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIHZpZXdwb3J0OiBOdW1iZXIsXG4gICAgICAgIC8vIERlcHJlY2F0ZWRcbiAgICAgICAgZWFzaW5nOiBOdW1iZXIsXG4gICAgICAgIHN0YXJ0OiBTdHJpbmcsXG4gICAgICAgIGVuZDogU3RyaW5nXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXQ6IGZhbHNlLFxuICAgICAgICB2aWV3cG9ydDogMSxcbiAgICAgICAgZWFzaW5nOiAxLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgZW5kOiAwXG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFyZ2V0OiAoeyB0YXJnZXQgfSwgJGVsKSA9PiBnZXRPZmZzZXRFbGVtZW50KHRhcmdldCAmJiBxdWVyeSh0YXJnZXQsICRlbCkgfHwgJGVsKSxcbiAgICAgICAgc3RhcnQoeyBzdGFydCB9KSB7XG4gICAgICAgICAgcmV0dXJuIHRvUHgoc3RhcnQsIFwiaGVpZ2h0XCIsIHRoaXMudGFyZ2V0LCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5kKHsgZW5kLCB2aWV3cG9ydDogdmlld3BvcnQyIH0pIHtcbiAgICAgICAgICByZXR1cm4gdG9QeChcbiAgICAgICAgICAgIGVuZCB8fCAodmlld3BvcnQyID0gKDEgLSB2aWV3cG9ydDIpICogMTAwKSAmJiBgJHt2aWV3cG9ydDJ9dmgrJHt2aWV3cG9ydDJ9JWAsXG4gICAgICAgICAgICBcImhlaWdodFwiLFxuICAgICAgICAgICAgdGhpcy50YXJnZXQsXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IFtcbiAgICAgICAgdmlld3BvcnQoKSxcbiAgICAgICAgc2Nyb2xsJDEoeyB0YXJnZXQ6ICh7IHRhcmdldCB9KSA9PiB0YXJnZXQgfSksXG4gICAgICAgIHJlc2l6ZSh7IHRhcmdldDogKHsgJGVsLCB0YXJnZXQgfSkgPT4gWyRlbCwgdGFyZ2V0LCBzY3JvbGxQYXJlbnQodGFyZ2V0LCB0cnVlKV0gfSlcbiAgICAgIF0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCh7IHBlcmNlbnQgfSwgdHlwZXMpIHtcbiAgICAgICAgICBpZiAoIXR5cGVzLmhhcyhcInNjcm9sbFwiKSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLm1hdGNoTWVkaWEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHJldiA9IHBlcmNlbnQ7XG4gICAgICAgICAgcGVyY2VudCA9IGVhc2Uoc2Nyb2xsZWRPdmVyKHRoaXMudGFyZ2V0LCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCksIHRoaXMuZWFzaW5nKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGVyY2VudCxcbiAgICAgICAgICAgIHN0eWxlOiBwcmV2ID09PSBwZXJjZW50ID8gZmFsc2UgOiB0aGlzLmdldENzcyhwZXJjZW50KVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlKHsgc3R5bGUgfSkge1xuICAgICAgICAgIGlmICghdGhpcy5tYXRjaE1lZGlhKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlICYmIGNzcyh0aGlzLiRlbCwgc3R5bGUpO1xuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IFtcInNjcm9sbFwiLCBcInJlc2l6ZVwiXVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0T2Zmc2V0RWxlbWVudChlbCkge1xuICAgICAgcmV0dXJuIGVsID8gXCJvZmZzZXRUb3BcIiBpbiBlbCA/IGVsIDogZ2V0T2Zmc2V0RWxlbWVudChwYXJlbnQoZWwpKSA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgU2xpZGVyUGFyYWxsYXggPSB7XG4gICAgICBwcm9wczoge1xuICAgICAgICBwYXJhbGxheDogQm9vbGVhbixcbiAgICAgICAgcGFyYWxsYXhUYXJnZXQ6IEJvb2xlYW4sXG4gICAgICAgIHBhcmFsbGF4U3RhcnQ6IFN0cmluZyxcbiAgICAgICAgcGFyYWxsYXhFbmQ6IFN0cmluZyxcbiAgICAgICAgcGFyYWxsYXhFYXNpbmc6IE51bWJlclxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGFyYWxsYXg6IGZhbHNlLFxuICAgICAgICBwYXJhbGxheFRhcmdldDogZmFsc2UsXG4gICAgICAgIHBhcmFsbGF4U3RhcnQ6IDAsXG4gICAgICAgIHBhcmFsbGF4RW5kOiAwLFxuICAgICAgICBwYXJhbGxheEVhc2luZzogMFxuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IFtcbiAgICAgICAgcmVzaXplKHtcbiAgICAgICAgICB0YXJnZXQ6ICh7ICRlbCwgcGFyYWxsYXhUYXJnZXQgfSkgPT4gWyRlbCwgcGFyYWxsYXhUYXJnZXRdLFxuICAgICAgICAgIGZpbHRlcjogKHsgcGFyYWxsYXggfSkgPT4gcGFyYWxsYXhcbiAgICAgICAgfSksXG4gICAgICAgIHNjcm9sbCQxKHsgZmlsdGVyOiAoeyBwYXJhbGxheCB9KSA9PiBwYXJhbGxheCB9KVxuICAgICAgXSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHBhcmFsbGF4VGFyZ2V0KHsgcGFyYWxsYXhUYXJnZXQgfSwgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmFsbGF4VGFyZ2V0ICYmIHF1ZXJ5KHBhcmFsbGF4VGFyZ2V0LCAkZWwpIHx8IHRoaXMubGlzdDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICghdGhpcy5wYXJhbGxheCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnBhcmFsbGF4VGFyZ2V0O1xuICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdG9QeCh0aGlzLnBhcmFsbGF4U3RhcnQsIFwiaGVpZ2h0XCIsIHRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgZW5kID0gdG9QeCh0aGlzLnBhcmFsbGF4RW5kLCBcImhlaWdodFwiLCB0YXJnZXQsIHRydWUpO1xuICAgICAgICAgIGNvbnN0IHBlcmNlbnQgPSBlYXNlKHNjcm9sbGVkT3Zlcih0YXJnZXQsIHN0YXJ0LCBlbmQpLCB0aGlzLnBhcmFsbGF4RWFzaW5nKTtcbiAgICAgICAgICByZXR1cm4geyBwYXJhbGxheDogdGhpcy5nZXRJbmRleEF0KHBlcmNlbnQpIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlKHsgcGFyYWxsYXggfSkge1xuICAgICAgICAgIGNvbnN0IFtwcmV2SW5kZXgsIHNsaWRlUGVyY2VudF0gPSBwYXJhbGxheDtcbiAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgocHJldkluZGV4ICsgTWF0aC5jZWlsKHNsaWRlUGVyY2VudCkpO1xuICAgICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLnNsaWRlc1twcmV2SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLnNsaWRlc1tuZXh0SW5kZXhdO1xuICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlclNob3csIHRyaWdnZXJTaG93biwgdHJpZ2dlckhpZGUsIHRyaWdnZXJIaWRkZW4gfSA9IHVzZVRyaWdnZXJzKHRoaXMpO1xuICAgICAgICAgIGlmICh+dGhpcy5wcmV2SW5kZXgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBvZiAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbdGhpcy5pbmRleCwgdGhpcy5wcmV2SW5kZXhdKSkge1xuICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVzKFtuZXh0SW5kZXgsIHByZXZJbmRleF0sIGkpKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckhpZGUodGhpcy5zbGlkZXNbaV0pO1xuICAgICAgICAgICAgICAgIHRyaWdnZXJIaWRkZW4odGhpcy5zbGlkZXNbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLnByZXZJbmRleCAhPT0gcHJldkluZGV4IHx8IHRoaXMuaW5kZXggIT09IG5leHRJbmRleDtcbiAgICAgICAgICB0aGlzLmRpciA9IDE7XG4gICAgICAgICAgdGhpcy5wcmV2SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgICAgICAgdHJpZ2dlckhpZGUocHJldik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyaWdnZXJTaG93KG5leHQpO1xuICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0cmlnZ2VyU2hvd24ocHJldik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0ZShwcmV2ID09PSBuZXh0ID8gMSA6IHNsaWRlUGVyY2VudCwgcHJldiwgbmV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czogW1wic2Nyb2xsXCIsIFwicmVzaXplXCJdXG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBnZXRJbmRleEF0KHBlcmNlbnQpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHBlcmNlbnQgKiAodGhpcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICByZXR1cm4gW01hdGguZmxvb3IoaW5kZXgpLCBpbmRleCAlIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiB1c2VUcmlnZ2VycyhjbXApIHtcbiAgICAgIGNvbnN0IHsgY2xzU2xpZGVBY3RpdmUsIGNsc0VudGVyLCBjbHNMZWF2ZSB9ID0gY21wO1xuICAgICAgcmV0dXJuIHsgdHJpZ2dlclNob3csIHRyaWdnZXJTaG93biwgdHJpZ2dlckhpZGUsIHRyaWdnZXJIaWRkZW4gfTtcbiAgICAgIGZ1bmN0aW9uIHRyaWdnZXJTaG93KGVsKSB7XG4gICAgICAgIGlmIChoYXNDbGFzcyhlbCwgY2xzTGVhdmUpKSB7XG4gICAgICAgICAgdHJpZ2dlckhpZGUoZWwpO1xuICAgICAgICAgIHRyaWdnZXJIaWRkZW4oZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzQ2xhc3MoZWwsIGNsc1NsaWRlQWN0aXZlKSkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsIFwiYmVmb3JlaXRlbXNob3dcIiwgW2NtcF0pO1xuICAgICAgICAgIHRyaWdnZXIoZWwsIFwiaXRlbXNob3dcIiwgW2NtcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0cmlnZ2VyU2hvd24oZWwpIHtcbiAgICAgICAgaWYgKGhhc0NsYXNzKGVsLCBjbHNFbnRlcikpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCBcIml0ZW1zaG93blwiLCBbY21wXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHRyaWdnZXJIaWRlKGVsKSB7XG4gICAgICAgIGlmICghaGFzQ2xhc3MoZWwsIGNsc1NsaWRlQWN0aXZlKSkge1xuICAgICAgICAgIHRyaWdnZXJTaG93KGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ2xhc3MoZWwsIGNsc0VudGVyKSkge1xuICAgICAgICAgIHRyaWdnZXJTaG93bihlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNDbGFzcyhlbCwgY2xzTGVhdmUpKSB7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgXCJiZWZvcmVpdGVtaGlkZVwiLCBbY21wXSk7XG4gICAgICAgICAgdHJpZ2dlcihlbCwgXCJpdGVtaGlkZVwiLCBbY21wXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHRyaWdnZXJIaWRkZW4oZWwpIHtcbiAgICAgICAgaWYgKGhhc0NsYXNzKGVsLCBjbHNMZWF2ZSkpIHtcbiAgICAgICAgICB0cmlnZ2VyKGVsLCBcIml0ZW1oaWRkZW5cIiwgW2NtcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFNsaWRlclJlYWN0aXZlID0ge1xuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHdyaXRlKCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCB8fCB0aGlzLmRyYWdnaW5nIHx8IHRoaXMucGFyYWxsYXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgoKTtcbiAgICAgICAgICBpZiAoIX50aGlzLnByZXZJbmRleCB8fCB0aGlzLmluZGV4ICE9PSBpbmRleCkge1xuICAgICAgICAgICAgdGhpcy5zaG93KGluZGV4KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZXZlbnRzOiBbXCJyZXNpemVcIl1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFNsaWRlclByZWxvYWQgPSB7XG4gICAgICBvYnNlcnZlOiBsYXp5bG9hZCh7XG4gICAgICAgIHRhcmdldDogKHsgc2xpZGVzIH0pID0+IHNsaWRlcyxcbiAgICAgICAgdGFyZ2V0czogKGluc3RhbmNlKSA9PiBpbnN0YW5jZS5nZXRBZGphY2VudFNsaWRlcygpXG4gICAgICB9KSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgZ2V0QWRqYWNlbnRTbGlkZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIFsxLCAtMV0ubWFwKChpKSA9PiB0aGlzLnNsaWRlc1t0aGlzLmdldEluZGV4KHRoaXMuaW5kZXggKyBpKV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFRyYW5zaXRpb25lcihwcmV2LCBuZXh0LCBkaXIsIHsgY2VudGVyLCBlYXNpbmcsIGxpc3QgfSkge1xuICAgICAgY29uc3QgZnJvbSA9IHByZXYgPyBnZXRMZWZ0KHByZXYsIGxpc3QsIGNlbnRlcikgOiBnZXRMZWZ0KG5leHQsIGxpc3QsIGNlbnRlcikgKyBkaW1lbnNpb25zJDEobmV4dCkud2lkdGggKiBkaXI7XG4gICAgICBjb25zdCB0byA9IG5leHQgPyBnZXRMZWZ0KG5leHQsIGxpc3QsIGNlbnRlcikgOiBmcm9tICsgZGltZW5zaW9ucyQxKHByZXYpLndpZHRoICogZGlyICogKGlzUnRsID8gLTEgOiAxKTtcbiAgICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gd2l0aFJlc29sdmVycygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlyLFxuICAgICAgICBzaG93KGR1cmF0aW9uLCBwZXJjZW50ID0gMCwgbGluZWFyKSB7XG4gICAgICAgICAgY29uc3QgdGltaW5nID0gbGluZWFyID8gXCJsaW5lYXJcIiA6IGVhc2luZztcbiAgICAgICAgICBkdXJhdGlvbiAtPSBNYXRoLnJvdW5kKGR1cmF0aW9uICogY2xhbXAocGVyY2VudCwgLTEsIDEpKTtcbiAgICAgICAgICBjc3MobGlzdCwgXCJ0cmFuc2l0aW9uUHJvcGVydHlcIiwgXCJub25lXCIpO1xuICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHBlcmNlbnQpO1xuICAgICAgICAgIGNzcyhsaXN0LCBcInRyYW5zaXRpb25Qcm9wZXJ0eVwiLCBcIlwiKTtcbiAgICAgICAgICBwZXJjZW50ID0gcHJldiA/IHBlcmNlbnQgOiBjbGFtcChwZXJjZW50LCAwLCAxKTtcbiAgICAgICAgICB0cmlnZ2VyVXBkYXRlKHRoaXMuZ2V0SXRlbUluKCksIFwiaXRlbWluXCIsIHsgcGVyY2VudCwgZHVyYXRpb24sIHRpbWluZywgZGlyIH0pO1xuICAgICAgICAgIHByZXYgJiYgdHJpZ2dlclVwZGF0ZSh0aGlzLmdldEl0ZW1Jbih0cnVlKSwgXCJpdGVtb3V0XCIsIHtcbiAgICAgICAgICAgIHBlcmNlbnQ6IDEgLSBwZXJjZW50LFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmcsXG4gICAgICAgICAgICBkaXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KFxuICAgICAgICAgICAgbGlzdCxcbiAgICAgICAgICAgIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLXRvICogKGlzUnRsID8gLTEgOiAxKSwgXCJweFwiKSB9LFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1pbmdcbiAgICAgICAgICApLnRoZW4ocmVzb2x2ZSwgbm9vcCk7XG4gICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbCgpIHtcbiAgICAgICAgICByZXR1cm4gVHJhbnNpdGlvbi5jYW5jZWwobGlzdCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgIGNzcyhsaXN0LCBcInRyYW5zZm9ybVwiLCBcIlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgZm9yd2FyZChkdXJhdGlvbiwgcGVyY2VudCA9IHRoaXMucGVyY2VudCgpKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaG93KGR1cmF0aW9uLCBwZXJjZW50LCB0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNsYXRlKHBlcmNlbnQpIHtcbiAgICAgICAgICBpZiAocGVyY2VudCA9PT0gdGhpcy5wZXJjZW50KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLmdldERpc3RhbmNlKCkgKiBkaXIgKiAoaXNSdGwgPyAtMSA6IDEpO1xuICAgICAgICAgIGNzcyhcbiAgICAgICAgICAgIGxpc3QsXG4gICAgICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgdHJhbnNsYXRlKFxuICAgICAgICAgICAgICBjbGFtcChcbiAgICAgICAgICAgICAgICAtdG8gKyAoZGlzdGFuY2UgLSBkaXN0YW5jZSAqIHBlcmNlbnQpLFxuICAgICAgICAgICAgICAgIC1nZXRXaWR0aChsaXN0KSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zJDEobGlzdCkud2lkdGhcbiAgICAgICAgICAgICAgKSAqIChpc1J0bCA/IC0xIDogMSksXG4gICAgICAgICAgICAgIFwicHhcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgYWN0aXZlcyA9IHRoaXMuZ2V0QWN0aXZlcygpO1xuICAgICAgICAgIGNvbnN0IGl0ZW1JbiA9IHRoaXMuZ2V0SXRlbUluKCk7XG4gICAgICAgICAgY29uc3QgaXRlbU91dCA9IHRoaXMuZ2V0SXRlbUluKHRydWUpO1xuICAgICAgICAgIHBlcmNlbnQgPSBwcmV2ID8gY2xhbXAocGVyY2VudCwgLTEsIDEpIDogMDtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIGNoaWxkcmVuKGxpc3QpKSB7XG4gICAgICAgICAgICBjb25zdCBpc0FjdGl2ZSA9IGluY2x1ZGVzKGFjdGl2ZXMsIHNsaWRlKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW4gPSBzbGlkZSA9PT0gaXRlbUluO1xuICAgICAgICAgICAgY29uc3QgaXNPdXQgPSBzbGlkZSA9PT0gaXRlbU91dDtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZUluID0gaXNJbiB8fCAhaXNPdXQgJiYgKGlzQWN0aXZlIHx8IGRpciAqIChpc1J0bCA/IC0xIDogMSkgPT09IC0xIF4gZ2V0RWxMZWZ0KHNsaWRlLCBsaXN0KSA+IGdldEVsTGVmdChwcmV2IHx8IG5leHQpKTtcbiAgICAgICAgICAgIHRyaWdnZXJVcGRhdGUoc2xpZGUsIGBpdGVtdHJhbnNsYXRlJHt0cmFuc2xhdGVJbiA/IFwiaW5cIiA6IFwib3V0XCJ9YCwge1xuICAgICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICAgIHBlcmNlbnQ6IGlzT3V0ID8gMSAtIHBlcmNlbnQgOiBpc0luID8gcGVyY2VudCA6IGlzQWN0aXZlID8gMSA6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcGVyY2VudCgpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5hYnMoXG4gICAgICAgICAgICAobmV3IERPTU1hdHJpeChjc3MobGlzdCwgXCJ0cmFuc2Zvcm1cIikpLm00MSAqIChpc1J0bCA/IC0xIDogMSkgKyBmcm9tKSAvICh0byAtIGZyb20pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0RGlzdGFuY2UoKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvIC0gZnJvbSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEl0ZW1JbihvdXQgPSBmYWxzZSkge1xuICAgICAgICAgIGxldCBhY3RpdmVzID0gdGhpcy5nZXRBY3RpdmVzKCk7XG4gICAgICAgICAgbGV0IG5leHRBY3RpdmVzID0gaW5WaWV3KGxpc3QsIGdldExlZnQobmV4dCB8fCBwcmV2LCBsaXN0LCBjZW50ZXIpKTtcbiAgICAgICAgICBpZiAob3V0KSB7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gYWN0aXZlcztcbiAgICAgICAgICAgIGFjdGl2ZXMgPSBuZXh0QWN0aXZlcztcbiAgICAgICAgICAgIG5leHRBY3RpdmVzID0gdGVtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5leHRBY3RpdmVzW2ZpbmRJbmRleChuZXh0QWN0aXZlcywgKGVsKSA9PiAhaW5jbHVkZXMoYWN0aXZlcywgZWwpKV07XG4gICAgICAgIH0sXG4gICAgICAgIGdldEFjdGl2ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGluVmlldyhsaXN0LCBnZXRMZWZ0KHByZXYgfHwgbmV4dCwgbGlzdCwgY2VudGVyKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldExlZnQoZWwsIGxpc3QsIGNlbnRlcikge1xuICAgICAgY29uc3QgbGVmdCA9IGdldEVsTGVmdChlbCwgbGlzdCk7XG4gICAgICByZXR1cm4gY2VudGVyID8gbGVmdCAtIGNlbnRlckVsKGVsLCBsaXN0KSA6IE1hdGgubWluKGxlZnQsIGdldE1heChsaXN0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE1heChsaXN0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgZ2V0V2lkdGgobGlzdCkgLSBkaW1lbnNpb25zJDEobGlzdCkud2lkdGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRXaWR0aChsaXN0LCBpbmRleCkge1xuICAgICAgcmV0dXJuIHN1bUJ5KGNoaWxkcmVuKGxpc3QpLnNsaWNlKDAsIGluZGV4KSwgKGVsKSA9PiBkaW1lbnNpb25zJDEoZWwpLndpZHRoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2VudGVyRWwoZWwsIGxpc3QpIHtcbiAgICAgIHJldHVybiBkaW1lbnNpb25zJDEobGlzdCkud2lkdGggLyAyIC0gZGltZW5zaW9ucyQxKGVsKS53aWR0aCAvIDI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEVsTGVmdChlbCwgbGlzdCkge1xuICAgICAgcmV0dXJuIGVsICYmIChwb3NpdGlvbihlbCkubGVmdCArIChpc1J0bCA/IGRpbWVuc2lvbnMkMShlbCkud2lkdGggLSBkaW1lbnNpb25zJDEobGlzdCkud2lkdGggOiAwKSkgKiAoaXNSdGwgPyAtMSA6IDEpIHx8IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluVmlldyhsaXN0LCBsaXN0TGVmdCkge1xuICAgICAgbGlzdExlZnQgLT0gMTtcbiAgICAgIGNvbnN0IGxpc3RXaWR0aCA9IGRpbWVuc2lvbnMkMShsaXN0KS53aWR0aDtcbiAgICAgIGNvbnN0IGxpc3RSaWdodCA9IGxpc3RMZWZ0ICsgbGlzdFdpZHRoICsgMjtcbiAgICAgIHJldHVybiBjaGlsZHJlbihsaXN0KS5maWx0ZXIoKHNsaWRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNsaWRlTGVmdCA9IGdldEVsTGVmdChzbGlkZSwgbGlzdCk7XG4gICAgICAgIGNvbnN0IHNsaWRlUmlnaHQgPSBzbGlkZUxlZnQgKyBNYXRoLm1pbihkaW1lbnNpb25zJDEoc2xpZGUpLndpZHRoLCBsaXN0V2lkdGgpO1xuICAgICAgICByZXR1cm4gc2xpZGVMZWZ0ID49IGxpc3RMZWZ0ICYmIHNsaWRlUmlnaHQgPD0gbGlzdFJpZ2h0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHNsaWRlciA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBTbGlkZXIsIFNsaWRlclJlYWN0aXZlLCBTbGlkZXJQYXJhbGxheCwgU2xpZGVyUHJlbG9hZF0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBjZW50ZXI6IEJvb2xlYW4sXG4gICAgICAgIHNldHM6IEJvb2xlYW4sXG4gICAgICAgIGFjdGl2ZTogU3RyaW5nXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBjZW50ZXI6IGZhbHNlLFxuICAgICAgICBzZXRzOiBmYWxzZSxcbiAgICAgICAgYXR0ckl0ZW06IFwidWstc2xpZGVyLWl0ZW1cIixcbiAgICAgICAgc2VsTGlzdDogXCIudWstc2xpZGVyLWl0ZW1zXCIsXG4gICAgICAgIHNlbE5hdjogXCIudWstc2xpZGVyLW5hdlwiLFxuICAgICAgICBjbHNDb250YWluZXI6IFwidWstc2xpZGVyLWNvbnRhaW5lclwiLFxuICAgICAgICBhY3RpdmU6IFwiYWxsXCIsXG4gICAgICAgIFRyYW5zaXRpb25lclxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGZpbml0ZSh7IGZpbml0ZSB9KSB7XG4gICAgICAgICAgcmV0dXJuIGZpbml0ZSB8fCBpc0Zpbml0ZSh0aGlzLmxpc3QsIHRoaXMuY2VudGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWF4SW5kZXgoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmZpbml0ZSB8fCB0aGlzLmNlbnRlciAmJiAhdGhpcy5zZXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0KHRoaXMuc2V0cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBsZnQgPSAwO1xuICAgICAgICAgIGNvbnN0IG1heCA9IGdldE1heCh0aGlzLmxpc3QpO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gZmluZEluZGV4KHRoaXMuc2xpZGVzLCAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChsZnQgPj0gbWF4IC0gNWUtMykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxmdCArPSBkaW1lbnNpb25zJDEoZWwpLndpZHRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB+aW5kZXggPyBpbmRleCA6IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0cyh7IHNldHM6IGVuYWJsZWQgfSkge1xuICAgICAgICAgIGlmICghZW5hYmxlZCB8fCB0aGlzLnBhcmFsbGF4KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBsZWZ0ID0gMDtcbiAgICAgICAgICBjb25zdCBzZXRzID0gW107XG4gICAgICAgICAgY29uc3Qgd2lkdGggPSBkaW1lbnNpb25zJDEodGhpcy5saXN0KS53aWR0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlV2lkdGggPSBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbaV0pLndpZHRoO1xuICAgICAgICAgICAgaWYgKGxlZnQgKyBzbGlkZVdpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGxlZnQgPCB3aWR0aCAvIDIgJiYgbGVmdCArIHNsaWRlV2lkdGggKyBkaW1lbnNpb25zJDEodGhpcy5zbGlkZXNbZ2V0SW5kZXgoaSArIDEsIHRoaXMuc2xpZGVzKV0pLndpZHRoIC8gMiA+IHdpZHRoIC8gMikge1xuICAgICAgICAgICAgICAgIHNldHMucHVzaChpKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gd2lkdGggLyAyIC0gc2xpZGVXaWR0aCAvIDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICBzZXRzLnB1c2goTWF0aC5taW4oaSwgdGhpcy5tYXhJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVmdCArPSBzbGlkZVdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRzO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNpdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5jZW50ZXIsXG4gICAgICAgICAgICBsaXN0OiB0aGlzLmxpc3RcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzbGlkZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuKHRoaXMubGlzdCkuZmlsdGVyKGlzVmlzaWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc0NvbnRhaW5lciwgISQoYC4ke3RoaXMuY2xzQ29udGFpbmVyfWAsIHRoaXMuJGVsKSk7XG4gICAgICB9LFxuICAgICAgb2JzZXJ2ZTogcmVzaXplKHtcbiAgICAgICAgdGFyZ2V0OiAoeyBzbGlkZXMsICRlbCB9KSA9PiBbJGVsLCAuLi5zbGlkZXNdXG4gICAgICB9KSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZSgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMubmF2SXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdG9OdW1iZXIoZGF0YShlbCwgdGhpcy5hdHRySXRlbSkpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlbC5oaWRkZW4gPSAhdGhpcy5tYXhJbmRleCB8fCBpbmRleCA+IHRoaXMubWF4SW5kZXggfHwgdGhpcy5zZXRzICYmICFpbmNsdWRlcyh0aGlzLnNldHMsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5yZW9yZGVyKCk7XG4gICAgICAgICAgaWYgKCF0aGlzLnBhcmFsbGF4KSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGUoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlQ2xhc3NlcygpO1xuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IFtcInJlc2l6ZVwiXVxuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBiZWZvcmVpdGVtc2hvdyhlKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWdnaW5nICYmIHRoaXMuc2V0cyAmJiB0aGlzLnN0YWNrLmxlbmd0aCA8IDIgJiYgIWluY2x1ZGVzKHRoaXMuc2V0cywgdGhpcy5pbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmdldFZhbGlkSW5kZXgoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZGlmZiA9IE1hdGguYWJzKFxuICAgICAgICAgICAgdGhpcy5pbmRleCAtIHRoaXMucHJldkluZGV4ICsgKHRoaXMuZGlyID4gMCAmJiB0aGlzLmluZGV4IDwgdGhpcy5wcmV2SW5kZXggfHwgdGhpcy5kaXIgPCAwICYmIHRoaXMuaW5kZXggPiB0aGlzLnByZXZJbmRleCA/ICh0aGlzLm1heEluZGV4ICsgMSkgKiB0aGlzLmRpciA6IDApXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcgJiYgZGlmZiA+IDEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RhY2suc3BsaWNlKDEsIDAsIHRoaXMuZGlyID4gMCA/IFwibmV4dFwiIDogXCJwcmV2aW91c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRpciA8IDAgfHwgIXRoaXMuc2xpZGVzW3RoaXMucHJldkluZGV4XSA/IHRoaXMuaW5kZXggOiB0aGlzLnByZXZJbmRleDtcbiAgICAgICAgICBjb25zdCBhdmdXaWR0aCA9IGdldFdpZHRoKHRoaXMubGlzdCkgLyB0aGlzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gc3BlZWRVcChhdmdXaWR0aCAvIHRoaXMudmVsb2NpdHkpICogKGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1tpbmRleF0pLndpZHRoIC8gYXZnV2lkdGgpO1xuICAgICAgICAgIHRoaXMucmVvcmRlcigpO1xuICAgICAgICB9LFxuICAgICAgICBpdGVtc2hvdygpIHtcbiAgICAgICAgICBpZiAofnRoaXMucHJldkluZGV4KSB7XG4gICAgICAgICAgICBhZGRDbGFzcyh0aGlzLl9nZXRUcmFuc2l0aW9uZXIoKS5nZXRJdGVtSW4oKSwgdGhpcy5jbHNBY3RpdmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUNsYXNzZXModGhpcy5wcmV2SW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBpdGVtc2hvd24oKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVDbGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHJlb3JkZXIoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmluaXRlKSB7XG4gICAgICAgICAgICBjc3ModGhpcy5zbGlkZXMsIFwib3JkZXJcIiwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kaXIgPiAwICYmIHRoaXMuc2xpZGVzW3RoaXMucHJldkluZGV4XSA/IHRoaXMucHJldkluZGV4IDogdGhpcy5pbmRleDtcbiAgICAgICAgICB0aGlzLnNsaWRlcy5mb3JFYWNoKFxuICAgICAgICAgICAgKHNsaWRlLCBpKSA9PiBjc3MoXG4gICAgICAgICAgICAgIHNsaWRlLFxuICAgICAgICAgICAgICBcIm9yZGVyXCIsXG4gICAgICAgICAgICAgIHRoaXMuZGlyID4gMCAmJiBpIDwgaW5kZXggPyAxIDogdGhpcy5kaXIgPCAwICYmIGkgPj0gdGhpcy5pbmRleCA/IC0xIDogXCJcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCF0aGlzLmNlbnRlciB8fCAhdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuc2xpZGVzW2luZGV4XTtcbiAgICAgICAgICBsZXQgd2lkdGggPSBkaW1lbnNpb25zJDEodGhpcy5saXN0KS53aWR0aCAvIDIgLSBkaW1lbnNpb25zJDEobmV4dCkud2lkdGggLyAyO1xuICAgICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgICB3aGlsZSAod2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRJbmRleCgtLWogKyBpbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc2xpZGUgPSB0aGlzLnNsaWRlc1tzbGlkZUluZGV4XTtcbiAgICAgICAgICAgIGNzcyhzbGlkZSwgXCJvcmRlclwiLCBzbGlkZUluZGV4ID4gaW5kZXggPyAtMiA6IC0xKTtcbiAgICAgICAgICAgIHdpZHRoIC09IGRpbWVuc2lvbnMkMShzbGlkZSkud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVBY3RpdmVDbGFzc2VzKGN1cnJlbnRJbmRleCA9IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICBsZXQgYWN0aXZlcyA9IHRoaXMuX2dldFRyYW5zaXRpb25lcihjdXJyZW50SW5kZXgpLmdldEFjdGl2ZXMoKTtcbiAgICAgICAgICBpZiAodGhpcy5hY3RpdmUgIT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgIGFjdGl2ZXMgPSBbdGhpcy5zbGlkZXNbdGhpcy5nZXRWYWxpZEluZGV4KGN1cnJlbnRJbmRleCldXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgYWN0aXZlQ2xhc3NlcyA9IFtcbiAgICAgICAgICAgIHRoaXMuY2xzQWN0aXZlLFxuICAgICAgICAgICAgIXRoaXMuc2V0cyB8fCBpbmNsdWRlcyh0aGlzLnNldHMsIHRvRmxvYXQodGhpcy5pbmRleCkpID8gdGhpcy5jbHNBY3RpdmF0ZWQgOiBcIlwiXG4gICAgICAgICAgXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNsaWRlIG9mIHRoaXMuc2xpZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUgPSBpbmNsdWRlcyhhY3RpdmVzLCBzbGlkZSk7XG4gICAgICAgICAgICB0b2dnbGVDbGFzcyhzbGlkZSwgYWN0aXZlQ2xhc3NlcywgYWN0aXZlKTtcbiAgICAgICAgICAgIGF0dHIoc2xpZGUsIFwiYXJpYS1oaWRkZW5cIiwgIWFjdGl2ZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZvY3VzYWJsZSBvZiAkJChzZWxGb2N1c2FibGUsIHNsaWRlKSkge1xuICAgICAgICAgICAgICBpZiAoIWhhc093bihmb2N1c2FibGUsIFwiX3RhYmluZGV4XCIpKSB7XG4gICAgICAgICAgICAgICAgZm9jdXNhYmxlLl90YWJpbmRleCA9IGF0dHIoZm9jdXNhYmxlLCBcInRhYmluZGV4XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF0dHIoZm9jdXNhYmxlLCBcInRhYmluZGV4XCIsIGFjdGl2ZSA/IGZvY3VzYWJsZS5fdGFiaW5kZXggOiAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRWYWxpZEluZGV4KGluZGV4ID0gdGhpcy5pbmRleCwgcHJldkluZGV4ID0gdGhpcy5wcmV2SW5kZXgpIHtcbiAgICAgICAgICBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoaW5kZXgsIHByZXZJbmRleCk7XG4gICAgICAgICAgaWYgKCF0aGlzLnNldHMpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHByZXY7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzKHRoaXMuc2V0cywgaW5kZXgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5nZXRJbmRleChpbmRleCArIHRoaXMuZGlyLCBwcmV2SW5kZXgpO1xuICAgICAgICAgIH0gd2hpbGUgKGluZGV4ICE9PSBwcmV2KTtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEFkamFjZW50U2xpZGVzKCkge1xuICAgICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IGRpbWVuc2lvbnMkMSh0aGlzLmxpc3QpO1xuICAgICAgICAgIGNvbnN0IGxlZnQgPSAtd2lkdGg7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSB3aWR0aCAqIDI7XG4gICAgICAgICAgY29uc3Qgc2xpZGVXaWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1t0aGlzLmluZGV4XSkud2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2xpZGVMZWZ0ID0gdGhpcy5jZW50ZXIgPyB3aWR0aCAvIDIgLSBzbGlkZVdpZHRoIC8gMiA6IDA7XG4gICAgICAgICAgY29uc3Qgc2xpZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGkgb2YgWy0xLCAxXSkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRMZWZ0ID0gc2xpZGVMZWZ0ICsgKGkgPiAwID8gc2xpZGVXaWR0aCA6IDApO1xuICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBjb25zdCBzbGlkZSA9IHRoaXMuc2xpZGVzW3RoaXMuZ2V0SW5kZXgodGhpcy5pbmRleCArIGkgKyBqKysgKiBpKV07XG4gICAgICAgICAgICAgIGN1cnJlbnRMZWZ0ICs9IGRpbWVuc2lvbnMkMShzbGlkZSkud2lkdGggKiBpO1xuICAgICAgICAgICAgICBzbGlkZXMuYWRkKHNsaWRlKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMubGVuZ3RoID4gaiAmJiBjdXJyZW50TGVmdCA+IGxlZnQgJiYgY3VycmVudExlZnQgPCByaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHNsaWRlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEluZGV4QXQocGVyY2VudCkge1xuICAgICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICAgIGNvbnN0IHNjcm9sbERpc3QgPSB0aGlzLmNlbnRlciA/IGdldFdpZHRoKHRoaXMubGlzdCkgLSAoZGltZW5zaW9ucyQxKHRoaXMuc2xpZGVzWzBdKS53aWR0aCAvIDIgKyBkaW1lbnNpb25zJDEobGFzdCh0aGlzLnNsaWRlcykpLndpZHRoIC8gMikgOiBnZXRXaWR0aCh0aGlzLmxpc3QsIHRoaXMubWF4SW5kZXgpO1xuICAgICAgICAgIGxldCBkaXN0ID0gcGVyY2VudCAqIHNjcm9sbERpc3Q7XG4gICAgICAgICAgbGV0IHNsaWRlUGVyY2VudCA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3Qgc2xpZGVXaWR0aCA9IGRpbWVuc2lvbnMkMSh0aGlzLnNsaWRlc1srK2luZGV4XSkud2lkdGg7XG4gICAgICAgICAgICBjb25zdCBzbGlkZURpc3QgPSB0aGlzLmNlbnRlciA/IHNsaWRlV2lkdGggLyAyICsgZGltZW5zaW9ucyQxKHRoaXMuc2xpZGVzW2luZGV4ICsgMV0pLndpZHRoIC8gMiA6IHNsaWRlV2lkdGg7XG4gICAgICAgICAgICBzbGlkZVBlcmNlbnQgPSBkaXN0IC8gc2xpZGVEaXN0ICUgMTtcbiAgICAgICAgICAgIGRpc3QgLT0gc2xpZGVEaXN0O1xuICAgICAgICAgIH0gd2hpbGUgKGRpc3QgPj0gMCAmJiBpbmRleCA8IHRoaXMubWF4SW5kZXgpO1xuICAgICAgICAgIHJldHVybiBbaW5kZXgsIHNsaWRlUGVyY2VudF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzRmluaXRlKGxpc3QsIGNlbnRlcikge1xuICAgICAgaWYgKCFsaXN0IHx8IGxpc3QubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgd2lkdGg6IGxpc3RXaWR0aCB9ID0gZGltZW5zaW9ucyQxKGxpc3QpO1xuICAgICAgaWYgKCFjZW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChnZXRXaWR0aChsaXN0KSkgPCBNYXRoLnRydW5jKGxpc3RXaWR0aCArIGdldE1heEVsV2lkdGgobGlzdCkpO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2xpZGVzID0gY2hpbGRyZW4obGlzdCk7XG4gICAgICBjb25zdCBsaXN0SGFsZiA9IE1hdGgudHJ1bmMobGlzdFdpZHRoIC8gMik7XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IGluIHNsaWRlcykge1xuICAgICAgICBjb25zdCBzbGlkZSA9IHNsaWRlc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHNsaWRlV2lkdGggPSBkaW1lbnNpb25zJDEoc2xpZGUpLndpZHRoO1xuICAgICAgICBjb25zdCBzbGlkZXNJblZpZXcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbc2xpZGVdKTtcbiAgICAgICAgbGV0IGRpZmYgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgWy0xLCAxXSkge1xuICAgICAgICAgIGxldCBsZWZ0ID0gc2xpZGVXaWR0aCAvIDI7XG4gICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgIHdoaWxlIChsZWZ0IDwgbGlzdEhhbGYpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTbGlkZSA9IHNsaWRlc1tnZXRJbmRleCgraW5kZXggKyBpICsgaisrICogaSwgc2xpZGVzKV07XG4gICAgICAgICAgICBpZiAoc2xpZGVzSW5WaWV3LmhhcyhuZXh0U2xpZGUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVmdCArPSBkaW1lbnNpb25zJDEobmV4dFNsaWRlKS53aWR0aDtcbiAgICAgICAgICAgIHNsaWRlc0luVmlldy5hZGQobmV4dFNsaWRlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlmZiA9IE1hdGgubWF4KFxuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIHNsaWRlV2lkdGggLyAyICsgZGltZW5zaW9ucyQxKHNsaWRlc1tnZXRJbmRleCgraW5kZXggKyBpLCBzbGlkZXMpXSkud2lkdGggLyAyIC0gKGxlZnQgLSBsaXN0SGFsZilcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChNYXRoLnRydW5jKGRpZmYpID4gc3VtQnkoXG4gICAgICAgICAgc2xpZGVzLmZpbHRlcigoc2xpZGUyKSA9PiAhc2xpZGVzSW5WaWV3LmhhcyhzbGlkZTIpKSxcbiAgICAgICAgICAoc2xpZGUyKSA9PiBkaW1lbnNpb25zJDEoc2xpZGUyKS53aWR0aFxuICAgICAgICApKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TWF4RWxXaWR0aChsaXN0KSB7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgLi4uY2hpbGRyZW4obGlzdCkubWFwKChlbCkgPT4gZGltZW5zaW9ucyQxKGVsKS53aWR0aCkpO1xuICAgIH1cblxuICAgIHZhciBzbGlkZXJQYXJhbGxheCA9IHtcbiAgICAgIG1peGluczogW1BhcmFsbGF4XSxcbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuaXRlbSA9IHRoaXMuJGVsLmNsb3Nlc3QoYC4ke3RoaXMuJG9wdGlvbnMuaWQucmVwbGFjZShcInBhcmFsbGF4XCIsIFwiaXRlbXNcIil9ID4gKmApO1xuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5pdGVtID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaXRlbWluIGl0ZW1vdXRcIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGVsOiAoeyBpdGVtIH0pID0+IGl0ZW0sXG4gICAgICAgICAgaGFuZGxlcih7IHR5cGUsIGRldGFpbDogeyBwZXJjZW50LCBkdXJhdGlvbiwgdGltaW5nLCBkaXIgfSB9KSB7XG4gICAgICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hNZWRpYSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwcm9wc0Zyb20gPSB0aGlzLmdldENzcyhnZXRDdXJyZW50UGVyY2VudCh0eXBlLCBkaXIsIHBlcmNlbnQpKTtcbiAgICAgICAgICAgICAgY29uc3QgcHJvcHNUbyA9IHRoaXMuZ2V0Q3NzKGlzSW4odHlwZSkgPyAwLjUgOiBkaXIgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgICBmYXN0ZG9tLndyaXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjc3ModGhpcy4kZWwsIHByb3BzRnJvbSk7XG4gICAgICAgICAgICAgICAgVHJhbnNpdGlvbi5zdGFydCh0aGlzLiRlbCwgcHJvcHNUbywgZHVyYXRpb24sIHRpbWluZykuY2F0Y2gobm9vcCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJ0cmFuc2l0aW9uY2FuY2VsZWQgdHJhbnNpdGlvbmVuZFwiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgZWw6ICh7IGl0ZW0gfSkgPT4gaXRlbSxcbiAgICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgICAgVHJhbnNpdGlvbi5jYW5jZWwodGhpcy4kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaXRlbXRyYW5zbGF0ZWluIGl0ZW10cmFuc2xhdGVvdXRcIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGVsOiAoeyBpdGVtIH0pID0+IGl0ZW0sXG4gICAgICAgICAgaGFuZGxlcih7IHR5cGUsIGRldGFpbDogeyBwZXJjZW50LCBkaXIgfSB9KSB7XG4gICAgICAgICAgICBmYXN0ZG9tLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0Y2hNZWRpYSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmdldENzcyhnZXRDdXJyZW50UGVyY2VudCh0eXBlLCBkaXIsIHBlcmNlbnQpKTtcbiAgICAgICAgICAgICAgZmFzdGRvbS53cml0ZSgoKSA9PiBjc3ModGhpcy4kZWwsIHByb3BzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzSW4odHlwZSkge1xuICAgICAgcmV0dXJuIGVuZHNXaXRoKHR5cGUsIFwiaW5cIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRQZXJjZW50KHR5cGUsIGRpciwgcGVyY2VudCkge1xuICAgICAgcGVyY2VudCAvPSAyO1xuICAgICAgcmV0dXJuIGlzSW4odHlwZSkgXiBkaXIgPCAwID8gcGVyY2VudCA6IDEgLSBwZXJjZW50O1xuICAgIH1cblxuICAgIHZhciBzbGlkZXNob3cgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgU2xpZGVzaG93LCBTbGlkZXJSZWFjdGl2ZSwgU2xpZGVyUGFyYWxsYXgsIFNsaWRlclByZWxvYWRdLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgcmF0aW86IFN0cmluZyxcbiAgICAgICAgbWluSGVpZ2h0OiBTdHJpbmcsXG4gICAgICAgIG1heEhlaWdodDogU3RyaW5nXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICByYXRpbzogXCIxNjo5XCIsXG4gICAgICAgIG1pbkhlaWdodDogdm9pZCAwLFxuICAgICAgICBtYXhIZWlnaHQ6IHZvaWQgMCxcbiAgICAgICAgc2VsTGlzdDogXCIudWstc2xpZGVzaG93LWl0ZW1zXCIsXG4gICAgICAgIGF0dHJJdGVtOiBcInVrLXNsaWRlc2hvdy1pdGVtXCIsXG4gICAgICAgIHNlbE5hdjogXCIudWstc2xpZGVzaG93LW5hdlwiLFxuICAgICAgICBBbmltYXRpb25zOiBBbmltYXRpb25zJDFcbiAgICAgIH0sXG4gICAgICB3YXRjaDoge1xuICAgICAgICBsaXN0KGxpc3QpIHtcbiAgICAgICAgICBjc3MobGlzdCwge1xuICAgICAgICAgICAgYXNwZWN0UmF0aW86IHRoaXMucmF0aW8gPyB0aGlzLnJhdGlvLnJlcGxhY2UoXCI6XCIsIFwiL1wiKSA6IHZvaWQgMCxcbiAgICAgICAgICAgIG1pbkhlaWdodDogdGhpcy5taW5IZWlnaHQsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IHRoaXMubWF4SGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldEFkamFjZW50U2xpZGVzKCkge1xuICAgICAgICAgIHJldHVybiBbMSwgLTFdLm1hcCgoaSkgPT4gdGhpcy5zbGlkZXNbdGhpcy5nZXRJbmRleCh0aGlzLmluZGV4ICsgaSldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc29ydGFibGUgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgQW5pbWF0ZV0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBncm91cDogU3RyaW5nLFxuICAgICAgICB0aHJlc2hvbGQ6IE51bWJlcixcbiAgICAgICAgY2xzSXRlbTogU3RyaW5nLFxuICAgICAgICBjbHNQbGFjZWhvbGRlcjogU3RyaW5nLFxuICAgICAgICBjbHNEcmFnOiBTdHJpbmcsXG4gICAgICAgIGNsc0RyYWdTdGF0ZTogU3RyaW5nLFxuICAgICAgICBjbHNCYXNlOiBTdHJpbmcsXG4gICAgICAgIGNsc05vRHJhZzogU3RyaW5nLFxuICAgICAgICBjbHNFbXB0eTogU3RyaW5nLFxuICAgICAgICBjbHNDdXN0b206IFN0cmluZyxcbiAgICAgICAgaGFuZGxlOiBTdHJpbmdcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGdyb3VwOiBmYWxzZSxcbiAgICAgICAgdGhyZXNob2xkOiA1LFxuICAgICAgICBjbHNJdGVtOiBcInVrLXNvcnRhYmxlLWl0ZW1cIixcbiAgICAgICAgY2xzUGxhY2Vob2xkZXI6IFwidWstc29ydGFibGUtcGxhY2Vob2xkZXJcIixcbiAgICAgICAgY2xzRHJhZzogXCJ1ay1zb3J0YWJsZS1kcmFnXCIsXG4gICAgICAgIGNsc0RyYWdTdGF0ZTogXCJ1ay1kcmFnXCIsXG4gICAgICAgIGNsc0Jhc2U6IFwidWstc29ydGFibGVcIixcbiAgICAgICAgY2xzTm9EcmFnOiBcInVrLXNvcnRhYmxlLW5vZHJhZ1wiLFxuICAgICAgICBjbHNFbXB0eTogXCJ1ay1zb3J0YWJsZS1lbXB0eVwiLFxuICAgICAgICBjbHNDdXN0b206IFwiXCIsXG4gICAgICAgIGhhbmRsZTogZmFsc2UsXG4gICAgICAgIHBvczoge31cbiAgICAgIH0sXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgbmFtZTogcG9pbnRlckRvd24kMSxcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIHRoaXMuaW5pdChlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRhcmdldDogKF8sICRlbCkgPT4gKCRlbC50Qm9kaWVzIHx8IFskZWxdKVswXSxcbiAgICAgICAgaXRlbXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkcmVuKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbXB0eSgpIHtcbiAgICAgICAgICByZXR1cm4gIXRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBoYW5kbGVzKHsgaGFuZGxlIH0sICRlbCkge1xuICAgICAgICAgIHJldHVybiBoYW5kbGUgPyAkJChoYW5kbGUsICRlbCkgOiB0aGlzLml0ZW1zO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd2F0Y2g6IHtcbiAgICAgICAgaXNFbXB0eShlbXB0eSkge1xuICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmNsc0VtcHR5LCBlbXB0eSk7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZXMoaGFuZGxlcywgcHJldikge1xuICAgICAgICAgIGNzcyhwcmV2LCB7IHRvdWNoQWN0aW9uOiBcIlwiLCB1c2VyU2VsZWN0OiBcIlwiIH0pO1xuICAgICAgICAgIGNzcyhoYW5kbGVzLCB7IHRvdWNoQWN0aW9uOiBcIm5vbmVcIiwgdXNlclNlbGVjdDogXCJub25lXCIgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgd3JpdGUoZGF0YSkge1xuICAgICAgICAgIGlmICghdGhpcy5kcmFnIHx8ICFwYXJlbnQodGhpcy5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgcG9zOiB7IHgsIHkgfSxcbiAgICAgICAgICAgIG9yaWdpbjogeyBvZmZzZXRUb3AsIG9mZnNldExlZnQgfSxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyXG4gICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgY3NzKHRoaXMuZHJhZywge1xuICAgICAgICAgICAgdG9wOiB5IC0gb2Zmc2V0VG9wLFxuICAgICAgICAgICAgbGVmdDogeCAtIG9mZnNldExlZnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBzb3J0YWJsZSA9IHRoaXMuZ2V0U29ydGFibGUoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KSk7XG4gICAgICAgICAgaWYgKCFzb3J0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IGl0ZW1zIH0gPSBzb3J0YWJsZTtcbiAgICAgICAgICBpZiAoaXRlbXMuc29tZShUcmFuc2l0aW9uLmluUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGZpbmRUYXJnZXQoaXRlbXMsIHsgeCwgeSB9KTtcbiAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoICYmICghdGFyZ2V0IHx8IHRhcmdldCA9PT0gcGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5nZXRTb3J0YWJsZShwbGFjZWhvbGRlcik7XG4gICAgICAgICAgY29uc3QgaW5zZXJ0VGFyZ2V0ID0gZmluZEluc2VydFRhcmdldChcbiAgICAgICAgICAgIHNvcnRhYmxlLnRhcmdldCxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICBzb3J0YWJsZSA9PT0gcHJldmlvdXMgJiYgZGF0YS5tb3ZlZCAhPT0gdGFyZ2V0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaW5zZXJ0VGFyZ2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5zZXJ0VGFyZ2V0ICYmIHBsYWNlaG9sZGVyID09PSBpbnNlcnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvcnRhYmxlICE9PSBwcmV2aW91cykge1xuICAgICAgICAgICAgcHJldmlvdXMucmVtb3ZlKHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIGRhdGEubW92ZWQgPSB0YXJnZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLm1vdmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb3J0YWJsZS5pbnNlcnQocGxhY2Vob2xkZXIsIGluc2VydFRhcmdldCk7XG4gICAgICAgICAgdGhpcy50b3VjaGVkLmFkZChzb3J0YWJsZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czogW1wibW92ZVwiXVxuICAgICAgfSxcbiAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgaW5pdChlKSB7XG4gICAgICAgICAgY29uc3QgeyB0YXJnZXQsIGJ1dHRvbiwgZGVmYXVsdFByZXZlbnRlZCB9ID0gZTtcbiAgICAgICAgICBjb25zdCBbcGxhY2Vob2xkZXJdID0gdGhpcy5pdGVtcy5maWx0ZXIoKGVsKSA9PiBlbC5jb250YWlucyh0YXJnZXQpKTtcbiAgICAgICAgICBpZiAoIXBsYWNlaG9sZGVyIHx8IGRlZmF1bHRQcmV2ZW50ZWQgfHwgYnV0dG9uID4gMCB8fCBpc0lucHV0KHRhcmdldCkgfHwgdGFyZ2V0LmNsb3Nlc3QoYC4ke3RoaXMuY2xzTm9EcmFnfWApIHx8IHRoaXMuaGFuZGxlICYmICF0YXJnZXQuY2xvc2VzdCh0aGlzLmhhbmRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMucG9zID0gZ2V0RXZlbnRQb3MoZSk7XG4gICAgICAgICAgdGhpcy50b3VjaGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW3RoaXNdKTtcbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgdGhpcy5vcmlnaW4gPSB7IHRhcmdldCwgaW5kZXg6IGluZGV4KHBsYWNlaG9sZGVyKSwgLi4udGhpcy5wb3MgfTtcbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlck1vdmUkMSwgdGhpcy5tb3ZlKTtcbiAgICAgICAgICBvbihkb2N1bWVudCwgcG9pbnRlclVwJDEsIHRoaXMuZW5kKTtcbiAgICAgICAgICBpZiAoIXRoaXMudGhyZXNob2xkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnQoZSkge1xuICAgICAgICAgIHRoaXMuZHJhZyA9IGFwcGVuZERyYWcodGhpcy4kY29udGFpbmVyLCB0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgICBjb25zdCB7IGxlZnQsIHRvcCB9ID0gZGltZW5zaW9ucyQxKHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgICAgIGFzc2lnbih0aGlzLm9yaWdpbiwgeyBvZmZzZXRMZWZ0OiB0aGlzLnBvcy54IC0gbGVmdCwgb2Zmc2V0VG9wOiB0aGlzLnBvcy55IC0gdG9wIH0pO1xuICAgICAgICAgIGFkZENsYXNzKHRoaXMuZHJhZywgdGhpcy5jbHNEcmFnLCB0aGlzLmNsc0N1c3RvbSk7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5wbGFjZWhvbGRlciwgdGhpcy5jbHNQbGFjZWhvbGRlcik7XG4gICAgICAgICAgYWRkQ2xhc3ModGhpcy5pdGVtcywgdGhpcy5jbHNJdGVtKTtcbiAgICAgICAgICBhZGRDbGFzcyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuY2xzRHJhZ1N0YXRlKTtcbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCBcInN0YXJ0XCIsIFt0aGlzLCB0aGlzLnBsYWNlaG9sZGVyXSk7XG4gICAgICAgICAgdHJhY2tTY3JvbGwodGhpcy5wb3MpO1xuICAgICAgICAgIHRoaXMubW92ZShlKTtcbiAgICAgICAgfSxcbiAgICAgICAgbW92ZTogdGhyb3R0bGUoZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGFzc2lnbih0aGlzLnBvcywgZ2V0RXZlbnRQb3MoZSkpO1xuICAgICAgICAgIGlmICghdGhpcy5kcmFnICYmIChNYXRoLmFicyh0aGlzLnBvcy54IC0gdGhpcy5vcmlnaW4ueCkgPiB0aGlzLnRocmVzaG9sZCB8fCBNYXRoLmFicyh0aGlzLnBvcy55IC0gdGhpcy5vcmlnaW4ueSkgPiB0aGlzLnRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuJGVtaXQoXCJtb3ZlXCIpO1xuICAgICAgICB9KSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgIG9mZihkb2N1bWVudCwgcG9pbnRlck1vdmUkMSwgdGhpcy5tb3ZlKTtcbiAgICAgICAgICBvZmYoZG9jdW1lbnQsIHBvaW50ZXJVcCQxLCB0aGlzLmVuZCk7XG4gICAgICAgICAgaWYgKCF0aGlzLmRyYWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW50cmFja1Njcm9sbCgpO1xuICAgICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy5nZXRTb3J0YWJsZSh0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgICBpZiAodGhpcyA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbi5pbmRleCAhPT0gaW5kZXgodGhpcy5wbGFjZWhvbGRlcikpIHtcbiAgICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgXCJtb3ZlZFwiLCBbdGhpcywgdGhpcy5wbGFjZWhvbGRlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmlnZ2VyKHNvcnRhYmxlLiRlbCwgXCJhZGRlZFwiLCBbc29ydGFibGUsIHRoaXMucGxhY2Vob2xkZXJdKTtcbiAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsIFwicmVtb3ZlZFwiLCBbdGhpcywgdGhpcy5wbGFjZWhvbGRlcl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCBcInN0b3BcIiwgW3RoaXMsIHRoaXMucGxhY2Vob2xkZXJdKTtcbiAgICAgICAgICByZW1vdmUkMSh0aGlzLmRyYWcpO1xuICAgICAgICAgIHRoaXMuZHJhZyA9IG51bGw7XG4gICAgICAgICAgZm9yIChjb25zdCB7IGNsc1BsYWNlaG9sZGVyLCBjbHNJdGVtIH0gb2YgdGhpcy50b3VjaGVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNvcnRhYmxlMiBvZiB0aGlzLnRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc29ydGFibGUyLml0ZW1zLCBjbHNQbGFjZWhvbGRlciwgY2xzSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudG91Y2hlZCA9IG51bGw7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmNsc0RyYWdTdGF0ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGluc2VydChlbGVtZW50LCB0YXJnZXQpIHtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLml0ZW1zLCB0aGlzLmNsc0l0ZW0pO1xuICAgICAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZSgoKSA9PiBiZWZvcmUodGFyZ2V0LCBlbGVtZW50KSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGFyZ2V0ICYmIHRoaXMudGFyZ2V0Lmxhc3RFbGVtZW50Q2hpbGQgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZSgoKSA9PiBhcHBlbmQodGhpcy50YXJnZXQsIGVsZW1lbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZShlbGVtZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGUoKCkgPT4gcmVtb3ZlJDEoZWxlbWVudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U29ydGFibGUoZWxlbWVudCkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IHNvcnRhYmxlID0gdGhpcy4kZ2V0Q29tcG9uZW50KGVsZW1lbnQsIFwic29ydGFibGVcIik7XG4gICAgICAgICAgICBpZiAoc29ydGFibGUgJiYgKHNvcnRhYmxlID09PSB0aGlzIHx8IHRoaXMuZ3JvdXAgIT09IGZhbHNlICYmIHNvcnRhYmxlLmdyb3VwID09PSB0aGlzLmdyb3VwKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc29ydGFibGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAoZWxlbWVudCA9IHBhcmVudChlbGVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCB0cmFja1RpbWVyO1xuICAgIGZ1bmN0aW9uIHRyYWNrU2Nyb2xsKHBvcykge1xuICAgICAgbGV0IGxhc3QgPSBEYXRlLm5vdygpO1xuICAgICAgdHJhY2tUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgbGV0IHsgeCwgeSB9ID0gcG9zO1xuICAgICAgICB5ICs9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICBjb25zdCBkaXN0ID0gKERhdGUubm93KCkgLSBsYXN0KSAqIDAuMztcbiAgICAgICAgbGFzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHNjcm9sbFBhcmVudHMoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCBwb3MueSkpLnJldmVyc2UoKS5zb21lKChzY3JvbGxFbCkgPT4ge1xuICAgICAgICAgIGxldCB7IHNjcm9sbFRvcDogc2Nyb2xsLCBzY3JvbGxIZWlnaHQgfSA9IHNjcm9sbEVsO1xuICAgICAgICAgIGNvbnN0IHsgdG9wLCBib3R0b20sIGhlaWdodDogaGVpZ2h0MiB9ID0gb2Zmc2V0Vmlld3BvcnQoc2Nyb2xsRWwpO1xuICAgICAgICAgIGlmICh0b3AgPCB5ICYmIHRvcCArIDM1ID4geSkge1xuICAgICAgICAgICAgc2Nyb2xsIC09IGRpc3Q7XG4gICAgICAgICAgfSBlbHNlIGlmIChib3R0b20gPiB5ICYmIGJvdHRvbSAtIDM1IDwgeSkge1xuICAgICAgICAgICAgc2Nyb2xsICs9IGRpc3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNjcm9sbCA+IDAgJiYgc2Nyb2xsIDwgc2Nyb2xsSGVpZ2h0IC0gaGVpZ2h0Mikge1xuICAgICAgICAgICAgc2Nyb2xsRWwuc2Nyb2xsVG9wID0gc2Nyb2xsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIDE1KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW50cmFja1Njcm9sbCgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodHJhY2tUaW1lcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGVuZERyYWcoY29udGFpbmVyLCBlbGVtZW50KSB7XG4gICAgICBsZXQgY2xvbmU7XG4gICAgICBpZiAoaXNUYWcoZWxlbWVudCwgXCJsaVwiLCBcInRyXCIpKSB7XG4gICAgICAgIGNsb25lID0gJChcIjxkaXY+XCIpO1xuICAgICAgICBhcHBlbmQoY2xvbmUsIGVsZW1lbnQuY2xvbmVOb2RlKHRydWUpLmNoaWxkcmVuKTtcbiAgICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgZWxlbWVudC5nZXRBdHRyaWJ1dGVOYW1lcygpKSB7XG4gICAgICAgICAgYXR0cihjbG9uZSwgYXR0cmlidXRlLCBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmUgPSBlbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIGFwcGVuZChjb250YWluZXIsIGNsb25lKTtcbiAgICAgIGNzcyhjbG9uZSwgXCJtYXJnaW5cIiwgXCIwXCIsIFwiaW1wb3J0YW50XCIpO1xuICAgICAgY3NzKGNsb25lLCB7XG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICBwYWRkaW5nOiBjc3MoZWxlbWVudCwgXCJwYWRkaW5nXCIpXG4gICAgICB9KTtcbiAgICAgIGhlaWdodChjbG9uZS5maXJzdEVsZW1lbnRDaGlsZCwgaGVpZ2h0KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpKTtcbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZmluZFRhcmdldChpdGVtcywgcG9pbnQpIHtcbiAgICAgIHJldHVybiBpdGVtc1tmaW5kSW5kZXgoaXRlbXMsIChpdGVtKSA9PiBwb2ludEluUmVjdChwb2ludCwgZGltZW5zaW9ucyQxKGl0ZW0pKSldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kSW5zZXJ0VGFyZ2V0KGxpc3QsIHRhcmdldCwgcGxhY2Vob2xkZXIsIHgsIHksIHNhbWVMaXN0KSB7XG4gICAgICBpZiAoIWNoaWxkcmVuKGxpc3QpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWN0ID0gZGltZW5zaW9ucyQxKHRhcmdldCk7XG4gICAgICBpZiAoIXNhbWVMaXN0KSB7XG4gICAgICAgIGlmICghaXNIb3Jpem9udGFsKGxpc3QsIHBsYWNlaG9sZGVyKSkge1xuICAgICAgICAgIHJldHVybiB5IDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIgPyB0YXJnZXQgOiB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZWhvbGRlclJlY3QgPSBkaW1lbnNpb25zJDEocGxhY2Vob2xkZXIpO1xuICAgICAgY29uc3Qgc2FtZVJvdyA9IGxpbmVzSW50ZXJzZWN0KFxuICAgICAgICBbcmVjdC50b3AsIHJlY3QuYm90dG9tXSxcbiAgICAgICAgW3BsYWNlaG9sZGVyUmVjdC50b3AsIHBsYWNlaG9sZGVyUmVjdC5ib3R0b21dXG4gICAgICApO1xuICAgICAgY29uc3QgW3BvaW50ZXJQb3MsIGxlbmd0aFByb3AsIHN0YXJ0UHJvcCwgZW5kUHJvcF0gPSBzYW1lUm93ID8gW3gsIFwid2lkdGhcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0gOiBbeSwgXCJoZWlnaHRcIiwgXCJ0b3BcIiwgXCJib3R0b21cIl07XG4gICAgICBjb25zdCBkaWZmID0gcGxhY2Vob2xkZXJSZWN0W2xlbmd0aFByb3BdIDwgcmVjdFtsZW5ndGhQcm9wXSA/IHJlY3RbbGVuZ3RoUHJvcF0gLSBwbGFjZWhvbGRlclJlY3RbbGVuZ3RoUHJvcF0gOiAwO1xuICAgICAgaWYgKHBsYWNlaG9sZGVyUmVjdFtzdGFydFByb3BdIDwgcmVjdFtzdGFydFByb3BdKSB7XG4gICAgICAgIGlmIChkaWZmICYmIHBvaW50ZXJQb3MgPCByZWN0W3N0YXJ0UHJvcF0gKyBkaWZmKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKGRpZmYgJiYgcG9pbnRlclBvcyA+IHJlY3RbZW5kUHJvcF0gLSBkaWZmKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzSG9yaXpvbnRhbChsaXN0LCBwbGFjZWhvbGRlcikge1xuICAgICAgY29uc3Qgc2luZ2xlID0gY2hpbGRyZW4obGlzdCkubGVuZ3RoID09PSAxO1xuICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICBhcHBlbmQobGlzdCwgcGxhY2Vob2xkZXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBjaGlsZHJlbihsaXN0KTtcbiAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbDIgPSBpdGVtcy5zb21lKChlbCwgaSkgPT4ge1xuICAgICAgICBjb25zdCByZWN0QSA9IGRpbWVuc2lvbnMkMShlbCk7XG4gICAgICAgIHJldHVybiBpdGVtcy5zbGljZShpICsgMSkuc29tZSgoZWwyKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVjdEIgPSBkaW1lbnNpb25zJDEoZWwyKTtcbiAgICAgICAgICByZXR1cm4gIWxpbmVzSW50ZXJzZWN0KFtyZWN0QS5sZWZ0LCByZWN0QS5yaWdodF0sIFtyZWN0Qi5sZWZ0LCByZWN0Qi5yaWdodF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICByZW1vdmUkMShwbGFjZWhvbGRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNIb3Jpem9udGFsMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGluZXNJbnRlcnNlY3QobGluZUEsIGxpbmVCKSB7XG4gICAgICByZXR1cm4gbGluZUFbMV0gPiBsaW5lQlswXSAmJiBsaW5lQlsxXSA+IGxpbmVBWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmbikge1xuICAgICAgbGV0IHRocm90dGxlZDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhyb3R0bGVkKSB7XG4gICAgICAgICAgdGhyb3R0bGVkID0gdHJ1ZTtcbiAgICAgICAgICBmbi5jYWxsKHRoaXMsIC4uLmFyZ3MpO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aHJvdHRsZWQgPSBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHRvb2x0aXAgPSB7XG4gICAgICBtaXhpbnM6IFtDb250YWluZXIsIFRvZ2dsYWJsZSwgUG9zaXRpb25dLFxuICAgICAgZGF0YToge1xuICAgICAgICBwb3M6IFwidG9wXCIsXG4gICAgICAgIGFuaW1hdGlvbjogW1widWstYW5pbWF0aW9uLXNjYWxlLXVwXCJdLFxuICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICBjbHM6IFwidWstYWN0aXZlXCJcbiAgICAgIH0sXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIG1ha2VGb2N1c2FibGUodGhpcy4kZWwpO1xuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCh0aGlzLnRvb2x0aXAgfHwgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgeyBkZWxheSA9IDAsIHRpdGxlIH0gPSBwYXJzZVByb3BzKHRoaXMuJG9wdGlvbnMpO1xuICAgICAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGl0bGVBdHRyID0gYXR0cih0aGlzLiRlbCwgXCJ0aXRsZVwiKTtcbiAgICAgICAgICBjb25zdCBvZmYgPSBvbih0aGlzLiRlbCwgW1wiYmx1clwiLCBwb2ludGVyTGVhdmVdLCAoZSkgPT4gIWlzVG91Y2goZSkgJiYgdGhpcy5oaWRlKCkpO1xuICAgICAgICAgIHRoaXMucmVzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICBhdHRyKHRoaXMuJGVsLCB7IHRpdGxlOiB0aXRsZUF0dHIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBudWxsIH0pO1xuICAgICAgICAgICAgb2ZmKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlSWQodGhpcyk7XG4gICAgICAgICAgYXR0cih0aGlzLiRlbCwgeyB0aXRsZTogbnVsbCwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGlkIH0pO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lcik7XG4gICAgICAgICAgdGhpcy5zaG93VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX3Nob3codGl0bGUsIGlkKSwgZGVsYXkpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBoaWRlKCkge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBpZiAobWF0Y2hlcyh0aGlzLiRlbCwgXCJpbnB1dDpmb2N1c1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zaG93VGltZXIpO1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCh0aGlzLnRvb2x0aXAgfHwgbnVsbCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLnRvb2x0aXAsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIChfYSA9IHRoaXMucmVzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICAgIHJlbW92ZSQxKHRoaXMudG9vbHRpcCk7XG4gICAgICAgICAgdGhpcy50b29sdGlwID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgX3Nob3codGl0bGUsIGlkKSB7XG4gICAgICAgICAgdGhpcy50b29sdGlwID0gYXBwZW5kKFxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIsXG4gICAgICAgICAgICBgPGRpdiBpZD1cIiR7aWR9XCIgY2xhc3M9XCJ1ay0ke3RoaXMuJG9wdGlvbnMubmFtZX1cIiByb2xlPVwidG9vbHRpcFwiPiA8ZGl2IGNsYXNzPVwidWstJHt0aGlzLiRvcHRpb25zLm5hbWV9LWlubmVyXCI+JHt0aXRsZX08L2Rpdj4gPC9kaXY+YFxuICAgICAgICAgICk7XG4gICAgICAgICAgb24odGhpcy50b29sdGlwLCBcInRvZ2dsZWRcIiwgKGUsIHRvZ2dsZWQpID0+IHtcbiAgICAgICAgICAgIGlmICghdG9nZ2xlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB0aGlzLnBvc2l0aW9uQXQodGhpcy50b29sdGlwLCB0aGlzLiRlbCk7XG4gICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IFtkaXIsIGFsaWduXSA9IGdldEFsaWdubWVudCh0aGlzLnRvb2x0aXAsIHRoaXMuJGVsLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IHRoaXMuYXhpcyA9PT0gXCJ5XCIgPyBgJHtmbGlwUG9zaXRpb24oZGlyKX0tJHthbGlnbn1gIDogYCR7YWxpZ259LSR7ZmxpcFBvc2l0aW9uKGRpcil9YDtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW1xuICAgICAgICAgICAgICBvbmNlKFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgICAgICAgIGBrZXlkb3duICR7cG9pbnRlckRvd24kMX1gLFxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICAoZTIpID0+IGUyLnR5cGUgPT09IHBvaW50ZXJEb3duJDEgJiYgIXRoaXMuJGVsLmNvbnRhaW5zKGUyLnRhcmdldCkgfHwgZTIudHlwZSA9PT0gXCJrZXlkb3duXCIgJiYgZTIua2V5Q29kZSA9PT0ga2V5TWFwLkVTQ1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBvbihbZG9jdW1lbnQsIC4uLm92ZXJmbG93UGFyZW50cyh0aGlzLiRlbCldLCBcInNjcm9sbFwiLCB1cGRhdGUsIHtcbiAgICAgICAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgb25jZSh0aGlzLnRvb2x0aXAsIFwiaGlkZVwiLCAoKSA9PiBoYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiBoYW5kbGVyKCkpLCB7XG4gICAgICAgICAgICAgIHNlbGY6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghYXdhaXQgdGhpcy50b2dnbGVFbGVtZW50KHRoaXMudG9vbHRpcCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICAvLyBDbGlja2luZyBhIGJ1dHRvbiBkb2VzIG5vdCBnaXZlIGl0IGZvY3VzIG9uIGFsbCBicm93c2VycyBhbmQgcGxhdGZvcm1zXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9idXR0b24jY2xpY2tpbmdfYW5kX2ZvY3VzXG4gICAgICAgIFtgZm9jdXMgJHtwb2ludGVyRW50ZXJ9ICR7cG9pbnRlckRvd24kMX1gXShlKSB7XG4gICAgICAgICAgaWYgKCghaXNUb3VjaChlKSB8fCBlLnR5cGUgPT09IHBvaW50ZXJEb3duJDEpICYmIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIG1ha2VGb2N1c2FibGUoZWwpIHtcbiAgICAgIGlmICghaXNGb2N1c2FibGUoZWwpKSB7XG4gICAgICAgIGF0dHIoZWwsIFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRBbGlnbm1lbnQoZWwsIHRhcmdldCwgW2RpciwgYWxpZ25dKSB7XG4gICAgICBjb25zdCBlbE9mZnNldCA9IG9mZnNldChlbCk7XG4gICAgICBjb25zdCB0YXJnZXRPZmZzZXQgPSBvZmZzZXQodGFyZ2V0KTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBbXG4gICAgICAgIFtcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgICAgICAgW1widG9wXCIsIFwiYm90dG9tXCJdXG4gICAgICBdO1xuICAgICAgZm9yIChjb25zdCBwcm9wczIgb2YgcHJvcGVydGllcykge1xuICAgICAgICBpZiAoZWxPZmZzZXRbcHJvcHMyWzBdXSA+PSB0YXJnZXRPZmZzZXRbcHJvcHMyWzFdXSkge1xuICAgICAgICAgIGRpciA9IHByb3BzMlsxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxPZmZzZXRbcHJvcHMyWzFdXSA8PSB0YXJnZXRPZmZzZXRbcHJvcHMyWzBdXSkge1xuICAgICAgICAgIGRpciA9IHByb3BzMlswXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcHJvcHMgPSBpbmNsdWRlcyhwcm9wZXJ0aWVzWzBdLCBkaXIpID8gcHJvcGVydGllc1sxXSA6IHByb3BlcnRpZXNbMF07XG4gICAgICBhbGlnbiA9IHByb3BzLmZpbmQoKHByb3ApID0+IGVsT2Zmc2V0W3Byb3BdID09PSB0YXJnZXRPZmZzZXRbcHJvcF0pIHx8IFwiY2VudGVyXCI7XG4gICAgICByZXR1cm4gW2RpciwgYWxpZ25dO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVByb3BzKG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHsgZWwsIGlkLCBkYXRhOiBkYXRhJDEgfSA9IG9wdGlvbnM7XG4gICAgICByZXR1cm4gW1wiZGVsYXlcIiwgXCJ0aXRsZVwiXS5yZWR1Y2UoKG9iaiwga2V5KSA9PiAoeyBba2V5XTogZGF0YShlbCwga2V5KSwgLi4ub2JqIH0pLCB7XG4gICAgICAgIC4uLnBhcnNlT3B0aW9ucyhkYXRhKGVsLCBpZCksIFtcInRpdGxlXCJdKSxcbiAgICAgICAgLi4uZGF0YSQxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgdXBsb2FkID0ge1xuICAgICAgbWl4aW5zOiBbSTE4bl0sXG4gICAgICBpMThuOiB7XG4gICAgICAgIGludmFsaWRNaW1lOiBcIkludmFsaWQgRmlsZSBUeXBlOiAlc1wiLFxuICAgICAgICBpbnZhbGlkTmFtZTogXCJJbnZhbGlkIEZpbGUgTmFtZTogJXNcIixcbiAgICAgICAgaW52YWxpZFNpemU6IFwiSW52YWxpZCBGaWxlIFNpemU6ICVzIEtpbG9ieXRlcyBNYXhcIlxuICAgICAgfSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGFsbG93OiBTdHJpbmcsXG4gICAgICAgIGNsc0RyYWdvdmVyOiBTdHJpbmcsXG4gICAgICAgIGNvbmN1cnJlbnQ6IE51bWJlcixcbiAgICAgICAgbWF4U2l6ZTogTnVtYmVyLFxuICAgICAgICBtZXRob2Q6IFN0cmluZyxcbiAgICAgICAgbWltZTogU3RyaW5nLFxuICAgICAgICBtdWx0aXBsZTogQm9vbGVhbixcbiAgICAgICAgbmFtZTogU3RyaW5nLFxuICAgICAgICBwYXJhbXM6IE9iamVjdCxcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICB1cmw6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYWxsb3c6IGZhbHNlLFxuICAgICAgICBjbHNEcmFnb3ZlcjogXCJ1ay1kcmFnb3ZlclwiLFxuICAgICAgICBjb25jdXJyZW50OiAxLFxuICAgICAgICBtYXhTaXplOiAwLFxuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBtaW1lOiBmYWxzZSxcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICBuYW1lOiBcImZpbGVzW11cIixcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgdHlwZTogXCJcIixcbiAgICAgICAgdXJsOiBcIlwiLFxuICAgICAgICBhYm9ydDogbm9vcCxcbiAgICAgICAgYmVmb3JlQWxsOiBub29wLFxuICAgICAgICBiZWZvcmVTZW5kOiBub29wLFxuICAgICAgICBjb21wbGV0ZTogbm9vcCxcbiAgICAgICAgY29tcGxldGVBbGw6IG5vb3AsXG4gICAgICAgIGVycm9yOiBub29wLFxuICAgICAgICBmYWlsOiBub29wLFxuICAgICAgICBsb2FkOiBub29wLFxuICAgICAgICBsb2FkRW5kOiBub29wLFxuICAgICAgICBsb2FkU3RhcnQ6IG5vb3AsXG4gICAgICAgIHByb2dyZXNzOiBub29wXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGNoYW5nZShlKSB7XG4gICAgICAgICAgaWYgKCFtYXRjaGVzKGUudGFyZ2V0LCAnaW5wdXRbdHlwZT1cImZpbGVcIl0nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0LmZpbGVzKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZChlLnRhcmdldC5maWxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGUudGFyZ2V0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgZHJvcChlKSB7XG4gICAgICAgICAgc3RvcChlKTtcbiAgICAgICAgICBjb25zdCB0cmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgIGlmICghKHRyYW5zZmVyID09IG51bGwgPyB2b2lkIDAgOiB0cmFuc2Zlci5maWxlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRHJhZ292ZXIpO1xuICAgICAgICAgIHRoaXMudXBsb2FkKHRyYW5zZmVyLmZpbGVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ2VudGVyKGUpIHtcbiAgICAgICAgICBzdG9wKGUpO1xuICAgICAgICB9LFxuICAgICAgICBkcmFnb3ZlcihlKSB7XG4gICAgICAgICAgc3RvcChlKTtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcmFnb3Zlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdsZWF2ZShlKSB7XG4gICAgICAgICAgc3RvcChlKTtcbiAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNEcmFnb3Zlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIHVwbG9hZChmaWxlcykge1xuICAgICAgICAgIGZpbGVzID0gdG9BcnJheShmaWxlcyk7XG4gICAgICAgICAgaWYgKCFmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgXCJ1cGxvYWRcIiwgW2ZpbGVzXSk7XG4gICAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXhTaXplICYmIHRoaXMubWF4U2l6ZSAqIDFlMyA8IGZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgICB0aGlzLmZhaWwodGhpcy50KFwiaW52YWxpZFNpemVcIiwgdGhpcy5tYXhTaXplKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93ICYmICFtYXRjaCQxKHRoaXMuYWxsb3csIGZpbGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5mYWlsKHRoaXMudChcImludmFsaWROYW1lXCIsIHRoaXMuYWxsb3cpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWltZSAmJiAhbWF0Y2gkMSh0aGlzLm1pbWUsIGZpbGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5mYWlsKHRoaXMudChcImludmFsaWRNaW1lXCIsIHRoaXMubWltZSkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkge1xuICAgICAgICAgICAgZmlsZXMgPSBmaWxlcy5zbGljZSgwLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5iZWZvcmVBbGwodGhpcywgZmlsZXMpO1xuICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGNodW5rKGZpbGVzLCB0aGlzLmNvbmN1cnJlbnQpO1xuICAgICAgICAgIGNvbnN0IHVwbG9hZCA9IGFzeW5jIChmaWxlczIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIGZpbGVzMi5mb3JFYWNoKChmaWxlKSA9PiBkYXRhLmFwcGVuZCh0aGlzLm5hbWUsIGZpbGUpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMucGFyYW1zKSB7XG4gICAgICAgICAgICAgIGRhdGEuYXBwZW5kKGtleSwgdGhpcy5wYXJhbXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCB4aHIgPSBhd2FpdCBhamF4KHRoaXMudXJsLCB7XG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGJlZm9yZVNlbmQ6IChlbnYpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeGhyOiB4aHIyIH0gPSBlbnY7XG4gICAgICAgICAgICAgICAgICBvbih4aHIyLnVwbG9hZCwgXCJwcm9ncmVzc1wiLCB0aGlzLnByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBbXCJsb2FkU3RhcnRcIiwgXCJsb2FkXCIsIFwibG9hZEVuZFwiLCBcImFib3J0XCJdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uKHhocjIsIHR5cGUudG9Mb3dlckNhc2UoKSwgdGhpc1t0eXBlXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVTZW5kKGVudik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSh4aHIpO1xuICAgICAgICAgICAgICBpZiAoY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwbG9hZChjaHVua3Muc2hpZnQoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFsbCh4aHIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhd2FpdCB1cGxvYWQoY2h1bmtzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBtYXRjaCQxKHBhdHRlcm4sIHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLm1hdGNoKFxuICAgICAgICBuZXcgUmVnRXhwKFxuICAgICAgICAgIGBeJHtwYXR0ZXJuLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpLnJlcGxhY2UoL1xcKlxcKi9nLCBcIihcXFxcL1teXFxcXC9dKykqXCIpLnJlcGxhY2UoL1xcKi9nLCBcIlteXFxcXC9dK1wiKS5yZXBsYWNlKC8oKD8hXFxcXCkpXFw/L2csIFwiJDEuXCIpfSRgLFxuICAgICAgICAgIFwiaVwiXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNodW5rKGZpbGVzLCBzaXplKSB7XG4gICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpICs9IHNpemUpIHtcbiAgICAgICAgY2h1bmtzLnB1c2goZmlsZXMuc2xpY2UoaSwgaSArIHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaHVua3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0b3AoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gYWpheCh1cmwsIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVudiA9IHtcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgeGhyOiBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcbiAgICAgICAgYmVmb3JlU2VuZDogbm9vcCxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBcIlwiLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9O1xuICAgICAgYXdhaXQgZW52LmJlZm9yZVNlbmQoZW52KTtcbiAgICAgIHJldHVybiBzZW5kKHVybCwgZW52KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2VuZCh1cmwsIGVudikge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgeyB4aHIgfSA9IGVudjtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGVudikge1xuICAgICAgICAgIGlmIChwcm9wIGluIHhocikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgeGhyW3Byb3BdID0gZW52W3Byb3BdO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB4aHIub3BlbihlbnYubWV0aG9kLnRvVXBwZXJDYXNlKCksIHVybCk7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIGluIGVudi5oZWFkZXJzKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCBlbnYuaGVhZGVyc1toZWFkZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBvbih4aHIsIFwibG9hZFwiLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT09IDAgfHwgeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCB8fCB4aHIuc3RhdHVzID09PSAzMDQpIHtcbiAgICAgICAgICAgIHJlc29sdmUoeGhyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBhc3NpZ24oRXJyb3IoeGhyLnN0YXR1c1RleHQpLCB7XG4gICAgICAgICAgICAgICAgeGhyLFxuICAgICAgICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1c1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvbih4aHIsIFwiZXJyb3JcIiwgKCkgPT4gcmVqZWN0KGFzc2lnbihFcnJvcihcIk5ldHdvcmsgRXJyb3JcIiksIHsgeGhyIH0pKSk7XG4gICAgICAgIG9uKHhociwgXCJ0aW1lb3V0XCIsICgpID0+IHJlamVjdChhc3NpZ24oRXJyb3IoXCJOZXR3b3JrIFRpbWVvdXRcIiksIHsgeGhyIH0pKSk7XG4gICAgICAgIHhoci5zZW5kKGVudi5kYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRzJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgQ291bnRkb3duOiBjb3VudGRvd24sXG4gICAgICAgIEZpbHRlcjogZmlsdGVyLFxuICAgICAgICBMaWdodGJveDogbGlnaHRib3gsXG4gICAgICAgIExpZ2h0Ym94UGFuZWw6IExpZ2h0Ym94UGFuZWwsXG4gICAgICAgIE5vdGlmaWNhdGlvbjogbm90aWZpY2F0aW9uLFxuICAgICAgICBQYXJhbGxheDogcGFyYWxsYXgsXG4gICAgICAgIFNsaWRlcjogc2xpZGVyLFxuICAgICAgICBTbGlkZXJQYXJhbGxheDogc2xpZGVyUGFyYWxsYXgsXG4gICAgICAgIFNsaWRlc2hvdzogc2xpZGVzaG93LFxuICAgICAgICBTbGlkZXNob3dQYXJhbGxheDogc2xpZGVyUGFyYWxsYXgsXG4gICAgICAgIFNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgVG9vbHRpcDogdG9vbHRpcCxcbiAgICAgICAgVXBsb2FkOiB1cGxvYWRcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGJvb3QoQXBwKSB7XG4gICAgICBpZiAoaW5Ccm93c2VyICYmIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAgIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGluaXQoQXBwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMsIG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICBpbml0KEFwcCk7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5vYnNlcnZlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChBcHApIHtcbiAgICAgIHRyaWdnZXIoZG9jdW1lbnQsIFwidWlraXQ6aW5pdFwiLCBBcHApO1xuICAgICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgYXBwbHkoZG9jdW1lbnQuYm9keSwgY29ubmVjdCk7XG4gICAgICB9XG4gICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbikub2JzZXJ2ZShkb2N1bWVudCwge1xuICAgICAgICBzdWJ0cmVlOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWVcbiAgICAgIH0pO1xuICAgICAgQXBwLl9pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU11dGF0aW9uKHJlY29yZHMpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGZvciAoY29uc3QgeyBhZGRlZE5vZGVzLCByZW1vdmVkTm9kZXMsIHRhcmdldCwgYXR0cmlidXRlTmFtZSB9IG9mIHJlY29yZHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgICAgICBhcHBseShub2RlLCBjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgICAgYXBwbHkobm9kZSwgZGlzY29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGF0dHJpYnV0ZU5hbWUgJiYgZ2V0Q29tcG9uZW50TmFtZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICBpZiAoaGFzQXR0cih0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICBjcmVhdGVDb21wb25lbnQobmFtZSwgdGFyZ2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKF9hID0gZ2V0Q29tcG9uZW50KHRhcmdldCwgbmFtZSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS4kZGVzdHJveSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb25uZWN0KG5vZGUpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMyID0gZ2V0Q29tcG9uZW50cyhub2RlKTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBjb21wb25lbnRzMikge1xuICAgICAgICBjYWxsQ29ubmVjdGVkKGNvbXBvbmVudHMyW25hbWVdKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBvZiBub2RlLmdldEF0dHJpYnV0ZU5hbWVzKCkpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIG5hbWUgJiYgY3JlYXRlQ29tcG9uZW50KG5hbWUsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNjb25uZWN0KG5vZGUpIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMyID0gZ2V0Q29tcG9uZW50cyhub2RlKTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBjb21wb25lbnRzMikge1xuICAgICAgICBjYWxsRGlzY29ubmVjdGVkKGNvbXBvbmVudHMyW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShhdHRyaWJ1dGUpIHtcbiAgICAgIGlmIChzdGFydHNXaXRoKGF0dHJpYnV0ZSwgXCJkYXRhLVwiKSkge1xuICAgICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuc2xpY2UoNSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjbXAgPSBjb21wb25lbnRzJDJbYXR0cmlidXRlXTtcbiAgICAgIHJldHVybiBjbXAgJiYgKGNtcC5vcHRpb25zIHx8IGNtcCkubmFtZTtcbiAgICB9XG5cbiAgICBnbG9iYWxBcGkoQXBwKTtcbiAgICBpbnN0YW5jZUFwaShBcHApO1xuXG4gICAgdmFyIEFjY29yZGlvbiA9IHtcbiAgICAgIG1peGluczogW0NsYXNzLCBUb2dnbGFibGVdLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYW5pbWF0aW9uOiBCb29sZWFuLFxuICAgICAgICB0YXJnZXRzOiBTdHJpbmcsXG4gICAgICAgIGFjdGl2ZTogbnVsbCxcbiAgICAgICAgY29sbGFwc2libGU6IEJvb2xlYW4sXG4gICAgICAgIG11bHRpcGxlOiBCb29sZWFuLFxuICAgICAgICB0b2dnbGU6IFN0cmluZyxcbiAgICAgICAgY29udGVudDogU3RyaW5nLFxuICAgICAgICBvZmZzZXQ6IE51bWJlclxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0czogXCI+ICpcIixcbiAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBjb2xsYXBzaWJsZTogdHJ1ZSxcbiAgICAgICAgbXVsdGlwbGU6IGZhbHNlLFxuICAgICAgICBjbHNPcGVuOiBcInVrLW9wZW5cIixcbiAgICAgICAgdG9nZ2xlOiBcIj4gLnVrLWFjY29yZGlvbi10aXRsZVwiLFxuICAgICAgICBjb250ZW50OiBcIj4gLnVrLWFjY29yZGlvbi1jb250ZW50XCIsXG4gICAgICAgIG9mZnNldDogMFxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGl0ZW1zOiAoeyB0YXJnZXRzIH0sICRlbCkgPT4gJCQodGFyZ2V0cywgJGVsKSxcbiAgICAgICAgdG9nZ2xlcyh7IHRvZ2dsZSB9KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMubWFwKChpdGVtKSA9PiAkKHRvZ2dsZSwgaXRlbSkpO1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50cyh7IGNvbnRlbnQgfSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLml0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBpdGVtLl93cmFwcGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmlyc3RFbGVtZW50Q2hpbGQpIHx8ICQoY29udGVudCwgaXRlbSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3YXRjaDoge1xuICAgICAgICBpdGVtcyhpdGVtcywgcHJldikge1xuICAgICAgICAgIGlmIChwcmV2IHx8IGhhc0NsYXNzKGl0ZW1zLCB0aGlzLmNsc09wZW4pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuYWN0aXZlICE9PSBmYWxzZSAmJiBpdGVtc1tOdW1iZXIodGhpcy5hY3RpdmUpXSB8fCAhdGhpcy5jb2xsYXBzaWJsZSAmJiBpdGVtc1swXTtcbiAgICAgICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZShhY3RpdmUsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZXMoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9LFxuICAgICAgICBjb250ZW50cyhpdGVtcykge1xuICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzT3BlbiA9IGhhc0NsYXNzKFxuICAgICAgICAgICAgICB0aGlzLml0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uY29udGFpbnMoZWwpKSxcbiAgICAgICAgICAgICAgdGhpcy5jbHNPcGVuXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaGlkZShlbCwgIWlzT3Blbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IGxhenlsb2FkKCksXG4gICAgICBldmVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiY2xpY2sga2V5ZG93blwiLFxuICAgICAgICAgIGRlbGVnYXRlOiAoeyB0YXJnZXRzLCAkcHJvcHMgfSkgPT4gYCR7dGFyZ2V0c30gJHskcHJvcHMudG9nZ2xlfWAsXG4gICAgICAgICAgYXN5bmMgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSBcImtleWRvd25cIiAmJiBlLmtleUNvZGUgIT09IGtleU1hcC5TUEFDRSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLl9vZmYpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fb2ZmID0ga2VlcFNjcm9sbFBvc2l0aW9uKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlKGluZGV4KHRoaXMudG9nZ2xlcywgZS5jdXJyZW50KSk7XG4gICAgICAgICAgICB0aGlzLl9vZmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInNob3duIGhpZGRlblwiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgZGVsZWdhdGU6ICh7IHRhcmdldHMgfSkgPT4gdGFyZ2V0cyxcbiAgICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlSXRlbXMgPSBmaWx0ZXIkMSh0aGlzLml0ZW1zLCBgLiR7dGhpcy5jbHNPcGVufWApO1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4MiBpbiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgY29uc3QgdG9nZ2xlID0gdGhpcy50b2dnbGVzW2luZGV4Ml07XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudHNbaW5kZXgyXTtcbiAgICAgICAgICBpZiAoIXRvZ2dsZSB8fCAhY29udGVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvZ2dsZS5pZCA9IGdlbmVyYXRlSWQodGhpcywgdG9nZ2xlKTtcbiAgICAgICAgICBjb250ZW50LmlkID0gZ2VuZXJhdGVJZCh0aGlzLCBjb250ZW50KTtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSBpbmNsdWRlcyhhY3RpdmVJdGVtcywgdGhpcy5pdGVtc1tpbmRleDJdKTtcbiAgICAgICAgICBhdHRyKHRvZ2dsZSwge1xuICAgICAgICAgICAgcm9sZTogaXNUYWcodG9nZ2xlLCBcImFcIikgPyBcImJ1dHRvblwiIDogbnVsbCxcbiAgICAgICAgICAgIFwiYXJpYS1jb250cm9sc1wiOiBjb250ZW50LmlkLFxuICAgICAgICAgICAgXCJhcmlhLWV4cGFuZGVkXCI6IGFjdGl2ZSxcbiAgICAgICAgICAgIFwiYXJpYS1kaXNhYmxlZFwiOiAhdGhpcy5jb2xsYXBzaWJsZSAmJiBhY3RpdmVJdGVtcy5sZW5ndGggPCAyICYmIGFjdGl2ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0dHIoY29udGVudCwgeyByb2xlOiBcInJlZ2lvblwiLCBcImFyaWEtbGFiZWxsZWRieVwiOiB0b2dnbGUuaWQgfSk7XG4gICAgICAgICAgaWYgKGlzVGFnKGNvbnRlbnQsIFwidWxcIikpIHtcbiAgICAgICAgICAgIGF0dHIoY2hpbGRyZW4oY29udGVudCksIFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHRvZ2dsZShpdGVtLCBhbmltYXRlKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXMuaXRlbXNbZ2V0SW5kZXgoaXRlbSwgdGhpcy5pdGVtcyldO1xuICAgICAgICAgIGxldCBpdGVtcyA9IFtpdGVtXTtcbiAgICAgICAgICBjb25zdCBhY3RpdmVJdGVtcyA9IGZpbHRlciQxKHRoaXMuaXRlbXMsIGAuJHt0aGlzLmNsc09wZW59YCk7XG4gICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlICYmICFpbmNsdWRlcyhhY3RpdmVJdGVtcywgaXRlbXNbMF0pKSB7XG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChhY3RpdmVJdGVtcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jb2xsYXBzaWJsZSAmJiBhY3RpdmVJdGVtcy5sZW5ndGggPCAyICYmIGluY2x1ZGVzKGFjdGl2ZUl0ZW1zLCBpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBpdGVtcy5tYXAoXG4gICAgICAgICAgICAgIChlbCkgPT4gdGhpcy50b2dnbGVFbGVtZW50KGVsLCAhaW5jbHVkZXMoYWN0aXZlSXRlbXMsIGVsKSwgKGVsMiwgc2hvdykgPT4ge1xuICAgICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGVsMiwgdGhpcy5jbHNPcGVuLCBzaG93KTtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0ZSA9PT0gZmFsc2UgfHwgIXRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICBoaWRlKCQodGhpcy5jb250ZW50LCBlbDIpLCAhc2hvdyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2l0aW9uKGVsMiwgc2hvdywgdGhpcyk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGlkZShlbCwgaGlkZTIpIHtcbiAgICAgIGVsICYmIChlbC5oaWRkZW4gPSBoaWRlMik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHRyYW5zaXRpb24oZWwsIHNob3csIHsgY29udGVudCwgZHVyYXRpb24sIHZlbG9jaXR5LCB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uMiB9KSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb250ZW50ID0gKChfYSA9IGVsLl93cmFwcGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZmlyc3RFbGVtZW50Q2hpbGQpIHx8ICQoY29udGVudCwgZWwpO1xuICAgICAgaWYgKCFlbC5fd3JhcHBlcikge1xuICAgICAgICBlbC5fd3JhcHBlciA9IHdyYXBBbGwoY29udGVudCwgXCI8ZGl2PlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBlbC5fd3JhcHBlcjtcbiAgICAgIGNzcyh3cmFwcGVyLCBcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpO1xuICAgICAgY29uc3QgY3VycmVudEhlaWdodCA9IHRvRmxvYXQoY3NzKHdyYXBwZXIsIFwiaGVpZ2h0XCIpKTtcbiAgICAgIGF3YWl0IFRyYW5zaXRpb24uY2FuY2VsKHdyYXBwZXIpO1xuICAgICAgaGlkZShjb250ZW50LCBmYWxzZSk7XG4gICAgICBjb25zdCBlbmRIZWlnaHQgPSBzdW1CeShbXCJtYXJnaW5Ub3BcIiwgXCJtYXJnaW5Cb3R0b21cIl0sIChwcm9wKSA9PiBjc3MoY29udGVudCwgcHJvcCkpICsgZGltZW5zaW9ucyQxKGNvbnRlbnQpLmhlaWdodDtcbiAgICAgIGNvbnN0IHBlcmNlbnQgPSBjdXJyZW50SGVpZ2h0IC8gZW5kSGVpZ2h0O1xuICAgICAgZHVyYXRpb24gPSAodmVsb2NpdHkgKiBlbmRIZWlnaHQgKyBkdXJhdGlvbikgKiAoc2hvdyA/IDEgLSBwZXJjZW50IDogcGVyY2VudCk7XG4gICAgICBjc3Mod3JhcHBlciwgXCJoZWlnaHRcIiwgY3VycmVudEhlaWdodCk7XG4gICAgICBhd2FpdCBUcmFuc2l0aW9uLnN0YXJ0KHdyYXBwZXIsIHsgaGVpZ2h0OiBzaG93ID8gZW5kSGVpZ2h0IDogMCB9LCBkdXJhdGlvbiwgdHJhbnNpdGlvbjIpO1xuICAgICAgdW53cmFwKGNvbnRlbnQpO1xuICAgICAgZGVsZXRlIGVsLl93cmFwcGVyO1xuICAgICAgaWYgKCFzaG93KSB7XG4gICAgICAgIGhpZGUoY29udGVudCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtlZXBTY3JvbGxQb3NpdGlvbihlbCkge1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHNjcm9sbFBhcmVudChlbCwgdHJ1ZSk7XG4gICAgICBsZXQgZnJhbWU7XG4gICAgICAoZnVuY3Rpb24gc2Nyb2xsKCkge1xuICAgICAgICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyB0b3AgfSA9IGRpbWVuc2lvbnMkMShlbCk7XG4gICAgICAgICAgaWYgKHRvcCA8IDApIHtcbiAgICAgICAgICAgIHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wICs9IHRvcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2Nyb2xsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoKTtcbiAgICAgIHJldHVybiAoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpKTtcbiAgICB9XG5cbiAgICB2YXIgYWxlcnQgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgVG9nZ2xhYmxlXSxcbiAgICAgIGFyZ3M6IFwiYW5pbWF0aW9uXCIsXG4gICAgICBwcm9wczoge1xuICAgICAgICBhbmltYXRpb246IEJvb2xlYW4sXG4gICAgICAgIGNsb3NlOiBTdHJpbmdcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICAgICAgc2VsQ2xvc2U6IFwiLnVrLWFsZXJ0LWNsb3NlXCIsXG4gICAgICAgIGR1cmF0aW9uOiAxNTBcbiAgICAgIH0sXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgbmFtZTogXCJjbGlja1wiLFxuICAgICAgICBkZWxlZ2F0ZTogKHsgc2VsQ2xvc2UgfSkgPT4gc2VsQ2xvc2UsXG4gICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudCh0aGlzLiRlbCwgZmFsc2UsIGFuaW1hdGUpO1xuICAgICAgICAgIHRoaXMuJGRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGFuaW1hdGUoZWwsIHNob3csIHsgZHVyYXRpb24sIHRyYW5zaXRpb24sIHZlbG9jaXR5IH0pIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRvRmxvYXQoY3NzKGVsLCBcImhlaWdodFwiKSk7XG4gICAgICBjc3MoZWwsIFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgICByZXR1cm4gVHJhbnNpdGlvbi5zdGFydChcbiAgICAgICAgZWwsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgIG1hcmdpbkJvdHRvbTogMCxcbiAgICAgICAgICBwYWRkaW5nVG9wOiAwLFxuICAgICAgICAgIHBhZGRpbmdCb3R0b206IDAsXG4gICAgICAgICAgYm9yZGVyVG9wOiAwLFxuICAgICAgICAgIGJvcmRlckJvdHRvbTogMCxcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH0sXG4gICAgICAgIHZlbG9jaXR5ICogaGVpZ2h0ICsgZHVyYXRpb24sXG4gICAgICAgIHRyYW5zaXRpb25cbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIFZpZGVvID0ge1xuICAgICAgYXJnczogXCJhdXRvcGxheVwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYXV0b211dGU6IEJvb2xlYW4sXG4gICAgICAgIGF1dG9wbGF5OiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBhdXRvbXV0ZTogZmFsc2UsXG4gICAgICAgIGF1dG9wbGF5OiB0cnVlXG4gICAgICB9LFxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b3BsYXkgPT09IFwiaW52aWV3XCIgJiYgIWhhc0F0dHIodGhpcy4kZWwsIFwicHJlbG9hZFwiKSkge1xuICAgICAgICAgIHRoaXMuJGVsLnByZWxvYWQgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUYWcodGhpcy4kZWwsIFwiaWZyYW1lXCIpICYmICFoYXNBdHRyKHRoaXMuJGVsLCBcImFsbG93XCIpKSB7XG4gICAgICAgICAgdGhpcy4kZWwuYWxsb3cgPSBcImF1dG9wbGF5XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b3BsYXkgPT09IFwiaG92ZXJcIikge1xuICAgICAgICAgIGlmIChpc1RhZyh0aGlzLiRlbCwgXCJ2aWRlb1wiKSkge1xuICAgICAgICAgICAgdGhpcy4kZWwudGFiaW5kZXggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b211dGUpIHtcbiAgICAgICAgICBtdXRlKHRoaXMuJGVsKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogYCR7cG9pbnRlckVudGVyfSBmb2N1c2luYCxcbiAgICAgICAgICBmaWx0ZXI6ICh7IGF1dG9wbGF5IH0pID0+IGluY2x1ZGVzKGF1dG9wbGF5LCBcImhvdmVyXCIpLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKCFpc1RvdWNoKGUpIHx8ICFpc1BsYXlpbmcodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICAgIHBsYXkodGhpcy4kZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGF1c2UodGhpcy4kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IGAke3BvaW50ZXJMZWF2ZX0gZm9jdXNvdXRgLFxuICAgICAgICAgIGZpbHRlcjogKHsgYXV0b3BsYXkgfSkgPT4gaW5jbHVkZXMoYXV0b3BsYXksIFwiaG92ZXJcIiksXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoIWlzVG91Y2goZSkpIHtcbiAgICAgICAgICAgICAgcGF1c2UodGhpcy4kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG9ic2VydmU6IFtcbiAgICAgICAgaW50ZXJzZWN0aW9uKHtcbiAgICAgICAgICBmaWx0ZXI6ICh7IGF1dG9wbGF5IH0pID0+IGF1dG9wbGF5ICE9PSBcImhvdmVyXCIsXG4gICAgICAgICAgaGFuZGxlcihbeyBpc0ludGVyc2VjdGluZyB9XSkge1xuICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCkge1xuICAgICAgICAgICAgICBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvcGxheSkge1xuICAgICAgICAgICAgICAgICAgcGxheSh0aGlzLiRlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdXNlKHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXJnczogeyBpbnRlcnNlY3Rpbmc6IGZhbHNlIH0sXG4gICAgICAgICAgb3B0aW9uczogKHsgJGVsLCBhdXRvcGxheSB9KSA9PiAoe1xuICAgICAgICAgICAgcm9vdDogYXV0b3BsYXkgPT09IFwiaW52aWV3XCIgPyBudWxsIDogcGFyZW50KCRlbCkuY2xvc2VzdChcIjpub3QoYSlcIilcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgXVxuICAgIH07XG4gICAgZnVuY3Rpb24gaXNQbGF5aW5nKHZpZGVvRWwpIHtcbiAgICAgIHJldHVybiAhdmlkZW9FbC5wYXVzZWQgJiYgIXZpZGVvRWwuZW5kZWQ7XG4gICAgfVxuXG4gICAgdmFyIGNvdmVyID0ge1xuICAgICAgbWl4aW5zOiBbVmlkZW9dLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgd2lkdGg6IE51bWJlcixcbiAgICAgICAgaGVpZ2h0OiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGF1dG9tdXRlOiB0cnVlXG4gICAgICB9LFxuICAgICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy51c2VPYmplY3RGaXQgPSBpc1RhZyh0aGlzLiRlbCwgXCJpbWdcIiwgXCJ2aWRlb1wiKTtcbiAgICAgIH0sXG4gICAgICBvYnNlcnZlOiByZXNpemUoe1xuICAgICAgICB0YXJnZXQ6ICh7ICRlbCB9KSA9PiBnZXRQb3NpdGlvbmVkUGFyZW50KCRlbCkgfHwgcGFyZW50KCRlbCksXG4gICAgICAgIGZpbHRlcjogKHsgdXNlT2JqZWN0Rml0IH0pID0+ICF1c2VPYmplY3RGaXRcbiAgICAgIH0pLFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMudXNlT2JqZWN0Rml0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgcmF0aW8sIGNvdmVyIH0gPSBEaW1lbnNpb25zO1xuICAgICAgICAgIGNvbnN0IHsgJGVsLCB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgICAgICAgIGxldCBkaW0gPSB7IHdpZHRoLCBoZWlnaHQgfTtcbiAgICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGludHJpbnNpYyA9IHtcbiAgICAgICAgICAgICAgd2lkdGg6ICRlbC5uYXR1cmFsV2lkdGggfHwgJGVsLnZpZGVvV2lkdGggfHwgJGVsLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICBoZWlnaHQ6ICRlbC5uYXR1cmFsSGVpZ2h0IHx8ICRlbC52aWRlb0hlaWdodCB8fCAkZWwuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgIGRpbSA9IHJhdGlvKGludHJpbnNpYywgXCJ3aWR0aFwiLCB3aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlaWdodCkge1xuICAgICAgICAgICAgICBkaW0gPSByYXRpbyhpbnRyaW5zaWMsIFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkaW0gPSBpbnRyaW5zaWM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0SGVpZ2h0OiBjb3ZlckhlaWdodCwgb2Zmc2V0V2lkdGg6IGNvdmVyV2lkdGggfSA9IGdldFBvc2l0aW9uZWRQYXJlbnQoJGVsKSB8fCBwYXJlbnQoJGVsKTtcbiAgICAgICAgICBjb25zdCBjb3ZlckRpbSA9IGNvdmVyKGRpbSwgeyB3aWR0aDogY292ZXJXaWR0aCwgaGVpZ2h0OiBjb3ZlckhlaWdodCB9KTtcbiAgICAgICAgICBpZiAoIWNvdmVyRGltLndpZHRoIHx8ICFjb3ZlckRpbS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvdmVyRGltO1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZSh7IGhlaWdodCwgd2lkdGggfSkge1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgeyBoZWlnaHQsIHdpZHRoIH0pO1xuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IFtcInJlc2l6ZVwiXVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFBhcmVudChlbCkge1xuICAgICAgd2hpbGUgKGVsID0gcGFyZW50KGVsKSkge1xuICAgICAgICBpZiAoY3NzKGVsLCBcInBvc2l0aW9uXCIpICE9PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGFjdGl2ZTtcbiAgICB2YXIgZHJvcCA9IHtcbiAgICAgIG1peGluczogW0NvbnRhaW5lciwgUG9zaXRpb24sIFRvZ2dsYWJsZV0sXG4gICAgICBhcmdzOiBcInBvc1wiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbW9kZTogXCJsaXN0XCIsXG4gICAgICAgIHRvZ2dsZTogQm9vbGVhbixcbiAgICAgICAgYm91bmRhcnk6IEJvb2xlYW4sXG4gICAgICAgIGJvdW5kYXJ5WDogQm9vbGVhbixcbiAgICAgICAgYm91bmRhcnlZOiBCb29sZWFuLFxuICAgICAgICB0YXJnZXQ6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldFg6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldFk6IEJvb2xlYW4sXG4gICAgICAgIHN0cmV0Y2g6IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5U2hvdzogTnVtYmVyLFxuICAgICAgICBkZWxheUhpZGU6IE51bWJlcixcbiAgICAgICAgYXV0b1VwZGF0ZTogQm9vbGVhbixcbiAgICAgICAgY2xzRHJvcDogU3RyaW5nLFxuICAgICAgICBhbmltYXRlT3V0OiBCb29sZWFuLFxuICAgICAgICBiZ1Njcm9sbDogQm9vbGVhbixcbiAgICAgICAgY2xvc2VPblNjcm9sbDogQm9vbGVhblxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbW9kZTogW1wiY2xpY2tcIiwgXCJob3ZlclwiXSxcbiAgICAgICAgdG9nZ2xlOiBcIi0gKlwiLFxuICAgICAgICBib3VuZGFyeTogZmFsc2UsXG4gICAgICAgIGJvdW5kYXJ5WDogZmFsc2UsXG4gICAgICAgIGJvdW5kYXJ5WTogZmFsc2UsXG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIHRhcmdldFg6IGZhbHNlLFxuICAgICAgICB0YXJnZXRZOiBmYWxzZSxcbiAgICAgICAgc3RyZXRjaDogZmFsc2UsXG4gICAgICAgIGRlbGF5U2hvdzogMCxcbiAgICAgICAgZGVsYXlIaWRlOiA4MDAsXG4gICAgICAgIGF1dG9VcGRhdGU6IHRydWUsXG4gICAgICAgIGNsc0Ryb3A6IGZhbHNlLFxuICAgICAgICBhbmltYXRlT3V0OiBmYWxzZSxcbiAgICAgICAgYmdTY3JvbGw6IHRydWUsXG4gICAgICAgIGFuaW1hdGlvbjogW1widWstYW5pbWF0aW9uLWZhZGVcIl0sXG4gICAgICAgIGNsczogXCJ1ay1vcGVuXCIsXG4gICAgICAgIGNvbnRhaW5lcjogZmFsc2UsXG4gICAgICAgIGNsb3NlT25TY3JvbGw6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgYm91bmRhcnkoeyBib3VuZGFyeSwgYm91bmRhcnlYLCBib3VuZGFyeVkgfSwgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHF1ZXJ5KGJvdW5kYXJ5WCB8fCBib3VuZGFyeSwgJGVsKSB8fCB3aW5kb3csXG4gICAgICAgICAgICBxdWVyeShib3VuZGFyeVkgfHwgYm91bmRhcnksICRlbCkgfHwgd2luZG93XG4gICAgICAgICAgXTtcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0KHsgdGFyZ2V0LCB0YXJnZXRYLCB0YXJnZXRZIH0sICRlbCkge1xuICAgICAgICAgIHRhcmdldFggfHwgKHRhcmdldFggPSB0YXJnZXQgfHwgdGhpcy50YXJnZXRFbCk7XG4gICAgICAgICAgdGFyZ2V0WSB8fCAodGFyZ2V0WSA9IHRhcmdldCB8fCB0aGlzLnRhcmdldEVsKTtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGFyZ2V0WCA9PT0gdHJ1ZSA/IHdpbmRvdyA6IHF1ZXJ5KHRhcmdldFgsICRlbCksXG4gICAgICAgICAgICB0YXJnZXRZID09PSB0cnVlID8gd2luZG93IDogcXVlcnkodGFyZ2V0WSwgJGVsKVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVkKCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSBuZXcgTW91c2VUcmFja2VyKCk7XG4gICAgICB9LFxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5jbHNEcm9wID0gdGhpcy4kcHJvcHMuY2xzRHJvcCB8fCB0aGlzLiRvcHRpb25zLmlkO1xuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIFwidWstZHJvcFwiLCB0aGlzLmNsc0Ryb3ApO1xuICAgICAgICBpZiAodGhpcy50b2dnbGUgJiYgIXRoaXMudGFyZ2V0RWwpIHtcbiAgICAgICAgICB0aGlzLnRhcmdldEVsID0gY3JlYXRlVG9nZ2xlQ29tcG9uZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0eWxlID0gcGljayh0aGlzLiRlbC5zdHlsZSwgW1wid2lkdGhcIiwgXCJoZWlnaHRcIl0pO1xuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgICAgIHRoaXMuaGlkZShmYWxzZSk7XG4gICAgICAgICAgYWN0aXZlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjc3ModGhpcy4kZWwsIHRoaXMuX3N0eWxlKTtcbiAgICAgIH0sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiY2xpY2tcIixcbiAgICAgICAgICBkZWxlZ2F0ZTogKCkgPT4gXCIudWstZHJvcC1jbG9zZVwiLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImNsaWNrXCIsXG4gICAgICAgICAgZGVsZWdhdGU6ICgpID0+ICdhW2hyZWYqPVwiI1wiXScsXG4gICAgICAgICAgaGFuZGxlcih7IGRlZmF1bHRQcmV2ZW50ZWQsIGN1cnJlbnQgfSkge1xuICAgICAgICAgICAgY29uc3QgeyBoYXNoIH0gPSBjdXJyZW50O1xuICAgICAgICAgICAgaWYgKCFkZWZhdWx0UHJldmVudGVkICYmIGhhc2ggJiYgaXNTYW1lU2l0ZUFuY2hvcihjdXJyZW50KSAmJiAhdGhpcy4kZWwuY29udGFpbnMoJChoYXNoKSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImJlZm9yZXNjcm9sbFwiLFxuICAgICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwidG9nZ2xlXCIsXG4gICAgICAgICAgc2VsZjogdHJ1ZSxcbiAgICAgICAgICBoYW5kbGVyKGUsIHRvZ2dsZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVkKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuc2hvdyh0b2dnbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHRvZ2dsZS4kZWwsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInRvZ2dsZXNob3dcIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXIoZSwgdG9nZ2xlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnNob3codG9nZ2xlID09IG51bGwgPyB2b2lkIDAgOiB0b2dnbGUuJGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInRvZ2dsZWhpZGVcIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVzKHRoaXMuJGVsLCBcIjpmb2N1cyw6aG92ZXJcIikpIHtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogYCR7cG9pbnRlckVudGVyfSBmb2N1c2luYCxcbiAgICAgICAgICBmaWx0ZXI6ICh7IG1vZGUgfSkgPT4gaW5jbHVkZXMobW9kZSwgXCJob3ZlclwiKSxcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGlmICghaXNUb3VjaChlKSkge1xuICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogYCR7cG9pbnRlckxlYXZlfSBmb2N1c291dGAsXG4gICAgICAgICAgZmlsdGVyOiAoeyBtb2RlIH0pID0+IGluY2x1ZGVzKG1vZGUsIFwiaG92ZXJcIiksXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAoIWlzVG91Y2goZSkgJiYgZS5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwidG9nZ2xlZFwiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcihlLCB0b2dnbGVkKSB7XG4gICAgICAgICAgICBpZiAodG9nZ2xlZCkge1xuICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBhY3RpdmUgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy50cmFja2VyLmluaXQoKTtcbiAgICAgICAgICAgIGF0dHIodGhpcy50YXJnZXRFbCwgXCJhcmlhLWV4cGFuZGVkXCIsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBbXG4gICAgICAgICAgICAgIGxpc3RlbkZvclJlc2l6ZSh0aGlzKSxcbiAgICAgICAgICAgICAgbGlzdGVuRm9yRXNjQ2xvc2UodGhpcyksXG4gICAgICAgICAgICAgIGxpc3RlbkZvckJhY2tncm91bmRDbG9zZSh0aGlzKSxcbiAgICAgICAgICAgICAgdGhpcy5hdXRvVXBkYXRlICYmIGxpc3RlbkZvclNjcm9sbCh0aGlzKSxcbiAgICAgICAgICAgICAgdGhpcy5jbG9zZU9uU2Nyb2xsICYmIGxpc3RlbkZvclNjcm9sbENsb3NlKHRoaXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgb25jZSh0aGlzLiRlbCwgXCJoaWRlXCIsICgpID0+IGhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IGhhbmRsZXIgJiYgaGFuZGxlcigpKSwge1xuICAgICAgICAgICAgICBzZWxmOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5iZ1Njcm9sbCkge1xuICAgICAgICAgICAgICBvbmNlKHRoaXMuJGVsLCBcImhpZGRlblwiLCBwcmV2ZW50QmFja2dyb3VuZFNjcm9sbCh0aGlzLiRlbCksIHsgc2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImJlZm9yZWhpZGVcIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZXJzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJoaWRlXCIsXG4gICAgICAgICAgaGFuZGxlcih7IHRhcmdldCB9KSB7XG4gICAgICAgICAgICBpZiAodGhpcy4kZWwgIT09IHRhcmdldCkge1xuICAgICAgICAgICAgICBhY3RpdmUgPSBhY3RpdmUgPT09IG51bGwgJiYgdGhpcy4kZWwuY29udGFpbnModGFyZ2V0KSAmJiB0aGlzLmlzVG9nZ2xlZCgpID8gdGhpcyA6IGFjdGl2ZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlID0gdGhpcy5pc0FjdGl2ZSgpID8gbnVsbCA6IGFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIGF0dHIodGhpcy50YXJnZXRFbCwgXCJhcmlhLWV4cGFuZGVkXCIsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB3cml0ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSAmJiAhaGFzQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRW50ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBzaG93KHRhcmdldCA9IHRoaXMudGFyZ2V0RWwsIGRlbGF5ID0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmIHRhcmdldCAmJiB0aGlzLnRhcmdldEVsICYmIHRhcmdldCAhPT0gdGhpcy50YXJnZXRFbCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudGFyZ2V0RWwgPSB0YXJnZXQ7XG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuICAgICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgaWYgKGRlbGF5ICYmIGFjdGl2ZS5pc0RlbGF5aW5nKCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zaG93VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IG1hdGNoZXModGFyZ2V0LCBcIjpob3ZlclwiKSAmJiB0aGlzLnNob3coKSwgMTApO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcHJldjtcbiAgICAgICAgICAgIHdoaWxlIChhY3RpdmUgJiYgcHJldiAhPT0gYWN0aXZlICYmICFhY3RpdmUuJGVsLmNvbnRhaW5zKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgICBwcmV2ID0gYWN0aXZlO1xuICAgICAgICAgICAgICBhY3RpdmUuaGlkZShmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5jb250YWluZXIgJiYgcGFyZW50KHRoaXMuJGVsKSAhPT0gdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZCh0aGlzLmNvbnRhaW5lciwgdGhpcy4kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IHNldFRpbWVvdXQoXG4gICAgICAgICAgICAoKSA9PiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIHRydWUpLFxuICAgICAgICAgICAgZGVsYXkgJiYgdGhpcy5kZWxheVNob3cgfHwgMFxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGUoZGVsYXkgPSB0cnVlLCBhbmltYXRlID0gdHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IGhpZGUgPSAoKSA9PiB0aGlzLnRvZ2dsZUVsZW1lbnQodGhpcy4kZWwsIGZhbHNlLCB0aGlzLmFuaW1hdGVPdXQgJiYgYW5pbWF0ZSk7XG4gICAgICAgICAgdGhpcy5jbGVhclRpbWVycygpO1xuICAgICAgICAgIHRoaXMuaXNEZWxheWVkSGlkZSA9IGRlbGF5O1xuICAgICAgICAgIGlmIChkZWxheSAmJiB0aGlzLmlzRGVsYXlpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZSwgNTApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVsYXkgJiYgdGhpcy5kZWxheUhpZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVRpbWVyID0gc2V0VGltZW91dChoaWRlLCB0aGlzLmRlbGF5SGlkZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyVGltZXJzKCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNob3dUaW1lcik7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTtcbiAgICAgICAgICB0aGlzLnNob3dUaW1lciA9IG51bGw7XG4gICAgICAgICAgdGhpcy5oaWRlVGltZXIgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aXZlID09PSB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBpc0RlbGF5aW5nKCkge1xuICAgICAgICAgIHJldHVybiBbdGhpcy4kZWwsIC4uLiQkKFwiLnVrLWRyb3BcIiwgdGhpcy4kZWwpXS5zb21lKChlbCkgPT4gdGhpcy50cmFja2VyLm1vdmVzVG8oZWwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb24oKSB7XG4gICAgICAgICAgY29uc3QgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID0gc3RvcmVTY3JvbGxQb3NpdGlvbih0aGlzLiRlbCk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIFwidWstZHJvcC1zdGFja1wiKTtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHRoaXMuX3N0eWxlKTtcbiAgICAgICAgICB0aGlzLiRlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHZpZXdwb3J0cyA9IHRoaXMudGFyZ2V0Lm1hcCgodGFyZ2V0KSA9PiBnZXRWaWV3cG9ydCQxKHRoaXMuJGVsLCB0YXJnZXQpKTtcbiAgICAgICAgICBjb25zdCB2aWV3cG9ydE9mZnNldCA9IHRoaXMuZ2V0Vmlld3BvcnRPZmZzZXQodGhpcy4kZWwpO1xuICAgICAgICAgIGNvbnN0IGRpcnMgPSBbXG4gICAgICAgICAgICBbMCwgW1wieFwiLCBcIndpZHRoXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdXSxcbiAgICAgICAgICAgIFsxLCBbXCJ5XCIsIFwiaGVpZ2h0XCIsIFwidG9wXCIsIFwiYm90dG9tXCJdXVxuICAgICAgICAgIF07XG4gICAgICAgICAgZm9yIChjb25zdCBbaSwgW2F4aXMsIHByb3BdXSBvZiBkaXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5heGlzICE9PSBheGlzICYmIGluY2x1ZGVzKFtheGlzLCB0cnVlXSwgdGhpcy5zdHJldGNoKSkge1xuICAgICAgICAgICAgICBjc3ModGhpcy4kZWwsIHtcbiAgICAgICAgICAgICAgICBbcHJvcF06IE1hdGgubWluKFxuICAgICAgICAgICAgICAgICAgb2Zmc2V0KHRoaXMuYm91bmRhcnlbaV0pW3Byb3BdLFxuICAgICAgICAgICAgICAgICAgdmlld3BvcnRzW2ldW3Byb3BdIC0gMiAqIHZpZXdwb3J0T2Zmc2V0XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBbYG92ZXJmbG93LSR7YXhpc31gXTogXCJhdXRvXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gdmlld3BvcnRzWzBdLndpZHRoIC0gMiAqIHZpZXdwb3J0T2Zmc2V0O1xuICAgICAgICAgIHRoaXMuJGVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgXCJtYXhXaWR0aFwiLCBcIlwiKTtcbiAgICAgICAgICBpZiAodGhpcy4kZWwub2Zmc2V0V2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIFwidWstZHJvcC1zdGFja1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCBcIm1heFdpZHRoXCIsIG1heFdpZHRoKTtcbiAgICAgICAgICB0aGlzLnBvc2l0aW9uQXQodGhpcy4kZWwsIHRoaXMudGFyZ2V0LCB0aGlzLmJvdW5kYXJ5KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtpLCBbYXhpcywgcHJvcCwgc3RhcnQsIGVuZF1dIG9mIGRpcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF4aXMgPT09IGF4aXMgJiYgaW5jbHVkZXMoW2F4aXMsIHRydWVdLCB0aGlzLnN0cmV0Y2gpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uT2Zmc2V0ID0gTWF0aC5hYnModGhpcy5nZXRQb3NpdGlvbk9mZnNldCgpKTtcbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0KHRoaXMudGFyZ2V0W2ldKTtcbiAgICAgICAgICAgICAgY29uc3QgZWxPZmZzZXQgPSBvZmZzZXQodGhpcy4kZWwpO1xuICAgICAgICAgICAgICBjc3ModGhpcy4kZWwsIHtcbiAgICAgICAgICAgICAgICBbcHJvcF06ICh0YXJnZXRPZmZzZXRbc3RhcnRdID4gZWxPZmZzZXRbc3RhcnRdID8gdGFyZ2V0T2Zmc2V0W3RoaXMuaW5zZXQgPyBlbmQgOiBzdGFydF0gLSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAgIG9mZnNldCh0aGlzLmJvdW5kYXJ5W2ldKVtzdGFydF0sXG4gICAgICAgICAgICAgICAgICB2aWV3cG9ydHNbaV1bc3RhcnRdICsgdmlld3BvcnRPZmZzZXRcbiAgICAgICAgICAgICAgICApIDogTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICBvZmZzZXQodGhpcy5ib3VuZGFyeVtpXSlbZW5kXSxcbiAgICAgICAgICAgICAgICAgIHZpZXdwb3J0c1tpXVtlbmRdIC0gdmlld3BvcnRPZmZzZXRcbiAgICAgICAgICAgICAgICApIC0gdGFyZ2V0T2Zmc2V0W3RoaXMuaW5zZXQgPyBzdGFydCA6IGVuZF0pIC0gcG9zaXRpb25PZmZzZXQsXG4gICAgICAgICAgICAgICAgW2BvdmVyZmxvdy0ke2F4aXN9YF06IFwiYXV0b1wiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uQXQodGhpcy4kZWwsIHRoaXMudGFyZ2V0LCB0aGlzLmJvdW5kYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldFZpZXdwb3J0JDEoZWwsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIG9mZnNldFZpZXdwb3J0KG92ZXJmbG93UGFyZW50cyh0YXJnZXQpLmZpbmQoKHBhcmVudDIpID0+IHBhcmVudDIuY29udGFpbnMoZWwpKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvZ2dsZUNvbXBvbmVudChkcm9wKSB7XG4gICAgICBjb25zdCB7ICRlbCB9ID0gZHJvcC4kY3JlYXRlKFwidG9nZ2xlXCIsIHF1ZXJ5KGRyb3AudG9nZ2xlLCBkcm9wLiRlbCksIHtcbiAgICAgICAgdGFyZ2V0OiBkcm9wLiRlbCxcbiAgICAgICAgbW9kZTogZHJvcC5tb2RlXG4gICAgICB9KTtcbiAgICAgIGF0dHIoJGVsLCBcImFyaWEtaGFzcG9wdXBcIiwgdHJ1ZSk7XG4gICAgICByZXR1cm4gJGVsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaXN0ZW5Gb3JSZXNpemUoZHJvcCkge1xuICAgICAgY29uc3QgdXBkYXRlID0gKCkgPT4gZHJvcC4kZW1pdCgpO1xuICAgICAgY29uc3Qgb2ZmID0gW1xuICAgICAgICBvYnNlcnZlVmlld3BvcnRSZXNpemUodXBkYXRlKSxcbiAgICAgICAgb2JzZXJ2ZVJlc2l6ZShvdmVyZmxvd1BhcmVudHMoZHJvcC4kZWwpLmNvbmNhdChkcm9wLnRhcmdldCksIHVwZGF0ZSlcbiAgICAgIF07XG4gICAgICByZXR1cm4gKCkgPT4gb2ZmLm1hcCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpc3RlbkZvclNjcm9sbChkcm9wLCBmbiA9ICgpID0+IGRyb3AuJGVtaXQoKSkge1xuICAgICAgcmV0dXJuIG9uKFtkb2N1bWVudCwgLi4ub3ZlcmZsb3dQYXJlbnRzKGRyb3AuJGVsKV0sIFwic2Nyb2xsXCIsIGZuLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsaXN0ZW5Gb3JFc2NDbG9zZShkcm9wKSB7XG4gICAgICByZXR1cm4gb24oZG9jdW1lbnQsIFwia2V5ZG93blwiLCAoZSkgPT4ge1xuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlNYXAuRVNDKSB7XG4gICAgICAgICAgZHJvcC5oaWRlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpc3RlbkZvclNjcm9sbENsb3NlKGRyb3ApIHtcbiAgICAgIHJldHVybiBsaXN0ZW5Gb3JTY3JvbGwoZHJvcCwgKCkgPT4gZHJvcC5oaWRlKGZhbHNlKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpc3RlbkZvckJhY2tncm91bmRDbG9zZShkcm9wKSB7XG4gICAgICByZXR1cm4gb24oZG9jdW1lbnQsIHBvaW50ZXJEb3duJDEsICh7IHRhcmdldCB9KSA9PiB7XG4gICAgICAgIGlmIChkcm9wLiRlbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uY2UoXG4gICAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgICAgYCR7cG9pbnRlclVwJDF9ICR7cG9pbnRlckNhbmNlbH0gc2Nyb2xsYCxcbiAgICAgICAgICAoeyBkZWZhdWx0UHJldmVudGVkLCB0eXBlLCB0YXJnZXQ6IG5ld1RhcmdldCB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIWRlZmF1bHRQcmV2ZW50ZWQgJiYgdHlwZSA9PT0gcG9pbnRlclVwJDEgJiYgdGFyZ2V0ID09PSBuZXdUYXJnZXQgJiYgISgoX2EgPSBkcm9wLnRhcmdldEVsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGFpbnModGFyZ2V0KSkpIHtcbiAgICAgICAgICAgICAgZHJvcC5oaWRlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBEcm9wbmF2ID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIENvbnRhaW5lcl0sXG4gICAgICBwcm9wczoge1xuICAgICAgICBhbGlnbjogU3RyaW5nLFxuICAgICAgICBjbHNEcm9wOiBTdHJpbmcsXG4gICAgICAgIGJvdW5kYXJ5OiBCb29sZWFuLFxuICAgICAgICBkcm9wYmFyOiBCb29sZWFuLFxuICAgICAgICBkcm9wYmFyQW5jaG9yOiBCb29sZWFuLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLFxuICAgICAgICBtb2RlOiBCb29sZWFuLFxuICAgICAgICBvZmZzZXQ6IEJvb2xlYW4sXG4gICAgICAgIHN0cmV0Y2g6IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5U2hvdzogQm9vbGVhbixcbiAgICAgICAgZGVsYXlIaWRlOiBCb29sZWFuLFxuICAgICAgICB0YXJnZXQ6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldFg6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldFk6IEJvb2xlYW4sXG4gICAgICAgIGFuaW1hdGlvbjogQm9vbGVhbixcbiAgICAgICAgYW5pbWF0ZU91dDogQm9vbGVhbixcbiAgICAgICAgY2xvc2VPblNjcm9sbDogQm9vbGVhblxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgYWxpZ246IGlzUnRsID8gXCJyaWdodFwiIDogXCJsZWZ0XCIsXG4gICAgICAgIGNsc0Ryb3A6IFwidWstZHJvcGRvd25cIixcbiAgICAgICAgY2xzRHJvcGJhcjogXCJ1ay1kcm9wbmF2LWRyb3BiYXJcIixcbiAgICAgICAgYm91bmRhcnk6IHRydWUsXG4gICAgICAgIGRyb3BiYXI6IGZhbHNlLFxuICAgICAgICBkcm9wYmFyQW5jaG9yOiBmYWxzZSxcbiAgICAgICAgZHVyYXRpb246IDIwMCxcbiAgICAgICAgY29udGFpbmVyOiBmYWxzZSxcbiAgICAgICAgc2VsTmF2SXRlbTogXCI+IGxpID4gYSwgPiB1bCA+IGxpID4gYVwiXG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZHJvcGJhckFuY2hvcjogKHsgZHJvcGJhckFuY2hvciB9LCAkZWwpID0+IHF1ZXJ5KGRyb3BiYXJBbmNob3IsICRlbCkgfHwgJGVsLFxuICAgICAgICBkcm9wYmFyKHsgZHJvcGJhciB9KSB7XG4gICAgICAgICAgaWYgKCFkcm9wYmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZHJvcGJhciA9IHRoaXMuX2Ryb3BiYXIgfHwgcXVlcnkoZHJvcGJhciwgdGhpcy4kZWwpIHx8ICQoYCsgLiR7dGhpcy5jbHNEcm9wYmFyfWAsIHRoaXMuJGVsKTtcbiAgICAgICAgICByZXR1cm4gZHJvcGJhciA/IGRyb3BiYXIgOiB0aGlzLl9kcm9wYmFyID0gJChcIjxkaXY+PC9kaXY+XCIpO1xuICAgICAgICB9LFxuICAgICAgICBkcm9wQ29udGFpbmVyKF8sICRlbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lciB8fCAkZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGRyb3Bkb3ducyh7IGNsc0Ryb3AgfSwgJGVsKSB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIGNvbnN0IGRyb3Bkb3ducyA9ICQkKGAuJHtjbHNEcm9wfWAsICRlbCk7XG4gICAgICAgICAgaWYgKHRoaXMuZHJvcENvbnRhaW5lciAhPT0gJGVsKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mICQkKGAuJHtjbHNEcm9wfWAsIHRoaXMuZHJvcENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gKF9hID0gdGhpcy5nZXREcm9wZG93bihlbCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS50YXJnZXRFbDtcbiAgICAgICAgICAgICAgaWYgKCFpbmNsdWRlcyhkcm9wZG93bnMsIGVsKSAmJiB0YXJnZXQgJiYgdGhpcy4kZWwuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGRyb3Bkb3ducy5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZHJvcGRvd25zO1xuICAgICAgICB9LFxuICAgICAgICBpdGVtcyh7IHNlbE5hdkl0ZW0gfSwgJGVsKSB7XG4gICAgICAgICAgcmV0dXJuICQkKHNlbE5hdkl0ZW0sICRlbCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3YXRjaDoge1xuICAgICAgICBkcm9wYmFyKGRyb3BiYXIpIHtcbiAgICAgICAgICBhZGRDbGFzcyhcbiAgICAgICAgICAgIGRyb3BiYXIsXG4gICAgICAgICAgICBcInVrLWRyb3BiYXJcIixcbiAgICAgICAgICAgIFwidWstZHJvcGJhci10b3BcIixcbiAgICAgICAgICAgIHRoaXMuY2xzRHJvcGJhcixcbiAgICAgICAgICAgIGB1ay0ke3RoaXMuJG9wdGlvbnMubmFtZX0tZHJvcGJhcmBcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBkcm9wZG93bnMoKSB7XG4gICAgICAgICAgdGhpcy5pbml0aWFsaXplRHJvcGRvd25zKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZURyb3Bkb3ducygpO1xuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmVtb3ZlJDEodGhpcy5fZHJvcGJhcik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9kcm9wYmFyO1xuICAgICAgfSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJtb3VzZW92ZXIgZm9jdXNpblwiLFxuICAgICAgICAgIGRlbGVnYXRlOiAoeyBzZWxOYXZJdGVtIH0pID0+IHNlbE5hdkl0ZW0sXG4gICAgICAgICAgaGFuZGxlcih7IGN1cnJlbnQgfSkge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlMiA9IHRoaXMuZ2V0QWN0aXZlKCk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlMiAmJiBpbmNsdWRlcyhhY3RpdmUyLm1vZGUsIFwiaG92ZXJcIikgJiYgYWN0aXZlMi50YXJnZXRFbCAmJiAhY3VycmVudC5jb250YWlucyhhY3RpdmUyLnRhcmdldEVsKSAmJiAhYWN0aXZlMi5pc0RlbGF5aW5nKCkpIHtcbiAgICAgICAgICAgICAgYWN0aXZlMi5oaWRlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImtleWRvd25cIixcbiAgICAgICAgICBzZWxmOiB0cnVlLFxuICAgICAgICAgIGRlbGVnYXRlOiAoeyBzZWxOYXZJdGVtIH0pID0+IHNlbE5hdkl0ZW0sXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGN1cnJlbnQsIGtleUNvZGUgfSA9IGU7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmUyID0gdGhpcy5nZXRBY3RpdmUoKTtcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuRE9XTiAmJiAoYWN0aXZlMiA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlMi50YXJnZXRFbCkgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAoX2EgPSAkKHNlbEZvY3VzYWJsZSwgYWN0aXZlMi4kZWwpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZU5hdkl0ZW1OYXZpZ2F0aW9uKGUsIHRoaXMuaXRlbXMsIGFjdGl2ZTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwia2V5ZG93blwiLFxuICAgICAgICAgIGVsOiAoeyBkcm9wQ29udGFpbmVyIH0pID0+IGRyb3BDb250YWluZXIsXG4gICAgICAgICAgZGVsZWdhdGU6ICh7IGNsc0Ryb3AgfSkgPT4gYC4ke2Nsc0Ryb3B9YCxcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudCwga2V5Q29kZSwgdGFyZ2V0IH0gPSBlO1xuICAgICAgICAgICAgaWYgKGlzSW5wdXQodGFyZ2V0KSB8fCAhaW5jbHVkZXModGhpcy5kcm9wZG93bnMsIGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZTIgPSB0aGlzLmdldEFjdGl2ZSgpO1xuICAgICAgICAgICAgbGV0IG5leHQgPSAtMTtcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXlNYXAuSE9NRSkge1xuICAgICAgICAgICAgICBuZXh0ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkVORCkge1xuICAgICAgICAgICAgICBuZXh0ID0gXCJsYXN0XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IGtleU1hcC5VUCkge1xuICAgICAgICAgICAgICBuZXh0ID0gXCJwcmV2aW91c1wiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBrZXlNYXAuRE9XTikge1xuICAgICAgICAgICAgICBuZXh0ID0gXCJuZXh0XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleUNvZGUgPT09IGtleU1hcC5FU0MpIHtcbiAgICAgICAgICAgICAgKF9hID0gYWN0aXZlMi50YXJnZXRFbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAofm5leHQpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9ICQkKHNlbEZvY3VzYWJsZSwgY3VycmVudCk7XG4gICAgICAgICAgICAgIGVsZW1lbnRzW2dldEluZGV4KFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgZmluZEluZGV4KGVsZW1lbnRzLCAoZWwpID0+IG1hdGNoZXMoZWwsIFwiOmZvY3VzXCIpKVxuICAgICAgICAgICAgICApXS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlTmF2SXRlbU5hdmlnYXRpb24oZSwgdGhpcy5pdGVtcywgYWN0aXZlMik7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJtb3VzZWxlYXZlXCIsXG4gICAgICAgICAgZWw6ICh7IGRyb3BiYXIgfSkgPT4gZHJvcGJhcixcbiAgICAgICAgICBmaWx0ZXI6ICh7IGRyb3BiYXIgfSkgPT4gZHJvcGJhcixcbiAgICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlMiA9IHRoaXMuZ2V0QWN0aXZlKCk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlMiAmJiBpbmNsdWRlcyhhY3RpdmUyLm1vZGUsIFwiaG92ZXJcIikgJiYgIXRoaXMuZHJvcGRvd25zLnNvbWUoKGVsKSA9PiBtYXRjaGVzKGVsLCBcIjpob3ZlclwiKSkpIHtcbiAgICAgICAgICAgICAgYWN0aXZlMi5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJiZWZvcmVzaG93XCIsXG4gICAgICAgICAgZWw6ICh7IGRyb3BDb250YWluZXIgfSkgPT4gZHJvcENvbnRhaW5lcixcbiAgICAgICAgICBmaWx0ZXI6ICh7IGRyb3BiYXIgfSkgPT4gZHJvcGJhcixcbiAgICAgICAgICBoYW5kbGVyKHsgdGFyZ2V0IH0pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Ryb3BiYXJEcm9wKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZHJvcGJhci5wcmV2aW91c0VsZW1lbnRTaWJsaW5nICE9PSB0aGlzLmRyb3BiYXJBbmNob3IpIHtcbiAgICAgICAgICAgICAgYWZ0ZXIodGhpcy5kcm9wYmFyQW5jaG9yLCB0aGlzLmRyb3BiYXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQ2xhc3ModGFyZ2V0LCBgJHt0aGlzLmNsc0Ryb3B9LWRyb3BiYXJgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICBlbDogKHsgZHJvcENvbnRhaW5lciB9KSA9PiBkcm9wQ29udGFpbmVyLFxuICAgICAgICAgIGZpbHRlcjogKHsgZHJvcGJhciB9KSA9PiBkcm9wYmFyLFxuICAgICAgICAgIGhhbmRsZXIoeyB0YXJnZXQgfSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJvcGJhckRyb3AodGFyZ2V0KSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkcm9wID0gdGhpcy5nZXREcm9wZG93bih0YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0SGVpZ2h0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBtYXhCb3R0b20gPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICAuLi5wYXJlbnRzKHRhcmdldCwgYC4ke3RoaXMuY2xzRHJvcH1gKS5jb25jYXQodGFyZ2V0KS5tYXAoKGVsKSA9PiBvZmZzZXQoZWwpLmJvdHRvbSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgb2Zmc2V0KHRoaXMuZHJvcGJhciwge1xuICAgICAgICAgICAgICAgIGxlZnQ6IG9mZnNldCh0aGlzLmRyb3BiYXIpLmxlZnQsXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLmdldERyb3BiYXJPZmZzZXQoZHJvcC5nZXRQb3NpdGlvbk9mZnNldCgpKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG8oXG4gICAgICAgICAgICAgICAgbWF4Qm90dG9tIC0gb2Zmc2V0KHRoaXMuZHJvcGJhcikudG9wICsgdG9GbG9hdChjc3ModGFyZ2V0LCBcIm1hcmdpbkJvdHRvbVwiKSksXG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBvYnNlcnZlUmVzaXplKFtkcm9wLiRlbCwgLi4uZHJvcC50YXJnZXRdLCBhZGp1c3RIZWlnaHQpO1xuICAgICAgICAgICAgYWRqdXN0SGVpZ2h0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJiZWZvcmVoaWRlXCIsXG4gICAgICAgICAgZWw6ICh7IGRyb3BDb250YWluZXIgfSkgPT4gZHJvcENvbnRhaW5lcixcbiAgICAgICAgICBmaWx0ZXI6ICh7IGRyb3BiYXIgfSkgPT4gZHJvcGJhcixcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZTIgPSB0aGlzLmdldEFjdGl2ZSgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXModGhpcy5kcm9wYmFyLCBcIjpob3ZlclwiKSAmJiBhY3RpdmUyLiRlbCA9PT0gZS50YXJnZXQgJiYgdGhpcy5pc0Ryb3BiYXJEcm9wKGFjdGl2ZTIuJGVsKSAmJiBpbmNsdWRlcyhhY3RpdmUyLm1vZGUsIFwiaG92ZXJcIikgJiYgYWN0aXZlMi5pc0RlbGF5ZWRIaWRlICYmICF0aGlzLml0ZW1zLnNvbWUoKGVsKSA9PiBhY3RpdmUyLnRhcmdldEVsICE9PSBlbCAmJiBtYXRjaGVzKGVsLCBcIjpmb2N1c1wiKSkpIHtcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaGlkZVwiLFxuICAgICAgICAgIGVsOiAoeyBkcm9wQ29udGFpbmVyIH0pID0+IGRyb3BDb250YWluZXIsXG4gICAgICAgICAgZmlsdGVyOiAoeyBkcm9wYmFyIH0pID0+IGRyb3BiYXIsXG4gICAgICAgICAgaGFuZGxlcih7IHRhcmdldCB9KSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNEcm9wYmFyRHJvcCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMuX29ic2VydmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlMiA9IHRoaXMuZ2V0QWN0aXZlKCk7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZTIgfHwgYWN0aXZlMi4kZWwgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UbygwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldEFjdGl2ZSgpIHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKHRoaXMuZHJvcGRvd25zLCAoX2EgPSBhY3RpdmUpID09IG51bGwgPyB2b2lkIDAgOiBfYS4kZWwpICYmIGFjdGl2ZTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgdHJhbnNpdGlvblRvKG5ld0hlaWdodCwgZWwpIHtcbiAgICAgICAgICBjb25zdCB7IGRyb3BiYXIgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3Qgb2xkSGVpZ2h0ID0gaGVpZ2h0KGRyb3BiYXIpO1xuICAgICAgICAgIGVsID0gb2xkSGVpZ2h0IDwgbmV3SGVpZ2h0ICYmIGVsO1xuICAgICAgICAgIGF3YWl0IFRyYW5zaXRpb24uY2FuY2VsKFtlbCwgZHJvcGJhcl0pO1xuICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IG9mZnNldChlbCkudG9wIC0gb2Zmc2V0KGRyb3BiYXIpLnRvcCAtIG9sZEhlaWdodDtcbiAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICBjc3MoZWwsIFwidHJhbnNpdGlvbkRlbGF5XCIsIGAke2RpZmYgLyBuZXdIZWlnaHQgKiB0aGlzLmR1cmF0aW9ufW1zYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzcyhlbCwgXCJjbGlwUGF0aFwiLCBgcG9seWdvbigwIDAsMTAwJSAwLDEwMCUgJHtvbGRIZWlnaHR9cHgsMCAke29sZEhlaWdodH1weClgKTtcbiAgICAgICAgICBoZWlnaHQoZHJvcGJhciwgb2xkSGVpZ2h0KTtcbiAgICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KGRyb3BiYXIsIHsgaGVpZ2h0OiBuZXdIZWlnaHQgfSwgdGhpcy5kdXJhdGlvbiksXG4gICAgICAgICAgICBUcmFuc2l0aW9uLnN0YXJ0KFxuICAgICAgICAgICAgICBlbCxcbiAgICAgICAgICAgICAgeyBjbGlwUGF0aDogYHBvbHlnb24oMCAwLDEwMCUgMCwxMDAlICR7bmV3SGVpZ2h0fXB4LDAgJHtuZXdIZWlnaHR9cHgpYCB9LFxuICAgICAgICAgICAgICB0aGlzLmR1cmF0aW9uXG4gICAgICAgICAgICApLmZpbmFsbHkoKCkgPT4gY3NzKGVsLCB7IGNsaXBQYXRoOiBcIlwiLCB0cmFuc2l0aW9uRGVsYXk6IFwiXCIgfSkpXG4gICAgICAgICAgXSkuY2F0Y2gobm9vcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldERyb3Bkb3duKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJGdldENvbXBvbmVudChlbCwgXCJkcm9wXCIpIHx8IHRoaXMuJGdldENvbXBvbmVudChlbCwgXCJkcm9wZG93blwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNEcm9wYmFyRHJvcChlbCkge1xuICAgICAgICAgIHJldHVybiBpbmNsdWRlcyh0aGlzLmRyb3Bkb3ducywgZWwpICYmIGhhc0NsYXNzKGVsLCB0aGlzLmNsc0Ryb3ApO1xuICAgICAgICB9LFxuICAgICAgICBnZXREcm9wYmFyT2Zmc2V0KG9mZnNldFRvcCkge1xuICAgICAgICAgIGNvbnN0IHsgJGVsLCB0YXJnZXQsIHRhcmdldFkgfSA9IHRoaXM7XG4gICAgICAgICAgY29uc3QgeyB0b3AsIGhlaWdodDogaGVpZ2h0MiB9ID0gb2Zmc2V0KHF1ZXJ5KHRhcmdldFkgfHwgdGFyZ2V0IHx8ICRlbCwgJGVsKSk7XG4gICAgICAgICAgcmV0dXJuIHRvcCArIGhlaWdodDIgKyBvZmZzZXRUb3A7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRpYWxpemVEcm9wZG93bnMoKSB7XG4gICAgICAgICAgdGhpcy4kY3JlYXRlKFxuICAgICAgICAgICAgXCJkcm9wXCIsXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3ducy5maWx0ZXIoKGVsKSA9PiAhdGhpcy5nZXREcm9wZG93bihlbCkpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi50aGlzLiRwcm9wcyxcbiAgICAgICAgICAgICAgZmxpcDogZmFsc2UsXG4gICAgICAgICAgICAgIHNoaWZ0OiB0cnVlLFxuICAgICAgICAgICAgICBwb3M6IGBib3R0b20tJHt0aGlzLmFsaWdufWAsXG4gICAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLmJvdW5kYXJ5ID09PSB0cnVlID8gdGhpcy4kZWwgOiB0aGlzLmJvdW5kYXJ5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaGFuZGxlTmF2SXRlbU5hdmlnYXRpb24oZSwgdG9nZ2xlcywgYWN0aXZlMikge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICBjb25zdCB7IGN1cnJlbnQsIGtleUNvZGUgfSA9IGU7XG4gICAgICBsZXQgbmV4dCA9IC0xO1xuICAgICAgaWYgKGtleUNvZGUgPT09IGtleU1hcC5IT01FKSB7XG4gICAgICAgIG5leHQgPSAwO1xuICAgICAgfSBlbHNlIGlmIChrZXlDb2RlID09PSBrZXlNYXAuRU5EKSB7XG4gICAgICAgIG5leHQgPSBcImxhc3RcIjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLkxFRlQpIHtcbiAgICAgICAgbmV4dCA9IFwicHJldmlvdXNcIjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLlJJR0hUKSB7XG4gICAgICAgIG5leHQgPSBcIm5leHRcIjtcbiAgICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA9PT0ga2V5TWFwLlRBQikge1xuICAgICAgICAoX2EgPSBhY3RpdmUyLnRhcmdldEVsKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgICAgKF9iID0gYWN0aXZlMi5oaWRlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChhY3RpdmUyLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAofm5leHQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAoX2MgPSBhY3RpdmUyLmhpZGUpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKGFjdGl2ZTIsIGZhbHNlKTtcbiAgICAgICAgdG9nZ2xlc1tnZXRJbmRleChuZXh0LCB0b2dnbGVzLCB0b2dnbGVzLmluZGV4T2YoYWN0aXZlMi50YXJnZXRFbCB8fCBjdXJyZW50KSldLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZvcm1DdXN0b20gPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzc10sXG4gICAgICBhcmdzOiBcInRhcmdldFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGFyZ2V0OiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICB0YXJnZXQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgaW5wdXQ6IChfLCAkZWwpID0+ICQoc2VsSW5wdXQsICRlbCksXG4gICAgICAgIHN0YXRlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmlucHV0Lm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0KHsgdGFyZ2V0IH0sICRlbCkge1xuICAgICAgICAgIHJldHVybiB0YXJnZXQgJiYgKHRhcmdldCA9PT0gdHJ1ZSAmJiBwYXJlbnQodGhpcy5pbnB1dCkgPT09ICRlbCAmJiB0aGlzLmlucHV0Lm5leHRFbGVtZW50U2libGluZyB8fCAkKHRhcmdldCwgJGVsKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQsIGlucHV0IH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3B0aW9uO1xuICAgICAgICBjb25zdCBwcm9wID0gaXNJbnB1dCh0YXJnZXQpID8gXCJ2YWx1ZVwiIDogXCJ0ZXh0Q29udGVudFwiO1xuICAgICAgICBjb25zdCBwcmV2ID0gdGFyZ2V0W3Byb3BdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9ICgoX2EgPSBpbnB1dC5maWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzBdKSA/IGlucHV0LmZpbGVzWzBdLm5hbWUgOiBtYXRjaGVzKGlucHV0LCBcInNlbGVjdFwiKSAmJiAob3B0aW9uID0gJCQoXCJvcHRpb25cIiwgaW5wdXQpLmZpbHRlcigoZWwpID0+IGVsLnNlbGVjdGVkKVswXSkgPyBvcHRpb24udGV4dENvbnRlbnQgOiBpbnB1dC52YWx1ZTtcbiAgICAgICAgaWYgKHByZXYgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiY2hhbmdlXCIsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInJlc2V0XCIsXG4gICAgICAgICAgZWw6ICh7ICRlbCB9KSA9PiAkZWwuY2xvc2VzdChcImZvcm1cIiksXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuXG4gICAgdmFyIGdyaWQgPSB7XG4gICAgICBleHRlbmRzOiBNYXJnaW4sXG4gICAgICBtaXhpbnM6IFtDbGFzc10sXG4gICAgICBuYW1lOiBcImdyaWRcIixcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG1hc29ucnk6IEJvb2xlYW4sXG4gICAgICAgIHBhcmFsbGF4OiBTdHJpbmcsXG4gICAgICAgIHBhcmFsbGF4U3RhcnQ6IFN0cmluZyxcbiAgICAgICAgcGFyYWxsYXhFbmQ6IFN0cmluZyxcbiAgICAgICAgcGFyYWxsYXhKdXN0aWZ5OiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBtYXJnaW46IFwidWstZ3JpZC1tYXJnaW5cIixcbiAgICAgICAgY2xzU3RhY2s6IFwidWstZ3JpZC1zdGFja1wiLFxuICAgICAgICBtYXNvbnJ5OiBmYWxzZSxcbiAgICAgICAgcGFyYWxsYXg6IDAsXG4gICAgICAgIHBhcmFsbGF4U3RhcnQ6IDAsXG4gICAgICAgIHBhcmFsbGF4RW5kOiAwLFxuICAgICAgICBwYXJhbGxheEp1c3RpZnk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLm1hc29ucnkgJiYgYWRkQ2xhc3ModGhpcy4kZWwsIFwidWstZmxleC10b3BcIiwgXCJ1ay1mbGV4LXdyYXAtdG9wXCIpO1xuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IHNjcm9sbCQxKHsgZmlsdGVyOiAoeyBwYXJhbGxheCwgcGFyYWxsYXhKdXN0aWZ5IH0pID0+IHBhcmFsbGF4IHx8IHBhcmFsbGF4SnVzdGlmeSB9KSxcbiAgICAgIHVwZGF0ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgd3JpdGUoeyByb3dzIH0pIHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuJGVsLCB0aGlzLmNsc1N0YWNrLCAhcm93cy5zb21lKChyb3cpID0+IHJvdy5sZW5ndGggPiAxKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBldmVudHM6IFtcInJlc2l6ZVwiXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcmVhZChkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IHJvd3MgfSA9IGRhdGE7XG4gICAgICAgICAgICBsZXQgeyBtYXNvbnJ5LCBwYXJhbGxheCwgcGFyYWxsYXhKdXN0aWZ5LCBtYXJnaW4gfSA9IHRoaXM7XG4gICAgICAgICAgICBwYXJhbGxheCA9IE1hdGgubWF4KDAsIHRvUHgocGFyYWxsYXgpKTtcbiAgICAgICAgICAgIGlmICghKG1hc29ucnkgfHwgcGFyYWxsYXggfHwgcGFyYWxsYXhKdXN0aWZ5KSB8fCBwb3NpdGlvbmVkQWJzb2x1dGUocm93cykgfHwgcm93c1swXS5zb21lKFxuICAgICAgICAgICAgICAoZWwsIGkpID0+IHJvd3Muc29tZSgocm93KSA9PiByb3dbaV0gJiYgcm93W2ldLm9mZnNldFdpZHRoICE9PSBlbC5vZmZzZXRXaWR0aClcbiAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEudHJhbnNsYXRlcyA9IGRhdGEuc2Nyb2xsQ29sdW1ucyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGd1dHRlciA9IGdldEd1dHRlcihyb3dzLCBtYXJnaW4pO1xuICAgICAgICAgICAgbGV0IGNvbHVtbnM7XG4gICAgICAgICAgICBsZXQgdHJhbnNsYXRlcztcbiAgICAgICAgICAgIGlmIChtYXNvbnJ5KSB7XG4gICAgICAgICAgICAgIFtjb2x1bW5zLCB0cmFuc2xhdGVzXSA9IGFwcGx5TWFzb25yeShyb3dzLCBndXR0ZXIsIG1hc29ucnkgPT09IFwibmV4dFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbHVtbnMgPSB0cmFuc3Bvc2Uocm93cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5IZWlnaHRzID0gY29sdW1ucy5tYXAoXG4gICAgICAgICAgICAgIChjb2x1bW4pID0+IHN1bUJ5KGNvbHVtbiwgXCJvZmZzZXRIZWlnaHRcIikgKyBndXR0ZXIgKiAoY29sdW1uLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgLi4uY29sdW1uSGVpZ2h0cyk7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsQ29sdW1ucztcbiAgICAgICAgICAgIGxldCBwYXJhbGxheFN0YXJ0O1xuICAgICAgICAgICAgbGV0IHBhcmFsbGF4RW5kO1xuICAgICAgICAgICAgaWYgKHBhcmFsbGF4IHx8IHBhcmFsbGF4SnVzdGlmeSkge1xuICAgICAgICAgICAgICBzY3JvbGxDb2x1bW5zID0gY29sdW1uSGVpZ2h0cy5tYXAoXG4gICAgICAgICAgICAgICAgKGhndCwgaSkgPT4gcGFyYWxsYXhKdXN0aWZ5ID8gaGVpZ2h0IC0gaGd0ICsgcGFyYWxsYXggOiBwYXJhbGxheCAvIChpICUgMiB8fCA4KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAoIXBhcmFsbGF4SnVzdGlmeSkge1xuICAgICAgICAgICAgICAgIHBhcmFsbGF4ID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgICAuLi5jb2x1bW5IZWlnaHRzLm1hcCgoaGd0LCBpKSA9PiBoZ3QgKyBzY3JvbGxDb2x1bW5zW2ldIC0gaGVpZ2h0KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGFyYWxsYXhTdGFydCA9IHRvUHgodGhpcy5wYXJhbGxheFN0YXJ0LCBcImhlaWdodFwiLCB0aGlzLiRlbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHBhcmFsbGF4RW5kID0gdG9QeCh0aGlzLnBhcmFsbGF4RW5kLCBcImhlaWdodFwiLCB0aGlzLiRlbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBjb2x1bW5zLFxuICAgICAgICAgICAgICB0cmFuc2xhdGVzLFxuICAgICAgICAgICAgICBzY3JvbGxDb2x1bW5zLFxuICAgICAgICAgICAgICBwYXJhbGxheFN0YXJ0LFxuICAgICAgICAgICAgICBwYXJhbGxheEVuZCxcbiAgICAgICAgICAgICAgcGFkZGluZzogcGFyYWxsYXgsXG4gICAgICAgICAgICAgIGhlaWdodDogdHJhbnNsYXRlcyA/IGhlaWdodCA6IFwiXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0ZSh7IGhlaWdodCwgcGFkZGluZyB9KSB7XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsIFwicGFkZGluZ0JvdHRvbVwiLCBwYWRkaW5nIHx8IFwiXCIpO1xuICAgICAgICAgICAgaGVpZ2h0ICE9PSBmYWxzZSAmJiBjc3ModGhpcy4kZWwsIFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBldmVudHM6IFtcInJlc2l6ZVwiXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgcmVhZCh7IHJvd3MsIHNjcm9sbENvbHVtbnMsIHBhcmFsbGF4U3RhcnQsIHBhcmFsbGF4RW5kIH0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHNjcm9sbGVkOiBzY3JvbGxDb2x1bW5zICYmICFwb3NpdGlvbmVkQWJzb2x1dGUocm93cykgPyBzY3JvbGxlZE92ZXIodGhpcy4kZWwsIHBhcmFsbGF4U3RhcnQsIHBhcmFsbGF4RW5kKSA6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JpdGUoeyBjb2x1bW5zLCBzY3JvbGxlZCwgc2Nyb2xsQ29sdW1ucywgdHJhbnNsYXRlcyB9KSB7XG4gICAgICAgICAgICBpZiAoIXNjcm9sbGVkICYmICF0cmFuc2xhdGVzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbHVtbnMuZm9yRWFjaChcbiAgICAgICAgICAgICAgKGNvbHVtbiwgaSkgPT4gY29sdW1uLmZvckVhY2goKGVsLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IFt4LCB5XSA9IHRyYW5zbGF0ZXMgJiYgdHJhbnNsYXRlc1tpXVtqXSB8fCBbMCwgMF07XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbGVkKSB7XG4gICAgICAgICAgICAgICAgICB5ICs9IHNjcm9sbGVkICogc2Nyb2xsQ29sdW1uc1tpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3NzKGVsLCBcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eH1weCwgJHt5fXB4KWApO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV2ZW50czogW1wic2Nyb2xsXCIsIFwicmVzaXplXCJdXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvc2l0aW9uZWRBYnNvbHV0ZShyb3dzKSB7XG4gICAgICByZXR1cm4gcm93cy5mbGF0KCkuc29tZSgoZWwpID0+IGNzcyhlbCwgXCJwb3NpdGlvblwiKSA9PT0gXCJhYnNvbHV0ZVwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlNYXNvbnJ5KHJvd3MsIGd1dHRlciwgbmV4dCkge1xuICAgICAgY29uc3QgY29sdW1ucyA9IFtdO1xuICAgICAgY29uc3QgdHJhbnNsYXRlcyA9IFtdO1xuICAgICAgY29uc3QgY29sdW1uSGVpZ2h0cyA9IEFycmF5KHJvd3NbMF0ubGVuZ3RoKS5maWxsKDApO1xuICAgICAgbGV0IHJvd0hlaWdodHMgPSAwO1xuICAgICAgZm9yIChsZXQgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgaWYgKGlzUnRsKSB7XG4gICAgICAgICAgcm93LnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBqIGluIHJvdykge1xuICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCB9ID0gcm93W2pdO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gbmV4dCA/IGogOiBjb2x1bW5IZWlnaHRzLmluZGV4T2YoTWF0aC5taW4oLi4uY29sdW1uSGVpZ2h0cykpO1xuICAgICAgICAgIHB1c2goY29sdW1ucywgaW5kZXgsIHJvd1tqXSk7XG4gICAgICAgICAgcHVzaCh0cmFuc2xhdGVzLCBpbmRleCwgW1xuICAgICAgICAgICAgKGluZGV4IC0gaikgKiBvZmZzZXRXaWR0aCAqIChpc1J0bCA/IC0xIDogMSksXG4gICAgICAgICAgICBjb2x1bW5IZWlnaHRzW2luZGV4XSAtIHJvd0hlaWdodHNcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBjb2x1bW5IZWlnaHRzW2luZGV4XSArPSBvZmZzZXRIZWlnaHQgKyBndXR0ZXI7XG4gICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0LCBvZmZzZXRIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJvd0hlaWdodHMgKz0gaGVpZ2h0ICsgZ3V0dGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtjb2x1bW5zLCB0cmFuc2xhdGVzXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0R3V0dGVyKHJvd3MsIGNscykge1xuICAgICAgY29uc3Qgbm9kZSA9IHJvd3MuZmxhdCgpLmZpbmQoKGVsKSA9PiBoYXNDbGFzcyhlbCwgY2xzKSk7XG4gICAgICByZXR1cm4gdG9GbG9hdChub2RlID8gY3NzKG5vZGUsIFwibWFyZ2luVG9wXCIpIDogY3NzKHJvd3NbMF1bMF0sIFwicGFkZGluZ0xlZnRcIikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc3Bvc2Uocm93cykge1xuICAgICAgY29uc3QgY29sdW1ucyA9IFtdO1xuICAgICAgZm9yIChjb25zdCByb3cgb2Ygcm93cykge1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gcm93KSB7XG4gICAgICAgICAgcHVzaChjb2x1bW5zLCBpLCByb3dbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29sdW1ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICBpZiAoIWFycmF5W2luZGV4XSkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGFycmF5W2luZGV4XS5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgaGVpZ2h0TWF0Y2ggPSB7XG4gICAgICBhcmdzOiBcInRhcmdldFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdGFyZ2V0OiBTdHJpbmcsXG4gICAgICAgIHJvdzogQm9vbGVhblxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiBcIj4gKlwiLFxuICAgICAgICByb3c6IHRydWVcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBlbGVtZW50czogKHsgdGFyZ2V0IH0sICRlbCkgPT4gJCQodGFyZ2V0LCAkZWwpXG4gICAgICB9LFxuICAgICAgb2JzZXJ2ZTogcmVzaXplKHtcbiAgICAgICAgdGFyZ2V0OiAoeyAkZWwsIGVsZW1lbnRzIH0pID0+IGVsZW1lbnRzLnJlZHVjZSgoZWxlbWVudHMyLCBlbCkgPT4gZWxlbWVudHMyLmNvbmNhdChlbCwgLi4uZWwuY2hpbGRyZW4pLCBbJGVsXSlcbiAgICAgIH0pLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC8vIEhpZGRlbiBlbGVtZW50cyBtYXkgY2hhbmdlIGhlaWdodCB3aGVuIGZvbnRzIGxvYWRcbiAgICAgICAgbmFtZTogXCJsb2FkaW5nZG9uZVwiLFxuICAgICAgICBlbDogKCkgPT4gZG9jdW1lbnQuZm9udHMsXG4gICAgICAgIGhhbmRsZXIoKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdChcInJlc2l6ZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3dzOiAodGhpcy5yb3cgPyBnZXRSb3dzKHRoaXMuZWxlbWVudHMpIDogW3RoaXMuZWxlbWVudHNdKS5tYXAobWF0Y2gpXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGUoeyByb3dzIH0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgaGVpZ2h0cywgZWxlbWVudHMgfSBvZiByb3dzKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbCwgaSkgPT4gY3NzKGVsLCBcIm1pbkhlaWdodFwiLCBoZWlnaHRzW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IFtcInJlc2l6ZVwiXVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gbWF0Y2goZWxlbWVudHMpIHtcbiAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiB7IGhlaWdodHM6IFtcIlwiXSwgZWxlbWVudHMgfTtcbiAgICAgIH1cbiAgICAgIGxldCBoZWlnaHRzID0gZWxlbWVudHMubWFwKGdldEhlaWdodCk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heCguLi5oZWlnaHRzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodHM6IGVsZW1lbnRzLm1hcCgoZWwsIGkpID0+IGhlaWdodHNbaV0udG9GaXhlZCgyKSA9PT0gbWF4LnRvRml4ZWQoMikgPyBcIlwiIDogbWF4KSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEhlaWdodChlbGVtZW50KSB7XG4gICAgICBjb25zdCBzdHlsZSA9IHBpY2soZWxlbWVudC5zdHlsZSwgW1wiZGlzcGxheVwiLCBcIm1pbkhlaWdodFwiXSk7XG4gICAgICBpZiAoIWlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICBjc3MoZWxlbWVudCwgXCJkaXNwbGF5XCIsIFwiYmxvY2tcIiwgXCJpbXBvcnRhbnRcIik7XG4gICAgICB9XG4gICAgICBjc3MoZWxlbWVudCwgXCJtaW5IZWlnaHRcIiwgXCJcIik7XG4gICAgICBjb25zdCBoZWlnaHQgPSBkaW1lbnNpb25zJDEoZWxlbWVudCkuaGVpZ2h0IC0gYm94TW9kZWxBZGp1c3QoZWxlbWVudCwgXCJoZWlnaHRcIiwgXCJjb250ZW50LWJveFwiKTtcbiAgICAgIGNzcyhlbGVtZW50LCBzdHlsZSk7XG4gICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH1cblxuICAgIHZhciBoZWlnaHRQbGFjZWhvbGRlciA9IHtcbiAgICAgIGFyZ3M6IFwidGFyZ2V0XCIsXG4gICAgICBwcm9wczoge1xuICAgICAgICB0YXJnZXQ6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiBcIlwiXG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgZ2V0OiAoeyB0YXJnZXQgfSwgJGVsKSA9PiBxdWVyeSh0YXJnZXQsICRlbCksXG4gICAgICAgICAgb2JzZXJ2ZTogKHsgdGFyZ2V0IH0pID0+IHRhcmdldFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb2JzZXJ2ZTogcmVzaXplKHsgdGFyZ2V0OiAoeyB0YXJnZXQgfSkgPT4gdGFyZ2V0IH0pLFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0ID8geyBoZWlnaHQ6IHRoaXMudGFyZ2V0Lm9mZnNldEhlaWdodCB9IDogZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlKHsgaGVpZ2h0IH0pIHtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIFwibWluSGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czogW1wicmVzaXplXCJdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBoZWlnaHRWaWV3cG9ydCA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGV4cGFuZDogQm9vbGVhbixcbiAgICAgICAgb2Zmc2V0VG9wOiBCb29sZWFuLFxuICAgICAgICBvZmZzZXRCb3R0b206IEJvb2xlYW4sXG4gICAgICAgIG1pbkhlaWdodDogTnVtYmVyXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBleHBhbmQ6IGZhbHNlLFxuICAgICAgICBvZmZzZXRUb3A6IGZhbHNlLFxuICAgICAgICBvZmZzZXRCb3R0b206IGZhbHNlLFxuICAgICAgICBtaW5IZWlnaHQ6IDBcbiAgICAgIH0sXG4gICAgICAvLyBjaGVjayBmb3Igb2Zmc2V0VG9wIGNoYW5nZVxuICAgICAgb2JzZXJ2ZTogW1xuICAgICAgICB2aWV3cG9ydCh7IGZpbHRlcjogKHsgZXhwYW5kIH0pID0+IGV4cGFuZCB9KSxcbiAgICAgICAgcmVzaXplKHsgdGFyZ2V0OiAoeyAkZWwgfSkgPT4gc2Nyb2xsUGFyZW50cygkZWwpIH0pXG4gICAgICBdLFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgaWYgKCFpc1Zpc2libGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBtaW5IZWlnaHQgPSBcIlwiO1xuICAgICAgICAgIGNvbnN0IGJveCA9IGJveE1vZGVsQWRqdXN0KHRoaXMuJGVsLCBcImhlaWdodFwiLCBcImNvbnRlbnQtYm94XCIpO1xuICAgICAgICAgIGNvbnN0IHsgYm9keSwgc2Nyb2xsaW5nRWxlbWVudCB9ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHNjcm9sbFBhcmVudCh0aGlzLiRlbCk7XG4gICAgICAgICAgY29uc3QgeyBoZWlnaHQ6IHZpZXdwb3J0SGVpZ2h0IH0gPSBvZmZzZXRWaWV3cG9ydChcbiAgICAgICAgICAgIHNjcm9sbEVsZW1lbnQgPT09IGJvZHkgPyBzY3JvbGxpbmdFbGVtZW50IDogc2Nyb2xsRWxlbWVudFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgaXNTY3JvbGxpbmdFbGVtZW50ID0gc2Nyb2xsaW5nRWxlbWVudCA9PT0gc2Nyb2xsRWxlbWVudCB8fCBib2R5ID09PSBzY3JvbGxFbGVtZW50O1xuICAgICAgICAgIG1pbkhlaWdodCA9IGBjYWxjKCR7aXNTY3JvbGxpbmdFbGVtZW50ID8gXCIxMDB2aFwiIDogYCR7dmlld3BvcnRIZWlnaHR9cHhgfWA7XG4gICAgICAgICAgaWYgKHRoaXMuZXhwYW5kKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZGltZW5zaW9ucyQxKHNjcm9sbEVsZW1lbnQpLmhlaWdodCAtIGRpbWVuc2lvbnMkMSh0aGlzLiRlbCkuaGVpZ2h0O1xuICAgICAgICAgICAgbWluSGVpZ2h0ICs9IGAgLSAke2RpZmZ9cHhgO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vZmZzZXRUb3ApIHtcbiAgICAgICAgICAgICAgaWYgKGlzU2Nyb2xsaW5nRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFRvcEVsID0gdGhpcy5vZmZzZXRUb3AgPT09IHRydWUgPyB0aGlzLiRlbCA6IHF1ZXJ5KHRoaXMub2Zmc2V0VG9wLCB0aGlzLiRlbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b3AgfSA9IG9mZnNldChvZmZzZXRUb3BFbCk7XG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IHRvcCA+IDAgJiYgdG9wIDwgdmlld3BvcnRIZWlnaHQgLyAyID8gYCAtICR7dG9wfXB4YCA6IFwiXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IGAgLSAke2JveE1vZGVsQWRqdXN0KHNjcm9sbEVsZW1lbnQsIFwiaGVpZ2h0XCIsIGNzcyhzY3JvbGxFbGVtZW50LCBcImJveFNpemluZ1wiKSl9cHhgO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vZmZzZXRCb3R0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IGAgLSAke2RpbWVuc2lvbnMkMSh0aGlzLiRlbC5uZXh0RWxlbWVudFNpYmxpbmcpLmhlaWdodH1weGA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTnVtZXJpYyh0aGlzLm9mZnNldEJvdHRvbSkpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IGAgLSAke3RoaXMub2Zmc2V0Qm90dG9tfXZoYDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vZmZzZXRCb3R0b20gJiYgZW5kc1dpdGgodGhpcy5vZmZzZXRCb3R0b20sIFwicHhcIikpIHtcbiAgICAgICAgICAgICAgbWluSGVpZ2h0ICs9IGAgLSAke3RvRmxvYXQodGhpcy5vZmZzZXRCb3R0b20pfXB4YDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodGhpcy5vZmZzZXRCb3R0b20pKSB7XG4gICAgICAgICAgICAgIG1pbkhlaWdodCArPSBgIC0gJHtkaW1lbnNpb25zJDEocXVlcnkodGhpcy5vZmZzZXRCb3R0b20sIHRoaXMuJGVsKSkuaGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbWluSGVpZ2h0ICs9IGAke2JveCA/IGAgLSAke2JveH1weGAgOiBcIlwifSlgO1xuICAgICAgICAgIHJldHVybiB7IG1pbkhlaWdodCB9O1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZSh7IG1pbkhlaWdodCB9KSB7XG4gICAgICAgICAgY3NzKHRoaXMuJGVsLCBcIm1pbkhlaWdodFwiLCBgbWF4KCR7dGhpcy5taW5IZWlnaHQgfHwgMH1weCwgJHttaW5IZWlnaHR9KWApO1xuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IFtcInJlc2l6ZVwiXVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY2xvc2VJY29uID0gXCI8c3ZnIHdpZHRoPVxcXCIxNFxcXCIgaGVpZ2h0PVxcXCIxNFxcXCIgdmlld0JveD1cXFwiMCAwIDE0IDE0XFxcIj48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMVxcXCIgeTE9XFxcIjFcXFwiIHgyPVxcXCIxM1xcXCIgeTI9XFxcIjEzXFxcIi8+PGxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgeDE9XFxcIjEzXFxcIiB5MT1cXFwiMVxcXCIgeDI9XFxcIjFcXFwiIHkyPVxcXCIxM1xcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIGNsb3NlTGFyZ2UgPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiPjxsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjRcXFwiIHgxPVxcXCIxXFxcIiB5MT1cXFwiMVxcXCIgeDI9XFxcIjE5XFxcIiB5Mj1cXFwiMTlcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiB4MT1cXFwiMTlcXFwiIHkxPVxcXCIxXFxcIiB4Mj1cXFwiMVxcXCIgeTI9XFxcIjE5XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgZHJvcFBhcmVudEljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjEyXFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTIgMTJcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBwb2ludHM9XFxcIjEgMy41IDYgOC41IDExIDMuNVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG1hcmtlciA9IFwiPHN2ZyB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMjBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyMCAyMFxcXCI+PHJlY3Qgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiMTFcXFwiIHg9XFxcIjlcXFwiIHk9XFxcIjRcXFwiLz48cmVjdCB3aWR0aD1cXFwiMTFcXFwiIGhlaWdodD1cXFwiMVxcXCIgeD1cXFwiNFxcXCIgeT1cXFwiOVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG5hdlBhcmVudEljb25MYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiMTRcXFwiIGhlaWdodD1cXFwiMTRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNCAxNFxcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIHBvaW50cz1cXFwiMSA0IDcgMTAgMTMgNFxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG5hdlBhcmVudEljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjEyXFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTIgMTJcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBwb2ludHM9XFxcIjEgMy41IDYgOC41IDExIDMuNVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG5hdmJhclBhcmVudEljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjEyXFxcIiBoZWlnaHQ9XFxcIjEyXFxcIiB2aWV3Qm94PVxcXCIwIDAgMTIgMTJcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiBwb2ludHM9XFxcIjEgMy41IDYgOC41IDExIDMuNVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIG5hdmJhclRvZ2dsZUljb24gPSBcIjxzdmcgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjIwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMjAgMjBcXFwiPjxzdHlsZT4udWstbmF2YmFyLXRvZ2dsZS1pY29uIHN2ZyZndDtbY2xhc3MqPSZxdW90O2xpbmUtJnF1b3Q7XXt0cmFuc2l0aW9uOjAuMnMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbi1wcm9wZXJ0eTp0cmFuc2Zvcm0sIG9wYWNpdHk7dHJhbnNmb3JtLW9yaWdpbjpjZW50ZXI7b3BhY2l0eToxfS51ay1uYXZiYXItdG9nZ2xlLWljb24gc3ZnJmd0Oy5saW5lLTN7b3BhY2l0eTowfS51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD0mcXVvdDt0cnVlJnF1b3Q7XSBzdmcmZ3Q7LmxpbmUtM3tvcGFjaXR5OjF9LnVrLW5hdmJhci10b2dnbGUtYW5pbWF0ZVthcmlhLWV4cGFuZGVkPSZxdW90O3RydWUmcXVvdDtdIHN2ZyZndDsubGluZS0ye3RyYW5zZm9ybTpyb3RhdGUoNDVkZWcpfS51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD0mcXVvdDt0cnVlJnF1b3Q7XSBzdmcmZ3Q7LmxpbmUtM3t0cmFuc2Zvcm06cm90YXRlKC00NWRlZyl9LnVrLW5hdmJhci10b2dnbGUtYW5pbWF0ZVthcmlhLWV4cGFuZGVkPSZxdW90O3RydWUmcXVvdDtdIHN2ZyZndDsubGluZS0xLC51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD0mcXVvdDt0cnVlJnF1b3Q7XSBzdmcmZ3Q7LmxpbmUtNHtvcGFjaXR5OjB9LnVrLW5hdmJhci10b2dnbGUtYW5pbWF0ZVthcmlhLWV4cGFuZGVkPSZxdW90O3RydWUmcXVvdDtdIHN2ZyZndDsubGluZS0xe3RyYW5zZm9ybTp0cmFuc2xhdGVZKDZweCkgc2NhbGVYKDApfS51ay1uYXZiYXItdG9nZ2xlLWFuaW1hdGVbYXJpYS1leHBhbmRlZD0mcXVvdDt0cnVlJnF1b3Q7XSBzdmcmZ3Q7LmxpbmUtNHt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNnB4KSBzY2FsZVgoMCl9PC9zdHlsZT48cmVjdCB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMlxcXCIgeT1cXFwiM1xcXCIgY2xhc3M9XFxcImxpbmUtMVxcXCIvPjxyZWN0IHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyXFxcIiB5PVxcXCI5XFxcIiBjbGFzcz1cXFwibGluZS0yXFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjIwXFxcIiBoZWlnaHQ9XFxcIjJcXFwiIHk9XFxcIjlcXFwiIGNsYXNzPVxcXCJsaW5lLTNcXFwiLz48cmVjdCB3aWR0aD1cXFwiMjBcXFwiIGhlaWdodD1cXFwiMlxcXCIgeT1cXFwiMTVcXFwiIGNsYXNzPVxcXCJsaW5lLTRcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBvdmVybGF5SWNvbiA9IFwiPHN2ZyB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCA0MCA0MFxcXCI+PHJlY3Qgd2lkdGg9XFxcIjFcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHg9XFxcIjE5XFxcIiB5PVxcXCIwXFxcIi8+PHJlY3Qgd2lkdGg9XFxcIjQwXFxcIiBoZWlnaHQ9XFxcIjFcXFwiIHg9XFxcIjBcXFwiIHk9XFxcIjE5XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgcGFnaW5hdGlvbk5leHQgPSBcIjxzdmcgd2lkdGg9XFxcIjdcXFwiIGhlaWdodD1cXFwiMTJcXFwiIHZpZXdCb3g9XFxcIjAgMCA3IDEyXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgcG9pbnRzPVxcXCIxIDEgNiA2IDEgMTFcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBwYWdpbmF0aW9uUHJldmlvdXMgPSBcIjxzdmcgd2lkdGg9XFxcIjdcXFwiIGhlaWdodD1cXFwiMTJcXFwiIHZpZXdCb3g9XFxcIjAgMCA3IDEyXFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMlxcXCIgcG9pbnRzPVxcXCI2IDEgMSA2IDYgMTFcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzZWFyY2hJY29uID0gXCI8c3ZnIHdpZHRoPVxcXCIyMFxcXCIgaGVpZ2h0PVxcXCIyMFxcXCIgdmlld0JveD1cXFwiMCAwIDIwIDIwXFxcIj48Y2lyY2xlIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGN4PVxcXCI5XFxcIiBjeT1cXFwiOVxcXCIgcj1cXFwiN1xcXCIvPjxwYXRoIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjFcXFwiIGQ9XFxcIk0xNCwxNCBMMTgsMTggTDE0LDE0IFpcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzZWFyY2hMYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiNDBcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCA0MCA0MFxcXCI+PGNpcmNsZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS44XFxcIiBjeD1cXFwiMTcuNVxcXCIgY3k9XFxcIjE3LjVcXFwiIHI9XFxcIjE2LjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS44XFxcIiB4MT1cXFwiMzhcXFwiIHkxPVxcXCIzOVxcXCIgeDI9XFxcIjI5XFxcIiB5Mj1cXFwiMzBcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzZWFyY2hNZWRpdW0gPSBcIjxzdmcgd2lkdGg9XFxcIjI0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMjQgMjRcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuMVxcXCIgY3g9XFxcIjEwLjVcXFwiIGN5PVxcXCIxMC41XFxcIiByPVxcXCI5LjVcXFwiLz48bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS4xXFxcIiB4MT1cXFwiMjNcXFwiIHkxPVxcXCIyM1xcXCIgeDI9XFxcIjE3XFxcIiB5Mj1cXFwiMTdcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciBzbGlkZW5hdk5leHRMYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiMjVcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNSA0MFxcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIiBwb2ludHM9XFxcIjQuMDAyLDM4LjU0NyAyMi41MjcsMjAuMDI0IDQsMS41XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgc2xpZGVuYXZOZXh0ID0gXCI8c3ZnIHdpZHRoPVxcXCIxNFxcXCIgaGVpZ2h0PVxcXCIyNFxcXCIgdmlld0JveD1cXFwiMCAwIDE0IDI0XFxcIj48cG9seWxpbmUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBzdHJva2Utd2lkdGg9XFxcIjEuNFxcXCIgcG9pbnRzPVxcXCIxLjIyNSwyMyAxMi43NzUsMTIgMS4yMjUsMVxcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNsaWRlbmF2UHJldmlvdXNMYXJnZSA9IFwiPHN2ZyB3aWR0aD1cXFwiMjVcXFwiIGhlaWdodD1cXFwiNDBcXFwiIHZpZXdCb3g9XFxcIjAgMCAyNSA0MFxcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIyXFxcIiBwb2ludHM9XFxcIjIwLjUyNywxLjUgMiwyMC4wMjQgMjAuNTI1LDM4LjU0N1xcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNsaWRlbmF2UHJldmlvdXMgPSBcIjxzdmcgd2lkdGg9XFxcIjE0XFxcIiBoZWlnaHQ9XFxcIjI0XFxcIiB2aWV3Qm94PVxcXCIwIDAgMTQgMjRcXFwiPjxwb2x5bGluZSBmaWxsPVxcXCJub25lXFxcIiBzdHJva2U9XFxcIiMwMDBcXFwiIHN0cm9rZS13aWR0aD1cXFwiMS40XFxcIiBwb2ludHM9XFxcIjEyLjc3NSwxIDEuMjI1LDEyIDEyLjc3NSwyM1xcXCIvPjwvc3ZnPlwiO1xuXG4gICAgdmFyIHNwaW5uZXIgPSBcIjxzdmcgd2lkdGg9XFxcIjMwXFxcIiBoZWlnaHQ9XFxcIjMwXFxcIiB2aWV3Qm94PVxcXCIwIDAgMzAgMzBcXFwiPjxjaXJjbGUgZmlsbD1cXFwibm9uZVxcXCIgc3Ryb2tlPVxcXCIjMDAwXFxcIiBjeD1cXFwiMTVcXFwiIGN5PVxcXCIxNVxcXCIgcj1cXFwiMTRcXFwiLz48L3N2Zz5cIjtcblxuICAgIHZhciB0b3RvcCA9IFwiPHN2ZyB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiMTBcXFwiIHZpZXdCb3g9XFxcIjAgMCAxOCAxMFxcXCI+PHBvbHlsaW5lIGZpbGw9XFxcIm5vbmVcXFwiIHN0cm9rZT1cXFwiIzAwMFxcXCIgc3Ryb2tlLXdpZHRoPVxcXCIxLjJcXFwiIHBvaW50cz1cXFwiMSA5IDkgMSAxNyA5XFxcIi8+PC9zdmc+XCI7XG5cbiAgICB2YXIgU3ZnID0ge1xuICAgICAgYXJnczogXCJzcmNcIixcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHdpZHRoOiBOdW1iZXIsXG4gICAgICAgIGhlaWdodDogTnVtYmVyLFxuICAgICAgICByYXRpbzogTnVtYmVyXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICByYXRpbzogMVxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5zdmcgPSB0aGlzLmdldFN2ZygpLnRoZW4oKGVsKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3ZnID0gaW5zZXJ0U1ZHKGVsLCB0aGlzLiRlbCk7XG4gICAgICAgICAgaWYgKHRoaXMuc3ZnRWwgJiYgc3ZnICE9PSB0aGlzLnN2Z0VsKSB7XG4gICAgICAgICAgICByZW1vdmUkMSh0aGlzLnN2Z0VsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXBwbHlXaWR0aEFuZEhlaWdodC5jYWxsKHRoaXMsIHN2ZywgZWwpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnN2Z0VsID0gc3ZnO1xuICAgICAgICB9LCBub29wKTtcbiAgICAgIH0sXG4gICAgICBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuc3ZnLnRoZW4oKHN2ZykgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzVm9pZEVsZW1lbnQodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVtb3ZlJDEoc3ZnKTtcbiAgICAgICAgICB0aGlzLnN2Z0VsID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3ZnID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGdldFN2ZygpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gaW5zZXJ0U1ZHKGVsLCByb290KSB7XG4gICAgICBpZiAoaXNWb2lkRWxlbWVudChyb290KSB8fCBpc1RhZyhyb290LCBcImNhbnZhc1wiKSkge1xuICAgICAgICByb290LmhpZGRlbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IG5leHQgPSByb290Lm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgcmV0dXJuIGVxdWFscyhlbCwgbmV4dCkgPyBuZXh0IDogYWZ0ZXIocm9vdCwgZWwpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFzdCA9IHJvb3QubGFzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHJldHVybiBlcXVhbHMoZWwsIGxhc3QpID8gbGFzdCA6IGFwcGVuZChyb290LCBlbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVxdWFscyhlbCwgb3RoZXIpIHtcbiAgICAgIHJldHVybiBpc1RhZyhlbCwgXCJzdmdcIikgJiYgaXNUYWcob3RoZXIsIFwic3ZnXCIpICYmIGVsLmlubmVySFRNTCA9PT0gb3RoZXIuaW5uZXJIVE1MO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseVdpZHRoQW5kSGVpZ2h0KGVsLCByZWYpIHtcbiAgICAgIGNvbnN0IHByb3BzID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIl07XG4gICAgICBsZXQgZGltZW5zaW9ucyA9IHByb3BzLm1hcCgocHJvcCkgPT4gdGhpc1twcm9wXSk7XG4gICAgICBpZiAoIWRpbWVuc2lvbnMuc29tZSgodmFsKSA9PiB2YWwpKSB7XG4gICAgICAgIGRpbWVuc2lvbnMgPSBwcm9wcy5tYXAoKHByb3ApID0+IGF0dHIocmVmLCBwcm9wKSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2aWV3Qm94ID0gYXR0cihyZWYsIFwidmlld0JveFwiKTtcbiAgICAgIGlmICh2aWV3Qm94ICYmICFkaW1lbnNpb25zLnNvbWUoKHZhbCkgPT4gdmFsKSkge1xuICAgICAgICBkaW1lbnNpb25zID0gdmlld0JveC5zcGxpdChcIiBcIikuc2xpY2UoMik7XG4gICAgICB9XG4gICAgICBkaW1lbnNpb25zLmZvckVhY2goKHZhbCwgaSkgPT4gYXR0cihlbCwgcHJvcHNbaV0sIHRvRmxvYXQodmFsKSAqIHRoaXMucmF0aW8gfHwgbnVsbCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVNWRyhzdmcsIGljb24pIHtcbiAgICAgIGlmIChpY29uICYmIGluY2x1ZGVzKHN2ZywgXCI8c3ltYm9sXCIpKSB7XG4gICAgICAgIHN2ZyA9IHBhcnNlU3ltYm9scyhzdmcpW2ljb25dIHx8IHN2ZztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b05vZGVzKGZyYWdtZW50KHN2ZykpLmZpbHRlcihpc0VsZW1lbnQpWzBdO1xuICAgIH1cbiAgICBjb25zdCBzeW1ib2xSZSA9IC88c3ltYm9sKFteXSo/aWQ9KFsnXCJdKSguKz8pXFwyW15dKj88XFwvKXN5bWJvbD4vZztcbiAgICBjb25zdCBwYXJzZVN5bWJvbHMgPSBtZW1vaXplKGZ1bmN0aW9uKHN2Zykge1xuICAgICAgY29uc3Qgc3ltYm9scyA9IHt9O1xuICAgICAgc3ltYm9sUmUubGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtYXRjaDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHN5bWJvbFJlLmV4ZWMoc3ZnKSkge1xuICAgICAgICBzeW1ib2xzW21hdGNoWzNdXSA9IGA8c3ZnICR7bWF0Y2hbMV19c3ZnPmA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3ltYm9scztcbiAgICB9KTtcblxuICAgIGNvbnN0IGljb25zID0ge1xuICAgICAgc3Bpbm5lcixcbiAgICAgIHRvdG9wLFxuICAgICAgbWFya2VyLFxuICAgICAgXCJjbG9zZS1pY29uXCI6IGNsb3NlSWNvbixcbiAgICAgIFwiY2xvc2UtbGFyZ2VcIjogY2xvc2VMYXJnZSxcbiAgICAgIFwiZHJvcC1wYXJlbnQtaWNvblwiOiBkcm9wUGFyZW50SWNvbixcbiAgICAgIFwibmF2LXBhcmVudC1pY29uXCI6IG5hdlBhcmVudEljb24sXG4gICAgICBcIm5hdi1wYXJlbnQtaWNvbi1sYXJnZVwiOiBuYXZQYXJlbnRJY29uTGFyZ2UsXG4gICAgICBcIm5hdmJhci1wYXJlbnQtaWNvblwiOiBuYXZiYXJQYXJlbnRJY29uLFxuICAgICAgXCJuYXZiYXItdG9nZ2xlLWljb25cIjogbmF2YmFyVG9nZ2xlSWNvbixcbiAgICAgIFwib3ZlcmxheS1pY29uXCI6IG92ZXJsYXlJY29uLFxuICAgICAgXCJwYWdpbmF0aW9uLW5leHRcIjogcGFnaW5hdGlvbk5leHQsXG4gICAgICBcInBhZ2luYXRpb24tcHJldmlvdXNcIjogcGFnaW5hdGlvblByZXZpb3VzLFxuICAgICAgXCJzZWFyY2gtaWNvblwiOiBzZWFyY2hJY29uLFxuICAgICAgXCJzZWFyY2gtbWVkaXVtXCI6IHNlYXJjaE1lZGl1bSxcbiAgICAgIFwic2VhcmNoLWxhcmdlXCI6IHNlYXJjaExhcmdlLFxuICAgICAgXCJzZWFyY2gtdG9nZ2xlLWljb25cIjogc2VhcmNoSWNvbixcbiAgICAgIFwic2xpZGVuYXYtbmV4dFwiOiBzbGlkZW5hdk5leHQsXG4gICAgICBcInNsaWRlbmF2LW5leHQtbGFyZ2VcIjogc2xpZGVuYXZOZXh0TGFyZ2UsXG4gICAgICBcInNsaWRlbmF2LXByZXZpb3VzXCI6IHNsaWRlbmF2UHJldmlvdXMsXG4gICAgICBcInNsaWRlbmF2LXByZXZpb3VzLWxhcmdlXCI6IHNsaWRlbmF2UHJldmlvdXNMYXJnZVxuICAgIH07XG4gICAgY29uc3QgSWNvbiA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwkMSxcbiAgICAgIG1peGluczogW1N2Z10sXG4gICAgICBhcmdzOiBcImljb25cIixcbiAgICAgIHByb3BzOiB7IGljb246IFN0cmluZyB9LFxuICAgICAgaXNJY29uOiB0cnVlLFxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgYWRkQ2xhc3ModGhpcy4kZWwsIFwidWstaWNvblwiKTtcbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIGdldFN2ZygpIHtcbiAgICAgICAgICBjb25zdCBpY29uID0gZ2V0SWNvbih0aGlzLmljb24pO1xuICAgICAgICAgIGlmICghaWNvbikge1xuICAgICAgICAgICAgdGhyb3cgXCJJY29uIG5vdCBmb3VuZC5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IEljb25Db21wb25lbnQgPSB7XG4gICAgICBhcmdzOiBmYWxzZSxcbiAgICAgIGV4dGVuZHM6IEljb24sXG4gICAgICBkYXRhOiAodm0pID0+ICh7XG4gICAgICAgIGljb246IGh5cGhlbmF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zLm5hbWUpXG4gICAgICB9KSxcbiAgICAgIGJlZm9yZUNvbm5lY3QoKSB7XG4gICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCB0aGlzLiRvcHRpb25zLmlkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IE5hdlBhcmVudEljb24gPSB7XG4gICAgICBleHRlbmRzOiBJY29uQ29tcG9uZW50LFxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuJHByb3BzLmljb247XG4gICAgICAgIHRoaXMuaWNvbiA9IHRoaXMuJGVsLmNsb3Nlc3QoXCIudWstbmF2LXByaW1hcnlcIikgPyBgJHtpY29ufS1sYXJnZWAgOiBpY29uO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgU2VhcmNoID0ge1xuICAgICAgZXh0ZW5kczogSWNvbkNvbXBvbmVudCxcbiAgICAgIG1peGluczogW0kxOG5dLFxuICAgICAgaTE4bjogeyB0b2dnbGU6IFwiT3BlbiBTZWFyY2hcIiwgc3VibWl0OiBcIlN1Ym1pdCBTZWFyY2hcIiB9LFxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgaXNUb2dnbGUgPSBoYXNDbGFzcyh0aGlzLiRlbCwgXCJ1ay1zZWFyY2gtdG9nZ2xlXCIpIHx8IGhhc0NsYXNzKHRoaXMuJGVsLCBcInVrLW5hdmJhci10b2dnbGVcIik7XG4gICAgICAgIHRoaXMuaWNvbiA9IGlzVG9nZ2xlID8gXCJzZWFyY2gtdG9nZ2xlLWljb25cIiA6IGhhc0NsYXNzKHRoaXMuJGVsLCBcInVrLXNlYXJjaC1pY29uXCIpICYmIHRoaXMuJGVsLmNsb3Nlc3QoXCIudWstc2VhcmNoLWxhcmdlXCIpID8gXCJzZWFyY2gtbGFyZ2VcIiA6IHRoaXMuJGVsLmNsb3Nlc3QoXCIudWstc2VhcmNoLW1lZGl1bVwiKSA/IFwic2VhcmNoLW1lZGl1bVwiIDogdGhpcy4kcHJvcHMuaWNvbjtcbiAgICAgICAgaWYgKGhhc0F0dHIodGhpcy4kZWwsIFwiYXJpYS1sYWJlbFwiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUb2dnbGUpIHtcbiAgICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMudChcInRvZ2dsZVwiKTtcbiAgICAgICAgICBhdHRyKHRoaXMuJGVsLCBcImFyaWEtbGFiZWxcIiwgbGFiZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuJGVsLmNsb3Nlc3QoXCJhLGJ1dHRvblwiKTtcbiAgICAgICAgICBpZiAoYnV0dG9uKSB7XG4gICAgICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMudChcInN1Ym1pdFwiKTtcbiAgICAgICAgICAgIGF0dHIoYnV0dG9uLCBcImFyaWEtbGFiZWxcIiwgbGFiZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgU3Bpbm5lciA9IHtcbiAgICAgIGV4dGVuZHM6IEljb25Db21wb25lbnQsXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhdHRyKHRoaXMuJGVsLCBcInJvbGVcIiwgXCJzdGF0dXNcIik7XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBnZXRTdmcoKSB7XG4gICAgICAgICAgY29uc3QgaWNvbiA9IGF3YWl0IEljb24ubWV0aG9kcy5nZXRTdmcuY2FsbCh0aGlzKTtcbiAgICAgICAgICBpZiAodGhpcy5yYXRpbyAhPT0gMSkge1xuICAgICAgICAgICAgY3NzKCQoXCJjaXJjbGVcIiwgaWNvbiksIFwic3Ryb2tlV2lkdGhcIiwgMSAvIHRoaXMucmF0aW8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaWNvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgQnV0dG9uQ29tcG9uZW50ID0ge1xuICAgICAgZXh0ZW5kczogSWNvbkNvbXBvbmVudCxcbiAgICAgIG1peGluczogW0kxOG5dLFxuICAgICAgYmVmb3JlQ29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy4kZWwuY2xvc2VzdChcImEsYnV0dG9uXCIpO1xuICAgICAgICBhdHRyKGJ1dHRvbiwgXCJyb2xlXCIsIHRoaXMucm9sZSAhPT0gbnVsbCAmJiBpc1RhZyhidXR0b24sIFwiYVwiKSA/IFwiYnV0dG9uXCIgOiB0aGlzLnJvbGUpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IHRoaXMudChcImxhYmVsXCIpO1xuICAgICAgICBpZiAobGFiZWwgJiYgIWhhc0F0dHIoYnV0dG9uLCBcImFyaWEtbGFiZWxcIikpIHtcbiAgICAgICAgICBhdHRyKGJ1dHRvbiwgXCJhcmlhLWxhYmVsXCIsIGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgU2xpZGVuYXYgPSB7XG4gICAgICBleHRlbmRzOiBCdXR0b25Db21wb25lbnQsXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgXCJ1ay1zbGlkZW5hdlwiKTtcbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuJHByb3BzLmljb247XG4gICAgICAgIHRoaXMuaWNvbiA9IGhhc0NsYXNzKHRoaXMuJGVsLCBcInVrLXNsaWRlbmF2LWxhcmdlXCIpID8gYCR7aWNvbn0tbGFyZ2VgIDogaWNvbjtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IE5hdmJhclRvZ2dsZUljb24gPSB7XG4gICAgICBleHRlbmRzOiBCdXR0b25Db21wb25lbnQsXG4gICAgICBpMThuOiB7IGxhYmVsOiBcIk9wZW4gbWVudVwiIH1cbiAgICB9O1xuICAgIGNvbnN0IENsb3NlID0ge1xuICAgICAgZXh0ZW5kczogQnV0dG9uQ29tcG9uZW50LFxuICAgICAgaTE4bjogeyBsYWJlbDogXCJDbG9zZVwiIH0sXG4gICAgICBiZWZvcmVDb25uZWN0KCkge1xuICAgICAgICB0aGlzLmljb24gPSBgY2xvc2UtJHtoYXNDbGFzcyh0aGlzLiRlbCwgXCJ1ay1jbG9zZS1sYXJnZVwiKSA/IFwibGFyZ2VcIiA6IFwiaWNvblwifWA7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBNYXJrZXIgPSB7XG4gICAgICBleHRlbmRzOiBCdXR0b25Db21wb25lbnQsXG4gICAgICBpMThuOiB7IGxhYmVsOiBcIk9wZW5cIiB9XG4gICAgfTtcbiAgICBjb25zdCBUb3RvcCA9IHtcbiAgICAgIGV4dGVuZHM6IEJ1dHRvbkNvbXBvbmVudCxcbiAgICAgIGkxOG46IHsgbGFiZWw6IFwiQmFjayB0byB0b3BcIiB9XG4gICAgfTtcbiAgICBjb25zdCBQYWdpbmF0aW9uTmV4dCA9IHtcbiAgICAgIGV4dGVuZHM6IEJ1dHRvbkNvbXBvbmVudCxcbiAgICAgIGkxOG46IHsgbGFiZWw6IFwiTmV4dCBwYWdlXCIgfSxcbiAgICAgIGRhdGE6IHsgcm9sZTogbnVsbCB9XG4gICAgfTtcbiAgICBjb25zdCBQYWdpbmF0aW9uUHJldmlvdXMgPSB7XG4gICAgICBleHRlbmRzOiBCdXR0b25Db21wb25lbnQsXG4gICAgICBpMThuOiB7IGxhYmVsOiBcIlByZXZpb3VzIHBhZ2VcIiB9LFxuICAgICAgZGF0YTogeyByb2xlOiBudWxsIH1cbiAgICB9O1xuICAgIGNvbnN0IHBhcnNlZCA9IHt9O1xuICAgIGZ1bmN0aW9uIGluc3RhbGwkMShVSWtpdCkge1xuICAgICAgVUlraXQuaWNvbi5hZGQgPSAobmFtZSwgc3ZnKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gaXNTdHJpbmcobmFtZSkgPyB7IFtuYW1lXTogc3ZnIH0gOiBuYW1lO1xuICAgICAgICBlYWNoKGFkZGVkLCAoc3ZnMiwgbmFtZTIpID0+IHtcbiAgICAgICAgICBpY29uc1tuYW1lMl0gPSBzdmcyO1xuICAgICAgICAgIGRlbGV0ZSBwYXJzZWRbbmFtZTJdO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKFVJa2l0Ll9pbml0aWFsaXplZCkge1xuICAgICAgICAgIGFwcGx5KFxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgIChlbCkgPT4gZWFjaChVSWtpdC5nZXRDb21wb25lbnRzKGVsKSwgKGNtcCkgPT4ge1xuICAgICAgICAgICAgICBjbXAuJG9wdGlvbnMuaXNJY29uICYmIGNtcC5pY29uIGluIGFkZGVkICYmIGNtcC4kcmVzZXQoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYWxpYXNlcyA9IHsgdHdpdHRlcjogXCJ4XCIgfTtcbiAgICBmdW5jdGlvbiBnZXRJY29uKGljb24pIHtcbiAgICAgIGljb24gPSBhbGlhc2VzW2ljb25dIHx8IGljb247XG4gICAgICBpZiAoIWljb25zW2ljb25dKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFwYXJzZWRbaWNvbl0pIHtcbiAgICAgICAgcGFyc2VkW2ljb25dID0gcGFyc2VTVkcoaWNvbnNbYXBwbHlSdGwoaWNvbildIHx8IGljb25zW2ljb25dKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRbaWNvbl0uY2xvbmVOb2RlKHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseVJ0bChpY29uKSB7XG4gICAgICByZXR1cm4gaXNSdGwgPyBzd2FwKHN3YXAoaWNvbiwgXCJsZWZ0XCIsIFwicmlnaHRcIiksIFwicHJldmlvdXNcIiwgXCJuZXh0XCIpIDogaWNvbjtcbiAgICB9XG5cbiAgICB2YXIgaW52ZXJzZSA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICBzZWxBY3RpdmU6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0OiBmYWxzZSxcbiAgICAgICAgc2VsQWN0aXZlOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRhcmdldDogKHsgdGFyZ2V0IH0sICRlbCkgPT4gdGFyZ2V0ID8gJCQodGFyZ2V0LCAkZWwpIDogJGVsXG4gICAgICB9LFxuICAgICAgb2JzZXJ2ZTogW1xuICAgICAgICBpbnRlcnNlY3Rpb24oe1xuICAgICAgICAgIGhhbmRsZXIoZW50cmllcykge1xuICAgICAgICAgICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGVudHJpZXMuc29tZSgoeyBpc0ludGVyc2VjdGluZyB9KSA9PiBpc0ludGVyc2VjdGluZyk7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YXJnZXQ6ICh7IHRhcmdldCB9KSA9PiB0YXJnZXQsXG4gICAgICAgICAgYXJnczogeyBpbnRlcnNlY3Rpbmc6IGZhbHNlIH1cbiAgICAgICAgfSksXG4gICAgICAgIG11dGF0aW9uKHtcbiAgICAgICAgICB0YXJnZXQ6ICh7IHRhcmdldCB9KSA9PiB0YXJnZXQsXG4gICAgICAgICAgb3B0aW9uczogeyBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVGaWx0ZXI6IFtcImNsYXNzXCJdLCBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSB9XG4gICAgICAgIH0pLFxuICAgICAgICB7XG4gICAgICAgICAgdGFyZ2V0OiAoeyB0YXJnZXQgfSkgPT4gdGFyZ2V0LFxuICAgICAgICAgIG9ic2VydmU6ICh0YXJnZXQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gb2JzZXJ2ZVJlc2l6ZShcbiAgICAgICAgICAgICAgWy4uLnRvTm9kZXModGFyZ2V0KSwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XSxcbiAgICAgICAgICAgICAgaGFuZGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gW1xuICAgICAgICAgICAgICBvbihkb2N1bWVudCwgXCJzY3JvbGwgaXRlbXNob3duIGl0ZW1oaWRkZW5cIiwgaGFuZGxlciwge1xuICAgICAgICAgICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgb24oZG9jdW1lbnQsIFwic2hvdyBoaWRlIHRyYW5zaXRpb25zdGFydFwiLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIub2JzZXJ2ZShlLnRhcmdldCk7XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBvbihkb2N1bWVudCwgXCJzaG93biBoaWRkZW4gdHJhbnNpdGlvbmVuZCB0cmFuc2l0aW9uY2FuY2VsXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci51bm9ic2VydmUoZS50YXJnZXQpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIG9ic2VydmU6IG9ic2VydmVyLm9ic2VydmUuYmluZChvYnNlcnZlciksXG4gICAgICAgICAgICAgIHVub2JzZXJ2ZTogb2JzZXJ2ZXIudW5vYnNlcnZlLmJpbmQob2JzZXJ2ZXIpLFxuICAgICAgICAgICAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5tYXAoKG9mZikgPT4gb2ZmKCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdG9Ob2Rlcyh0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgICAgIGxldCBjb2xvciA9ICF0aGlzLnNlbEFjdGl2ZSB8fCBtYXRjaGVzKHRhcmdldCwgdGhpcy5zZWxBY3RpdmUpID8gZmluZFRhcmdldENvbG9yKHRhcmdldCkgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKGNvbG9yICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXBsYWNlQ2xhc3ModGFyZ2V0LCBcInVrLWxpZ2h0IHVrLWRhcmtcIiwgY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gZmluZFRhcmdldENvbG9yKHRhcmdldCkge1xuICAgICAgY29uc3QgZGltID0gZGltZW5zaW9ucyQxKHRhcmdldCk7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IGRpbWVuc2lvbnMkMSh3aW5kb3cpO1xuICAgICAgaWYgKCFpbnRlcnNlY3RSZWN0KGRpbSwgdmlld3BvcnQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgbGVmdCwgdG9wLCBoZWlnaHQsIHdpZHRoIH0gPSBkaW07XG4gICAgICBsZXQgbGFzdDtcbiAgICAgIGZvciAoY29uc3QgcGVyY2VudCBvZiBbMC4yNSwgMC41LCAwLjc1XSkge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRhcmdldC5vd25lckRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KFxuICAgICAgICAgIE1hdGgubWF4KDAsIE1hdGgubWluKGxlZnQgKyB3aWR0aCAqIHBlcmNlbnQsIHZpZXdwb3J0LndpZHRoIC0gMSkpLFxuICAgICAgICAgIE1hdGgubWF4KDAsIE1hdGgubWluKHRvcCArIGhlaWdodCAvIDIsIHZpZXdwb3J0LmhlaWdodCAtIDEpKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICBpZiAodGFyZ2V0LmNvbnRhaW5zKGVsZW1lbnQpIHx8ICFjaGVja1Zpc2liaWxpdHkoZWxlbWVudCkgfHwgZWxlbWVudC5jbG9zZXN0KCdbY2xhc3MqPVwiLWxlYXZlXCJdJykgJiYgZWxlbWVudHMuc29tZSgoZWwpID0+IGVsZW1lbnQgIT09IGVsICYmIG1hdGNoZXMoZWwsICdbY2xhc3MqPVwiLWVudGVyXCJdJykpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29sb3IgPSBjc3MoZWxlbWVudCwgXCItLXVrLWludmVyc2VcIik7XG4gICAgICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IgPT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGB1ay0ke2NvbG9yfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0ID0gY29sb3I7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsYXN0ID8gYHVrLSR7bGFzdH1gIDogXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tWaXNpYmlsaXR5KGVsZW1lbnQpIHtcbiAgICAgIGlmIChjc3MoZWxlbWVudCwgXCJ2aXNpYmlsaXR5XCIpICE9PSBcInZpc2libGVcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICBpZiAoY3NzKGVsZW1lbnQsIFwib3BhY2l0eVwiKSA9PT0gXCIwXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudCA9IHBhcmVudChlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsZWFkZXIgPSB7XG4gICAgICBtaXhpbnM6IFtDbGFzcywgTWVkaWFdLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgZmlsbDogU3RyaW5nXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBmaWxsOiBcIlwiLFxuICAgICAgICBjbHNXcmFwcGVyOiBcInVrLWxlYWRlci1maWxsXCIsXG4gICAgICAgIGNsc0hpZGU6IFwidWstbGVhZGVyLWhpZGVcIixcbiAgICAgICAgYXR0ckZpbGw6IFwiZGF0YS1maWxsXCJcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBmaWxsOiAoeyBmaWxsIH0sICRlbCkgPT4gZmlsbCB8fCBjc3MoJGVsLCBcIi0tdWstbGVhZGVyLWZpbGwtY29udGVudFwiKVxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgW3RoaXMud3JhcHBlcl0gPSB3cmFwSW5uZXIodGhpcy4kZWwsIGA8c3BhbiBjbGFzcz1cIiR7dGhpcy5jbHNXcmFwcGVyfVwiPmApO1xuICAgICAgfSxcbiAgICAgIGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdW53cmFwKHRoaXMud3JhcHBlci5jaGlsZE5vZGVzKTtcbiAgICAgIH0sXG4gICAgICBvYnNlcnZlOiByZXNpemUoKSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC50cnVuYyh0aGlzLiRlbC5vZmZzZXRXaWR0aCAvIDIpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGZpbGw6IHRoaXMuZmlsbCxcbiAgICAgICAgICAgIGhpZGU6ICF0aGlzLm1hdGNoTWVkaWFcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB3cml0ZSh7IHdpZHRoLCBmaWxsLCBoaWRlIH0pIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0aGlzLndyYXBwZXIsIHRoaXMuY2xzSGlkZSwgaGlkZSk7XG4gICAgICAgICAgYXR0cih0aGlzLndyYXBwZXIsIHRoaXMuYXR0ckZpbGwsIG5ldyBBcnJheSh3aWR0aCkuam9pbihmaWxsKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czogW1wicmVzaXplXCJdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBtb2RhbCA9IHtcbiAgICAgIGluc3RhbGwsXG4gICAgICBtaXhpbnM6IFtNb2RhbF0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNsc1BhZ2U6IFwidWstbW9kYWwtcGFnZVwiLFxuICAgICAgICBzZWxQYW5lbDogXCIudWstbW9kYWwtZGlhbG9nXCIsXG4gICAgICAgIHNlbENsb3NlOiAnW2NsYXNzKj1cInVrLW1vZGFsLWNsb3NlXCJdJ1xuICAgICAgfSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJmdWxsc2NyZWVuY2hhbmdlIHdlYmtpdGVuZGZ1bGxzY3JlZW5cIixcbiAgICAgICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKGlzVGFnKGUudGFyZ2V0LCBcInZpZGVvXCIpICYmIHRoaXMuaXNUb2dnbGVkKCkgJiYgIWRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmIChoYXNDbGFzcyh0aGlzLnBhbmVsLCBcInVrLW1hcmdpbi1hdXRvLXZlcnRpY2FsXCIpKSB7XG4gICAgICAgICAgICAgIGFkZENsYXNzKHRoaXMuJGVsLCBcInVrLWZsZXhcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjc3ModGhpcy4kZWwsIFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVpZ2h0KHRoaXMuJGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImhpZGRlblwiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgXCJkaXNwbGF5XCIsIFwiXCIpO1xuICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIFwidWstZmxleFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIGluc3RhbGwoeyBtb2RhbCB9KSB7XG4gICAgICBtb2RhbC5kaWFsb2cgPSBmdW5jdGlvbihjb250ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRpYWxvZyA9IG1vZGFsKCQoYDxkaXY+PGRpdiBjbGFzcz1cInVrLW1vZGFsLWRpYWxvZ1wiPiR7Y29udGVudH08L2Rpdj48L2Rpdj5gKSwge1xuICAgICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICAgIHJvbGU6IFwiYWxlcnRkaWFsb2dcIixcbiAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBkaWFsb2cuc2hvdygpO1xuICAgICAgICBvbihcbiAgICAgICAgICBkaWFsb2cuJGVsLFxuICAgICAgICAgIFwiaGlkZGVuXCIsXG4gICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICBkaWFsb2cuJGRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IHNlbGY6IHRydWUgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZGlhbG9nO1xuICAgICAgfTtcbiAgICAgIG1vZGFsLmFsZXJ0ID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3BlbkRpYWxvZyhcbiAgICAgICAgICAoeyBpMThuIH0pID0+IGA8ZGl2IGNsYXNzPVwidWstbW9kYWwtYm9keVwiPiR7aXNTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogaHRtbChtZXNzYWdlKX08L2Rpdj4gPGRpdiBjbGFzcz1cInVrLW1vZGFsLWZvb3RlciB1ay10ZXh0LXJpZ2h0XCI+IDxidXR0b24gY2xhc3M9XCJ1ay1idXR0b24gdWstYnV0dG9uLXByaW1hcnkgdWstbW9kYWwtY2xvc2VcIiBhdXRvZm9jdXM+JHtpMThuLm9rfTwvYnV0dG9uPiA8L2Rpdj5gLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBtb2RhbC5jb25maXJtID0gZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3BlbkRpYWxvZyhcbiAgICAgICAgICAoeyBpMThuIH0pID0+IGA8Zm9ybT4gPGRpdiBjbGFzcz1cInVrLW1vZGFsLWJvZHlcIj4ke2lzU3RyaW5nKG1lc3NhZ2UpID8gbWVzc2FnZSA6IGh0bWwobWVzc2FnZSl9PC9kaXY+IDxkaXYgY2xhc3M9XCJ1ay1tb2RhbC1mb290ZXIgdWstdGV4dC1yaWdodFwiPiA8YnV0dG9uIGNsYXNzPVwidWstYnV0dG9uIHVrLWJ1dHRvbi1kZWZhdWx0IHVrLW1vZGFsLWNsb3NlXCIgdHlwZT1cImJ1dHRvblwiPiR7aTE4bi5jYW5jZWx9PC9idXR0b24+IDxidXR0b24gY2xhc3M9XCJ1ay1idXR0b24gdWstYnV0dG9uLXByaW1hcnlcIiBhdXRvZm9jdXM+JHtpMThuLm9rfTwvYnV0dG9uPiA8L2Rpdj4gPC9mb3JtPmAsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAoKSA9PiBQcm9taXNlLnJlamVjdCgpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgbW9kYWwucHJvbXB0ID0gZnVuY3Rpb24obWVzc2FnZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG9wZW5EaWFsb2coXG4gICAgICAgICAgKHsgaTE4biB9KSA9PiBgPGZvcm0gY2xhc3M9XCJ1ay1mb3JtLXN0YWNrZWRcIj4gPGRpdiBjbGFzcz1cInVrLW1vZGFsLWJvZHlcIj4gPGxhYmVsPiR7aXNTdHJpbmcobWVzc2FnZSkgPyBtZXNzYWdlIDogaHRtbChtZXNzYWdlKX08L2xhYmVsPiA8aW5wdXQgY2xhc3M9XCJ1ay1pbnB1dFwiIGF1dG9mb2N1cz4gPC9kaXY+IDxkaXYgY2xhc3M9XCJ1ay1tb2RhbC1mb290ZXIgdWstdGV4dC1yaWdodFwiPiA8YnV0dG9uIGNsYXNzPVwidWstYnV0dG9uIHVrLWJ1dHRvbi1kZWZhdWx0IHVrLW1vZGFsLWNsb3NlXCIgdHlwZT1cImJ1dHRvblwiPiR7aTE4bi5jYW5jZWx9PC9idXR0b24+IDxidXR0b24gY2xhc3M9XCJ1ay1idXR0b24gdWstYnV0dG9uLXByaW1hcnlcIj4ke2kxOG4ub2t9PC9idXR0b24+IDwvZGl2PiA8L2Zvcm0+YCxcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICgpID0+IG51bGwsXG4gICAgICAgICAgKCkgPT4gaW5wdXQudmFsdWVcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgeyAkZWwgfSA9IHByb21pc2UuZGlhbG9nO1xuICAgICAgICBjb25zdCBpbnB1dCA9ICQoXCJpbnB1dFwiLCAkZWwpO1xuICAgICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlIHx8IFwiXCI7XG4gICAgICAgIG9uKCRlbCwgXCJzaG93XCIsICgpID0+IGlucHV0LnNlbGVjdCgpKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9O1xuICAgICAgbW9kYWwuaTE4biA9IHtcbiAgICAgICAgb2s6IFwiT2tcIixcbiAgICAgICAgY2FuY2VsOiBcIkNhbmNlbFwiXG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gb3BlbkRpYWxvZyh0bXBsLCBvcHRpb25zLCBoaWRlRm4gPSBub29wLCBzdWJtaXRGbiA9IG5vb3ApIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICBiZ0Nsb3NlOiBmYWxzZSxcbiAgICAgICAgICBlc2NDbG9zZTogdHJ1ZSxcbiAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgIGkxOG46IHsgLi4ubW9kYWwuaTE4biwgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5pMThuIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGlhbG9nID0gbW9kYWwuZGlhbG9nKHRtcGwob3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYXNzaWduKFxuICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvZmYgPSBvbihkaWFsb2cuJGVsLCBcImhpZGVcIiwgKCkgPT4gcmVzb2x2ZShoaWRlRm4oKSkpO1xuICAgICAgICAgICAgb24oZGlhbG9nLiRlbCwgXCJzdWJtaXRcIiwgXCJmb3JtXCIsIChlKSA9PiB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZShzdWJtaXRGbihkaWFsb2cpKTtcbiAgICAgICAgICAgICAgb2ZmKCk7XG4gICAgICAgICAgICAgIGRpYWxvZy5oaWRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IGRpYWxvZyB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5hdiA9IHtcbiAgICAgIGV4dGVuZHM6IEFjY29yZGlvbixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdGFyZ2V0czogXCI+IC51ay1wYXJlbnRcIixcbiAgICAgICAgdG9nZ2xlOiBcIj4gYVwiLFxuICAgICAgICBjb250ZW50OiBcIj4gdWxcIlxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBjbHNOYXZiYXJUcmFuc3BhcmVudCA9IFwidWstbmF2YmFyLXRyYW5zcGFyZW50XCI7XG4gICAgdmFyIG5hdmJhciA9IHtcbiAgICAgIGV4dGVuZHM6IERyb3BuYXYsXG4gICAgICBwcm9wczoge1xuICAgICAgICBkcm9wYmFyVHJhbnNwYXJlbnRNb2RlOiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBjbHNEcm9wOiBcInVrLW5hdmJhci1kcm9wZG93blwiLFxuICAgICAgICBzZWxOYXZJdGVtOiBcIi51ay1uYXZiYXItbmF2ID4gbGkgPiBhLGEudWstbmF2YmFyLWl0ZW0sYnV0dG9uLnVrLW5hdmJhci1pdGVtLC51ay1uYXZiYXItaXRlbSBhLC51ay1uYXZiYXItaXRlbSBidXR0b24sLnVrLW5hdmJhci10b2dnbGVcIixcbiAgICAgICAgLy8gU2ltcGxpZnkgd2l0aCA6d2hlcmUoKSBzZWxlY3RvciBvbmNlIGJyb3dzZXIgdGFyZ2V0IGlzIFNhZmFyaSAxNCtcbiAgICAgICAgZHJvcGJhclRyYW5zcGFyZW50TW9kZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBjb21wdXRlZDoge1xuICAgICAgICBuYXZiYXJDb250YWluZXI6IChfLCAkZWwpID0+ICRlbC5jbG9zZXN0KFwiLnVrLW5hdmJhci1jb250YWluZXJcIilcbiAgICAgIH0sXG4gICAgICB3YXRjaDoge1xuICAgICAgICBpdGVtcygpIHtcbiAgICAgICAgICBjb25zdCBqdXN0aWZ5ID0gaGFzQ2xhc3ModGhpcy4kZWwsIFwidWstbmF2YmFyLWp1c3RpZnlcIik7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVycyA9ICQkKFwiLnVrLW5hdmJhci1uYXYsIC51ay1uYXZiYXItbGVmdCwgLnVrLW5hdmJhci1yaWdodFwiLCB0aGlzLiRlbCk7XG4gICAgICAgICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgY29udGFpbmVycykge1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBqdXN0aWZ5ID8gJCQoXCIudWstbmF2YmFyLW5hdiA+IGxpID4gYSwgLnVrLW5hdmJhci1pdGVtLCAudWstbmF2YmFyLXRvZ2dsZVwiLCBjb250YWluZXIpLmxlbmd0aCA6IFwiXCI7XG4gICAgICAgICAgICBjc3MoY29udGFpbmVyLCBcImZsZXhHcm93XCIsIGl0ZW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBldmVudHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgIGVsOiAoeyBkcm9wQ29udGFpbmVyIH0pID0+IGRyb3BDb250YWluZXIsXG4gICAgICAgICAgaGFuZGxlcih7IHRhcmdldCB9KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUcmFuc3BhcmVudE1vZGUodGFyZ2V0KSA9PT0gXCJyZW1vdmVcIiAmJiBoYXNDbGFzcyh0aGlzLm5hdmJhckNvbnRhaW5lciwgY2xzTmF2YmFyVHJhbnNwYXJlbnQpKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMubmF2YmFyQ29udGFpbmVyLCBjbHNOYXZiYXJUcmFuc3BhcmVudCk7XG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImhpZGVcIixcbiAgICAgICAgICBlbDogKHsgZHJvcENvbnRhaW5lciB9KSA9PiBkcm9wQ29udGFpbmVyLFxuICAgICAgICAgIGFzeW5jIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBhd2FpdCBhd2FpdE1hY3JvVGFzaygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RyYW5zcGFyZW50ICYmICghYWN0aXZlIHx8ICF0aGlzLmRyb3BDb250YWluZXIuY29udGFpbnMoYWN0aXZlLiRlbCkpKSB7XG4gICAgICAgICAgICAgIGFkZENsYXNzKHRoaXMubmF2YmFyQ29udGFpbmVyLCBjbHNOYXZiYXJUcmFuc3BhcmVudCk7XG4gICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldFRyYW5zcGFyZW50TW9kZShlbCkge1xuICAgICAgICAgIGlmICghdGhpcy5uYXZiYXJDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZHJvcGJhciAmJiB0aGlzLmlzRHJvcGJhckRyb3AoZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wYmFyVHJhbnNwYXJlbnRNb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkcm9wID0gdGhpcy5nZXREcm9wZG93bihlbCk7XG4gICAgICAgICAgaWYgKGRyb3AgJiYgaGFzQ2xhc3MoZWwsIFwidWstZHJvcGJhclwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRyb3AuaW5zZXQgPyBcImJlaGluZFwiIDogXCJyZW1vdmVcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldERyb3BiYXJPZmZzZXQob2Zmc2V0VG9wKSB7XG4gICAgICAgICAgY29uc3QgeyB0b3AsIGhlaWdodCB9ID0gb2Zmc2V0KHRoaXMubmF2YmFyQ29udGFpbmVyKTtcbiAgICAgICAgICByZXR1cm4gdG9wICsgKHRoaXMuZHJvcGJhclRyYW5zcGFyZW50TW9kZSA9PT0gXCJiZWhpbmRcIiA/IDAgOiBoZWlnaHQgKyBvZmZzZXRUb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBhd2FpdE1hY3JvVGFzaygpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlKSk7XG4gICAgfVxuXG4gICAgdmFyIG9mZmNhbnZhcyA9IHtcbiAgICAgIG1peGluczogW01vZGFsXSxcbiAgICAgIGFyZ3M6IFwibW9kZVwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbW9kZTogU3RyaW5nLFxuICAgICAgICBmbGlwOiBCb29sZWFuLFxuICAgICAgICBvdmVybGF5OiBCb29sZWFuLFxuICAgICAgICBzd2lwaW5nOiBCb29sZWFuXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBtb2RlOiBcInNsaWRlXCIsXG4gICAgICAgIGZsaXA6IGZhbHNlLFxuICAgICAgICBvdmVybGF5OiBmYWxzZSxcbiAgICAgICAgY2xzUGFnZTogXCJ1ay1vZmZjYW52YXMtcGFnZVwiLFxuICAgICAgICBjbHNDb250YWluZXI6IFwidWstb2ZmY2FudmFzLWNvbnRhaW5lclwiLFxuICAgICAgICBzZWxQYW5lbDogXCIudWstb2ZmY2FudmFzLWJhclwiLFxuICAgICAgICBjbHNGbGlwOiBcInVrLW9mZmNhbnZhcy1mbGlwXCIsXG4gICAgICAgIGNsc0NvbnRhaW5lckFuaW1hdGlvbjogXCJ1ay1vZmZjYW52YXMtY29udGFpbmVyLWFuaW1hdGlvblwiLFxuICAgICAgICBjbHNTaWRlYmFyQW5pbWF0aW9uOiBcInVrLW9mZmNhbnZhcy1iYXItYW5pbWF0aW9uXCIsXG4gICAgICAgIGNsc01vZGU6IFwidWstb2ZmY2FudmFzXCIsXG4gICAgICAgIGNsc092ZXJsYXk6IFwidWstb2ZmY2FudmFzLW92ZXJsYXlcIixcbiAgICAgICAgc2VsQ2xvc2U6IFwiLnVrLW9mZmNhbnZhcy1jbG9zZVwiLFxuICAgICAgICBjb250YWluZXI6IGZhbHNlLFxuICAgICAgICBzd2lwaW5nOiB0cnVlXG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgY2xzRmxpcDogKHsgZmxpcCwgY2xzRmxpcCB9KSA9PiBmbGlwID8gY2xzRmxpcCA6IFwiXCIsXG4gICAgICAgIGNsc092ZXJsYXk6ICh7IG92ZXJsYXksIGNsc092ZXJsYXkgfSkgPT4gb3ZlcmxheSA/IGNsc092ZXJsYXkgOiBcIlwiLFxuICAgICAgICBjbHNNb2RlOiAoeyBtb2RlLCBjbHNNb2RlIH0pID0+IGAke2Nsc01vZGV9LSR7bW9kZX1gLFxuICAgICAgICBjbHNTaWRlYmFyQW5pbWF0aW9uOiAoeyBtb2RlLCBjbHNTaWRlYmFyQW5pbWF0aW9uIH0pID0+IG1vZGUgPT09IFwibm9uZVwiIHx8IG1vZGUgPT09IFwicmV2ZWFsXCIgPyBcIlwiIDogY2xzU2lkZWJhckFuaW1hdGlvbixcbiAgICAgICAgY2xzQ29udGFpbmVyQW5pbWF0aW9uOiAoeyBtb2RlLCBjbHNDb250YWluZXJBbmltYXRpb24gfSkgPT4gbW9kZSAhPT0gXCJwdXNoXCIgJiYgbW9kZSAhPT0gXCJyZXZlYWxcIiA/IFwiXCIgOiBjbHNDb250YWluZXJBbmltYXRpb24sXG4gICAgICAgIHRyYW5zaXRpb25FbGVtZW50KHsgbW9kZSB9KSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGUgPT09IFwicmV2ZWFsXCIgPyBwYXJlbnQodGhpcy5wYW5lbCkgOiB0aGlzLnBhbmVsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb2JzZXJ2ZTogc3dpcGUoeyBmaWx0ZXI6ICh7IHN3aXBpbmcgfSkgPT4gc3dpcGluZyB9KSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICByZWFkKCkge1xuICAgICAgICAgIGlmICh0aGlzLmlzVG9nZ2xlZCgpICYmICFpc1Zpc2libGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czogW1wicmVzaXplXCJdXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInRvdWNobW92ZVwiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgICAgZmlsdGVyOiAoeyBvdmVybGF5IH0pID0+IG92ZXJsYXksXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBlLmNhbmNlbGFibGUgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2hvd1wiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwicmV2ZWFsXCIgJiYgIWhhc0NsYXNzKHBhcmVudCh0aGlzLnBhbmVsKSwgdGhpcy5jbHNNb2RlKSkge1xuICAgICAgICAgICAgICBhZGRDbGFzcyh3cmFwQWxsKHRoaXMucGFuZWwsIFwiPGRpdj5cIiksIHRoaXMuY2xzTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGJvZHksIHNjcm9sbGluZ0VsZW1lbnQgfSA9IGRvY3VtZW50O1xuICAgICAgICAgICAgYWRkQ2xhc3MoYm9keSwgdGhpcy5jbHNDb250YWluZXIsIHRoaXMuY2xzRmxpcCk7XG4gICAgICAgICAgICBjc3MoYm9keSwgXCJ0b3VjaEFjdGlvblwiLCBcInBhbi15IHBpbmNoLXpvb21cIik7XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsIFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xuICAgICAgICAgICAgY3NzKHRoaXMucGFuZWwsIFwibWF4V2lkdGhcIiwgc2Nyb2xsaW5nRWxlbWVudC5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNPdmVybGF5KTtcbiAgICAgICAgICAgIGFkZENsYXNzKFxuICAgICAgICAgICAgICB0aGlzLnBhbmVsLFxuICAgICAgICAgICAgICB0aGlzLmNsc1NpZGViYXJBbmltYXRpb24sXG4gICAgICAgICAgICAgIHRoaXMubW9kZSA9PT0gXCJyZXZlYWxcIiA/IFwiXCIgOiB0aGlzLmNsc01vZGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBoZWlnaHQoYm9keSk7XG4gICAgICAgICAgICBhZGRDbGFzcyhib2R5LCB0aGlzLmNsc0NvbnRhaW5lckFuaW1hdGlvbik7XG4gICAgICAgICAgICB0aGlzLmNsc0NvbnRhaW5lckFuaW1hdGlvbiAmJiBzdXBwcmVzc1VzZXJTY2FsZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaGlkZVwiLFxuICAgICAgICAgIHNlbGY6IHRydWUsXG4gICAgICAgICAgaGFuZGxlcigpIHtcbiAgICAgICAgICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIHRoaXMuY2xzQ29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCBcInRvdWNoQWN0aW9uXCIsIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiaGlkZGVuXCIsXG4gICAgICAgICAgc2VsZjogdHJ1ZSxcbiAgICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgICAgdGhpcy5jbHNDb250YWluZXJBbmltYXRpb24gJiYgcmVzdW1lVXNlclNjYWxlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5tb2RlID09PSBcInJldmVhbFwiICYmIGhhc0NsYXNzKHBhcmVudCh0aGlzLnBhbmVsKSwgdGhpcy5jbHNNb2RlKSkge1xuICAgICAgICAgICAgICB1bndyYXAodGhpcy5wYW5lbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLnBhbmVsLCB0aGlzLmNsc1NpZGViYXJBbmltYXRpb24sIHRoaXMuY2xzTW9kZSk7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNPdmVybGF5KTtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgXCJkaXNwbGF5XCIsIFwiXCIpO1xuICAgICAgICAgICAgY3NzKHRoaXMucGFuZWwsIFwibWF4V2lkdGhcIiwgXCJcIik7XG4gICAgICAgICAgICByZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCB0aGlzLmNsc0NvbnRhaW5lciwgdGhpcy5jbHNGbGlwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInN3aXBlTGVmdCBzd2lwZVJpZ2h0XCIsXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RvZ2dsZWQoKSAmJiBlbmRzV2l0aChlLnR5cGUsIFwiTGVmdFwiKSBeIHRoaXMuZmxpcCkge1xuICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIGZ1bmN0aW9uIHN1cHByZXNzVXNlclNjYWxlKCkge1xuICAgICAgZ2V0Vmlld3BvcnQoKS5jb250ZW50ICs9IFwiLHVzZXItc2NhbGFibGU9MFwiO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZXN1bWVVc2VyU2NhbGUoKSB7XG4gICAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0KCk7XG4gICAgICB2aWV3cG9ydC5jb250ZW50ID0gdmlld3BvcnQuY29udGVudC5yZXBsYWNlKC8sdXNlci1zY2FsYWJsZT0wJC8sIFwiXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydCgpIHtcbiAgICAgIHJldHVybiAkKCdtZXRhW25hbWU9XCJ2aWV3cG9ydFwiXScsIGRvY3VtZW50LmhlYWQpIHx8IGFwcGVuZChkb2N1bWVudC5oZWFkLCAnPG1ldGEgbmFtZT1cInZpZXdwb3J0XCI+Jyk7XG4gICAgfVxuXG4gICAgdmFyIG92ZXJmbG93QXV0byA9IHtcbiAgICAgIG1peGluczogW0NsYXNzXSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHNlbENvbnRhaW5lcjogU3RyaW5nLFxuICAgICAgICBzZWxDb250ZW50OiBTdHJpbmcsXG4gICAgICAgIG1pbkhlaWdodDogTnVtYmVyXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBzZWxDb250YWluZXI6IFwiLnVrLW1vZGFsXCIsXG4gICAgICAgIHNlbENvbnRlbnQ6IFwiLnVrLW1vZGFsLWRpYWxvZ1wiLFxuICAgICAgICBtaW5IZWlnaHQ6IDE1MFxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbnRhaW5lcjogKHsgc2VsQ29udGFpbmVyIH0sICRlbCkgPT4gJGVsLmNsb3Nlc3Qoc2VsQ29udGFpbmVyKSxcbiAgICAgICAgY29udGVudDogKHsgc2VsQ29udGVudCB9LCAkZWwpID0+ICRlbC5jbG9zZXN0KHNlbENvbnRlbnQpXG4gICAgICB9LFxuICAgICAgb2JzZXJ2ZTogcmVzaXplKHtcbiAgICAgICAgdGFyZ2V0OiAoeyBjb250YWluZXIsIGNvbnRlbnQgfSkgPT4gW2NvbnRhaW5lciwgY29udGVudF1cbiAgICAgIH0pLFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQgfHwgIXRoaXMuY29udGFpbmVyIHx8ICFpc1Zpc2libGUodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXg6IE1hdGgubWF4KFxuICAgICAgICAgICAgICB0aGlzLm1pbkhlaWdodCxcbiAgICAgICAgICAgICAgaGVpZ2h0KHRoaXMuY29udGFpbmVyKSAtIChkaW1lbnNpb25zJDEodGhpcy5jb250ZW50KS5oZWlnaHQgLSBoZWlnaHQodGhpcy4kZWwpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRlKHsgbWF4IH0pIHtcbiAgICAgICAgICBjc3ModGhpcy4kZWwsIHsgbWluSGVpZ2h0OiB0aGlzLm1pbkhlaWdodCwgbWF4SGVpZ2h0OiBtYXggfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czogW1wicmVzaXplXCJdXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNwb25zaXZlID0ge1xuICAgICAgcHJvcHM6IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgXCJ1ay1yZXNwb25zaXZlLXdpZHRoXCIpO1xuICAgICAgICBjc3ModGhpcy4kZWwsIFwiYXNwZWN0UmF0aW9cIiwgYCR7dGhpcy53aWR0aH0vJHt0aGlzLmhlaWdodH1gKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNjcm9sbCA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIG9mZnNldDogTnVtYmVyXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBvZmZzZXQ6IDBcbiAgICAgIH0sXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJlZ2lzdGVyQ2xpY2sodGhpcyk7XG4gICAgICB9LFxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICB1bnJlZ2lzdGVyQ2xpY2sodGhpcyk7XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBzY3JvbGxUbyhlbCkge1xuICAgICAgICAgIGVsID0gZWwgJiYgJChlbCkgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICBpZiAodHJpZ2dlcih0aGlzLiRlbCwgXCJiZWZvcmVzY3JvbGxcIiwgW3RoaXMsIGVsXSkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNjcm9sbEludG9WaWV3KGVsLCB7IG9mZnNldDogdGhpcy5vZmZzZXQgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyKHRoaXMuJGVsLCBcInNjcm9sbGVkXCIsIFt0aGlzLCBlbF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmdW5jdGlvbiByZWdpc3RlckNsaWNrKGNtcCkge1xuICAgICAgaWYgKCFpbnN0YW5jZXMuc2l6ZSkge1xuICAgICAgICBvbihkb2N1bWVudCwgXCJjbGlja1wiLCBjbGlja0hhbmRsZXIpO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2VzLmFkZChjbXApO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyQ2xpY2soY21wKSB7XG4gICAgICBpbnN0YW5jZXMuZGVsZXRlKGNtcCk7XG4gICAgICBpZiAoIWluc3RhbmNlcy5zaXplKSB7XG4gICAgICAgIG9mZihkb2N1bWVudCwgXCJjbGlja1wiLCBjbGlja0hhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbGlja0hhbmRsZXIoZSkge1xuICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICBpZiAoaW5zdGFuY2UuJGVsLmNvbnRhaW5zKGUudGFyZ2V0KSAmJiBpc1NhbWVTaXRlQW5jaG9yKGluc3RhbmNlLiRlbCkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgaWYgKHdpbmRvdy5sb2NhdGlvbi5ocmVmICE9PSBpbnN0YW5jZS4kZWwuaHJlZikge1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHt9LCBcIlwiLCBpbnN0YW5jZS4kZWwuaHJlZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RhbmNlLnNjcm9sbFRvKGdldFRhcmdldGVkRWxlbWVudChpbnN0YW5jZS4kZWwpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNsc0luVmlldyA9IFwidWstc2Nyb2xsc3B5LWludmlld1wiO1xuICAgIHZhciBzY3JvbGxzcHkgPSB7XG4gICAgICBhcmdzOiBcImNsc1wiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY2xzOiBTdHJpbmcsXG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICBoaWRkZW46IEJvb2xlYW4sXG4gICAgICAgIG1hcmdpbjogU3RyaW5nLFxuICAgICAgICByZXBlYXQ6IEJvb2xlYW4sXG4gICAgICAgIGRlbGF5OiBOdW1iZXJcbiAgICAgIH0sXG4gICAgICBkYXRhOiAoKSA9PiAoe1xuICAgICAgICBjbHM6IFwiXCIsXG4gICAgICAgIHRhcmdldDogZmFsc2UsXG4gICAgICAgIGhpZGRlbjogdHJ1ZSxcbiAgICAgICAgbWFyZ2luOiBcIi0xcHhcIixcbiAgICAgICAgcmVwZWF0OiBmYWxzZSxcbiAgICAgICAgZGVsYXk6IDBcbiAgICAgIH0pLFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgZWxlbWVudHM6ICh7IHRhcmdldCB9LCAkZWwpID0+IHRhcmdldCA/ICQkKHRhcmdldCwgJGVsKSA6IFskZWxdXG4gICAgICB9LFxuICAgICAgd2F0Y2g6IHtcbiAgICAgICAgZWxlbWVudHMoZWxlbWVudHMpIHtcbiAgICAgICAgICBpZiAodGhpcy5oaWRkZW4pIHtcbiAgICAgICAgICAgIGNzcyhmaWx0ZXIkMShlbGVtZW50cywgYDpub3QoLiR7Y2xzSW5WaWV3fSlgKSwgXCJvcGFjaXR5XCIsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50RGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICB9LFxuICAgICAgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtlbCwgc3RhdGVdIG9mIHRoaXMuZWxlbWVudERhdGEuZW50cmllcygpKSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3MoZWwsIGNsc0luVmlldywgKHN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5jbHMpIHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmVsZW1lbnREYXRhO1xuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IGludGVyc2VjdGlvbih7XG4gICAgICAgIHRhcmdldDogKHsgZWxlbWVudHMgfSkgPT4gZWxlbWVudHMsXG4gICAgICAgIGhhbmRsZXIocmVjb3Jkcykge1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5lbGVtZW50RGF0YTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHsgdGFyZ2V0OiBlbCwgaXNJbnRlcnNlY3RpbmcgfSBvZiByZWNvcmRzKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRzLmhhcyhlbCkpIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMuc2V0KGVsLCB7XG4gICAgICAgICAgICAgICAgY2xzOiBkYXRhKGVsLCBcInVrLXNjcm9sbHNweS1jbGFzc1wiKSB8fCB0aGlzLmNsc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZWxlbWVudHMuZ2V0KGVsKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXBlYXQgJiYgc3RhdGUuc2hvdykge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnNob3cgPSBpc0ludGVyc2VjdGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zOiAoeyBtYXJnaW4gfSkgPT4gKHsgcm9vdE1hcmdpbjogbWFyZ2luIH0pLFxuICAgICAgICBhcmdzOiB7IGludGVyc2VjdGluZzogZmFsc2UgfVxuICAgICAgfSksXG4gICAgICB1cGRhdGU6IFtcbiAgICAgICAge1xuICAgICAgICAgIHdyaXRlKGRhdGEpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2VsLCBzdGF0ZV0gb2YgdGhpcy5lbGVtZW50RGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLnNob3cgJiYgIXN0YXRlLmludmlldyAmJiAhc3RhdGUucXVldWVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkYXRhLnByb21pc2UgPSAoZGF0YS5wcm9taXNlIHx8IFByb21pc2UucmVzb2x2ZSgpKS50aGVuKCgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHRoaXMuZGVsYXkpKSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZShlbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucXVldWVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnNob3cgJiYgc3RhdGUuaW52aWV3ICYmICFzdGF0ZS5xdWV1ZWQgJiYgdGhpcy5yZXBlYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZShlbCwgZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICB0b2dnbGUoZWwsIGludmlldykge1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSAoX2EgPSB0aGlzLmVsZW1lbnREYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0KGVsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIChfYiA9IHN0YXRlLm9mZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoc3RhdGUpO1xuICAgICAgICAgIGNzcyhlbCwgXCJvcGFjaXR5XCIsICFpbnZpZXcgJiYgdGhpcy5oaWRkZW4gPyAwIDogXCJcIik7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIGNsc0luVmlldywgaW52aWV3KTtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhlbCwgc3RhdGUuY2xzKTtcbiAgICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgICAgaWYgKG1hdGNoID0gc3RhdGUuY2xzLm1hdGNoKC9cXGJ1ay1hbmltYXRpb24tW1xcdy1dKy9nKSkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlQW5pbWF0aW9uQ2xhc3NlcyA9ICgpID0+IHJlbW92ZUNsYXNzKGVsLCBtYXRjaCk7XG4gICAgICAgICAgICBpZiAoaW52aWV3KSB7XG4gICAgICAgICAgICAgIHN0YXRlLm9mZiA9IG9uY2UoZWwsIFwiYW5pbWF0aW9uY2FuY2VsIGFuaW1hdGlvbmVuZFwiLCByZW1vdmVBbmltYXRpb25DbGFzc2VzLCB7XG4gICAgICAgICAgICAgICAgc2VsZjogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbW92ZUFuaW1hdGlvbkNsYXNzZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJpZ2dlcihlbCwgaW52aWV3ID8gXCJpbnZpZXdcIiA6IFwib3V0dmlld1wiKTtcbiAgICAgICAgICBzdGF0ZS5pbnZpZXcgPSBpbnZpZXc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNjcm9sbHNweU5hdiA9IHtcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsczogU3RyaW5nLFxuICAgICAgICBjbG9zZXN0OiBCb29sZWFuLFxuICAgICAgICBzY3JvbGw6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldDogU3RyaW5nLFxuICAgICAgICBvZmZzZXQ6IE51bWJlclxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgY2xzOiBcInVrLWFjdGl2ZVwiLFxuICAgICAgICBjbG9zZXN0OiBmYWxzZSxcbiAgICAgICAgc2Nyb2xsOiBmYWxzZSxcbiAgICAgICAgdGFyZ2V0OiAnYVtocmVmXTpub3QoW3JvbGU9XCJidXR0b25cIl0pJyxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgbGlua3M6ICh7IHRhcmdldCB9LCAkZWwpID0+ICQkKHRhcmdldCwgJGVsKS5maWx0ZXIoKGVsKSA9PiBpc1NhbWVTaXRlQW5jaG9yKGVsKSksXG4gICAgICAgIGVsZW1lbnRzKHsgY2xvc2VzdCB9KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGlua3MubWFwKChlbCkgPT4gZWwuY2xvc2VzdChjbG9zZXN0IHx8IFwiKlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB3YXRjaDoge1xuICAgICAgICBsaW5rcyhsaW5rcykge1xuICAgICAgICAgIGlmICh0aGlzLnNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy4kY3JlYXRlKFwic2Nyb2xsXCIsIGxpbmtzLCB7IG9mZnNldDogdGhpcy5vZmZzZXQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb2JzZXJ2ZTogW2ludGVyc2VjdGlvbigpLCBzY3JvbGwkMSgpXSxcbiAgICAgIHVwZGF0ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgcmVhZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldHMgPSB0aGlzLmxpbmtzLm1hcCgoZWwpID0+IGdldFRhcmdldGVkRWxlbWVudChlbCkpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSB0YXJnZXRzO1xuICAgICAgICAgICAgaWYgKCFsZW5ndGggfHwgIWlzVmlzaWJsZSh0aGlzLiRlbCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHNjcm9sbFBhcmVudCh0YXJnZXRzLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQgfSA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IG9mZnNldFZpZXdwb3J0KHNjcm9sbEVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gc2Nyb2xsSGVpZ2h0IC0gdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNjcm9sbFRvcCA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgYWN0aXZlID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9mZnNldEJ5ID0gdGhpcy5vZmZzZXQgKyBkaW1lbnNpb25zJDEoZ2V0Q292ZXJpbmdFbGVtZW50KCkpLmhlaWdodCArIHZpZXdwb3J0LmhlaWdodCAqIDAuMTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCh0YXJnZXRzW2ldKS50b3AgLSB2aWV3cG9ydC50b3AgLSBvZmZzZXRCeSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY3RpdmUgPSAraTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgYWN0aXZlIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cml0ZSh7IGFjdGl2ZSB9KSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gYWN0aXZlICE9PSBmYWxzZSAmJiAhaGFzQ2xhc3ModGhpcy5lbGVtZW50c1thY3RpdmVdLCB0aGlzLmNscyk7XG4gICAgICAgICAgICB0aGlzLmxpbmtzLmZvckVhY2goKGVsKSA9PiBlbC5ibHVyKCkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRvZ2dsZUNsYXNzKHRoaXMuZWxlbWVudHNbaV0sIHRoaXMuY2xzLCAraSA9PT0gYWN0aXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsIFwiYWN0aXZlXCIsIFthY3RpdmUsIHRoaXMuZWxlbWVudHNbYWN0aXZlXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZXZlbnRzOiBbXCJzY3JvbGxcIiwgXCJyZXNpemVcIl1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG5cbiAgICB2YXIgc3RpY2t5ID0ge1xuICAgICAgbWl4aW5zOiBbQ2xhc3MsIE1lZGlhXSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHBvc2l0aW9uOiBTdHJpbmcsXG4gICAgICAgIHRvcDogbnVsbCxcbiAgICAgICAgYm90dG9tOiBudWxsLFxuICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICBvZmZzZXQ6IFN0cmluZyxcbiAgICAgICAgb2Zmc2V0RW5kOiBTdHJpbmcsXG4gICAgICAgIG92ZXJmbG93RmxpcDogQm9vbGVhbixcbiAgICAgICAgYW5pbWF0aW9uOiBTdHJpbmcsXG4gICAgICAgIGNsc0FjdGl2ZTogU3RyaW5nLFxuICAgICAgICBjbHNJbmFjdGl2ZTogU3RyaW5nLFxuICAgICAgICBjbHNGaXhlZDogU3RyaW5nLFxuICAgICAgICBjbHNCZWxvdzogU3RyaW5nLFxuICAgICAgICBzZWxUYXJnZXQ6IFN0cmluZyxcbiAgICAgICAgc2hvd09uVXA6IEJvb2xlYW4sXG4gICAgICAgIHRhcmdldE9mZnNldDogTnVtYmVyXG4gICAgICB9LFxuICAgICAgZGF0YToge1xuICAgICAgICBwb3NpdGlvbjogXCJ0b3BcIixcbiAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgYm90dG9tOiBmYWxzZSxcbiAgICAgICAgc3RhcnQ6IGZhbHNlLFxuICAgICAgICBlbmQ6IGZhbHNlLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIG9mZnNldEVuZDogMCxcbiAgICAgICAgb3ZlcmZsb3dGbGlwOiBmYWxzZSxcbiAgICAgICAgYW5pbWF0aW9uOiBcIlwiLFxuICAgICAgICBjbHNBY3RpdmU6IFwidWstYWN0aXZlXCIsXG4gICAgICAgIGNsc0luYWN0aXZlOiBcIlwiLFxuICAgICAgICBjbHNGaXhlZDogXCJ1ay1zdGlja3ktZml4ZWRcIixcbiAgICAgICAgY2xzQmVsb3c6IFwidWstc3RpY2t5LWJlbG93XCIsXG4gICAgICAgIHNlbFRhcmdldDogXCJcIixcbiAgICAgICAgc2hvd09uVXA6IGZhbHNlLFxuICAgICAgICB0YXJnZXRPZmZzZXQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY29tcHV0ZWQ6IHtcbiAgICAgICAgdGFyZ2V0OiAoeyBzZWxUYXJnZXQgfSwgJGVsKSA9PiBzZWxUYXJnZXQgJiYgJChzZWxUYXJnZXQsICRlbCkgfHwgJGVsXG4gICAgICB9LFxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gY29lcmNlKHRoaXMuc3RhcnQgfHwgdGhpcy50b3ApO1xuICAgICAgICB0aGlzLmVuZCA9IGNvZXJjZSh0aGlzLmVuZCB8fCB0aGlzLmJvdHRvbSk7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSAkKFwiKyAudWstc3RpY2t5LXBsYWNlaG9sZGVyXCIsIHRoaXMuJGVsKSB8fCAkKCc8ZGl2IGNsYXNzPVwidWstc3RpY2t5LXBsYWNlaG9sZGVyXCI+PC9kaXY+Jyk7XG4gICAgICAgIHRoaXMuaXNGaXhlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldEFjdGl2ZShmYWxzZSk7XG4gICAgICB9LFxuICAgICAgYmVmb3JlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaXhlZCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmNsc0luYWN0aXZlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNldCh0aGlzLiRlbCk7XG4gICAgICAgIHJlbW92ZSQxKHRoaXMucGxhY2Vob2xkZXIpO1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICBvYnNlcnZlOiBbXG4gICAgICAgIHZpZXdwb3J0KCksXG4gICAgICAgIHNjcm9sbCQxKHsgdGFyZ2V0OiAoKSA9PiBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IH0pLFxuICAgICAgICByZXNpemUoe1xuICAgICAgICAgIHRhcmdldDogKHsgJGVsIH0pID0+IFskZWwsIGdldFZpc2libGVQYXJlbnQoJGVsKSwgZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudF0sXG4gICAgICAgICAgaGFuZGxlcihlbnRyaWVzKSB7XG4gICAgICAgICAgICB0aGlzLiRlbWl0KFxuICAgICAgICAgICAgICB0aGlzLl9kYXRhLnJlc2l6ZWQgJiYgZW50cmllcy5zb21lKCh7IHRhcmdldCB9KSA9PiB0YXJnZXQgPT09IGdldFZpc2libGVQYXJlbnQodGhpcy4kZWwpKSA/IFwidXBkYXRlXCIgOiBcInJlc2l6ZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5fZGF0YS5yZXNpemVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBdLFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImxvYWQgaGFzaGNoYW5nZSBwb3BzdGF0ZVwiLFxuICAgICAgICAgIGVsOiAoKSA9PiB3aW5kb3csXG4gICAgICAgICAgZmlsdGVyOiAoeyB0YXJnZXRPZmZzZXQgfSkgPT4gdGFyZ2V0T2Zmc2V0ICE9PSBmYWxzZSxcbiAgICAgICAgICBoYW5kbGVyKCkge1xuICAgICAgICAgICAgY29uc3QgeyBzY3JvbGxpbmdFbGVtZW50IH0gPSBkb2N1bWVudDtcbiAgICAgICAgICAgIGlmICghbG9jYXRpb24uaGFzaCB8fCBzY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0T2Zmc2V0ID0gb2Zmc2V0KCQobG9jYXRpb24uaGFzaCkpO1xuICAgICAgICAgICAgICBjb25zdCBlbE9mZnNldCA9IG9mZnNldCh0aGlzLiRlbCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzRml4ZWQgJiYgaW50ZXJzZWN0UmVjdCh0YXJnZXRPZmZzZXQsIGVsT2Zmc2V0KSkge1xuICAgICAgICAgICAgICAgIHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wID0gTWF0aC5jZWlsKFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0T2Zmc2V0LnRvcCAtIGVsT2Zmc2V0LmhlaWdodCAtIHRvUHgodGhpcy50YXJnZXRPZmZzZXQsIFwiaGVpZ2h0XCIsIHRoaXMucGxhY2Vob2xkZXIpIC0gdG9QeCh0aGlzLm9mZnNldCwgXCJoZWlnaHRcIiwgdGhpcy5wbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB1cGRhdGU6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJlYWQoeyBoZWlnaHQ6IGhlaWdodCQxLCB3aWR0aCwgbWFyZ2luLCBzdGlja3kgfSwgdHlwZXMpIHtcbiAgICAgICAgICAgIHRoaXMuaW5hY3RpdmUgPSAhdGhpcy5tYXRjaE1lZGlhIHx8ICFpc1Zpc2libGUodGhpcy4kZWwpIHx8ICF0aGlzLiRlbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmFjdGl2ZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljVmlld3BvcnQgPSBoZWlnaHQod2luZG93KTtcbiAgICAgICAgICAgIGNvbnN0IG1heFNjcm9sbEhlaWdodCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbEhlaWdodCAtIGR5bmFtaWNWaWV3cG9ydFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghbWF4U2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoaWRlID0gdGhpcy5pc0ZpeGVkICYmIHR5cGVzLmhhcyhcInVwZGF0ZVwiKTtcbiAgICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgIHByZXZlbnRUcmFuc2l0aW9uKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICh7IGhlaWdodDogaGVpZ2h0JDEsIHdpZHRoIH0gPSBkaW1lbnNpb25zJDEodGhpcy4kZWwpKTtcbiAgICAgICAgICAgICAgbWFyZ2luID0gY3NzKHRoaXMuJGVsLCBcIm1hcmdpblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQyID0gdG9QeChcIjEwMHZoXCIsIFwiaGVpZ2h0XCIpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLm92ZXJmbG93RmxpcCAmJiBoZWlnaHQkMSA+IHZpZXdwb3J0Mikge1xuICAgICAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSBcInRvcFwiID8gXCJib3R0b21cIiA6IFwidG9wXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5pc0ZpeGVkID8gdGhpcy5wbGFjZWhvbGRlciA6IHRoaXMuJGVsO1xuICAgICAgICAgICAgbGV0IFtvZmZzZXQkMSwgb2Zmc2V0RW5kXSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXRFbmRdLm1hcChcbiAgICAgICAgICAgICAgKHZhbHVlKSA9PiB0b1B4KHZhbHVlLCBcImhlaWdodFwiLCBzdGlja3kgPyB0aGlzLiRlbCA6IHJlZmVyZW5jZUVsZW1lbnQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSBcImJvdHRvbVwiICYmIChoZWlnaHQkMSA8IGR5bmFtaWNWaWV3cG9ydCB8fCB0aGlzLm92ZXJmbG93RmxpcCkpIHtcbiAgICAgICAgICAgICAgb2Zmc2V0JDEgKz0gZHluYW1pY1ZpZXdwb3J0IC0gaGVpZ2h0JDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50Qm94ID0gaGVpZ2h0JDEgKyBvZmZzZXQkMSArIG9mZnNldEVuZDtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93ID0gdGhpcy5vdmVyZmxvd0ZsaXAgPyAwIDogTWF0aC5tYXgoMCwgZWxlbWVudEJveCAtIHZpZXdwb3J0Mik7XG4gICAgICAgICAgICBjb25zdCB0b3BPZmZzZXQgPSBvZmZzZXQocmVmZXJlbmNlRWxlbWVudCkudG9wIC0gLy8gb2Zmc2V0IHBvc3NpYmxlIGB0cmFuc2Zvcm06IHRyYW5zbGF0ZVlgIGFuaW1hdGlvbiAndWstYW5pbWF0aW9uLXNsaWRlLXRvcCcgd2hpbGUgaGlkaW5nXG4gICAgICAgICAgICBuZXcgRE9NTWF0cml4KGNzcyhyZWZlcmVuY2VFbGVtZW50LCBcInRyYW5zZm9ybVwiKSkubTQyO1xuICAgICAgICAgICAgY29uc3QgZWxIZWlnaHQgPSBkaW1lbnNpb25zJDEodGhpcy4kZWwpLmhlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gKHRoaXMuc3RhcnQgPT09IGZhbHNlID8gdG9wT2Zmc2V0IDogcGFyc2VQcm9wKHRoaXMuc3RhcnQsIHRoaXMuJGVsLCB0b3BPZmZzZXQpKSAtIG9mZnNldCQxO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5lbmQgPT09IGZhbHNlID8gbWF4U2Nyb2xsSGVpZ2h0IDogTWF0aC5taW4oXG4gICAgICAgICAgICAgIG1heFNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAgcGFyc2VQcm9wKHRoaXMuZW5kLCB0aGlzLiRlbCwgdG9wT2Zmc2V0ICsgaGVpZ2h0JDEsIHRydWUpIC0gZWxIZWlnaHQgLSBvZmZzZXQkMSArIG92ZXJmbG93XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc3RpY2t5ID0gIXRoaXMuc2hvd09uVXAgJiYgc3RhcnQgKyBvZmZzZXQkMSA9PT0gdG9wT2Zmc2V0ICYmIGVuZCA9PT0gTWF0aC5taW4oXG4gICAgICAgICAgICAgIG1heFNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAgcGFyc2VQcm9wKHRydWUsIHRoaXMuJGVsLCAwLCB0cnVlKSAtIGVsSGVpZ2h0IC0gb2Zmc2V0JDEgKyBvdmVyZmxvd1xuICAgICAgICAgICAgKSAmJiBjc3MoZ2V0VmlzaWJsZVBhcmVudCh0aGlzLiRlbCksIFwib3ZlcmZsb3dZXCIpICE9PSBcImhpZGRlblwiO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQkMSxcbiAgICAgICAgICAgICAgb3ZlcmZsb3csXG4gICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0JDEsXG4gICAgICAgICAgICAgIGVsSGVpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgbWFyZ2luLFxuICAgICAgICAgICAgICB0b3A6IG9mZnNldFBvc2l0aW9uKHJlZmVyZW5jZUVsZW1lbnQpWzBdLFxuICAgICAgICAgICAgICBzdGlja3ksXG4gICAgICAgICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydDIsXG4gICAgICAgICAgICAgIG1heFNjcm9sbEhlaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRlKHsgaGVpZ2h0LCB3aWR0aCwgbWFyZ2luLCBvZmZzZXQsIHN0aWNreSB9KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmFjdGl2ZSB8fCBzdGlja3kgfHwgIXRoaXMuaXNGaXhlZCkge1xuICAgICAgICAgICAgICByZXNldCh0aGlzLiRlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pbmFjdGl2ZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RpY2t5KSB7XG4gICAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoID0gbWFyZ2luID0gMDtcbiAgICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCB7IHBvc2l0aW9uOiBcInN0aWNreVwiLCB0b3A6IG9mZnNldCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcGxhY2Vob2xkZXIgfSA9IHRoaXM7XG4gICAgICAgICAgICBjc3MocGxhY2Vob2xkZXIsIHsgaGVpZ2h0LCB3aWR0aCwgbWFyZ2luIH0pO1xuICAgICAgICAgICAgaWYgKHBhcmVudChwbGFjZWhvbGRlcikgIT09IHBhcmVudCh0aGlzLiRlbCkgfHwgc3RpY2t5IF4gaW5kZXgocGxhY2Vob2xkZXIpIDwgaW5kZXgodGhpcy4kZWwpKSB7XG4gICAgICAgICAgICAgIChzdGlja3kgPyBiZWZvcmUgOiBhZnRlcikodGhpcy4kZWwsIHBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV2ZW50czogW1wicmVzaXplXCJdXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByZWFkKHtcbiAgICAgICAgICAgIHNjcm9sbDogcHJldlNjcm9sbCA9IDAsXG4gICAgICAgICAgICBkaXI6IHByZXZEaXIgPSBcImRvd25cIixcbiAgICAgICAgICAgIG92ZXJmbG93LFxuICAgICAgICAgICAgb3ZlcmZsb3dTY3JvbGwgPSAwLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBlbEhlaWdodCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHN0aWNreSxcbiAgICAgICAgICAgIG1heFNjcm9sbEhlaWdodFxuICAgICAgICAgIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbDIgPSBNYXRoLm1pbihkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCwgbWF4U2Nyb2xsSGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IHByZXZTY3JvbGwgPD0gc2Nyb2xsMiA/IFwiZG93blwiIDogXCJ1cFwiO1xuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuaXNGaXhlZCA/IHRoaXMucGxhY2Vob2xkZXIgOiB0aGlzLiRlbDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgcHJldkRpcixcbiAgICAgICAgICAgICAgc2Nyb2xsOiBzY3JvbGwyLFxuICAgICAgICAgICAgICBwcmV2U2Nyb2xsLFxuICAgICAgICAgICAgICBiZWxvdzogc2Nyb2xsMiA+IG9mZnNldChyZWZlcmVuY2VFbGVtZW50KS50b3AgKyAoc3RpY2t5ID8gTWF0aC5taW4oaGVpZ2h0LCBlbEhlaWdodCkgOiBoZWlnaHQpLFxuICAgICAgICAgICAgICBvZmZzZXRQYXJlbnRUb3A6IG9mZnNldChyZWZlcmVuY2VFbGVtZW50Lm9mZnNldFBhcmVudCkudG9wLFxuICAgICAgICAgICAgICBvdmVyZmxvd1Njcm9sbDogY2xhbXAoXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dTY3JvbGwgKyBjbGFtcChzY3JvbGwyLCBzdGFydCwgZW5kKSAtIGNsYW1wKHByZXZTY3JvbGwsIHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHdyaXRlKGRhdGEsIHR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpc1Njcm9sbFVwZGF0ZSA9IHR5cGVzLmhhcyhcInNjcm9sbFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaW5pdFRpbWVzdGFtcCA9IDAsXG4gICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgcHJldkRpcixcbiAgICAgICAgICAgICAgc2Nyb2xsOiBzY3JvbGwyLFxuICAgICAgICAgICAgICBwcmV2U2Nyb2xsID0gMCxcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgYmVsb3dcbiAgICAgICAgICAgIH0gPSBkYXRhO1xuICAgICAgICAgICAgaWYgKHNjcm9sbDIgPCAwIHx8IHNjcm9sbDIgPT09IHByZXZTY3JvbGwgJiYgaXNTY3JvbGxVcGRhdGUgfHwgdGhpcy5zaG93T25VcCAmJiAhaXNTY3JvbGxVcGRhdGUgJiYgIXRoaXMuaXNGaXhlZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgaWYgKG5vdyAtIGluaXRUaW1lc3RhbXAgPiAzMDAgfHwgZGlyICE9PSBwcmV2RGlyKSB7XG4gICAgICAgICAgICAgIGRhdGEuaW5pdFNjcm9sbCA9IHNjcm9sbDI7XG4gICAgICAgICAgICAgIGRhdGEuaW5pdFRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dPblVwICYmICF0aGlzLmlzRml4ZWQgJiYgTWF0aC5hYnMoZGF0YS5pbml0U2Nyb2xsIC0gc2Nyb2xsMikgPD0gMzAgJiYgTWF0aC5hYnMocHJldlNjcm9sbCAtIHNjcm9sbDIpIDw9IDEwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmluYWN0aXZlIHx8IHNjcm9sbDIgPCBzdGFydCB8fCB0aGlzLnNob3dPblVwICYmIChzY3JvbGwyIDw9IHN0YXJ0IHx8IGRpciA9PT0gXCJkb3duXCIgJiYgaXNTY3JvbGxVcGRhdGUgfHwgZGlyID09PSBcInVwXCIgJiYgIXRoaXMuaXNGaXhlZCAmJiAhYmVsb3cpKSB7XG4gICAgICAgICAgICAgIGlmICghdGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFuaW1hdGlvbi5pblByb2dyZXNzKHRoaXMuJGVsKSAmJiB0b3AgPiBzY3JvbGwyKSB7XG4gICAgICAgICAgICAgICAgICBBbmltYXRpb24uY2FuY2VsKHRoaXMuJGVsKTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uICYmIGJlbG93KSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHRoaXMuJGVsLCBcInVrLWFuaW1hdGlvbi1sZWF2ZVwiKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBBbmltYXRpb24ub3V0KHRoaXMuJGVsLCB0aGlzLmFuaW1hdGlvbikudGhlbigoKSA9PiB0aGlzLmhpZGUoKSwgbm9vcCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0ZpeGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYW5pbWF0aW9uICYmIGJlbG93KSB7XG4gICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgICBBbmltYXRpb24uaW4odGhpcy4kZWwsIHRoaXMuYW5pbWF0aW9uKS5jYXRjaChub29wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByZXZlbnRUcmFuc2l0aW9uKHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBldmVudHM6IFtcInJlc2l6ZVwiLCBcInJlc2l6ZVZpZXdwb3J0XCIsIFwic2Nyb2xsXCJdXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIHNob3coKSB7XG4gICAgICAgICAgdGhpcy5pc0ZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGUoKSB7XG4gICAgICAgICAgY29uc3QgeyBvZmZzZXQsIHN0aWNreSB9ID0gdGhpcy5fZGF0YTtcbiAgICAgICAgICB0aGlzLnNldEFjdGl2ZShmYWxzZSk7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzRml4ZWQsIHRoaXMuY2xzQmVsb3cpO1xuICAgICAgICAgIGlmIChzdGlja3kpIHtcbiAgICAgICAgICAgIGNzcyh0aGlzLiRlbCwgXCJ0b3BcIiwgb2Zmc2V0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3NzKHRoaXMuJGVsLCB7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBcIlwiLFxuICAgICAgICAgICAgICB0b3A6IFwiXCIsXG4gICAgICAgICAgICAgIHdpZHRoOiBcIlwiLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3A6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5pc0ZpeGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBzY3JvbGw6IHNjcm9sbDIgPSAwLFxuICAgICAgICAgICAgb3ZlcmZsb3csXG4gICAgICAgICAgICBvdmVyZmxvd1Njcm9sbCA9IDAsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9mZnNldFBhcmVudFRvcCxcbiAgICAgICAgICAgIHN0aWNreSxcbiAgICAgICAgICAgIGJlbG93XG4gICAgICAgICAgfSA9IHRoaXMuX2RhdGE7XG4gICAgICAgICAgY29uc3QgYWN0aXZlID0gc3RhcnQgIT09IDAgfHwgc2Nyb2xsMiA+IHN0YXJ0O1xuICAgICAgICAgIGlmICghc3RpY2t5KSB7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsMiA+IGVuZCkge1xuICAgICAgICAgICAgICBvZmZzZXQgKz0gZW5kIC0gb2Zmc2V0UGFyZW50VG9wICsgb3ZlcmZsb3dTY3JvbGwgLSBvdmVyZmxvdztcbiAgICAgICAgICAgICAgcG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjc3ModGhpcy4kZWwsIHsgcG9zaXRpb24sIHdpZHRoLCBtYXJnaW5Ub3A6IDAgfSwgXCJpbXBvcnRhbnRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNzcyh0aGlzLiRlbCwgXCJ0b3BcIiwgb2Zmc2V0IC0gb3ZlcmZsb3dTY3JvbGwpO1xuICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKGFjdGl2ZSk7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3ModGhpcy4kZWwsIHRoaXMuY2xzQmVsb3csIGJlbG93KTtcbiAgICAgICAgICBhZGRDbGFzcyh0aGlzLiRlbCwgdGhpcy5jbHNGaXhlZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldEFjdGl2ZShhY3RpdmUpIHtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5hY3RpdmU7XG4gICAgICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAgICAgcmVwbGFjZUNsYXNzKHRoaXMudGFyZ2V0LCB0aGlzLmNsc0luYWN0aXZlLCB0aGlzLmNsc0FjdGl2ZSk7XG4gICAgICAgICAgICBwcmV2ICE9PSBhY3RpdmUgJiYgdHJpZ2dlcih0aGlzLiRlbCwgXCJhY3RpdmVcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2VDbGFzcyh0aGlzLnRhcmdldCwgdGhpcy5jbHNBY3RpdmUsIHRoaXMuY2xzSW5hY3RpdmUpO1xuICAgICAgICAgICAgaWYgKHByZXYgIT09IGFjdGl2ZSkge1xuICAgICAgICAgICAgICBwcmV2ZW50VHJhbnNpdGlvbih0aGlzLnRhcmdldCk7XG4gICAgICAgICAgICAgIHRyaWdnZXIodGhpcy4kZWwsIFwiaW5hY3RpdmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwYXJzZVByb3AodmFsdWUsIGVsLCBwcm9wT2Zmc2V0LCBwYWRkaW5nKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtZXJpYyh2YWx1ZSkgfHwgaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLm1hdGNoKC9eLT9cXGQvKSkge1xuICAgICAgICByZXR1cm4gcHJvcE9mZnNldCArIHRvUHgodmFsdWUsIFwiaGVpZ2h0XCIsIGVsLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlZkVsZW1lbnQgPSB2YWx1ZSA9PT0gdHJ1ZSA/IGdldFZpc2libGVQYXJlbnQoZWwpIDogcXVlcnkodmFsdWUsIGVsKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldChyZWZFbGVtZW50KS5ib3R0b20gLSAocGFkZGluZyAmJiAocmVmRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcmVmRWxlbWVudC5jb250YWlucyhlbCkpID8gdG9GbG9hdChjc3MocmVmRWxlbWVudCwgXCJwYWRkaW5nQm90dG9tXCIpKSArIHRvRmxvYXQoY3NzKHJlZkVsZW1lbnQsIFwiYm9yZGVyQm90dG9tV2lkdGhcIikpIDogMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvZXJjZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09PSBcInRydWVcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc2V0KGVsKSB7XG4gICAgICBjc3MoZWwsIHsgcG9zaXRpb246IFwiXCIsIHRvcDogXCJcIiwgbWFyZ2luVG9wOiBcIlwiLCB3aWR0aDogXCJcIiB9KTtcbiAgICB9XG4gICAgY29uc3QgY2xzVHJhbnNpdGlvbkRpc2FibGUgPSBcInVrLXRyYW5zaXRpb24tZGlzYWJsZVwiO1xuICAgIGZ1bmN0aW9uIHByZXZlbnRUcmFuc2l0aW9uKGVsZW1lbnQpIHtcbiAgICAgIGlmICghaGFzQ2xhc3MoZWxlbWVudCwgY2xzVHJhbnNpdGlvbkRpc2FibGUpKSB7XG4gICAgICAgIGFkZENsYXNzKGVsZW1lbnQsIGNsc1RyYW5zaXRpb25EaXNhYmxlKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsc1RyYW5zaXRpb25EaXNhYmxlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZpc2libGVQYXJlbnQoZWxlbWVudCkge1xuICAgICAgd2hpbGUgKGVsZW1lbnQgPSBwYXJlbnQoZWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGlzVmlzaWJsZShlbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN2ZyA9IHtcbiAgICAgIG1peGluczogW1N2Z10sXG4gICAgICBhcmdzOiBcInNyY1wiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgc3JjOiBTdHJpbmcsXG4gICAgICAgIGljb246IFN0cmluZyxcbiAgICAgICAgYXR0cmlidXRlczogXCJsaXN0XCIsXG4gICAgICAgIHN0cm9rZUFuaW1hdGlvbjogQm9vbGVhblxuICAgICAgfSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgc3Ryb2tlQW5pbWF0aW9uOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IFtcbiAgICAgICAgbXV0YXRpb24oe1xuICAgICAgICAgIGFzeW5jIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBjb25zdCBzdmcgPSBhd2FpdCB0aGlzLnN2ZztcbiAgICAgICAgICAgIGlmIChzdmcpIHtcbiAgICAgICAgICAgICAgYXBwbHlBdHRyaWJ1dGVzLmNhbGwodGhpcywgc3ZnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IFtcImlkXCIsIFwiY2xhc3NcIiwgXCJzdHlsZVwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIF0sXG4gICAgICBhc3luYyBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLnNyYywgXCIjXCIpKSB7XG4gICAgICAgICAgW3RoaXMuc3JjLCB0aGlzLmljb25dID0gdGhpcy5zcmMuc3BsaXQoXCIjXCIsIDIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN2ZyA9IGF3YWl0IHRoaXMuc3ZnO1xuICAgICAgICBpZiAoc3ZnKSB7XG4gICAgICAgICAgYXBwbHlBdHRyaWJ1dGVzLmNhbGwodGhpcywgc3ZnKTtcbiAgICAgICAgICBpZiAodGhpcy5zdHJva2VBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGFwcGx5QW5pbWF0aW9uKHN2Zyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBhc3luYyBnZXRTdmcoKSB7XG4gICAgICAgICAgaWYgKGlzVGFnKHRoaXMuJGVsLCBcImltZ1wiKSAmJiAhdGhpcy4kZWwuY29tcGxldGUgJiYgdGhpcy4kZWwubG9hZGluZyA9PT0gXCJsYXp5XCIpIHtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBvbmNlKHRoaXMuJGVsLCBcImxvYWRcIiwgcmVzb2x2ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGFyc2VTVkcoYXdhaXQgbG9hZFNWRyh0aGlzLnNyYyksIHRoaXMuaWNvbikgfHwgUHJvbWlzZS5yZWplY3QoXCJTVkcgbm90IGZvdW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzKGVsKSB7XG4gICAgICBjb25zdCB7ICRlbCB9ID0gdGhpcztcbiAgICAgIGFkZENsYXNzKGVsLCBhdHRyKCRlbCwgXCJjbGFzc1wiKSwgXCJ1ay1zdmdcIik7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8ICRlbC5zdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcm9wID0gJGVsLnN0eWxlW2ldO1xuICAgICAgICBjc3MoZWwsIHByb3AsIGNzcygkZWwsIHByb3ApKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBbcHJvcCwgdmFsdWVdID0gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZV0uc3BsaXQoXCI6XCIsIDIpO1xuICAgICAgICBhdHRyKGVsLCBwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuJGVsLmlkKSB7XG4gICAgICAgIHJlbW92ZUF0dHIoZWwsIFwiaWRcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxvYWRTVkcgPSBtZW1vaXplKGFzeW5jIChzcmMpID0+IHtcbiAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGgoc3JjLCBcImRhdGE6XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzcmMuc3BsaXQoXCIsXCIsIDIpWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHNyYyk7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpID09PSBcImltYWdlL3N2Zyt4bWxcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uKGVsKSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBnZXRNYXhQYXRoTGVuZ3RoKGVsKTtcbiAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgY3NzKGVsLCBcIi0tdWstYW5pbWF0aW9uLXN0cm9rZVwiLCBsZW5ndGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlbERpc2FibGVkID0gXCIudWstZGlzYWJsZWQgKiwgLnVrLWRpc2FibGVkLCBbZGlzYWJsZWRdXCI7XG4gICAgdmFyIFN3aXRjaGVyID0ge1xuICAgICAgbWl4aW5zOiBbVG9nZ2xhYmxlXSxcbiAgICAgIGFyZ3M6IFwiY29ubmVjdFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY29ubmVjdDogU3RyaW5nLFxuICAgICAgICB0b2dnbGU6IFN0cmluZyxcbiAgICAgICAgaXRlbU5hdjogU3RyaW5nLFxuICAgICAgICBhY3RpdmU6IE51bWJlcixcbiAgICAgICAgZm9sbG93Rm9jdXM6IEJvb2xlYW4sXG4gICAgICAgIHN3aXBpbmc6IEJvb2xlYW5cbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbm5lY3Q6IFwifi51ay1zd2l0Y2hlclwiLFxuICAgICAgICB0b2dnbGU6IFwiPiAqID4gOmZpcnN0LWNoaWxkXCIsXG4gICAgICAgIGl0ZW1OYXY6IGZhbHNlLFxuICAgICAgICBhY3RpdmU6IDAsXG4gICAgICAgIGNsczogXCJ1ay1hY3RpdmVcIixcbiAgICAgICAgYXR0ckl0ZW06IFwidWstc3dpdGNoZXItaXRlbVwiLFxuICAgICAgICBzZWxWZXJ0aWNhbDogXCIudWstbmF2XCIsXG4gICAgICAgIGZvbGxvd0ZvY3VzOiBmYWxzZSxcbiAgICAgICAgc3dpcGluZzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGNvbm5lY3RzOiB7XG4gICAgICAgICAgZ2V0OiAoeyBjb25uZWN0IH0sICRlbCkgPT4gcXVlcnlBbGwoY29ubmVjdCwgJGVsKSxcbiAgICAgICAgICBvYnNlcnZlOiAoeyBjb25uZWN0IH0pID0+IGNvbm5lY3RcbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdENoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RzLm1hcCgoZWwpID0+IGNoaWxkcmVuKGVsKSkuZmxhdCgpO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVzOiAoeyB0b2dnbGUgfSwgJGVsKSA9PiAkJCh0b2dnbGUsICRlbCksXG4gICAgICAgIGNoaWxkcmVuKF8sICRlbCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZHJlbigkZWwpLmZpbHRlcihcbiAgICAgICAgICAgIChjaGlsZCkgPT4gdGhpcy50b2dnbGVzLnNvbWUoKHRvZ2dsZSkgPT4gY2hpbGQuY29udGFpbnModG9nZ2xlKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd2F0Y2g6IHtcbiAgICAgICAgY29ubmVjdHMoY29ubmVjdHMpIHtcbiAgICAgICAgICBpZiAodGhpcy5zd2lwaW5nKSB7XG4gICAgICAgICAgICBjc3MoY29ubmVjdHMsIFwidG91Y2hBY3Rpb25cIiwgXCJwYW4teSBwaW5jaC16b29tXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiRlbWl0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RDaGlsZHJlbigpIHtcbiAgICAgICAgICBsZXQgaW5kZXggPSBNYXRoLm1heCgwLCB0aGlzLmluZGV4KCkpO1xuICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5jb25uZWN0cykge1xuICAgICAgICAgICAgY2hpbGRyZW4oZWwpLmZvckVhY2goKGNoaWxkLCBpKSA9PiB0b2dnbGVDbGFzcyhjaGlsZCwgdGhpcy5jbHMsIGkgPT09IGluZGV4KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuJGVtaXQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlcyh0b2dnbGVzKSB7XG4gICAgICAgICAgdGhpcy4kZW1pdCgpO1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgICB0aGlzLnNob3cofmFjdGl2ZSA/IGFjdGl2ZSA6IHRvZ2dsZXNbdGhpcy5hY3RpdmVdIHx8IHRvZ2dsZXNbMF0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY29ubmVjdGVkKCkge1xuICAgICAgICBhdHRyKHRoaXMuJGVsLCBcInJvbGVcIiwgXCJ0YWJsaXN0XCIpO1xuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IFtcbiAgICAgICAgbGF6eWxvYWQoeyB0YXJnZXRzOiAoeyBjb25uZWN0Q2hpbGRyZW4gfSkgPT4gY29ubmVjdENoaWxkcmVuIH0pLFxuICAgICAgICBzd2lwZSh7IHRhcmdldDogKHsgY29ubmVjdHMgfSkgPT4gY29ubmVjdHMsIGZpbHRlcjogKHsgc3dpcGluZyB9KSA9PiBzd2lwaW5nIH0pXG4gICAgICBdLFxuICAgICAgZXZlbnRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImNsaWNrIGtleWRvd25cIixcbiAgICAgICAgICBkZWxlZ2F0ZTogKHsgdG9nZ2xlIH0pID0+IHRvZ2dsZSxcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcyhlLmN1cnJlbnQsIHNlbERpc2FibGVkKSAmJiAoZS50eXBlID09PSBcImNsaWNrXCIgfHwgZS5rZXlDb2RlID09PSBrZXlNYXAuU1BBQ0UpKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgdGhpcy5zaG93KGUuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJrZXlkb3duXCIsXG4gICAgICAgICAgZGVsZWdhdGU6ICh7IHRvZ2dsZSB9KSA9PiB0b2dnbGUsXG4gICAgICAgICAgaGFuZGxlcihlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGN1cnJlbnQsIGtleUNvZGUgfSA9IGU7XG4gICAgICAgICAgICBjb25zdCBpc1ZlcnRpY2FsID0gbWF0Y2hlcyh0aGlzLiRlbCwgdGhpcy5zZWxWZXJ0aWNhbCk7XG4gICAgICAgICAgICBsZXQgaSA9IGtleUNvZGUgPT09IGtleU1hcC5IT01FID8gMCA6IGtleUNvZGUgPT09IGtleU1hcC5FTkQgPyBcImxhc3RcIiA6IGtleUNvZGUgPT09IGtleU1hcC5MRUZUICYmICFpc1ZlcnRpY2FsIHx8IGtleUNvZGUgPT09IGtleU1hcC5VUCAmJiBpc1ZlcnRpY2FsID8gXCJwcmV2aW91c1wiIDoga2V5Q29kZSA9PT0ga2V5TWFwLlJJR0hUICYmICFpc1ZlcnRpY2FsIHx8IGtleUNvZGUgPT09IGtleU1hcC5ET1dOICYmIGlzVmVydGljYWwgPyBcIm5leHRcIiA6IC0xO1xuICAgICAgICAgICAgaWYgKH5pKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgY29uc3QgdG9nZ2xlcyA9IHRoaXMudG9nZ2xlcy5maWx0ZXIoKGVsKSA9PiAhbWF0Y2hlcyhlbCwgc2VsRGlzYWJsZWQpKTtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRvZ2dsZXNbZ2V0SW5kZXgoaSwgdG9nZ2xlcywgdG9nZ2xlcy5pbmRleE9mKGN1cnJlbnQpKV07XG4gICAgICAgICAgICAgIG5leHQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuZm9sbG93Rm9jdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3cobmV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImNsaWNrXCIsXG4gICAgICAgICAgZWw6ICh7ICRlbCwgY29ubmVjdHMsIGl0ZW1OYXYgfSkgPT4gY29ubmVjdHMuY29uY2F0KGl0ZW1OYXYgPyBxdWVyeUFsbChpdGVtTmF2LCAkZWwpIDogW10pLFxuICAgICAgICAgIGRlbGVnYXRlOiAoeyBhdHRySXRlbSB9KSA9PiBgWyR7YXR0ckl0ZW19XSxbZGF0YS0ke2F0dHJJdGVtfV1gLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNsb3Nlc3QoXCJhLGJ1dHRvblwiKSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIHRoaXMuc2hvdyhkYXRhKGUuY3VycmVudCwgdGhpcy5hdHRySXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic3dpcGVSaWdodCBzd2lwZUxlZnRcIixcbiAgICAgICAgICBmaWx0ZXI6ICh7IHN3aXBpbmcgfSkgPT4gc3dpcGluZyxcbiAgICAgICAgICBlbDogKHsgY29ubmVjdHMgfSkgPT4gY29ubmVjdHMsXG4gICAgICAgICAgaGFuZGxlcih7IHR5cGUgfSkge1xuICAgICAgICAgICAgdGhpcy5zaG93KGVuZHNXaXRoKHR5cGUsIFwiTGVmdFwiKSA/IFwibmV4dFwiIDogXCJwcmV2aW91c1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICB1cGRhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLmNvbm5lY3RzKSB7XG4gICAgICAgICAgaWYgKGlzVGFnKGVsLCBcInVsXCIpKSB7XG4gICAgICAgICAgICBhdHRyKGVsLCBcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHIoY2hpbGRyZW4odGhpcy4kZWwpLCBcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICAgIGZvciAoY29uc3QgaW5kZXggaW4gdGhpcy50b2dnbGVzKSB7XG4gICAgICAgICAgY29uc3QgdG9nZ2xlID0gdGhpcy50b2dnbGVzW2luZGV4XTtcbiAgICAgICAgICBjb25zdCBpdGVtID0gKF9hID0gdGhpcy5jb25uZWN0c1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICBhdHRyKHRvZ2dsZSwgXCJyb2xlXCIsIFwidGFiXCIpO1xuICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRvZ2dsZS5pZCA9IGdlbmVyYXRlSWQodGhpcywgdG9nZ2xlKTtcbiAgICAgICAgICBpdGVtLmlkID0gZ2VuZXJhdGVJZCh0aGlzLCBpdGVtKTtcbiAgICAgICAgICBhdHRyKHRvZ2dsZSwgXCJhcmlhLWNvbnRyb2xzXCIsIGl0ZW0uaWQpO1xuICAgICAgICAgIGF0dHIoaXRlbSwgeyByb2xlOiBcInRhYnBhbmVsXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRvZ2dsZS5pZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyKHRoaXMuJGVsLCBcImFyaWEtb3JpZW50YXRpb25cIiwgbWF0Y2hlcyh0aGlzLiRlbCwgdGhpcy5zZWxWZXJ0aWNhbCkgPyBcInZlcnRpY2FsXCIgOiBudWxsKTtcbiAgICAgIH0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGluZGV4KCkge1xuICAgICAgICAgIHJldHVybiBmaW5kSW5kZXgodGhpcy5jaGlsZHJlbiwgKGVsKSA9PiBoYXNDbGFzcyhlbCwgdGhpcy5jbHMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvdyhpdGVtKSB7XG4gICAgICAgICAgY29uc3QgdG9nZ2xlcyA9IHRoaXMudG9nZ2xlcy5maWx0ZXIoKGVsKSA9PiAhbWF0Y2hlcyhlbCwgc2VsRGlzYWJsZWQpKTtcbiAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5pbmRleCgpO1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBnZXRJbmRleChcbiAgICAgICAgICAgICFpc05vZGUoaXRlbSkgfHwgaW5jbHVkZXModG9nZ2xlcywgaXRlbSkgPyBpdGVtIDogMCxcbiAgICAgICAgICAgIHRvZ2dsZXMsXG4gICAgICAgICAgICBnZXRJbmRleCh0aGlzLnRvZ2dsZXNbcHJldl0sIHRvZ2dsZXMpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBhY3RpdmUgPSBnZXRJbmRleCh0b2dnbGVzW25leHRdLCB0aGlzLnRvZ2dsZXMpO1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgICAgIHRvZ2dsZUNsYXNzKGNoaWxkLCB0aGlzLmNscywgYWN0aXZlID09PSBpKTtcbiAgICAgICAgICAgIGF0dHIodGhpcy50b2dnbGVzW2ldLCB7XG4gICAgICAgICAgICAgIFwiYXJpYS1zZWxlY3RlZFwiOiBhY3RpdmUgPT09IGksXG4gICAgICAgICAgICAgIHRhYmluZGV4OiBhY3RpdmUgPT09IGkgPyBudWxsIDogLTFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IGFuaW1hdGUgPSBwcmV2ID49IDAgJiYgcHJldiAhPT0gbmV4dDtcbiAgICAgICAgICB0aGlzLmNvbm5lY3RzLmZvckVhY2goYXN5bmMgKHsgY2hpbGRyZW46IGNoaWxkcmVuMiB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhY3RpdmVzID0gdG9BcnJheShjaGlsZHJlbjIpLmZpbHRlcihcbiAgICAgICAgICAgICAgKGNoaWxkLCBpKSA9PiBpICE9PSBhY3RpdmUgJiYgaGFzQ2xhc3MoY2hpbGQsIHRoaXMuY2xzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQoYWN0aXZlcywgZmFsc2UsIGFuaW1hdGUpKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMudG9nZ2xlRWxlbWVudChjaGlsZHJlbjJbYWN0aXZlXSwgdHJ1ZSwgYW5pbWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHRhYiA9IHtcbiAgICAgIG1peGluczogW0NsYXNzXSxcbiAgICAgIGV4dGVuZHM6IFN3aXRjaGVyLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgbWVkaWE6IEJvb2xlYW5cbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIG1lZGlhOiA5NjAsXG4gICAgICAgIGF0dHJJdGVtOiBcInVrLXRhYi1pdGVtXCIsXG4gICAgICAgIHNlbFZlcnRpY2FsOiBcIi51ay10YWItbGVmdCwudWstdGFiLXJpZ2h0XCJcbiAgICAgIH0sXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGNscyA9IGhhc0NsYXNzKHRoaXMuJGVsLCBcInVrLXRhYi1sZWZ0XCIpID8gXCJ1ay10YWItbGVmdFwiIDogaGFzQ2xhc3ModGhpcy4kZWwsIFwidWstdGFiLXJpZ2h0XCIpID8gXCJ1ay10YWItcmlnaHRcIiA6IGZhbHNlO1xuICAgICAgICBpZiAoY2xzKSB7XG4gICAgICAgICAgdGhpcy4kY3JlYXRlKFwidG9nZ2xlXCIsIHRoaXMuJGVsLCB7IGNscywgbW9kZTogXCJtZWRpYVwiLCBtZWRpYTogdGhpcy5tZWRpYSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBLRVlfU1BBQ0UgPSAzMjtcbiAgICB2YXIgdG9nZ2xlID0ge1xuICAgICAgbWl4aW5zOiBbTWVkaWEsIFRvZ2dsYWJsZV0sXG4gICAgICBhcmdzOiBcInRhcmdldFwiLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgaHJlZjogU3RyaW5nLFxuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIG1vZGU6IFwibGlzdFwiLFxuICAgICAgICBxdWV1ZWQ6IEJvb2xlYW5cbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGhyZWY6IGZhbHNlLFxuICAgICAgICB0YXJnZXQ6IGZhbHNlLFxuICAgICAgICBtb2RlOiBcImNsaWNrXCIsXG4gICAgICAgIHF1ZXVlZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgIGdldDogKHsgdGFyZ2V0IH0sICRlbCkgPT4ge1xuICAgICAgICAgICAgdGFyZ2V0ID0gcXVlcnlBbGwodGFyZ2V0IHx8ICRlbC5oYXNoLCAkZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5sZW5ndGggPyB0YXJnZXQgOiBbJGVsXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9ic2VydmU6ICh7IHRhcmdldCB9KSA9PiB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKCFpbmNsdWRlcyh0aGlzLm1vZGUsIFwibWVkaWFcIikpIHtcbiAgICAgICAgICBpZiAoIWlzRm9jdXNhYmxlKHRoaXMuJGVsKSkge1xuICAgICAgICAgICAgYXR0cih0aGlzLiRlbCwgXCJ0YWJpbmRleFwiLCBcIjBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdGhpcy5jbHMgJiYgaXNUYWcodGhpcy4kZWwsIFwiYVwiKSkge1xuICAgICAgICAgICAgYXR0cih0aGlzLiRlbCwgXCJyb2xlXCIsIFwiYnV0dG9uXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9ic2VydmU6IGxhenlsb2FkKHsgdGFyZ2V0czogKHsgdGFyZ2V0IH0pID0+IHRhcmdldCB9KSxcbiAgICAgIGV2ZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogcG9pbnRlckRvd24kMSxcbiAgICAgICAgICBmaWx0ZXI6ICh7IG1vZGUgfSkgPT4gaW5jbHVkZXMobW9kZSwgXCJob3ZlclwiKSxcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRDbGljayA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIWlzVG91Y2goZSkgfHwgaXNCb29sZWFuKHRoaXMuX3Nob3dTdGF0ZSkgfHwgdGhpcy4kZWwuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJpZ2dlcih0aGlzLiRlbCwgXCJmb2N1c1wiKTtcbiAgICAgICAgICAgIG9uY2UoXG4gICAgICAgICAgICAgIGRvY3VtZW50LFxuICAgICAgICAgICAgICBwb2ludGVyRG93biQxLFxuICAgICAgICAgICAgICAoKSA9PiB0cmlnZ2VyKHRoaXMuJGVsLCBcImJsdXJcIiksXG4gICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgIChlMikgPT4gIXRoaXMuJGVsLmNvbnRhaW5zKGUyLnRhcmdldClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaW5jbHVkZXModGhpcy5tb2RlLCBcImNsaWNrXCIpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3ByZXZlbnRDbGljayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgLy8gbW91c2VlbnRlciBtb3VzZWxlYXZlIGFyZSBhZGRlZCBiZWNhdXNlIG9mIEZpcmVmb3ggYnVnLFxuICAgICAgICAgIC8vIHdoZXJlIHBvaW50ZXJsZWF2ZSBpcyB0cmlnZ2VyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgcG9pbnRlcmVudGVyIG9uIHNjcm9sbFxuICAgICAgICAgIG5hbWU6IGBtb3VzZWVudGVyIG1vdXNlbGVhdmUgJHtwb2ludGVyRW50ZXJ9ICR7cG9pbnRlckxlYXZlfSBmb2N1cyBibHVyYCxcbiAgICAgICAgICBmaWx0ZXI6ICh7IG1vZGUgfSkgPT4gaW5jbHVkZXMobW9kZSwgXCJob3ZlclwiKSxcbiAgICAgICAgICBoYW5kbGVyKGUpIHtcbiAgICAgICAgICAgIGlmIChpc1RvdWNoKGUpIHx8IHRoaXMuJGVsLmRpc2FibGVkIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNob3cgPSBpbmNsdWRlcyhbXCJtb3VzZWVudGVyXCIsIHBvaW50ZXJFbnRlciwgXCJmb2N1c1wiXSwgZS50eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkID0gdGhpcy5pc1RvZ2dsZWQodGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgaWYgKCFzaG93ICYmICghaXNCb29sZWFuKHRoaXMuX3Nob3dTdGF0ZSkgfHwgZS50eXBlICE9PSBcImJsdXJcIiAmJiBtYXRjaGVzKHRoaXMuJGVsLCBcIjpmb2N1c1wiKSB8fCBlLnR5cGUgPT09IFwiYmx1clwiICYmIG1hdGNoZXModGhpcy4kZWwsIFwiOmhvdmVyXCIpKSkge1xuICAgICAgICAgICAgICBpZiAoZXhwYW5kZWQgPT09IHRoaXMuX3Nob3dTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3dTdGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3cgJiYgaXNCb29sZWFuKHRoaXMuX3Nob3dTdGF0ZSkgJiYgZXhwYW5kZWQgIT09IHRoaXMuX3Nob3dTdGF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zaG93U3RhdGUgPSBzaG93ID8gZXhwYW5kZWQgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoYHRvZ2dsZSR7c2hvdyA/IFwic2hvd1wiIDogXCJoaWRlXCJ9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJrZXlkb3duXCIsXG4gICAgICAgICAgZmlsdGVyOiAoeyAkZWwsIG1vZGUgfSkgPT4gaW5jbHVkZXMobW9kZSwgXCJjbGlja1wiKSAmJiAhaXNUYWcoJGVsLCBcImlucHV0XCIpLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gS0VZX1NQQUNFKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgdGhpcy4kZWwuY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImNsaWNrXCIsXG4gICAgICAgICAgZmlsdGVyOiAoeyBtb2RlIH0pID0+IFtcImNsaWNrXCIsIFwiaG92ZXJcIl0uc29tZSgobSkgPT4gaW5jbHVkZXMobW9kZSwgbSkpLFxuICAgICAgICAgIGhhbmRsZXIoZSkge1xuICAgICAgICAgICAgbGV0IGxpbms7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJldmVudENsaWNrIHx8IGUudGFyZ2V0LmNsb3Nlc3QoJ2FbaHJlZj1cIiNcIl0sIGFbaHJlZj1cIlwiXScpIHx8IChsaW5rID0gZS50YXJnZXQuY2xvc2VzdChcImFbaHJlZl1cIikpICYmICghdGhpcy5pc1RvZ2dsZWQodGhpcy50YXJnZXQpIHx8IGxpbmsuaGFzaCAmJiBtYXRjaGVzKHRoaXMudGFyZ2V0LCBsaW5rLmhhc2gpKSkge1xuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByZXZlbnRDbGljayAmJiBpbmNsdWRlcyh0aGlzLm1vZGUsIFwiY2xpY2tcIikpIHtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm1lZGlhY2hhbmdlXCIsXG4gICAgICAgICAgZmlsdGVyOiAoeyBtb2RlIH0pID0+IGluY2x1ZGVzKG1vZGUsIFwibWVkaWFcIiksXG4gICAgICAgICAgZWw6ICh7IHRhcmdldCB9KSA9PiB0YXJnZXQsXG4gICAgICAgICAgaGFuZGxlcihlLCBtZWRpYU9iaikge1xuICAgICAgICAgICAgaWYgKG1lZGlhT2JqLm1hdGNoZXMgXiB0aGlzLmlzVG9nZ2xlZCh0aGlzLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBtZXRob2RzOiB7XG4gICAgICAgIGFzeW5jIHRvZ2dsZSh0eXBlKSB7XG4gICAgICAgICAgaWYgKCF0cmlnZ2VyKHRoaXMudGFyZ2V0LCB0eXBlIHx8IFwidG9nZ2xlXCIsIFt0aGlzXSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc0F0dHIodGhpcy4kZWwsIFwiYXJpYS1leHBhbmRlZFwiKSkge1xuICAgICAgICAgICAgYXR0cih0aGlzLiRlbCwgXCJhcmlhLWV4cGFuZGVkXCIsICF0aGlzLmlzVG9nZ2xlZCh0aGlzLnRhcmdldCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMucXVldWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGVFbGVtZW50KHRoaXMudGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbGVhdmluZyA9IHRoaXMudGFyZ2V0LmZpbHRlcigoZWwpID0+IGhhc0NsYXNzKGVsLCB0aGlzLmNsc0xlYXZlKSk7XG4gICAgICAgICAgaWYgKGxlYXZpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlzTGVhdmluZyA9IGluY2x1ZGVzKGxlYXZpbmcsIGVsKTtcbiAgICAgICAgICAgICAgdGhpcy50b2dnbGVFbGVtZW50KGVsLCBpc0xlYXZpbmcsIGlzTGVhdmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRvZ2dsZWQgPSB0aGlzLnRhcmdldC5maWx0ZXIodGhpcy5pc1RvZ2dsZWQpO1xuICAgICAgICAgIGlmIChhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQodG9nZ2xlZCwgZmFsc2UpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnRvZ2dsZUVsZW1lbnQoXG4gICAgICAgICAgICAgIHRoaXMudGFyZ2V0LmZpbHRlcigoZWwpID0+ICFpbmNsdWRlcyh0b2dnbGVkLCBlbCkpLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgY29tcG9uZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBBY2NvcmRpb246IEFjY29yZGlvbixcbiAgICAgICAgQWxlcnQ6IGFsZXJ0LFxuICAgICAgICBDbG9zZTogQ2xvc2UsXG4gICAgICAgIENvdmVyOiBjb3ZlcixcbiAgICAgICAgRHJvcDogZHJvcCxcbiAgICAgICAgRHJvcFBhcmVudEljb246IEljb25Db21wb25lbnQsXG4gICAgICAgIERyb3Bkb3duOiBkcm9wLFxuICAgICAgICBEcm9wbmF2OiBEcm9wbmF2LFxuICAgICAgICBGb3JtQ3VzdG9tOiBmb3JtQ3VzdG9tLFxuICAgICAgICBHcmlkOiBncmlkLFxuICAgICAgICBIZWlnaHRNYXRjaDogaGVpZ2h0TWF0Y2gsXG4gICAgICAgIEhlaWdodFBsYWNlaG9sZGVyOiBoZWlnaHRQbGFjZWhvbGRlcixcbiAgICAgICAgSGVpZ2h0Vmlld3BvcnQ6IGhlaWdodFZpZXdwb3J0LFxuICAgICAgICBJY29uOiBJY29uLFxuICAgICAgICBJbWc6IGltZyxcbiAgICAgICAgSW52ZXJzZTogaW52ZXJzZSxcbiAgICAgICAgTGVhZGVyOiBsZWFkZXIsXG4gICAgICAgIE1hcmdpbjogTWFyZ2luLFxuICAgICAgICBNYXJrZXI6IE1hcmtlcixcbiAgICAgICAgTW9kYWw6IG1vZGFsLFxuICAgICAgICBOYXY6IG5hdixcbiAgICAgICAgTmF2UGFyZW50SWNvbjogTmF2UGFyZW50SWNvbixcbiAgICAgICAgTmF2YmFyOiBuYXZiYXIsXG4gICAgICAgIE5hdmJhclBhcmVudEljb246IEljb25Db21wb25lbnQsXG4gICAgICAgIE5hdmJhclRvZ2dsZUljb246IE5hdmJhclRvZ2dsZUljb24sXG4gICAgICAgIE9mZmNhbnZhczogb2ZmY2FudmFzLFxuICAgICAgICBPdmVyZmxvd0F1dG86IG92ZXJmbG93QXV0byxcbiAgICAgICAgT3ZlcmxheUljb246IEljb25Db21wb25lbnQsXG4gICAgICAgIFBhZ2luYXRpb25OZXh0OiBQYWdpbmF0aW9uTmV4dCxcbiAgICAgICAgUGFnaW5hdGlvblByZXZpb3VzOiBQYWdpbmF0aW9uUHJldmlvdXMsXG4gICAgICAgIFJlc3BvbnNpdmU6IHJlc3BvbnNpdmUsXG4gICAgICAgIFNjcm9sbDogc2Nyb2xsLFxuICAgICAgICBTY3JvbGxzcHk6IHNjcm9sbHNweSxcbiAgICAgICAgU2Nyb2xsc3B5TmF2OiBzY3JvbGxzcHlOYXYsXG4gICAgICAgIFNlYXJjaEljb246IFNlYXJjaCxcbiAgICAgICAgU2xpZGVuYXZOZXh0OiBTbGlkZW5hdixcbiAgICAgICAgU2xpZGVuYXZQcmV2aW91czogU2xpZGVuYXYsXG4gICAgICAgIFNwaW5uZXI6IFNwaW5uZXIsXG4gICAgICAgIFN0aWNreTogc3RpY2t5LFxuICAgICAgICBTdmc6IHN2ZyxcbiAgICAgICAgU3dpdGNoZXI6IFN3aXRjaGVyLFxuICAgICAgICBUYWI6IHRhYixcbiAgICAgICAgVG9nZ2xlOiB0b2dnbGUsXG4gICAgICAgIFRvdG9wOiBUb3RvcCxcbiAgICAgICAgVmlkZW86IFZpZGVvXG4gICAgfSk7XG5cbiAgICBlYWNoKGNvbXBvbmVudHMsIChjb21wb25lbnQsIG5hbWUpID0+IEFwcC5jb21wb25lbnQobmFtZSwgY29tcG9uZW50KSk7XG4gICAgYm9vdChBcHApO1xuXG4gICAgZWFjaChjb21wb25lbnRzJDEsIChjb21wb25lbnQsIG5hbWUpID0+IEFwcC5jb21wb25lbnQobmFtZSwgY29tcG9uZW50KSk7XG5cbiAgICByZXR1cm4gQXBwO1xuXG59KSk7XG4iLCIvKiFcbiAqIFZ1ZS5qcyB2Mi43LjE2XG4gKiAoYykgMjAxNC0yMDIzIEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4vLyBleHBsaWNpdG5lc3MgYW5kIGZ1bmN0aW9uIGlubGluaW5nLlxuZnVuY3Rpb24gaXNVbmRlZih2KSB7XG4gICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNEZWYodikge1xuICAgIHJldHVybiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzVHJ1ZSh2KSB7XG4gICAgcmV0dXJuIHYgPT09IHRydWU7XG59XG5mdW5jdGlvbiBpc0ZhbHNlKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJyB8fFxuICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogUXVpY2sgb2JqZWN0IGNoZWNrIC0gdGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byB0ZWxsXG4gKiBvYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gKiBpcyBhIEpTT04tY29tcGxpYW50IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEdldCB0aGUgcmF3IHR5cGUgc3RyaW5nIG9mIGEgdmFsdWUsIGUuZy4sIFtvYmplY3QgT2JqZWN0XS5cbiAqL1xuY29uc3QgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmZ1bmN0aW9uIHRvUmF3VHlwZSh2YWx1ZSkge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufVxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwKHYpIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodikgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuLyoqXG4gKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEFycmF5SW5kZXgodmFsKSB7XG4gICAgY29uc3QgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICAgIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpO1xufVxuZnVuY3Rpb24gaXNQcm9taXNlKHZhbCkge1xuICAgIHJldHVybiAoaXNEZWYodmFsKSAmJlxuICAgICAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHZhbC5jYXRjaCA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWwpIHtcbiAgICByZXR1cm4gdmFsID09IG51bGxcbiAgICAgICAgPyAnJ1xuICAgICAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIHJlcGxhY2VyLCAyKVxuICAgICAgICAgICAgOiBTdHJpbmcodmFsKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VyKF9rZXksIHZhbCkge1xuICAgIC8vIGF2b2lkIGNpcmN1bGFyIGRlcHMgZnJvbSB2M1xuICAgIGlmICh2YWwgJiYgdmFsLl9fdl9pc1JlZikge1xuICAgICAgICByZXR1cm4gdmFsLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuLyoqXG4gKiBDb252ZXJ0IGFuIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWwpIHtcbiAgICBjb25zdCBuID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIHJldHVybiBpc05hTihuKSA/IHZhbCA6IG47XG59XG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAoc3RyLCBleHBlY3RzTG93ZXJDYXNlKSB7XG4gICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBjb25zdCBsaXN0ID0gc3RyLnNwbGl0KCcsJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlID8gdmFsID0+IG1hcFt2YWwudG9Mb3dlckNhc2UoKV0gOiB2YWwgPT4gbWFwW3ZhbF07XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdGFnIGlzIGEgYnVpbHQtaW4gdGFnLlxuICovXG5jb25zdCBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuLyoqXG4gKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyaWJ1dGUgPSBtYWtlTWFwKCdrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpcycpO1xuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiByZW1vdmUkMihhcnIsIGl0ZW0pIHtcbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIGZvciB0aGUgb25seSAvIGxhc3QgaXRlbVxuICAgICAgICBpZiAoaXRlbSA9PT0gYXJyW2xlbiAtIDFdKSB7XG4gICAgICAgICAgICBhcnIubGVuZ3RoID0gbGVuIC0gMTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBoYXNPd24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FjaGVkKGZuKSB7XG4gICAgY29uc3QgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBmdW5jdGlvbiBjYWNoZWRGbihzdHIpIHtcbiAgICAgICAgY29uc3QgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICAgICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpO1xuICAgIH07XG59XG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gKi9cbmNvbnN0IGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG5jb25zdCBjYW1lbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKGNhbWVsaXplUkUsIChfLCBjKSA9PiAoYyA/IGMudG9VcHBlckNhc2UoKSA6ICcnKSk7XG59KTtcbi8qKlxuICogQ2FwaXRhbGl6ZSBhIHN0cmluZy5cbiAqL1xuY29uc3QgY2FwaXRhbGl6ZSA9IGNhY2hlZCgoc3RyKSA9PiB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn0pO1xuLyoqXG4gKiBIeXBoZW5hdGUgYSBjYW1lbENhc2Ugc3RyaW5nLlxuICovXG5jb25zdCBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG5jb25zdCBoeXBoZW5hdGUgPSBjYWNoZWQoKHN0cikgPT4ge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59KTtcbi8qKlxuICogU2ltcGxlIGJpbmQgcG9seWZpbGwgZm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBzdXBwb3J0IGl0LFxuICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gKiBzaW5jZSBuYXRpdmUgYmluZCBpcyBub3cgcGVyZm9ybWFudCBlbm91Z2ggaW4gbW9zdCBicm93c2Vycy5cbiAqIEJ1dCByZW1vdmluZyBpdCB3b3VsZCBtZWFuIGJyZWFraW5nIGNvZGUgdGhhdCB3YXMgYWJsZSB0byBydW4gaW5cbiAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICovXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gcG9seWZpbGxCaW5kKGZuLCBjdHgpIHtcbiAgICBmdW5jdGlvbiBib3VuZEZuKGEpIHtcbiAgICAgICAgY29uc3QgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsXG4gICAgICAgICAgICA/IGwgPiAxXG4gICAgICAgICAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgICAgICAgOiBmbi5jYWxsKGN0eCk7XG4gICAgfVxuICAgIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgICByZXR1cm4gYm91bmRGbjtcbn1cbmZ1bmN0aW9uIG5hdGl2ZUJpbmQoZm4sIGN0eCkge1xuICAgIHJldHVybiBmbi5iaW5kKGN0eCk7XG59XG4vLyBAdHMtZXhwZWN0LWVycm9yIGJpbmQgY2Fubm90IGJlIGB1bmRlZmluZWRgXG5jb25zdCBiaW5kJDEgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA/IG5hdGl2ZUJpbmQgOiBwb2x5ZmlsbEJpbmQ7XG4vKipcbiAqIENvbnZlcnQgYW4gQXJyYXktbGlrZSBvYmplY3QgdG8gYSByZWFsIEFycmF5LlxuICovXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIHN0YXJ0KSB7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGxldCBpID0gbGlzdC5sZW5ndGggLSBzdGFydDtcbiAgICBjb25zdCByZXQgPSBuZXcgQXJyYXkoaSk7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKHRvLCBfZnJvbSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIF9mcm9tKSB7XG4gICAgICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdG87XG59XG4vKipcbiAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHRvT2JqZWN0KGFycikge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJbaV0pIHtcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LykuXG4gKi9cbmZ1bmN0aW9uIG5vb3AoYSwgYiwgYykgeyB9XG4vKipcbiAqIEFsd2F5cyByZXR1cm4gZmFsc2UuXG4gKi9cbmNvbnN0IG5vID0gKGEsIGIsIGMpID0+IGZhbHNlO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyoqXG4gKiBSZXR1cm4gdGhlIHNhbWUgdmFsdWUuXG4gKi9cbmNvbnN0IGlkZW50aXR5ID0gKF8pID0+IF87XG4vKipcbiAqIEdlbmVyYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmcgc3RhdGljIGtleXMgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzJDEobW9kdWxlcykge1xuICAgIHJldHVybiBtb2R1bGVzXG4gICAgICAgIC5yZWR1Y2UoKGtleXMsIG0pID0+IGtleXMuY29uY2F0KG0uc3RhdGljS2V5cyB8fCBbXSksIFtdKVxuICAgICAgICAuam9pbignLCcpO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IGlzT2JqZWN0QSA9IGlzT2JqZWN0KGEpO1xuICAgIGNvbnN0IGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICAgIGlmIChpc09iamVjdEEgJiYgaXNPYmplY3RCKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICAgICAgICBjb25zdCBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICAgICAgICBpZiAoaXNBcnJheUEgJiYgaXNBcnJheUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICBhLmV2ZXJ5KChlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlBICYmICFpc0FycmF5Qikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXNBID0gT2JqZWN0LmtleXMoYSk7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgIGtleXNBLmV2ZXJ5KGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc09iamVjdEEgJiYgIWlzT2JqZWN0Qikge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpcnN0IGluZGV4IGF0IHdoaWNoIGEgbG9vc2VseSBlcXVhbCB2YWx1ZSBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBhcnJheSAoaWYgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QsIHRoZSBhcnJheSBtdXN0XG4gKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBsb29zZUluZGV4T2YoYXJyLCB2YWwpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpXG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICovXG5mdW5jdGlvbiBvbmNlKGZuKSB7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXMjcG9seWZpbGxcbmZ1bmN0aW9uIGhhc0NoYW5nZWQoeCwgeSkge1xuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgIHJldHVybiB4ID09PSAwICYmIDEgLyB4ICE9PSAxIC8geTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB4ID09PSB4IHx8IHkgPT09IHk7XG4gICAgfVxufVxuXG5jb25zdCBTU1JfQVRUUiA9ICdkYXRhLXNlcnZlci1yZW5kZXJlZCc7XG5jb25zdCBBU1NFVF9UWVBFUyA9IFsnY29tcG9uZW50JywgJ2RpcmVjdGl2ZScsICdmaWx0ZXInXTtcbmNvbnN0IExJRkVDWUNMRV9IT09LUyA9IFtcbiAgICAnYmVmb3JlQ3JlYXRlJyxcbiAgICAnY3JlYXRlZCcsXG4gICAgJ2JlZm9yZU1vdW50JyxcbiAgICAnbW91bnRlZCcsXG4gICAgJ2JlZm9yZVVwZGF0ZScsXG4gICAgJ3VwZGF0ZWQnLFxuICAgICdiZWZvcmVEZXN0cm95JyxcbiAgICAnZGVzdHJveWVkJyxcbiAgICAnYWN0aXZhdGVkJyxcbiAgICAnZGVhY3RpdmF0ZWQnLFxuICAgICdlcnJvckNhcHR1cmVkJyxcbiAgICAnc2VydmVyUHJlZmV0Y2gnLFxuICAgICdyZW5kZXJUcmFja2VkJyxcbiAgICAncmVuZGVyVHJpZ2dlcmVkJ1xuXTtcblxudmFyIGNvbmZpZyA9IHtcbiAgICAvKipcbiAgICAgKiBPcHRpb24gbWVyZ2Ugc3RyYXRlZ2llcyAodXNlZCBpbiBjb3JlL3V0aWwvb3B0aW9ucylcbiAgICAgKi9cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICAgKi9cbiAgICBzaWxlbnQ6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIFNob3cgcHJvZHVjdGlvbiBtb2RlIHRpcCBtZXNzYWdlIG9uIGJvb3Q/XG4gICAgICovXG4gICAgcHJvZHVjdGlvblRpcDogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgICAqL1xuICAgIGRldnRvb2xzOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcmVjb3JkIHBlcmZcbiAgICAgKi9cbiAgICBwZXJmb3JtYW5jZTogZmFsc2UsXG4gICAgLyoqXG4gICAgICogRXJyb3IgaGFuZGxlciBmb3Igd2F0Y2hlciBlcnJvcnNcbiAgICAgKi9cbiAgICBlcnJvckhhbmRsZXI6IG51bGwsXG4gICAgLyoqXG4gICAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAgICovXG4gICAgd2FybkhhbmRsZXI6IG51bGwsXG4gICAgLyoqXG4gICAgICogSWdub3JlIGNlcnRhaW4gY3VzdG9tIGVsZW1lbnRzXG4gICAgICovXG4gICAgaWdub3JlZEVsZW1lbnRzOiBbXSxcbiAgICAvKipcbiAgICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgICAqL1xuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIGtleUNvZGVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKi9cbiAgICBpc1Jlc2VydmVkVGFnOiBubyxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgICAqIHByb3AuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAgICovXG4gICAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIGFuIHVua25vd24gZWxlbWVudC5cbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAgICovXG4gICAgaXNVbmtub3duRWxlbWVudDogbm8sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgcmVhbCB0YWcgbmFtZSBmb3IgdGhlIHNwZWNpZmljIHBsYXRmb3JtLlxuICAgICAqL1xuICAgIHBhcnNlUGxhdGZvcm1UYWdOYW1lOiBpZGVudGl0eSxcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICAgKi9cbiAgICBtdXN0VXNlUHJvcDogbm8sXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBFeHBvc2VkIGZvciBsZWdhY3kgcmVhc29uc1xuICAgICAqL1xuICAgIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59O1xuXG4vKipcbiAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAqIHVzaW5nIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNTMvc2VtYW50aWNzLXNjcmlwdGluZy5odG1sI3BvdGVudGlhbGN1c3RvbWVsZW1lbnRuYW1lXG4gKiBza2lwcGluZyBcXHUxMDAwMC1cXHVFRkZGRiBkdWUgdG8gaXQgZnJlZXppbmcgdXAgUGhhbnRvbUpTXG4gKi9cbmNvbnN0IHVuaWNvZGVSZWdFeHAgPSAvYS16QS1aXFx1MDBCN1xcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwM0YtXFx1MjA0MFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRC87XG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIHN0YXJ0cyB3aXRoICQgb3IgX1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkKHN0cikge1xuICAgIGNvbnN0IGMgPSAoc3RyICsgJycpLmNoYXJDb2RlQXQoMCk7XG4gICAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1Zjtcbn1cbi8qKlxuICogRGVmaW5lIGEgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGRlZihvYmosIGtleSwgdmFsLCBlbnVtZXJhYmxlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xufVxuLyoqXG4gKiBQYXJzZSBzaW1wbGUgcGF0aC5cbiAqL1xuY29uc3QgYmFpbFJFID0gbmV3IFJlZ0V4cChgW14ke3VuaWNvZGVSZWdFeHAuc291cmNlfS4kX1xcXFxkXWApO1xuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbn1cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG5jb25zdCBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xuY29uc3QgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBVQSA9IGluQnJvd3NlciAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuY29uc3QgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xuY29uc3QgaXNJRTkgPSBVQSAmJiBVQS5pbmRleE9mKCdtc2llIDkuMCcpID4gMDtcbmNvbnN0IGlzRWRnZSA9IFVBICYmIFVBLmluZGV4T2YoJ2VkZ2UvJykgPiAwO1xuVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbmNvbnN0IGlzSU9TID0gVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKTtcblVBICYmIC9jaHJvbWVcXC9cXGQrLy50ZXN0KFVBKSAmJiAhaXNFZGdlO1xuVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG5jb25zdCBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbi8vIEB0cy1leHBlY3QtZXJyb3IgZmlyZWJveCBzdXBwb3J0XG5jb25zdCBuYXRpdmVXYXRjaCA9IHt9LndhdGNoO1xubGV0IHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuaWYgKGluQnJvd3Nlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdHMsICdwYXNzaXZlJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkgeyB9XG59XG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG5sZXQgX2lzU2VydmVyO1xuY29uc3QgaXNTZXJ2ZXJSZW5kZXJpbmcgPSAoKSA9PiB7XG4gICAgaWYgKF9pc1NlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAgICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICAgICAgICBfaXNTZXJ2ZXIgPVxuICAgICAgICAgICAgICAgIGdsb2JhbFsncHJvY2VzcyddICYmIGdsb2JhbFsncHJvY2VzcyddLmVudi5WVUVfRU5WID09PSAnc2VydmVyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfaXNTZXJ2ZXI7XG59O1xuLy8gZGV0ZWN0IGRldnRvb2xzXG5jb25zdCBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpc05hdGl2ZShDdG9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBDdG9yID09PSAnZnVuY3Rpb24nICYmIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpO1xufVxuY29uc3QgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBpc05hdGl2ZShTeW1ib2wpICYmXG4gICAgdHlwZW9mIFJlZmxlY3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcbmxldCBfU2V0OyAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyBpZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAgIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICAgIF9TZXQgPSBTZXQ7XG59XG5lbHNlIHtcbiAgICAvLyBhIG5vbi1zdGFuZGFyZCBTZXQgcG9seWZpbGwgdGhhdCBvbmx5IHdvcmtzIHdpdGggcHJpbWl0aXZlIGtleXMuXG4gICAgX1NldCA9IGNsYXNzIFNldCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGhhcyhrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFtrZXldID09PSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGFkZChrZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxubGV0IGN1cnJlbnRJbnN0YW5jZSA9IG51bGw7XG4vKipcbiAqIFRoaXMgaXMgZXhwb3NlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIHYzIChlLmcuIHNvbWUgZnVuY3Rpb25zIGluIFZ1ZVVzZVxuICogcmVsaWVzIG9uIGl0KS4gRG8gbm90IHVzZSB0aGlzIGludGVybmFsbHksIGp1c3QgdXNlIGBjdXJyZW50SW5zdGFuY2VgLlxuICpcbiAqIEBpbnRlcm5hbCB0aGlzIGZ1bmN0aW9uIG5lZWRzIG1hbnVhbCB0eXBlIGRlY2xhcmF0aW9uIGJlY2F1c2UgaXQgcmVsaWVzXG4gKiBvbiBwcmV2aW91c2x5IG1hbnVhbGx5IGF1dGhvcmVkIHR5cGVzIGZyb20gVnVlIDJcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudEluc3RhbmNlKCkge1xuICAgIHJldHVybiBjdXJyZW50SW5zdGFuY2UgJiYgeyBwcm94eTogY3VycmVudEluc3RhbmNlIH07XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBzZXRDdXJyZW50SW5zdGFuY2Uodm0gPSBudWxsKSB7XG4gICAgaWYgKCF2bSlcbiAgICAgICAgY3VycmVudEluc3RhbmNlICYmIGN1cnJlbnRJbnN0YW5jZS5fc2NvcGUub2ZmKCk7XG4gICAgY3VycmVudEluc3RhbmNlID0gdm07XG4gICAgdm0gJiYgdm0uX3Njb3BlLm9uKCk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFZOb2RlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWcsIGRhdGEsIGNoaWxkcmVuLCB0ZXh0LCBlbG0sIGNvbnRleHQsIGNvbXBvbmVudE9wdGlvbnMsIGFzeW5jRmFjdG9yeSkge1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmVsbSA9IGVsbTtcbiAgICAgICAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5mbkNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZuU2NvcGVJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5rZXkgPSBkYXRhICYmIGRhdGEua2V5O1xuICAgICAgICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICAgICAgICB0aGlzLmNvbXBvbmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0YXRpYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUm9vdEluc2VydCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbG9uZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc09uY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gICAgICAgIHRoaXMuYXN5bmNNZXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlzQXN5bmNQbGFjZWhvbGRlciA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBERVBSRUNBVEVEOiBhbGlhcyBmb3IgY29tcG9uZW50SW5zdGFuY2UgZm9yIGJhY2t3YXJkcyBjb21wYXQuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBnZXQgY2hpbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlO1xuICAgIH1cbn1cbmNvbnN0IGNyZWF0ZUVtcHR5Vk5vZGUgPSAodGV4dCA9ICcnKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBWTm9kZSgpO1xuICAgIG5vZGUudGV4dCA9IHRleHQ7XG4gICAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICAgIHJldHVybiBub2RlO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSh2YWwpIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIFN0cmluZyh2YWwpKTtcbn1cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlKHZub2RlKSB7XG4gICAgY29uc3QgY2xvbmVkID0gbmV3IFZOb2RlKHZub2RlLnRhZywgdm5vZGUuZGF0YSwgXG4gICAgLy8gIzc5NzVcbiAgICAvLyBjbG9uZSBjaGlsZHJlbiBhcnJheSB0byBhdm9pZCBtdXRhdGluZyBvcmlnaW5hbCBpbiBjYXNlIG9mIGNsb25pbmdcbiAgICAvLyBhIGNoaWxkLlxuICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksIHZub2RlLnRleHQsIHZub2RlLmVsbSwgdm5vZGUuY29udGV4dCwgdm5vZGUuY29tcG9uZW50T3B0aW9ucywgdm5vZGUuYXN5bmNGYWN0b3J5KTtcbiAgICBjbG9uZWQubnMgPSB2bm9kZS5ucztcbiAgICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgICBjbG9uZWQua2V5ID0gdm5vZGUua2V5O1xuICAgIGNsb25lZC5pc0NvbW1lbnQgPSB2bm9kZS5pc0NvbW1lbnQ7XG4gICAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgICBjbG9uZWQuZm5PcHRpb25zID0gdm5vZGUuZm5PcHRpb25zO1xuICAgIGNsb25lZC5mblNjb3BlSWQgPSB2bm9kZS5mblNjb3BlSWQ7XG4gICAgY2xvbmVkLmFzeW5jTWV0YSA9IHZub2RlLmFzeW5jTWV0YTtcbiAgICBjbG9uZWQuaXNDbG9uZWQgPSB0cnVlO1xuICAgIHJldHVybiBjbG9uZWQ7XG59XG5cbi8qIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aCBQcm94eSAqL1xubGV0IGluaXRQcm94eTtcbntcbiAgICBjb25zdCBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAgICAgJ01hdGgsTnVtYmVyLERhdGUsQXJyYXksT2JqZWN0LEJvb2xlYW4sU3RyaW5nLFJlZ0V4cCxNYXAsU2V0LEpTT04sSW50bCxCaWdJbnQsJyArXG4gICAgICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICAgKTtcbiAgICBjb25zdCB3YXJuTm9uUHJlc2VudCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICB3YXJuJDIoYFByb3BlcnR5IG9yIG1ldGhvZCBcIiR7a2V5fVwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgYCArXG4gICAgICAgICAgICAncmVmZXJlbmNlZCBkdXJpbmcgcmVuZGVyLiBNYWtlIHN1cmUgdGhhdCB0aGlzIHByb3BlcnR5IGlzIHJlYWN0aXZlLCAnICtcbiAgICAgICAgICAgICdlaXRoZXIgaW4gdGhlIGRhdGEgb3B0aW9uLCBvciBmb3IgY2xhc3MtYmFzZWQgY29tcG9uZW50cywgYnkgJyArXG4gICAgICAgICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAgICAgICAnU2VlOiBodHRwczovL3YyLnZ1ZWpzLm9yZy92Mi9ndWlkZS9yZWFjdGl2aXR5Lmh0bWwjRGVjbGFyaW5nLVJlYWN0aXZlLVByb3BlcnRpZXMuJywgdGFyZ2V0KTtcbiAgICB9O1xuICAgIGNvbnN0IHdhcm5SZXNlcnZlZFByZWZpeCA9ICh0YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICB3YXJuJDIoYFByb3BlcnR5IFwiJHtrZXl9XCIgbXVzdCBiZSBhY2Nlc3NlZCB3aXRoIFwiJGRhdGEuJHtrZXl9XCIgYmVjYXVzZSBgICtcbiAgICAgICAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAgICAgICAncHJldmVudCBjb25mbGljdHMgd2l0aCBWdWUgaW50ZXJuYWxzLiAnICtcbiAgICAgICAgICAgICdTZWU6IGh0dHBzOi8vdjIudnVlanMub3JnL3YyL2FwaS8jZGF0YScsIHRhcmdldCk7XG4gICAgfTtcbiAgICBjb25zdCBoYXNQcm94eSA9IHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJveHkpO1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgICBjb25zdCBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICAgICAgY29uZmlnLmtleUNvZGVzID0gbmV3IFByb3h5KGNvbmZpZy5rZXlDb2Rlcywge1xuICAgICAgICAgICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihgQXZvaWQgb3ZlcndyaXRpbmcgYnVpbHQtaW4gbW9kaWZpZXIgaW4gY29uZmlnLmtleUNvZGVzOiAuJHtrZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGhhc0hhbmRsZXIgPSB7XG4gICAgICAgIGhhcyh0YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgY29uc3QgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmXG4gICAgICAgICAgICAgICAgICAgICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gdGFyZ2V0LiRkYXRhKVxuICAgICAgICAgICAgICAgICAgICB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgd2Fybk5vblByZXNlbnQodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhcyB8fCAhaXNBbGxvd2VkO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBnZXRIYW5kbGVyID0ge1xuICAgICAgICBnZXQodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5SZXNlcnZlZFByZWZpeCh0YXJnZXQsIGtleSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W2tleV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGluaXRQcm94eSA9IGZ1bmN0aW9uIGluaXRQcm94eSh2bSkge1xuICAgICAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB3aGljaCBwcm94eSBoYW5kbGVyIHRvIHVzZVxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBvcHRpb25zLnJlbmRlciAmJiBvcHRpb25zLnJlbmRlci5fd2l0aFN0cmlwcGVkID8gZ2V0SGFuZGxlciA6IGhhc0hhbmRsZXI7XG4gICAgICAgICAgICB2bS5fcmVuZGVyUHJveHkgPSBuZXcgUHJveHkodm0sIGhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxubGV0IHVpZCQyID0gMDtcbmNvbnN0IHBlbmRpbmdDbGVhbnVwRGVwcyA9IFtdO1xuY29uc3QgY2xlYW51cERlcHMgPSAoKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZW5kaW5nQ2xlYW51cERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVwID0gcGVuZGluZ0NsZWFudXBEZXBzW2ldO1xuICAgICAgICBkZXAuc3VicyA9IGRlcC5zdWJzLmZpbHRlcihzID0+IHMpO1xuICAgICAgICBkZXAuX3BlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgcGVuZGluZ0NsZWFudXBEZXBzLmxlbmd0aCA9IDA7XG59O1xuLyoqXG4gKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAqIGRpcmVjdGl2ZXMgc3Vic2NyaWJpbmcgdG8gaXQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgRGVwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gcGVuZGluZyBzdWJzIGNsZWFudXBcbiAgICAgICAgdGhpcy5fcGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlkID0gdWlkJDIrKztcbiAgICAgICAgdGhpcy5zdWJzID0gW107XG4gICAgfVxuICAgIGFkZFN1YihzdWIpIHtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbiAgICB9XG4gICAgcmVtb3ZlU3ViKHN1Yikge1xuICAgICAgICAvLyAjMTI2OTYgZGVwcyB3aXRoIG1hc3NpdmUgYW1vdW50IG9mIHN1YnNjcmliZXJzIGFyZSBleHRyZW1lbHkgc2xvdyB0b1xuICAgICAgICAvLyBjbGVhbiB1cCBpbiBDaHJvbWl1bVxuICAgICAgICAvLyB0byB3b3JrYXJvdW5kIHRoaXMsIHdlIHVuc2V0IHRoZSBzdWIgZm9yIG5vdywgYW5kIGNsZWFyIHRoZW0gb25cbiAgICAgICAgLy8gbmV4dCBzY2hlZHVsZXIgZmx1c2guXG4gICAgICAgIHRoaXMuc3Vic1t0aGlzLnN1YnMuaW5kZXhPZihzdWIpXSA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICBwZW5kaW5nQ2xlYW51cERlcHMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXBlbmQoaW5mbykge1xuICAgICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICAgICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gICAgICAgICAgICBpZiAoaW5mbyAmJiBEZXAudGFyZ2V0Lm9uVHJhY2spIHtcbiAgICAgICAgICAgICAgICBEZXAudGFyZ2V0Lm9uVHJhY2soT2JqZWN0LmFzc2lnbih7IGVmZmVjdDogRGVwLnRhcmdldCB9LCBpbmZvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5KGluZm8pIHtcbiAgICAgICAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgICAgICAgY29uc3Qgc3VicyA9IHRoaXMuc3Vicy5maWx0ZXIocyA9PiBzKTtcbiAgICAgICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgICAgIC8vIHN1YnMgYXJlbid0IHNvcnRlZCBpbiBzY2hlZHVsZXIgaWYgbm90IHJ1bm5pbmcgYXN5bmNcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVtIG5vdyB0byBtYWtlIHN1cmUgdGhleSBmaXJlIGluIGNvcnJlY3RcbiAgICAgICAgICAgIC8vIG9yZGVyXG4gICAgICAgICAgICBzdWJzLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHN1YnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBzdWJzW2ldO1xuICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICBzdWIub25UcmlnZ2VyICYmXG4gICAgICAgICAgICAgICAgICAgIHN1Yi5vblRyaWdnZXIoT2JqZWN0LmFzc2lnbih7IGVmZmVjdDogc3Vic1tpXSB9LCBpbmZvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBUaGUgY3VycmVudCB0YXJnZXQgd2F0Y2hlciBiZWluZyBldmFsdWF0ZWQuXG4vLyBUaGlzIGlzIGdsb2JhbGx5IHVuaXF1ZSBiZWNhdXNlIG9ubHkgb25lIHdhdGNoZXJcbi8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG5jb25zdCB0YXJnZXRTdGFjayA9IFtdO1xuZnVuY3Rpb24gcHVzaFRhcmdldCh0YXJnZXQpIHtcbiAgICB0YXJnZXRTdGFjay5wdXNoKHRhcmdldCk7XG4gICAgRGVwLnRhcmdldCA9IHRhcmdldDtcbn1cbmZ1bmN0aW9uIHBvcFRhcmdldCgpIHtcbiAgICB0YXJnZXRTdGFjay5wb3AoKTtcbiAgICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2tbdGFyZ2V0U3RhY2subGVuZ3RoIC0gMV07XG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5jb25zdCBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuY29uc3QgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtcbmNvbnN0IG1ldGhvZHNUb1BhdGNoID0gW1xuICAgICdwdXNoJyxcbiAgICAncG9wJyxcbiAgICAnc2hpZnQnLFxuICAgICd1bnNoaWZ0JyxcbiAgICAnc3BsaWNlJyxcbiAgICAnc29ydCcsXG4gICAgJ3JldmVyc2UnXG5dO1xuLyoqXG4gKiBJbnRlcmNlcHQgbXV0YXRpbmcgbWV0aG9kcyBhbmQgZW1pdCBldmVudHNcbiAqL1xubWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gICAgY29uc3Qgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gICAgZGVmKGFycmF5TWV0aG9kcywgbWV0aG9kLCBmdW5jdGlvbiBtdXRhdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGNvbnN0IG9iID0gdGhpcy5fX29iX187XG4gICAgICAgIGxldCBpbnNlcnRlZDtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgICAgICAgICBpbnNlcnRlZCA9IGFyZ3Muc2xpY2UoMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc2VydGVkKVxuICAgICAgICAgICAgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTtcbiAgICAgICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgICAgICB7XG4gICAgICAgICAgICBvYi5kZXAubm90aWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5IG11dGF0aW9uXCIgLyogVHJpZ2dlck9wVHlwZXMuQVJSQVlfTVVUQVRJT04gKi8sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgIGtleTogbWV0aG9kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufSk7XG5cbmNvbnN0IGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5jb25zdCBOT19JTklUSUFMX1ZBTFVFID0ge307XG4vKipcbiAqIEluIHNvbWUgY2FzZXMgd2UgbWF5IHdhbnQgdG8gZGlzYWJsZSBvYnNlcnZhdGlvbiBpbnNpZGUgYSBjb21wb25lbnQnc1xuICogdXBkYXRlIGNvbXB1dGF0aW9uLlxuICovXG5sZXQgc2hvdWxkT2JzZXJ2ZSA9IHRydWU7XG5mdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcodmFsdWUpIHtcbiAgICBzaG91bGRPYnNlcnZlID0gdmFsdWU7XG59XG4vLyBzc3IgbW9jayBkZXBcbmNvbnN0IG1vY2tEZXAgPSB7XG4gICAgbm90aWZ5OiBub29wLFxuICAgIGRlcGVuZDogbm9vcCxcbiAgICBhZGRTdWI6IG5vb3AsXG4gICAgcmVtb3ZlU3ViOiBub29wXG59O1xuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGlzIGF0dGFjaGVkIHRvIGVhY2ggb2JzZXJ2ZWRcbiAqIG9iamVjdC4gT25jZSBhdHRhY2hlZCwgdGhlIG9ic2VydmVyIGNvbnZlcnRzIHRoZSB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2ggdXBkYXRlcy5cbiAqL1xuY2xhc3MgT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBzaGFsbG93ID0gZmFsc2UsIG1vY2sgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2hhbGxvdyA9IHNoYWxsb3c7XG4gICAgICAgIHRoaXMubW9jayA9IG1vY2s7XG4gICAgICAgIC8vIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgICAgICB0aGlzLmRlcCA9IG1vY2sgPyBtb2NrRGVwIDogbmV3IERlcCgpO1xuICAgICAgICB0aGlzLnZtQ291bnQgPSAwO1xuICAgICAgICBkZWYodmFsdWUsICdfX29iX18nLCB0aGlzKTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIW1vY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuX19wcm90b19fID0gYXJyYXlNZXRob2RzO1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5S2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGFycmF5S2V5c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZih2YWx1ZSwga2V5LCBhcnJheU1ldGhvZHNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAgICAgICAgICAgICAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICAgICAgICAgICAgICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWN0aXZlKHZhbHVlLCBrZXksIE5PX0lOSVRJQUxfVkFMVUUsIHVuZGVmaW5lZCwgc2hhbGxvdywgbW9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gICAgICovXG4gICAgb2JzZXJ2ZUFycmF5KHZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBvYnNlcnZlKHZhbHVlW2ldLCBmYWxzZSwgdGhpcy5tb2NrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIGhlbHBlcnNcbi8qKlxuICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gKiByZXR1cm5zIHRoZSBuZXcgb2JzZXJ2ZXIgaWYgc3VjY2Vzc2Z1bGx5IG9ic2VydmVkLFxuICogb3IgdGhlIGV4aXN0aW5nIG9ic2VydmVyIGlmIHRoZSB2YWx1ZSBhbHJlYWR5IGhhcyBvbmUuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmUodmFsdWUsIHNoYWxsb3csIHNzck1vY2tSZWFjdGl2aXR5KSB7XG4gICAgaWYgKHZhbHVlICYmIGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5fX29iX187XG4gICAgfVxuICAgIGlmIChzaG91bGRPYnNlcnZlICYmXG4gICAgICAgIChzc3JNb2NrUmVhY3Rpdml0eSB8fCAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkgJiZcbiAgICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpKSAmJlxuICAgICAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICAgICAhdmFsdWUuX192X3NraXAgLyogUmVhY3RpdmVGbGFncy5TS0lQICovICYmXG4gICAgICAgICFpc1JlZih2YWx1ZSkgJiZcbiAgICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmVyKHZhbHVlLCBzaGFsbG93LCBzc3JNb2NrUmVhY3Rpdml0eSk7XG4gICAgfVxufVxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlKG9iaiwga2V5LCB2YWwsIGN1c3RvbVNldHRlciwgc2hhbGxvdywgbW9jaywgb2JzZXJ2ZUV2ZW5JZlNoYWxsb3cgPSBmYWxzZSkge1xuICAgIGNvbnN0IGRlcCA9IG5ldyBEZXAoKTtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gY2F0ZXIgZm9yIHByZS1kZWZpbmVkIGdldHRlci9zZXR0ZXJzXG4gICAgY29uc3QgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICAgIGNvbnN0IHNldHRlciA9IHByb3BlcnR5ICYmIHByb3BlcnR5LnNldDtcbiAgICBpZiAoKCFnZXR0ZXIgfHwgc2V0dGVyKSAmJlxuICAgICAgICAodmFsID09PSBOT19JTklUSUFMX1ZBTFVFIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpKSB7XG4gICAgICAgIHZhbCA9IG9ialtrZXldO1xuICAgIH1cbiAgICBsZXQgY2hpbGRPYiA9IHNoYWxsb3cgPyB2YWwgJiYgdmFsLl9fb2JfXyA6IG9ic2VydmUodmFsLCBmYWxzZSwgbW9jayk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkZXAuZGVwZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogb2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRPYikge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNSZWYodmFsdWUpICYmICFzaGFsbG93ID8gdmFsdWUudmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiByZWFjdGl2ZVNldHRlcihuZXdWYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgICAgICAgIGlmICghaGFzQ2hhbmdlZCh2YWx1ZSwgbmV3VmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXN0b21TZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21TZXR0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChnZXR0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyAjNzk4MTogZm9yIGFjY2Vzc29yIHByb3BlcnRpZXMgd2l0aG91dCBzZXR0ZXJcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghc2hhbGxvdyAmJiBpc1JlZih2YWx1ZSkgJiYgIWlzUmVmKG5ld1ZhbCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS52YWx1ZSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZE9iID0gc2hhbGxvdyA/IG5ld1ZhbCAmJiBuZXdWYWwuX19vYl9fIDogb2JzZXJ2ZShuZXdWYWwsIGZhbHNlLCBtb2NrKTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZXAubm90aWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogb2JqLFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdWYWwsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlcDtcbn1cbmZ1bmN0aW9uIHNldCh0YXJnZXQsIGtleSwgdmFsKSB7XG4gICAgaWYgKChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSkpIHtcbiAgICAgICAgd2FybiQyKGBDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiAke3RhcmdldH1gKTtcbiAgICB9XG4gICAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xuICAgICAgICB3YXJuJDIoYFNldCBvcGVyYXRpb24gb24ga2V5IFwiJHtrZXl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb2IgPSB0YXJnZXQuX19vYl9fO1xuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgICAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgICAgIC8vIHdoZW4gbW9ja2luZyBmb3IgU1NSLCBhcnJheSBtZXRob2RzIGFyZSBub3QgaGlqYWNrZWRcbiAgICAgICAgaWYgKG9iICYmICFvYi5zaGFsbG93ICYmIG9iLm1vY2spIHtcbiAgICAgICAgICAgIG9ic2VydmUodmFsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgaWYgKGtleSBpbiB0YXJnZXQgJiYgIShrZXkgaW4gT2JqZWN0LnByb3RvdHlwZSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGlmICh0YXJnZXQuX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgICAgICB3YXJuJDIoJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgICAgICAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nKTtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgaWYgKCFvYikge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZGVmaW5lUmVhY3RpdmUob2IudmFsdWUsIGtleSwgdmFsLCB1bmRlZmluZWQsIG9iLnNoYWxsb3csIG9iLm1vY2spO1xuICAgIHtcbiAgICAgICAgb2IuZGVwLm5vdGlmeSh7XG4gICAgICAgICAgICB0eXBlOiBcImFkZFwiIC8qIFRyaWdnZXJPcFR5cGVzLkFERCAqLyxcbiAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgbmV3VmFsdWU6IHZhbCxcbiAgICAgICAgICAgIG9sZFZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBkZWwodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoKGlzVW5kZWYodGFyZ2V0KSB8fCBpc1ByaW1pdGl2ZSh0YXJnZXQpKSkge1xuICAgICAgICB3YXJuJDIoYENhbm5vdCBkZWxldGUgcmVhY3RpdmUgcHJvcGVydHkgb24gdW5kZWZpbmVkLCBudWxsLCBvciBwcmltaXRpdmUgdmFsdWU6ICR7dGFyZ2V0fWApO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzVmFsaWRBcnJheUluZGV4KGtleSkpIHtcbiAgICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9iID0gdGFyZ2V0Ll9fb2JfXztcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgICAgd2FybiQyKCdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgICAgICAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUmVhZG9ubHkodGFyZ2V0KSkge1xuICAgICAgICB3YXJuJDIoYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtrZXl9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgIGlmICghb2IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB7XG4gICAgICAgIG9iLmRlcC5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogXCJkZWxldGVcIiAvKiBUcmlnZ2VyT3BUeXBlcy5ERUxFVEUgKi8sXG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgIGtleVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkodmFsdWUpIHtcbiAgICBmb3IgKGxldCBlLCBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBlID0gdmFsdWVbaV07XG4gICAgICAgIGlmIChlICYmIGUuX19vYl9fKSB7XG4gICAgICAgICAgICBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkoZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFjdGl2ZSh0YXJnZXQpIHtcbiAgICBtYWtlUmVhY3RpdmUodGFyZ2V0LCBmYWxzZSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogUmV0dXJuIGEgc2hhbGxvd2x5LXJlYWN0aXZlIGNvcHkgb2YgdGhlIG9yaWdpbmFsIG9iamVjdCwgd2hlcmUgb25seSB0aGUgcm9vdFxuICogbGV2ZWwgcHJvcGVydGllcyBhcmUgcmVhY3RpdmUuIEl0IGFsc28gZG9lcyBub3QgYXV0by11bndyYXAgcmVmcyAoZXZlbiBhdCB0aGVcbiAqIHJvb3QgbGV2ZWwpLlxuICovXG5mdW5jdGlvbiBzaGFsbG93UmVhY3RpdmUodGFyZ2V0KSB7XG4gICAgbWFrZVJlYWN0aXZlKHRhcmdldCwgdHJ1ZSk7XG4gICAgZGVmKHRhcmdldCwgXCJfX3ZfaXNTaGFsbG93XCIgLyogUmVhY3RpdmVGbGFncy5JU19TSEFMTE9XICovLCB0cnVlKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbWFrZVJlYWN0aXZlKHRhcmdldCwgc2hhbGxvdykge1xuICAgIC8vIGlmIHRyeWluZyB0byBvYnNlcnZlIGEgcmVhZG9ubHkgcHJveHksIHJldHVybiB0aGUgcmVhZG9ubHkgdmVyc2lvbi5cbiAgICBpZiAoIWlzUmVhZG9ubHkodGFyZ2V0KSkge1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBBdm9pZCB1c2luZyBBcnJheSBhcyByb290IHZhbHVlIGZvciAke3NoYWxsb3cgPyBgc2hhbGxvd1JlYWN0aXZlKClgIDogYHJlYWN0aXZlKClgfSBhcyBpdCBjYW5ub3QgYmUgdHJhY2tlZCBpbiB3YXRjaCgpIG9yIHdhdGNoRWZmZWN0KCkuIFVzZSAke3NoYWxsb3cgPyBgc2hhbGxvd1JlZigpYCA6IGByZWYoKWB9IGluc3RlYWQuIFRoaXMgaXMgYSBWdWUtMi1vbmx5IGxpbWl0YXRpb24uYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ09iID0gdGFyZ2V0ICYmIHRhcmdldC5fX29iX187XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdPYiAmJiBleGlzdGluZ09iLnNoYWxsb3cgIT09IHNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYFRhcmdldCBpcyBhbHJlYWR5IGEgJHtleGlzdGluZ09iLnNoYWxsb3cgPyBgYCA6IGBub24tYH1zaGFsbG93IHJlYWN0aXZlIG9iamVjdCwgYW5kIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gJHtzaGFsbG93ID8gYGAgOiBgbm9uLWB9c2hhbGxvdy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYiA9IG9ic2VydmUodGFyZ2V0LCBzaGFsbG93LCBpc1NlcnZlclJlbmRlcmluZygpIC8qIHNzciBtb2NrIHJlYWN0aXZpdHkgKi8pO1xuICAgICAgICBpZiAoIW9iKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09IG51bGwgfHwgaXNQcmltaXRpdmUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHRhcmdldCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBWdWUgMiBkb2VzIG5vdCBzdXBwb3J0IHJlYWN0aXZlIGNvbGxlY3Rpb24gdHlwZXMgc3VjaCBhcyBNYXAgb3IgU2V0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNSZWFjdGl2ZSh2YWx1ZSkge1xuICAgIGlmIChpc1JlYWRvbmx5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gaXNSZWFjdGl2ZSh2YWx1ZVtcIl9fdl9yYXdcIiAvKiBSZWFjdGl2ZUZsYWdzLlJBVyAqL10pO1xuICAgIH1cbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19vYl9fKTtcbn1cbmZ1bmN0aW9uIGlzU2hhbGxvdyh2YWx1ZSkge1xuICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX3ZfaXNTaGFsbG93KTtcbn1cbmZ1bmN0aW9uIGlzUmVhZG9ubHkodmFsdWUpIHtcbiAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX192X2lzUmVhZG9ubHkpO1xufVxuZnVuY3Rpb24gaXNQcm94eSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1JlYWN0aXZlKHZhbHVlKSB8fCBpc1JlYWRvbmx5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHRvUmF3KG9ic2VydmVkKSB7XG4gICAgY29uc3QgcmF3ID0gb2JzZXJ2ZWQgJiYgb2JzZXJ2ZWRbXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi9dO1xuICAgIHJldHVybiByYXcgPyB0b1JhdyhyYXcpIDogb2JzZXJ2ZWQ7XG59XG5mdW5jdGlvbiBtYXJrUmF3KHZhbHVlKSB7XG4gICAgLy8gbm9uLWV4dGVuc2libGUgb2JqZWN0cyB3b24ndCBiZSBvYnNlcnZlZCBhbnl3YXlcbiAgICBpZiAoT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgZGVmKHZhbHVlLCBcIl9fdl9za2lwXCIgLyogUmVhY3RpdmVGbGFncy5TS0lQICovLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNDb2xsZWN0aW9uVHlwZSh2YWx1ZSkge1xuICAgIGNvbnN0IHR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICAgIHJldHVybiAodHlwZSA9PT0gJ01hcCcgfHwgdHlwZSA9PT0gJ1dlYWtNYXAnIHx8IHR5cGUgPT09ICdTZXQnIHx8IHR5cGUgPT09ICdXZWFrU2V0Jyk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFJlZkZsYWcgPSBgX192X2lzUmVmYDtcbmZ1bmN0aW9uIGlzUmVmKHIpIHtcbiAgICByZXR1cm4gISEociAmJiByLl9fdl9pc1JlZiA9PT0gdHJ1ZSk7XG59XG5mdW5jdGlvbiByZWYkMSh2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGVSZWYodmFsdWUsIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNoYWxsb3dSZWYodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVmKHZhbHVlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlZihyYXdWYWx1ZSwgc2hhbGxvdykge1xuICAgIGlmIChpc1JlZihyYXdWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHJhd1ZhbHVlO1xuICAgIH1cbiAgICBjb25zdCByZWYgPSB7fTtcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcbiAgICBkZWYocmVmLCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHNoYWxsb3cpO1xuICAgIGRlZihyZWYsICdkZXAnLCBkZWZpbmVSZWFjdGl2ZShyZWYsICd2YWx1ZScsIHJhd1ZhbHVlLCBudWxsLCBzaGFsbG93LCBpc1NlcnZlclJlbmRlcmluZygpKSk7XG4gICAgcmV0dXJuIHJlZjtcbn1cbmZ1bmN0aW9uIHRyaWdnZXJSZWYocmVmKSB7XG4gICAgaWYgKCFyZWYuZGVwKSB7XG4gICAgICAgIHdhcm4kMihgcmVjZWl2ZWQgb2JqZWN0IGlzIG5vdCBhIHRyaWdnZXJhYmxlIHJlZi5gKTtcbiAgICB9XG4gICAge1xuICAgICAgICByZWYuZGVwICYmXG4gICAgICAgICAgICByZWYuZGVwLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXG4gICAgICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bnJlZihyZWYpIHtcbiAgICByZXR1cm4gaXNSZWYocmVmKSA/IHJlZi52YWx1ZSA6IHJlZjtcbn1cbmZ1bmN0aW9uIHByb3h5UmVmcyhvYmplY3RXaXRoUmVmcykge1xuICAgIGlmIChpc1JlYWN0aXZlKG9iamVjdFdpdGhSZWZzKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0V2l0aFJlZnM7XG4gICAgfVxuICAgIGNvbnN0IHByb3h5ID0ge307XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdFdpdGhSZWZzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJveHlXaXRoUmVmVW53cmFwKHByb3h5LCBvYmplY3RXaXRoUmVmcywga2V5c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIHByb3h5V2l0aFJlZlVud3JhcCh0YXJnZXQsIHNvdXJjZSwga2V5KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIGlmIChpc1JlZih2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iID0gdmFsICYmIHZhbC5fX29iX187XG4gICAgICAgICAgICAgICAgaWYgKG9iKVxuICAgICAgICAgICAgICAgICAgICBvYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgaWYgKGlzUmVmKG9sZFZhbHVlKSAmJiAhaXNSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGN1c3RvbVJlZihmYWN0b3J5KSB7XG4gICAgY29uc3QgZGVwID0gbmV3IERlcCgpO1xuICAgIGNvbnN0IHsgZ2V0LCBzZXQgfSA9IGZhY3RvcnkoKCkgPT4ge1xuICAgICAgICB7XG4gICAgICAgICAgICBkZXAuZGVwZW5kKHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHJlZixcbiAgICAgICAgICAgICAgICB0eXBlOiBcImdldFwiIC8qIFRyYWNrT3BUeXBlcy5HRVQgKi8sXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sICgpID0+IHtcbiAgICAgICAge1xuICAgICAgICAgICAgZGVwLm5vdGlmeSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIiAvKiBUcmlnZ2VyT3BUeXBlcy5TRVQgKi8sXG4gICAgICAgICAgICAgICAga2V5OiAndmFsdWUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHJlZiA9IHtcbiAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgdmFsdWUobmV3VmFsKSB7XG4gICAgICAgICAgICBzZXQobmV3VmFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVmKHJlZiwgUmVmRmxhZywgdHJ1ZSk7XG4gICAgcmV0dXJuIHJlZjtcbn1cbmZ1bmN0aW9uIHRvUmVmcyhvYmplY3QpIHtcbiAgICBpZiAoIWlzUmVhY3RpdmUob2JqZWN0KSkge1xuICAgICAgICB3YXJuJDIoYHRvUmVmcygpIGV4cGVjdHMgYSByZWFjdGl2ZSBvYmplY3QgYnV0IHJlY2VpdmVkIGEgcGxhaW4gb25lLmApO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSBpc0FycmF5KG9iamVjdCkgPyBuZXcgQXJyYXkob2JqZWN0Lmxlbmd0aCkgOiB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgcmV0W2tleV0gPSB0b1JlZihvYmplY3QsIGtleSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiB0b1JlZihvYmplY3QsIGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgY29uc3QgdmFsID0gb2JqZWN0W2tleV07XG4gICAgaWYgKGlzUmVmKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgY29uc3QgcmVmID0ge1xuICAgICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHZhbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IHZhbHVlKG5ld1ZhbCkge1xuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBuZXdWYWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlZihyZWYsIFJlZkZsYWcsIHRydWUpO1xuICAgIHJldHVybiByZWY7XG59XG5cbmNvbnN0IHJhd1RvUmVhZG9ubHlGbGFnID0gYF9fdl9yYXdUb1JlYWRvbmx5YDtcbmNvbnN0IHJhd1RvU2hhbGxvd1JlYWRvbmx5RmxhZyA9IGBfX3ZfcmF3VG9TaGFsbG93UmVhZG9ubHlgO1xuZnVuY3Rpb24gcmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRvbmx5KHRhcmdldCwgZmFsc2UpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVhZG9ubHkodGFyZ2V0LCBzaGFsbG93KSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHRhcmdldCkpIHtcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMihgVnVlIDIgZG9lcyBub3Qgc3VwcG9ydCByZWFkb25seSBhcnJheXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0NvbGxlY3Rpb25UeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYFZ1ZSAyIGRvZXMgbm90IHN1cHBvcnQgcmVhZG9ubHkgY29sbGVjdGlvbiB0eXBlcyBzdWNoIGFzIE1hcCBvciBTZXQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYHZhbHVlIGNhbm5vdCBiZSBtYWRlIHJlYWRvbmx5OiAke3R5cGVvZiB0YXJnZXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgaWYgKCFPYmplY3QuaXNFeHRlbnNpYmxlKHRhcmdldCkpIHtcbiAgICAgICAgd2FybiQyKGBWdWUgMiBkb2VzIG5vdCBzdXBwb3J0IGNyZWF0aW5nIHJlYWRvbmx5IHByb3h5IGZvciBub24tZXh0ZW5zaWJsZSBvYmplY3QuYCk7XG4gICAgfVxuICAgIC8vIGFscmVhZHkgYSByZWFkb25seSBvYmplY3RcbiAgICBpZiAoaXNSZWFkb25seSh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8vIGFscmVhZHkgaGFzIGEgcmVhZG9ubHkgcHJveHlcbiAgICBjb25zdCBleGlzdGluZ0ZsYWcgPSBzaGFsbG93ID8gcmF3VG9TaGFsbG93UmVhZG9ubHlGbGFnIDogcmF3VG9SZWFkb25seUZsYWc7XG4gICAgY29uc3QgZXhpc3RpbmdQcm94eSA9IHRhcmdldFtleGlzdGluZ0ZsYWddO1xuICAgIGlmIChleGlzdGluZ1Byb3h5KSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1Byb3h5O1xuICAgIH1cbiAgICBjb25zdCBwcm94eSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCkpO1xuICAgIGRlZih0YXJnZXQsIGV4aXN0aW5nRmxhZywgcHJveHkpO1xuICAgIGRlZihwcm94eSwgXCJfX3ZfaXNSZWFkb25seVwiIC8qIFJlYWN0aXZlRmxhZ3MuSVNfUkVBRE9OTFkgKi8sIHRydWUpO1xuICAgIGRlZihwcm94eSwgXCJfX3ZfcmF3XCIgLyogUmVhY3RpdmVGbGFncy5SQVcgKi8sIHRhcmdldCk7XG4gICAgaWYgKGlzUmVmKHRhcmdldCkpIHtcbiAgICAgICAgZGVmKHByb3h5LCBSZWZGbGFnLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHNoYWxsb3cgfHwgaXNTaGFsbG93KHRhcmdldCkpIHtcbiAgICAgICAgZGVmKHByb3h5LCBcIl9fdl9pc1NoYWxsb3dcIiAvKiBSZWFjdGl2ZUZsYWdzLklTX1NIQUxMT1cgKi8sIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVmaW5lUmVhZG9ubHlQcm9wZXJ0eShwcm94eSwgdGFyZ2V0LCBrZXlzW2ldLCBzaGFsbG93KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gZGVmaW5lUmVhZG9ubHlQcm9wZXJ0eShwcm94eSwgdGFyZ2V0LCBrZXksIHNoYWxsb3cpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIHNoYWxsb3cgfHwgIWlzUGxhaW5PYmplY3QodmFsKSA/IHZhbCA6IHJlYWRvbmx5KHZhbCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgIHdhcm4kMihgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke2tleX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgcmVhY3RpdmUtY29weSBvZiB0aGUgb3JpZ2luYWwgb2JqZWN0LCB3aGVyZSBvbmx5IHRoZSByb290IGxldmVsXG4gKiBwcm9wZXJ0aWVzIGFyZSByZWFkb25seSwgYW5kIGRvZXMgTk9UIHVud3JhcCByZWZzIG5vciByZWN1cnNpdmVseSBjb252ZXJ0XG4gKiByZXR1cm5lZCBwcm9wZXJ0aWVzLlxuICogVGhpcyBpcyB1c2VkIGZvciBjcmVhdGluZyB0aGUgcHJvcHMgcHJveHkgb2JqZWN0IGZvciBzdGF0ZWZ1bCBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBzaGFsbG93UmVhZG9ubHkodGFyZ2V0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRvbmx5KHRhcmdldCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVkKGdldHRlck9yT3B0aW9ucywgZGVidWdPcHRpb25zKSB7XG4gICAgbGV0IGdldHRlcjtcbiAgICBsZXQgc2V0dGVyO1xuICAgIGNvbnN0IG9ubHlHZXR0ZXIgPSBpc0Z1bmN0aW9uKGdldHRlck9yT3B0aW9ucyk7XG4gICAgaWYgKG9ubHlHZXR0ZXIpIHtcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zO1xuICAgICAgICBzZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgd2FybiQyKCdXcml0ZSBvcGVyYXRpb24gZmFpbGVkOiBjb21wdXRlZCB2YWx1ZSBpcyByZWFkb25seScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLmdldDtcbiAgICAgICAgc2V0dGVyID0gZ2V0dGVyT3JPcHRpb25zLnNldDtcbiAgICB9XG4gICAgY29uc3Qgd2F0Y2hlciA9IGlzU2VydmVyUmVuZGVyaW5nKClcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogbmV3IFdhdGNoZXIoY3VycmVudEluc3RhbmNlLCBnZXR0ZXIsIG5vb3AsIHsgbGF6eTogdHJ1ZSB9KTtcbiAgICBpZiAod2F0Y2hlciAmJiBkZWJ1Z09wdGlvbnMpIHtcbiAgICAgICAgd2F0Y2hlci5vblRyYWNrID0gZGVidWdPcHRpb25zLm9uVHJhY2s7XG4gICAgICAgIHdhdGNoZXIub25UcmlnZ2VyID0gZGVidWdPcHRpb25zLm9uVHJpZ2dlcjtcbiAgICB9XG4gICAgY29uc3QgcmVmID0ge1xuICAgICAgICAvLyBzb21lIGxpYnMgcmVseSBvbiB0aGUgcHJlc2VuY2UgZWZmZWN0IGZvciBjaGVja2luZyBjb21wdXRlZCByZWZzXG4gICAgICAgIC8vIGZyb20gbm9ybWFsIHJlZnMsIGJ1dCB0aGUgaW1wbGVtZW50YXRpb24gZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgZWZmZWN0OiB3YXRjaGVyLFxuICAgICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgICAgICBpZiAod2F0Y2hlcikge1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaGVyLmRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKERlcC50YXJnZXQub25UcmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgRGVwLnRhcmdldC5vblRyYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZmZlY3Q6IERlcC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiByZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ3ZhbHVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldCB2YWx1ZShuZXdWYWwpIHtcbiAgICAgICAgICAgIHNldHRlcihuZXdWYWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkZWYocmVmLCBSZWZGbGFnLCB0cnVlKTtcbiAgICBkZWYocmVmLCBcIl9fdl9pc1JlYWRvbmx5XCIgLyogUmVhY3RpdmVGbGFncy5JU19SRUFET05MWSAqLywgb25seUdldHRlcik7XG4gICAgcmV0dXJuIHJlZjtcbn1cblxubGV0IG1hcms7XG5sZXQgbWVhc3VyZTtcbntcbiAgICBjb25zdCBwZXJmID0gaW5Ccm93c2VyICYmIHdpbmRvdy5wZXJmb3JtYW5jZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocGVyZiAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBlcmYubWFyayAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBlcmYubWVhc3VyZSAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBlcmYuY2xlYXJNYXJrcyAmJlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBlcmYuY2xlYXJNZWFzdXJlcykge1xuICAgICAgICBtYXJrID0gdGFnID0+IHBlcmYubWFyayh0YWcpO1xuICAgICAgICBtZWFzdXJlID0gKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpID0+IHtcbiAgICAgICAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgICAgIHBlcmYuY2xlYXJNYXJrcyhzdGFydFRhZyk7XG4gICAgICAgICAgICBwZXJmLmNsZWFyTWFya3MoZW5kVGFnKTtcbiAgICAgICAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuY29uc3Qgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoKG5hbWUpID0+IHtcbiAgICBjb25zdCBwYXNzaXZlID0gbmFtZS5jaGFyQXQoMCkgPT09ICcmJztcbiAgICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIGNvbnN0IG9uY2UgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJ34nOyAvLyBQcmVmaXhlZCBsYXN0LCBjaGVja2VkIGZpcnN0XG4gICAgbmFtZSA9IG9uY2UgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICBjb25zdCBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG9uY2UsXG4gICAgICAgIGNhcHR1cmUsXG4gICAgICAgIHBhc3NpdmVcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBjcmVhdGVGbkludm9rZXIoZm5zLCB2bSkge1xuICAgIGZ1bmN0aW9uIGludm9rZXIoKSB7XG4gICAgICAgIGNvbnN0IGZucyA9IGludm9rZXIuZm5zO1xuICAgICAgICBpZiAoaXNBcnJheShmbnMpKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBmbnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMsIHZtLCBgdi1vbiBoYW5kbGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZucywgbnVsbCwgYXJndW1lbnRzLCB2bSwgYHYtb24gaGFuZGxlcmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZXIuZm5zID0gZm5zO1xuICAgIHJldHVybiBpbnZva2VyO1xufVxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkLCByZW1vdmUsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bSkge1xuICAgIGxldCBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gICAgZm9yIChuYW1lIGluIG9uKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdO1xuICAgICAgICBvbGQgPSBvbGRPbltuYW1lXTtcbiAgICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgICAgICAgd2FybiQyKGBJbnZhbGlkIGhhbmRsZXIgZm9yIGV2ZW50IFwiJHtldmVudC5uYW1lfVwiOiBnb3QgYCArIFN0cmluZyhjdXIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNVbmRlZihvbGQpKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVHJ1ZShldmVudC5vbmNlKSkge1xuICAgICAgICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlT25jZUhhbmRsZXIoZXZlbnQubmFtZSwgY3VyLCBldmVudC5jYXB0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZChldmVudC5uYW1lLCBjdXIsIGV2ZW50LmNhcHR1cmUsIGV2ZW50LnBhc3NpdmUsIGV2ZW50LnBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgICAgICAgIG9sZC5mbnMgPSBjdXI7XG4gICAgICAgICAgICBvbltuYW1lXSA9IG9sZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICAgICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgICAgICAgcmVtb3ZlKGV2ZW50Lm5hbWUsIG9sZE9uW25hbWVdLCBldmVudC5jYXB0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2soZGVmLCBob29rS2V5LCBob29rKSB7XG4gICAgaWYgKGRlZiBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gICAgfVxuICAgIGxldCBpbnZva2VyO1xuICAgIGNvbnN0IG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG4gICAgZnVuY3Rpb24gd3JhcHBlZEhvb2soKSB7XG4gICAgICAgIGhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgICAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgICByZW1vdmUkMihpbnZva2VyLmZucywgd3JhcHBlZEhvb2spO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgICAgICAvLyBubyBleGlzdGluZyBob29rXG4gICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAgICAgICAvLyBhbHJlYWR5IGEgbWVyZ2VkIGludm9rZXJcbiAgICAgICAgICAgIGludm9rZXIgPSBvbGRIb29rO1xuICAgICAgICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICAgICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgICBkZWZbaG9va0tleV0gPSBpbnZva2VyO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZykge1xuICAgIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gICAgY29uc3QgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gICAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgY29uc3QgeyBhdHRycywgcHJvcHMgfSA9IGRhdGE7XG4gICAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0ga2V5SW5Mb3dlckNhc2UgJiYgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGlwKGBQcm9wIFwiJHtrZXlJbkxvd2VyQ2FzZX1cIiBpcyBwYXNzZWQgdG8gY29tcG9uZW50IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGFnIGlzIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnIHx8IEN0b3IpfSwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGAgXCIke2tleX1cIi4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgY2FtZWxDYXNlZCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBwcm9wcyBuZWVkIHRvIHVzZSB0aGVpciBrZWJhYi1jYXNlIGVxdWl2YWxlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYHRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXCIke2FsdEtleX1cIiBpbnN0ZWFkIG9mIFwiJHtrZXl9XCIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgICAgICAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjaGVja1Byb3AocmVzLCBoYXNoLCBrZXksIGFsdEtleSwgcHJlc2VydmUpIHtcbiAgICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICAgICAgaWYgKGhhc093bihoYXNoLCBrZXkpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IGhhc2hba2V5XTtcbiAgICAgICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzT3duKGhhc2gsIGFsdEtleSkpIHtcbiAgICAgICAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYXNoW2FsdEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuLy8gc3RhdGljYWxseSBhbmFseXppbmcgdGhlIHRlbXBsYXRlIGF0IGNvbXBpbGUgdGltZS5cbi8vXG4vLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuLy8gZ2VuZXJhdGVkIHJlbmRlciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJldHVybiBBcnJheTxWTm9kZT4uIFRoZXJlIGFyZVxuLy8gdHdvIGNhc2VzIHdoZXJlIGV4dHJhIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkOlxuLy8gMS4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29tcG9uZW50cyAtIGJlY2F1c2UgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuLy8gbWF5IHJldHVybiBhbiBBcnJheSBpbnN0ZWFkIG9mIGEgc2luZ2xlIHJvb3QuIEluIHRoaXMgY2FzZSwganVzdCBhIHNpbXBsZVxuLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4vLyB0aGluZyB3aXRoIEFycmF5LnByb3RvdHlwZS5jb25jYXQuIEl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgb25seSAxLWxldmVsIGRlZXBcbi8vIGJlY2F1c2UgZnVuY3Rpb25hbCBjb21wb25lbnRzIGFscmVhZHkgbm9ybWFsaXplIHRoZWlyIG93biBjaGlsZHJlbi5cbmZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbikge1xuICAgIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICAgICAgPyBbY3JlYXRlVGV4dFZOb2RlKGNoaWxkcmVuKV1cbiAgICAgICAgOiBpc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5Q2hpbGRyZW4oY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgbGV0IGksIGMsIGxhc3RJbmRleCwgbGFzdDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgICAgICBsYXN0ID0gcmVzW2xhc3RJbmRleF07XG4gICAgICAgIC8vICBuZXN0ZWRcbiAgICAgICAgaWYgKGlzQXJyYXkoYykpIHtcbiAgICAgICAgICAgIGlmIChjLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCBgJHtuZXN0ZWRJbmRleCB8fCAnJ31fJHtpfWApO1xuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShjWzBdKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGNbMF0udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIFNTUiBoeWRyYXRpb24gYmVjYXVzZSB0ZXh0IG5vZGVzIGFyZVxuICAgICAgICAgICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0Tm9kZShjKSAmJiBpc1RleHROb2RlKGxhc3QpKSB7XG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICAgICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc1VuZGVmKGMua2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5rZXkgPSBgX192bGlzdCR7bmVzdGVkSW5kZXh9XyR7aX1fX2A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmNvbnN0IFNJTVBMRV9OT1JNQUxJWkUgPSAxO1xuY29uc3QgQUxXQVlTX05PUk1BTElaRSA9IDI7XG4vLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuLy8gd2l0aG91dCBnZXR0aW5nIHllbGxlZCBhdCBieSBmbG93XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZSkge1xuICAgIGlmIChpc0FycmF5KGRhdGEpIHx8IGlzUHJpbWl0aXZlKGRhdGEpKSB7XG4gICAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICAgICAgZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzVHJ1ZShhbHdheXNOb3JtYWxpemUpKSB7XG4gICAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKSB7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuX19vYl9fKSkge1xuICAgICAgICB3YXJuJDIoYEF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9XFxuYCArICdBbHdheXMgY3JlYXRlIGZyZXNoIHZub2RlIGRhdGEgb2JqZWN0cyBpbiBlYWNoIHJlbmRlciEnLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICB9XG4gICAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICAgICAgdGFnID0gZGF0YS5pcztcbiAgICB9XG4gICAgaWYgKCF0YWcpIHtcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBjb21wb25lbnQgOmlzIHNldCB0byBmYWxzeSB2YWx1ZVxuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyB3YXJuIGFnYWluc3Qgbm9uLXByaW1pdGl2ZSBrZXlcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSkpIHtcbiAgICAgICAgd2FybiQyKCdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLCBjb250ZXh0KTtcbiAgICB9XG4gICAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSAmJiBpc0Z1bmN0aW9uKGNoaWxkcmVuWzBdKSkge1xuICAgICAgICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gU0lNUExFX05PUk1BTElaRSkge1xuICAgICAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9XG4gICAgbGV0IHZub2RlLCBucztcbiAgICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IEN0b3I7XG4gICAgICAgIG5zID0gKGNvbnRleHQuJHZub2RlICYmIGNvbnRleHQuJHZub2RlLm5zKSB8fCBjb25maWcuZ2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAgICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmXG4gICAgICAgICAgICAgICAgaXNEZWYoZGF0YS5uYXRpdmVPbikgJiZcbiAgICAgICAgICAgICAgICBkYXRhLnRhZyAhPT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYFRoZSAubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGlzIG9ubHkgdmFsaWQgb24gY29tcG9uZW50cyBidXQgaXQgd2FzIHVzZWQgb24gPCR7dGFnfT4uYCwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bm9kZSA9IG5ldyBWTm9kZShjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJlxuICAgICAgICAgICAgaXNEZWYoKEN0b3IgPSByZXNvbHZlQXNzZXQoY29udGV4dC4kb3B0aW9ucywgJ2NvbXBvbmVudHMnLCB0YWcpKSkpIHtcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgdm5vZGUgPSBjcmVhdGVDb21wb25lbnQoQ3RvciwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAgICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgICAgICAgdm5vZGUgPSBuZXcgVk5vZGUodGFnLCBkYXRhLCBjaGlsZHJlbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgICAgICB2bm9kZSA9IGNyZWF0ZUNvbXBvbmVudCh0YWcsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHJldHVybiB2bm9kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgICAgIGlmIChpc0RlZihucykpXG4gICAgICAgICAgICBhcHBseU5TKHZub2RlLCBucyk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSlcbiAgICAgICAgICAgIHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpO1xuICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5TlModm5vZGUsIG5zLCBmb3JjZSkge1xuICAgIHZub2RlLm5zID0gbnM7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgICAgIC8vIHVzZSBkZWZhdWx0IG5hbWVzcGFjZSBpbnNpZGUgZm9yZWlnbk9iamVjdFxuICAgICAgICBucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNEZWYodm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHZub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGNoaWxkLnRhZykgJiZcbiAgICAgICAgICAgICAgICAoaXNVbmRlZihjaGlsZC5ucykgfHwgKGlzVHJ1ZShmb3JjZSkgJiYgY2hpbGQudGFnICE9PSAnc3ZnJykpKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIHJlZiAjNTMxOFxuLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBwYXJlbnQgcmUtcmVuZGVyIHdoZW4gZGVlcCBiaW5kaW5ncyBsaWtlIDpzdHlsZSBhbmRcbi8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG5mdW5jdGlvbiByZWdpc3RlckRlZXBCaW5kaW5ncyhkYXRhKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgICAgIHRyYXZlcnNlKGRhdGEuc3R5bGUpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QoZGF0YS5jbGFzcykpIHtcbiAgICAgICAgdHJhdmVyc2UoZGF0YS5jbGFzcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QodmFsLCByZW5kZXIpIHtcbiAgICBsZXQgcmV0ID0gbnVsbCwgaSwgbCwga2V5cywga2V5O1xuICAgIGlmIChpc0FycmF5KHZhbCkgfHwgdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWw7IGkrKykge1xuICAgICAgICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgICAgIHJldCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB2YWxbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgICAgIHJldCA9IFtdO1xuICAgIH1cbiAgICByZXQuX2lzVkxpc3QgPSB0cnVlO1xuICAgIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdChuYW1lLCBmYWxsYmFja1JlbmRlciwgcHJvcHMsIGJpbmRPYmplY3QpIHtcbiAgICBjb25zdCBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgICBsZXQgbm9kZXM7XG4gICAgaWYgKHNjb3BlZFNsb3RGbikge1xuICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgICAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChiaW5kT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMignc2xvdCB2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCcsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVzID1cbiAgICAgICAgICAgIHNjb3BlZFNsb3RGbihwcm9wcykgfHxcbiAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihmYWxsYmFja1JlbmRlcikgPyBmYWxsYmFja1JlbmRlcigpIDogZmFsbGJhY2tSZW5kZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZXMgPVxuICAgICAgICAgICAgdGhpcy4kc2xvdHNbbmFtZV0gfHxcbiAgICAgICAgICAgICAgICAoaXNGdW5jdGlvbihmYWxsYmFja1JlbmRlcikgPyBmYWxsYmFja1JlbmRlcigpIDogZmFsbGJhY2tSZW5kZXIpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJywgeyBzbG90OiB0YXJnZXQgfSwgbm9kZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIGZpbHRlcnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUZpbHRlcihpZCkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHk7XG59XG5cbmZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2goZXhwZWN0LCBhY3R1YWwpIHtcbiAgICBpZiAoaXNBcnJheShleHBlY3QpKSB7XG4gICAgICAgIHJldHVybiBleHBlY3QuaW5kZXhPZihhY3R1YWwpID09PSAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbDtcbiAgICB9XG59XG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMoZXZlbnRLZXlDb2RlLCBrZXksIGJ1aWx0SW5LZXlDb2RlLCBldmVudEtleU5hbWUsIGJ1aWx0SW5LZXlOYW1lKSB7XG4gICAgY29uc3QgbWFwcGVkS2V5Q29kZSA9IGNvbmZpZy5rZXlDb2Rlc1trZXldIHx8IGJ1aWx0SW5LZXlDb2RlO1xuICAgIGlmIChidWlsdEluS2V5TmFtZSAmJiBldmVudEtleU5hbWUgJiYgIWNvbmZpZy5rZXlDb2Rlc1trZXldKSB7XG4gICAgICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgICAgIHJldHVybiBpc0tleU5vdE1hdGNoKG1hcHBlZEtleUNvZGUsIGV2ZW50S2V5Q29kZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50S2V5TmFtZSkge1xuICAgICAgICByZXR1cm4gaHlwaGVuYXRlKGV2ZW50S2V5TmFtZSkgIT09IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50S2V5Q29kZSA9PT0gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGJpbmRPYmplY3RQcm9wcyhkYXRhLCB0YWcsIHZhbHVlLCBhc1Byb3AsIGlzU3luYykge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgd2FybiQyKCd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaGFzaDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJyB8fCBrZXkgPT09ICdzdHlsZScgfHwgaXNSZXNlcnZlZEF0dHJpYnV0ZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2ggPSBkYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgICAgICAgICAgICBoYXNoID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCB0eXBlLCBrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYW1lbGl6ZWRLZXkgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIShjYW1lbGl6ZWRLZXkgaW4gaGFzaCkgJiYgIShoeXBoZW5hdGVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc2hba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uID0gZGF0YS5vbiB8fCAoZGF0YS5vbiA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uW2B1cGRhdGU6JHtrZXl9YF0gPSBmdW5jdGlvbiAoJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclN0YXRpYyhpbmRleCwgaXNJbkZvcikge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgICBsZXQgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gICAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gICAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gICAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5LCB0aGlzLl9jLCB0aGlzIC8vIGZvciByZW5kZXIgZm5zIGdlbmVyYXRlZCBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgdGVtcGxhdGVzXG4gICAgKTtcbiAgICBtYXJrU3RhdGljJDEodHJlZSwgYF9fc3RhdGljX18ke2luZGV4fWAsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJlZTtcbn1cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHYtb25jZS5cbiAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICovXG5mdW5jdGlvbiBtYXJrT25jZSh0cmVlLCBpbmRleCwga2V5KSB7XG4gICAgbWFya1N0YXRpYyQxKHRyZWUsIGBfX29uY2VfXyR7aW5kZXh9JHtrZXkgPyBgXyR7a2V5fWAgOiBgYH1gLCB0cnVlKTtcbiAgICByZXR1cm4gdHJlZTtcbn1cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSh0cmVlLCBrZXksIGlzT25jZSkge1xuICAgIGlmIChpc0FycmF5KHRyZWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZVtpXSwgYCR7a2V5fV8ke2l9YCwgaXNPbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFya1N0YXRpY05vZGUodHJlZSwga2V5LCBpc09uY2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcmtTdGF0aWNOb2RlKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gICAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gICAgbm9kZS5rZXkgPSBrZXk7XG4gICAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbmZ1bmN0aW9uIGJpbmRPYmplY3RMaXN0ZW5lcnMoZGF0YSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgd2FybiQyKCd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9uID0gKGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91cnMgPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU2NvcGVkU2xvdHMoZm5zLCByZXMsIFxuLy8gdGhlIGZvbGxvd2luZyBhcmUgYWRkZWQgaW4gMi42XG5oYXNEeW5hbWljS2V5cywgY29udGVudEhhc2hLZXkpIHtcbiAgICByZXMgPSByZXMgfHwgeyAkc3RhYmxlOiAhaGFzRHluYW1pY0tleXMgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzbG90ID0gZm5zW2ldO1xuICAgICAgICBpZiAoaXNBcnJheShzbG90KSkge1xuICAgICAgICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKHNsb3QsIHJlcywgaGFzRHluYW1pY0tleXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIC8vIG1hcmtlciBmb3IgcmV2ZXJzZSBwcm94eWluZyB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgaWYgKHNsb3QucHJveHkpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgc2xvdC5mbi5wcm94eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNbc2xvdC5rZXldID0gc2xvdC5mbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGVudEhhc2hLZXkpIHtcbiAgICAgICAgcmVzLiRrZXkgPSBjb250ZW50SGFzaEtleTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gaGVscGVyIHRvIHByb2Nlc3MgZHluYW1pYyBrZXlzIGZvciBkeW5hbWljIGFyZ3VtZW50cyBpbiB2LWJpbmQgYW5kIHYtb24uXG5mdW5jdGlvbiBiaW5kRHluYW1pY0tleXMoYmFzZU9iaiwgdmFsdWVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdmFsdWVzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5KSB7XG4gICAgICAgICAgICBiYXNlT2JqW3ZhbHVlc1tpXV0gPSB2YWx1ZXNbaSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBudWxsIGlzIGEgc3BlY2lhbCB2YWx1ZSBmb3IgZXhwbGljaXRseSByZW1vdmluZyBhIGJpbmRpbmdcbiAgICAgICAgICAgIHdhcm4kMihgSW52YWxpZCB2YWx1ZSBmb3IgZHluYW1pYyBkaXJlY3RpdmUgYXJndW1lbnQgKGV4cGVjdGVkIHN0cmluZyBvciBudWxsKTogJHtrZXl9YCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2VPYmo7XG59XG4vLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbi8vIGVuc3VyZSBvbmx5IGFwcGVuZCB3aGVuIHZhbHVlIGlzIGFscmVhZHkgc3RyaW5nLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBjYXN0XG4vLyB0byBzdHJpbmcgYW5kIGNhdXNlIHRoZSB0eXBlIGNoZWNrIHRvIG1pc3MuXG5mdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIodmFsdWUsIHN5bWJvbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3ltYm9sICsgdmFsdWUgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnModGFyZ2V0KSB7XG4gICAgdGFyZ2V0Ll9vID0gbWFya09uY2U7XG4gICAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gICAgdGFyZ2V0Ll9zID0gdG9TdHJpbmc7XG4gICAgdGFyZ2V0Ll9sID0gcmVuZGVyTGlzdDtcbiAgICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICAgIHRhcmdldC5fcSA9IGxvb3NlRXF1YWw7XG4gICAgdGFyZ2V0Ll9pID0gbG9vc2VJbmRleE9mO1xuICAgIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgICB0YXJnZXQuX2YgPSByZXNvbHZlRmlsdGVyO1xuICAgIHRhcmdldC5fayA9IGNoZWNrS2V5Q29kZXM7XG4gICAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICAgIHRhcmdldC5fdiA9IGNyZWF0ZVRleHRWTm9kZTtcbiAgICB0YXJnZXQuX2UgPSBjcmVhdGVFbXB0eVZOb2RlO1xuICAgIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgICB0YXJnZXQuX2cgPSBiaW5kT2JqZWN0TGlzdGVuZXJzO1xuICAgIHRhcmdldC5fZCA9IGJpbmREeW5hbWljS2V5cztcbiAgICB0YXJnZXQuX3AgPSBwcmVwZW5kTW9kaWZpZXI7XG59XG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gICAgaWYgKCFjaGlsZHJlbiB8fCAhY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3Qgc2xvdHMgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBjb25zdCBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAgICAgLy8gcmVtb3ZlIHNsb3QgYXR0cmlidXRlIGlmIHRoZSBub2RlIGlzIHJlc29sdmVkIGFzIGEgVnVlIHNsb3Qgbm9kZVxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAgICAgLy8gc2FtZSBjb250ZXh0LlxuICAgICAgICBpZiAoKGNoaWxkLmNvbnRleHQgPT09IGNvbnRleHQgfHwgY2hpbGQuZm5Db250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgICAgICAgZGF0YSAmJlxuICAgICAgICAgICAgZGF0YS5zbG90ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBkYXRhLnNsb3Q7XG4gICAgICAgICAgICBjb25zdCBzbG90ID0gc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzbG90cykge1xuICAgICAgICBpZiAoc2xvdHNbbmFtZV0uZXZlcnkoaXNXaGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgZGVsZXRlIHNsb3RzW25hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90cztcbn1cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnO1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIobm9kZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3Igbm90IHJlYWxseSBib29sZWFuIHR5cGVcbiAgICByZXR1cm4gbm9kZS5pc0NvbW1lbnQgJiYgbm9kZS5hc3luY0ZhY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKG93bmVyVm0sIHNjb3BlZFNsb3RzLCBub3JtYWxTbG90cywgcHJldlNjb3BlZFNsb3RzKSB7XG4gICAgbGV0IHJlcztcbiAgICBjb25zdCBoYXNOb3JtYWxTbG90cyA9IE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGlzU3RhYmxlID0gc2NvcGVkU2xvdHMgPyAhIXNjb3BlZFNsb3RzLiRzdGFibGUgOiAhaGFzTm9ybWFsU2xvdHM7XG4gICAgY29uc3Qga2V5ID0gc2NvcGVkU2xvdHMgJiYgc2NvcGVkU2xvdHMuJGtleTtcbiAgICBpZiAoIXNjb3BlZFNsb3RzKSB7XG4gICAgICAgIHJlcyA9IHt9O1xuICAgIH1cbiAgICBlbHNlIGlmIChzY29wZWRTbG90cy5fbm9ybWFsaXplZCkge1xuICAgICAgICAvLyBmYXN0IHBhdGggMTogY2hpbGQgY29tcG9uZW50IHJlLXJlbmRlciBvbmx5LCBwYXJlbnQgZGlkIG5vdCBjaGFuZ2VcbiAgICAgICAgcmV0dXJuIHNjb3BlZFNsb3RzLl9ub3JtYWxpemVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0YWJsZSAmJlxuICAgICAgICBwcmV2U2NvcGVkU2xvdHMgJiZcbiAgICAgICAgcHJldlNjb3BlZFNsb3RzICE9PSBlbXB0eU9iamVjdCAmJlxuICAgICAgICBrZXkgPT09IHByZXZTY29wZWRTbG90cy4ka2V5ICYmXG4gICAgICAgICFoYXNOb3JtYWxTbG90cyAmJlxuICAgICAgICAhcHJldlNjb3BlZFNsb3RzLiRoYXNOb3JtYWwpIHtcbiAgICAgICAgLy8gZmFzdCBwYXRoIDI6IHN0YWJsZSBzY29wZWQgc2xvdHMgdy8gbm8gbm9ybWFsIHNsb3RzIHRvIHByb3h5LFxuICAgICAgICAvLyBvbmx5IG5lZWQgdG8gbm9ybWFsaXplIG9uY2VcbiAgICAgICAgcmV0dXJuIHByZXZTY29wZWRTbG90cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY29wZWRTbG90cykge1xuICAgICAgICAgICAgaWYgKHNjb3BlZFNsb3RzW2tleV0gJiYga2V5WzBdICE9PSAnJCcpIHtcbiAgICAgICAgICAgICAgICByZXNba2V5XSA9IG5vcm1hbGl6ZVNjb3BlZFNsb3Qob3duZXJWbSwgbm9ybWFsU2xvdHMsIGtleSwgc2NvcGVkU2xvdHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXhwb3NlIG5vcm1hbCBzbG90cyBvbiBzY29wZWRTbG90c1xuICAgIGZvciAoY29uc3Qga2V5IGluIG5vcm1hbFNsb3RzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiByZXMpKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gICAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gICAgaWYgKHNjb3BlZFNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2NvcGVkU2xvdHMpKSB7XG4gICAgICAgIHNjb3BlZFNsb3RzLl9ub3JtYWxpemVkID0gcmVzO1xuICAgIH1cbiAgICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgICBkZWYocmVzLCAnJGtleScsIGtleSk7XG4gICAgZGVmKHJlcywgJyRoYXNOb3JtYWwnLCBoYXNOb3JtYWxTbG90cyk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNjb3BlZFNsb3Qodm0sIG5vcm1hbFNsb3RzLCBrZXksIGZuKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY3VyID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xuICAgICAgICBsZXQgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA/IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgOiBmbih7fSk7XG4gICAgICAgIHJlcyA9XG4gICAgICAgICAgICByZXMgJiYgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkocmVzKVxuICAgICAgICAgICAgICAgID8gW3Jlc10gLy8gc2luZ2xlIHZub2RlXG4gICAgICAgICAgICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgICAgICBjb25zdCB2bm9kZSA9IHJlcyAmJiByZXNbMF07XG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShjdXIpO1xuICAgICAgICByZXR1cm4gcmVzICYmXG4gICAgICAgICAgICAoIXZub2RlIHx8XG4gICAgICAgICAgICAgICAgKHJlcy5sZW5ndGggPT09IDEgJiYgdm5vZGUuaXNDb21tZW50ICYmICFpc0FzeW5jUGxhY2Vob2xkZXIodm5vZGUpKSkgLy8gIzk2NTgsICMxMDM5MVxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogcmVzO1xuICAgIH07XG4gICAgLy8gdGhpcyBpcyBhIHNsb3QgdXNpbmcgdGhlIG5ldyB2LXNsb3Qgc3ludGF4IHdpdGhvdXQgc2NvcGUuIGFsdGhvdWdoIGl0IGlzXG4gICAgLy8gY29tcGlsZWQgYXMgYSBzY29wZWQgc2xvdCwgcmVuZGVyIGZuIHVzZXJzIHdvdWxkIGV4cGVjdCBpdCB0byBiZSBwcmVzZW50XG4gICAgLy8gb24gdGhpcy4kc2xvdHMgYmVjYXVzZSB0aGUgdXNhZ2UgaXMgc2VtYW50aWNhbGx5IGEgbm9ybWFsIHNsb3QuXG4gICAgaWYgKGZuLnByb3h5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XG4gICAgICAgICAgICBnZXQ6IG5vcm1hbGl6ZWQsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbmZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XG4gICAgcmV0dXJuICgpID0+IHNsb3RzW2tleV07XG59XG5cbmZ1bmN0aW9uIGluaXRTZXR1cCh2bSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgICBjb25zdCBzZXR1cCA9IG9wdGlvbnMuc2V0dXA7XG4gICAgaWYgKHNldHVwKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9ICh2bS5fc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KHZtKSk7XG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh2bSk7XG4gICAgICAgIHB1c2hUYXJnZXQoKTtcbiAgICAgICAgY29uc3Qgc2V0dXBSZXN1bHQgPSBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhzZXR1cCwgbnVsbCwgW3ZtLl9wcm9wcyB8fCBzaGFsbG93UmVhY3RpdmUoe30pLCBjdHhdLCB2bSwgYHNldHVwYCk7XG4gICAgICAgIHBvcFRhcmdldCgpO1xuICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UoKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oc2V0dXBSZXN1bHQpKSB7XG4gICAgICAgICAgICAvLyByZW5kZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG9wdGlvbnMucmVuZGVyID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3Qoc2V0dXBSZXN1bHQpKSB7XG4gICAgICAgICAgICAvLyBiaW5kaW5nc1xuICAgICAgICAgICAgaWYgKHNldHVwUmVzdWx0IGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYHNldHVwKCkgc2hvdWxkIG5vdCByZXR1cm4gVk5vZGVzIGRpcmVjdGx5IC0gYCArXG4gICAgICAgICAgICAgICAgICAgIGByZXR1cm4gYSByZW5kZXIgZnVuY3Rpb24gaW5zdGVhZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZtLl9zZXR1cFN0YXRlID0gc2V0dXBSZXN1bHQ7XG4gICAgICAgICAgICAvLyBfX3NmYyBpbmRpY2F0ZXMgY29tcGlsZWQgYmluZGluZ3MgZnJvbSA8c2NyaXB0IHNldHVwPlxuICAgICAgICAgICAgaWYgKCFzZXR1cFJlc3VsdC5fX3NmYykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNldHVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm94eVdpdGhSZWZVbndyYXAodm0sIHNldHVwUmVzdWx0LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyKGBBdm9pZCB1c2luZyB2YXJpYWJsZXMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJCBpbiBzZXR1cCgpLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXhwb3NlZCBmb3IgY29tcGlsZWQgcmVuZGVyIGZuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJveHkgPSAodm0uX3NldHVwUHJveHkgPSB7fSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXBSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ19fc2ZjJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlXaXRoUmVmVW53cmFwKHByb3h5LCBzZXR1cFJlc3VsdCwga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZXR1cFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3YXJuJDIoYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke3NldHVwUmVzdWx0ID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHNldHVwUmVzdWx0fWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlU2V0dXBDb250ZXh0KHZtKSB7XG4gICAgbGV0IGV4cG9zZUNhbGxlZCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgICAgIGlmICghdm0uX2F0dHJzUHJveHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm94eSA9ICh2bS5fYXR0cnNQcm94eSA9IHt9KTtcbiAgICAgICAgICAgICAgICBkZWYocHJveHksICdfdl9hdHRyX3Byb3h5JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgc3luY1NldHVwUHJveHkocHJveHksIHZtLiRhdHRycywgZW1wdHlPYmplY3QsIHZtLCAnJGF0dHJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm0uX2F0dHJzUHJveHk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBsaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICBpZiAoIXZtLl9saXN0ZW5lcnNQcm94eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3h5ID0gKHZtLl9saXN0ZW5lcnNQcm94eSA9IHt9KTtcbiAgICAgICAgICAgICAgICBzeW5jU2V0dXBQcm94eShwcm94eSwgdm0uJGxpc3RlbmVycywgZW1wdHlPYmplY3QsIHZtLCAnJGxpc3RlbmVycycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZtLl9saXN0ZW5lcnNQcm94eTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNsb3RzKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluaXRTbG90c1Byb3h5KHZtKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW1pdDogYmluZCQxKHZtLiRlbWl0LCB2bSksXG4gICAgICAgIGV4cG9zZShleHBvc2VkKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9zZUNhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoYGV4cG9zZSgpIHNob3VsZCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBzZXR1cCgpLmAsIHZtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhwb3NlQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBvc2VkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZXhwb3NlZCkuZm9yRWFjaChrZXkgPT4gcHJveHlXaXRoUmVmVW53cmFwKHZtLCBleHBvc2VkLCBrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBzeW5jU2V0dXBQcm94eSh0bywgZnJvbSwgcHJldiwgaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRvKSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBkZWZpbmVQcm94eUF0dHIodG8sIGtleSwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyb21ba2V5XSAhPT0gcHJldltrZXldKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0bykge1xuICAgICAgICBpZiAoIShrZXkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlIHRvW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBkZWZpbmVQcm94eUF0dHIocHJveHksIGtleSwgaW5zdGFuY2UsIHR5cGUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJveHksIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVt0eXBlXVtrZXldO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2xvdHNQcm94eSh2bSkge1xuICAgIGlmICghdm0uX3Nsb3RzUHJveHkpIHtcbiAgICAgICAgc3luY1NldHVwU2xvdHMoKHZtLl9zbG90c1Byb3h5ID0ge30pLCB2bS4kc2NvcGVkU2xvdHMpO1xuICAgIH1cbiAgICByZXR1cm4gdm0uX3Nsb3RzUHJveHk7XG59XG5mdW5jdGlvbiBzeW5jU2V0dXBTbG90cyh0bywgZnJvbSkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZyb20pIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG8pIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIGZyb20pKSB7XG4gICAgICAgICAgICBkZWxldGUgdG9ba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsIHVzZSBtYW51YWwgdHlwZSBkZWYgYmVjYXVzZSBwdWJsaWMgc2V0dXAgY29udGV4dCB0eXBlIHJlbGllcyBvblxuICogbGVnYWN5IFZOb2RlIHR5cGVzXG4gKi9cbmZ1bmN0aW9uIHVzZVNsb3RzKCkge1xuICAgIHJldHVybiBnZXRDb250ZXh0KCkuc2xvdHM7XG59XG4vKipcbiAqIEBpbnRlcm5hbCB1c2UgbWFudWFsIHR5cGUgZGVmIGJlY2F1c2UgcHVibGljIHNldHVwIGNvbnRleHQgdHlwZSByZWxpZXMgb25cbiAqIGxlZ2FjeSBWTm9kZSB0eXBlc1xuICovXG5mdW5jdGlvbiB1c2VBdHRycygpIHtcbiAgICByZXR1cm4gZ2V0Q29udGV4dCgpLmF0dHJzO1xufVxuLyoqXG4gKiBWdWUgMiBvbmx5XG4gKiBAaW50ZXJuYWwgdXNlIG1hbnVhbCB0eXBlIGRlZiBiZWNhdXNlIHB1YmxpYyBzZXR1cCBjb250ZXh0IHR5cGUgcmVsaWVzIG9uXG4gKiBsZWdhY3kgVk5vZGUgdHlwZXNcbiAqL1xuZnVuY3Rpb24gdXNlTGlzdGVuZXJzKCkge1xuICAgIHJldHVybiBnZXRDb250ZXh0KCkubGlzdGVuZXJzO1xufVxuZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICB3YXJuJDIoYHVzZUNvbnRleHQoKSBjYWxsZWQgd2l0aG91dCBhY3RpdmUgaW5zdGFuY2UuYCk7XG4gICAgfVxuICAgIGNvbnN0IHZtID0gY3VycmVudEluc3RhbmNlO1xuICAgIHJldHVybiB2bS5fc2V0dXBDb250ZXh0IHx8ICh2bS5fc2V0dXBDb250ZXh0ID0gY3JlYXRlU2V0dXBDb250ZXh0KHZtKSk7XG59XG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIGRlZmF1bHQgZGVjbGFyYXRpb25zLiBJbXBvcnRlZCBieSBjb21waWxlZCBjb2RlXG4gKiBvbmx5LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdHMocmF3LCBkZWZhdWx0cykge1xuICAgIGNvbnN0IHByb3BzID0gaXNBcnJheShyYXcpXG4gICAgICAgID8gcmF3LnJlZHVjZSgobm9ybWFsaXplZCwgcCkgPT4gKChub3JtYWxpemVkW3BdID0ge30pLCBub3JtYWxpemVkKSwge30pXG4gICAgICAgIDogcmF3O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHByb3BzW2tleV07XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG9wdCkgfHwgaXNGdW5jdGlvbihvcHQpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XSA9IHsgdHlwZTogb3B0LCBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHQuZGVmYXVsdCA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9wc1trZXldID0geyBkZWZhdWx0OiBkZWZhdWx0c1trZXldIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXJuJDIoYHByb3BzIGRlZmF1bHQga2V5IFwiJHtrZXl9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0UmVuZGVyKHZtKSB7XG4gICAgdm0uX3Zub2RlID0gbnVsbDsgLy8gdGhlIHJvb3Qgb2YgdGhlIGNoaWxkIHRyZWVcbiAgICB2bS5fc3RhdGljVHJlZXMgPSBudWxsOyAvLyB2LW9uY2UgY2FjaGVkIHRyZWVzXG4gICAgY29uc3Qgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgIGNvbnN0IHBhcmVudFZub2RlID0gKHZtLiR2bm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlKTsgLy8gdGhlIHBsYWNlaG9sZGVyIG5vZGUgaW4gcGFyZW50IHRyZWVcbiAgICBjb25zdCByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMob3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4sIHJlbmRlckNvbnRleHQpO1xuICAgIHZtLiRzY29wZWRTbG90cyA9IHBhcmVudFZub2RlXG4gICAgICAgID8gbm9ybWFsaXplU2NvcGVkU2xvdHModm0uJHBhcmVudCwgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cywgdm0uJHNsb3RzKVxuICAgICAgICA6IGVtcHR5T2JqZWN0O1xuICAgIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAgIC8vIHNvIHRoYXQgd2UgZ2V0IHByb3BlciByZW5kZXIgY29udGV4dCBpbnNpZGUgaXQuXG4gICAgLy8gYXJncyBvcmRlcjogdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUsIGFsd2F5c05vcm1hbGl6ZVxuICAgIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHZtLl9jID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQkMSh2bSwgYSwgYiwgYywgZCwgZmFsc2UpO1xuICAgIC8vIG5vcm1hbGl6YXRpb24gaXMgYWx3YXlzIGFwcGxpZWQgZm9yIHRoZSBwdWJsaWMgdmVyc2lvbiwgdXNlZCBpblxuICAgIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICB2bS4kY3JlYXRlRWxlbWVudCA9IChhLCBiLCBjLCBkKSA9PiBjcmVhdGVFbGVtZW50JDEodm0sIGEsIGIsIGMsIGQsIHRydWUpO1xuICAgIC8vICRhdHRycyAmICRsaXN0ZW5lcnMgYXJlIGV4cG9zZWQgZm9yIGVhc2llciBIT0MgY3JlYXRpb24uXG4gICAgLy8gdGhleSBuZWVkIHRvIGJlIHJlYWN0aXZlIHNvIHRoYXQgSE9DcyB1c2luZyB0aGVtIGFyZSBhbHdheXMgdXBkYXRlZFxuICAgIGNvbnN0IHBhcmVudERhdGEgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5kYXRhO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIChwYXJlbnREYXRhICYmIHBhcmVudERhdGEuYXR0cnMpIHx8IGVtcHR5T2JqZWN0LCAoKSA9PiB7XG4gICAgICAgICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4kMihgJGF0dHJzIGlzIHJlYWRvbmx5LmAsIHZtKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGxpc3RlbmVycycsIG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyB8fCBlbXB0eU9iamVjdCwgKCkgPT4ge1xuICAgICAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuJDIoYCRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuYCwgdm0pO1xuICAgICAgICB9LCB0cnVlKTtcbiAgICB9XG59XG5sZXQgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gbnVsbDtcbmZ1bmN0aW9uIHJlbmRlck1peGluKFZ1ZSkge1xuICAgIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gICAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG4gICAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKTtcbiAgICB9O1xuICAgIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHJlbmRlciwgX3BhcmVudFZub2RlIH0gPSB2bS4kb3B0aW9ucztcbiAgICAgICAgaWYgKF9wYXJlbnRWbm9kZSAmJiB2bS5faXNNb3VudGVkKSB7XG4gICAgICAgICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyh2bS4kcGFyZW50LCBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cywgdm0uJHNsb3RzLCB2bS4kc2NvcGVkU2xvdHMpO1xuICAgICAgICAgICAgaWYgKHZtLl9zbG90c1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgc3luY1NldHVwU2xvdHModm0uX3Nsb3RzUHJveHksIHZtLiRzY29wZWRTbG90cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHBhcmVudCB2bm9kZS4gdGhpcyBhbGxvd3MgcmVuZGVyIGZ1bmN0aW9ucyB0byBoYXZlIGFjY2Vzc1xuICAgICAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICAgICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgICAgICAvLyByZW5kZXIgc2VsZlxuICAgICAgICBjb25zdCBwcmV2SW5zdCA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgY29uc3QgcHJldlJlbmRlckluc3QgPSBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U7XG4gICAgICAgIGxldCB2bm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZSh2bSk7XG4gICAgICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSB2bTtcbiAgICAgICAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgcmVuZGVyYCk7XG4gICAgICAgICAgICAvLyByZXR1cm4gZXJyb3IgcmVuZGVyIHJlc3VsdCxcbiAgICAgICAgICAgIC8vIG9yIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHZtLiRvcHRpb25zLnJlbmRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgYHJlbmRlckVycm9yYCk7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlID0gcHJldlJlbmRlckluc3Q7XG4gICAgICAgICAgICBzZXRDdXJyZW50SW5zdGFuY2UocHJldkluc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSByZXR1cm5lZCBhcnJheSBjb250YWlucyBvbmx5IGEgc2luZ2xlIG5vZGUsIGFsbG93IGl0XG4gICAgICAgIGlmIChpc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZub2RlID0gdm5vZGVbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgICAgICBpZiAoISh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKCdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICAgICAgICAgICdzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHJvb3Qgbm9kZS4nLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2bm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgcGFyZW50XG4gICAgICAgIHZub2RlLnBhcmVudCA9IF9wYXJlbnRWbm9kZTtcbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUN0b3IoY29tcCwgYmFzZSkge1xuICAgIGlmIChjb21wLl9fZXNNb2R1bGUgfHwgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKSkge1xuICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gaXNPYmplY3QoY29tcCkgPyBiYXNlLmV4dGVuZChjb21wKSA6IGNvbXA7XG59XG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKGZhY3RvcnksIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpIHtcbiAgICBjb25zdCBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICAgIG5vZGUuYXN5bmNGYWN0b3J5ID0gZmFjdG9yeTtcbiAgICBub2RlLmFzeW5jTWV0YSA9IHsgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyB9O1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGZhY3RvcnksIGJhc2VDdG9yKSB7XG4gICAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkuZXJyb3JDb21wO1xuICAgIH1cbiAgICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkucmVzb2x2ZWQ7XG4gICAgfVxuICAgIGNvbnN0IG93bmVyID0gY3VycmVudFJlbmRlcmluZ0luc3RhbmNlO1xuICAgIGlmIChvd25lciAmJiBpc0RlZihmYWN0b3J5Lm93bmVycykgJiYgZmFjdG9yeS5vd25lcnMuaW5kZXhPZihvd25lcikgPT09IC0xKSB7XG4gICAgICAgIC8vIGFscmVhZHkgcGVuZGluZ1xuICAgICAgICBmYWN0b3J5Lm93bmVycy5wdXNoKG93bmVyKTtcbiAgICB9XG4gICAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmxvYWRpbmdDb21wO1xuICAgIH1cbiAgICBpZiAob3duZXIgJiYgIWlzRGVmKGZhY3Rvcnkub3duZXJzKSkge1xuICAgICAgICBjb25zdCBvd25lcnMgPSAoZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdKTtcbiAgICAgICAgbGV0IHN5bmMgPSB0cnVlO1xuICAgICAgICBsZXQgdGltZXJMb2FkaW5nID0gbnVsbDtcbiAgICAgICAgbGV0IHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgIG93bmVyLiRvbignaG9vazpkZXN0cm95ZWQnLCAoKSA9PiByZW1vdmUkMihvd25lcnMsIG93bmVyKSk7XG4gICAgICAgIGNvbnN0IGZvcmNlUmVuZGVyID0gKHJlbmRlckNvbXBsZXRlZCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3duZXJzW2ldLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lckxvYWRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyTG9hZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyTG9hZGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lclRpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNvbHZlID0gb25jZSgocmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAgICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAgICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgICAgICAgIGlmICghc3luYykge1xuICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZWplY3QgPSBvbmNlKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICB3YXJuJDIoYEZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogJHtTdHJpbmcoZmFjdG9yeSl9YCArXG4gICAgICAgICAgICAgICAgICAgIChyZWFzb24gPyBgXFxuUmVhc29uOiAke3JlYXNvbn1gIDogJycpKTtcbiAgICAgICAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3J5LmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UocmVzKSkge1xuICAgICAgICAgICAgICAgIC8vICgpID0+IFByb21pc2VcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIGlmIChpc0RlZihyZXMuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHJlcy5sb2FkaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzLmRlbGF5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOb2RlSlMgdGltZW91dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lckxvYWRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpICYmIGlzVW5kZWYoZmFjdG9yeS5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBOb2RlSlMgdGltZW91dCB0eXBlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmKGZhY3RvcnkucmVzb2x2ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGB0aW1lb3V0ICgke3Jlcy50aW1lb3V0fW1zKWAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzeW5jID0gZmFsc2U7XG4gICAgICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZyA/IGZhY3RvcnkubG9hZGluZ0NvbXAgOiBmYWN0b3J5LnJlc29sdmVkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjaGlsZHJlbikge1xuICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbml0RXZlbnRzKHZtKSB7XG4gICAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAgIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gICAgfVxufVxubGV0IHRhcmdldCQxO1xuZnVuY3Rpb24gYWRkJDEoZXZlbnQsIGZuKSB7XG4gICAgdGFyZ2V0JDEuJG9uKGV2ZW50LCBmbik7XG59XG5mdW5jdGlvbiByZW1vdmUkMShldmVudCwgZm4pIHtcbiAgICB0YXJnZXQkMS4kb2ZmKGV2ZW50LCBmbik7XG59XG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciQxKGV2ZW50LCBmbikge1xuICAgIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQkMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF90YXJnZXQuJG9mZihldmVudCwgb25jZUhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudExpc3RlbmVycyh2bSwgbGlzdGVuZXJzLCBvbGRMaXN0ZW5lcnMpIHtcbiAgICB0YXJnZXQkMSA9IHZtO1xuICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkJDEsIHJlbW92ZSQxLCBjcmVhdGVPbmNlSGFuZGxlciQxLCB2bSk7XG4gICAgdGFyZ2V0JDEgPSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBldmVudHNNaXhpbihWdWUpIHtcbiAgICBjb25zdCBob29rUkUgPSAvXmhvb2s6LztcbiAgICBWdWUucHJvdG90eXBlLiRvbiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICBpZiAoaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdm0uJG9uKGV2ZW50W2ldLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgICAgICAgIC8vIG9wdGltaXplIGhvb2s6ZXZlbnQgY29zdCBieSB1c2luZyBhIGJvb2xlYW4gZmxhZyBtYXJrZWQgYXQgcmVnaXN0cmF0aW9uXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIGEgaGFzaCBsb29rdXBcbiAgICAgICAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm07XG4gICAgfTtcbiAgICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIGZ1bmN0aW9uIG9uKCkge1xuICAgICAgICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgb24uZm4gPSBmbjtcbiAgICAgICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgICAgIHJldHVybiB2bTtcbiAgICB9O1xuICAgIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICAvLyBhbGxcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybiB2bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICAgICAgaWYgKGlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHZtLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgICAgICBjb25zdCBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICAgICAgaWYgKCFjYnMpIHtcbiAgICAgICAgICAgIHJldHVybiB2bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdm07XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgICAgICBsZXQgY2I7XG4gICAgICAgIGxldCBpID0gY2JzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgY2IgPSBjYnNbaV07XG4gICAgICAgICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICAgICAgICAgIGNicy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZtO1xuICAgIH07XG4gICAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGxvd2VyQ2FzZUV2ZW50ID0gZXZlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChsb3dlckNhc2VFdmVudCAhPT0gZXZlbnQgJiYgdm0uX2V2ZW50c1tsb3dlckNhc2VFdmVudF0pIHtcbiAgICAgICAgICAgICAgICB0aXAoYEV2ZW50IFwiJHtsb3dlckNhc2VFdmVudH1cIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9IGJ1dCB0aGUgaGFuZGxlciBpcyByZWdpc3RlcmVkIGZvciBcIiR7ZXZlbnR9XCIuIGAgK1xuICAgICAgICAgICAgICAgICAgICBgTm90ZSB0aGF0IEhUTUwgYXR0cmlidXRlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZSBhbmQgeW91IGNhbm5vdCB1c2UgYCArXG4gICAgICAgICAgICAgICAgICAgIGB2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7aHlwaGVuYXRlKGV2ZW50KX1cIiBpbnN0ZWFkIG9mIFwiJHtldmVudH1cIi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgICAgIGlmIChjYnMpIHtcbiAgICAgICAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBgZXZlbnQgaGFuZGxlciBmb3IgXCIke2V2ZW50fVwiYDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdm07XG4gICAgfTtcbn1cblxubGV0IGFjdGl2ZUVmZmVjdFNjb3BlO1xuY2xhc3MgRWZmZWN0U2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKGRldGFjaGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5kZXRhY2hlZCA9IGRldGFjaGVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFudXBzID0gW107XG4gICAgICAgIHRoaXMucGFyZW50ID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgICAgIGlmICghZGV0YWNoZWQgJiYgYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPVxuICAgICAgICAgICAgICAgIChhY3RpdmVFZmZlY3RTY29wZS5zY29wZXMgfHwgKGFjdGl2ZUVmZmVjdFNjb3BlLnNjb3BlcyA9IFtdKSkucHVzaCh0aGlzKSAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuKGZuKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEVmZmVjdFNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gY3VycmVudEVmZmVjdFNjb3BlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FybiQyKGBjYW5ub3QgcnVuIGFuIGluYWN0aXZlIGVmZmVjdCBzY29wZS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBub24tZGV0YWNoZWQgc2NvcGVzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgb24oKSB7XG4gICAgICAgIGFjdGl2ZUVmZmVjdFNjb3BlID0gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9mZigpIHtcbiAgICAgICAgYWN0aXZlRWZmZWN0U2NvcGUgPSB0aGlzLnBhcmVudDtcbiAgICB9XG4gICAgc3RvcChmcm9tUGFyZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgbGV0IGksIGw7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5lZmZlY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWZmZWN0c1tpXS50ZWFyZG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2NvcGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjb3Blc1tpXS5zdG9wKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5lc3RlZCBzY29wZSwgZGVyZWZlcmVuY2UgZnJvbSBwYXJlbnQgdG8gYXZvaWQgbWVtb3J5IGxlYWtzXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGV0YWNoZWQgJiYgdGhpcy5wYXJlbnQgJiYgIWZyb21QYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWQgTygxKSByZW1vdmFsXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGVmZmVjdFNjb3BlKGRldGFjaGVkKSB7XG4gICAgcmV0dXJuIG5ldyBFZmZlY3RTY29wZShkZXRhY2hlZCk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZWNvcmRFZmZlY3RTY29wZShlZmZlY3QsIHNjb3BlID0gYWN0aXZlRWZmZWN0U2NvcGUpIHtcbiAgICBpZiAoc2NvcGUgJiYgc2NvcGUuYWN0aXZlKSB7XG4gICAgICAgIHNjb3BlLmVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gYWN0aXZlRWZmZWN0U2NvcGU7XG59XG5mdW5jdGlvbiBvblNjb3BlRGlzcG9zZShmbikge1xuICAgIGlmIChhY3RpdmVFZmZlY3RTY29wZSkge1xuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZS5jbGVhbnVwcy5wdXNoKGZuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhcm4kMihgb25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlYCArXG4gICAgICAgICAgICBgIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5gKTtcbiAgICB9XG59XG5cbmxldCBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5sZXQgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG5mdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICAgIGNvbnN0IHByZXZBY3RpdmVJbnN0YW5jZSA9IGFjdGl2ZUluc3RhbmNlO1xuICAgIGFjdGl2ZUluc3RhbmNlID0gdm07XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUodm0pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgICBsZXQgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgICAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuJHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICAgIH1cbiAgICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICAgIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG4gICAgdm0uJGNoaWxkcmVuID0gW107XG4gICAgdm0uJHJlZnMgPSB7fTtcbiAgICB2bS5fcHJvdmlkZWQgPSBwYXJlbnQgPyBwYXJlbnQuX3Byb3ZpZGVkIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gICAgdm0uX2luYWN0aXZlID0gbnVsbDtcbiAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSBmYWxzZTtcbiAgICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gICAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluKFZ1ZSkge1xuICAgIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICAgICAgY29uc3QgcHJldkVsID0gdm0uJGVsO1xuICAgICAgICBjb25zdCBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIGNvbnN0IHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHZtKTtcbiAgICAgICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgcmVuZGVyaW5nIGJhY2tlbmQgdXNlZC5cbiAgICAgICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZXNcbiAgICAgICAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgICAgIGlmIChwcmV2RWwpIHtcbiAgICAgICAgICAgIHByZXZFbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm0uJGVsKSB7XG4gICAgICAgICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICAgICAgbGV0IHdyYXBwZXIgPSB2bTtcbiAgICAgICAgd2hpbGUgKHdyYXBwZXIgJiZcbiAgICAgICAgICAgIHdyYXBwZXIuJHZub2RlICYmXG4gICAgICAgICAgICB3cmFwcGVyLiRwYXJlbnQgJiZcbiAgICAgICAgICAgIHdyYXBwZXIuJHZub2RlID09PSB3cmFwcGVyLiRwYXJlbnQuX3Zub2RlKSB7XG4gICAgICAgICAgICB3cmFwcGVyLiRwYXJlbnQuJGVsID0gd3JhcHBlci4kZWw7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlci4kcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZWQgaG9vayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBlbnN1cmUgdGhhdCBjaGlsZHJlbiBhcmVcbiAgICAgICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgICB9O1xuICAgIFZ1ZS5wcm90b3R5cGUuJGZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB2bSA9IHRoaXM7XG4gICAgICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHZtID0gdGhpcztcbiAgICAgICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICAgICAgdm0uX2lzQmVpbmdEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgICAgICBjb25zdCBwYXJlbnQgPSB2bS4kcGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICAgICAgICByZW1vdmUkMihwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVhcmRvd24gc2NvcGUuIHRoaXMgaW5jbHVkZXMgYm90aCB0aGUgcmVuZGVyIHdhdGNoZXIgYW5kIG90aGVyXG4gICAgICAgIC8vIHdhdGNoZXJzIGNyZWF0ZWRcbiAgICAgICAgdm0uX3Njb3BlLnN0b3AoKTtcbiAgICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAgICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgICAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIC8vIGludm9rZSBkZXN0cm95IGhvb2tzIG9uIGN1cnJlbnQgcmVuZGVyZWQgdHJlZVxuICAgICAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAgICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgICAgICBjYWxsSG9vayQxKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgICAgIHZtLiRvZmYoKTtcbiAgICAgICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgICAgIGlmICh2bS4kZWwpIHtcbiAgICAgICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgICAgICAgIHZtLiR2bm9kZS5wYXJlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1vdW50Q29tcG9uZW50KHZtLCBlbCwgaHlkcmF0aW5nKSB7XG4gICAgdm0uJGVsID0gZWw7XG4gICAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBpbnZhbGlkIHR5cGVcbiAgICAgICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICAgICAge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgICAgIHZtLiRvcHRpb25zLmVsIHx8XG4gICAgICAgICAgICAgICAgZWwpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoJ1lvdSBhcmUgdXNpbmcgdGhlIHJ1bnRpbWUtb25seSBidWlsZCBvZiBWdWUgd2hlcmUgdGhlIHRlbXBsYXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJywgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKCdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJywgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVNb3VudCcpO1xuICAgIGxldCB1cGRhdGVDb21wb25lbnQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdm0uX3VpZDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGFnID0gYHZ1ZS1wZXJmLXN0YXJ0OiR7aWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGVuZFRhZyA9IGB2dWUtcGVyZi1lbmQ6JHtpZH1gO1xuICAgICAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgICAgICBjb25zdCB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgICAgICAgIG1hcmsoZW5kVGFnKTtcbiAgICAgICAgICAgIG1lYXN1cmUoYHZ1ZSAke25hbWV9IHJlbmRlcmAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICAgICAgbWVhc3VyZShgdnVlICR7bmFtZX0gcGF0Y2hgLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHVwZGF0ZUNvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgICAgICAgIHZtLl91cGRhdGUodm0uX3JlbmRlcigpLCBoeWRyYXRpbmcpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB3YXRjaGVyT3B0aW9ucyA9IHtcbiAgICAgICAgYmVmb3JlKCkge1xuICAgICAgICAgICAgaWYgKHZtLl9pc01vdW50ZWQgJiYgIXZtLl9pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGNhbGxIb29rJDEodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAge1xuICAgICAgICB3YXRjaGVyT3B0aW9ucy5vblRyYWNrID0gZSA9PiBjYWxsSG9vayQxKHZtLCAncmVuZGVyVHJhY2tlZCcsIFtlXSk7XG4gICAgICAgIHdhdGNoZXJPcHRpb25zLm9uVHJpZ2dlciA9IGUgPT4gY2FsbEhvb2skMSh2bSwgJ3JlbmRlclRyaWdnZXJlZCcsIFtlXSk7XG4gICAgfVxuICAgIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gICAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gICAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwgd2F0Y2hlck9wdGlvbnMsIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgICBoeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAvLyBmbHVzaCBidWZmZXIgZm9yIGZsdXNoOiBcInByZVwiIHdhdGNoZXJzIHF1ZXVlZCBpbiBzZXR1cCgpXG4gICAgY29uc3QgcHJlV2F0Y2hlcnMgPSB2bS5fcHJlV2F0Y2hlcnM7XG4gICAgaWYgKHByZVdhdGNoZXJzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlV2F0Y2hlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByZVdhdGNoZXJzW2ldLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gICAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIGNhbGxIb29rJDEodm0sICdtb3VudGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2bTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkQ29tcG9uZW50KHZtLCBwcm9wc0RhdGEsIGxpc3RlbmVycywgcGFyZW50Vm5vZGUsIHJlbmRlckNoaWxkcmVuKSB7XG4gICAge1xuICAgICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cbiAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZHluYW1pYyBzY29wZWRTbG90cyAoaGFuZC13cml0dGVuIG9yIGNvbXBpbGVkIGJ1dCB3aXRoXG4gICAgLy8gZHluYW1pYyBzbG90IG5hbWVzKS4gU3RhdGljIHNjb3BlZCBzbG90cyBjb21waWxlZCBmcm9tIHRlbXBsYXRlIGhhcyB0aGVcbiAgICAvLyBcIiRzdGFibGVcIiBtYXJrZXIuXG4gICAgY29uc3QgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICAgIGNvbnN0IG9sZFNjb3BlZFNsb3RzID0gdm0uJHNjb3BlZFNsb3RzO1xuICAgIGNvbnN0IGhhc0R5bmFtaWNTY29wZWRTbG90ID0gISEoKG5ld1Njb3BlZFNsb3RzICYmICFuZXdTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICAgICAob2xkU2NvcGVkU2xvdHMgIT09IGVtcHR5T2JqZWN0ICYmICFvbGRTY29wZWRTbG90cy4kc3RhYmxlKSB8fFxuICAgICAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpIHx8XG4gICAgICAgICghbmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkpKTtcbiAgICAvLyBBbnkgc3RhdGljIHNsb3QgY2hpbGRyZW4gZnJvbSB0aGUgcGFyZW50IG1heSBoYXZlIGNoYW5nZWQgZHVyaW5nIHBhcmVudCdzXG4gICAgLy8gdXBkYXRlLiBEeW5hbWljIHNjb3BlZCBzbG90cyBtYXkgYWxzbyBoYXZlIGNoYW5nZWQuIEluIHN1Y2ggY2FzZXMsIGEgZm9yY2VkXG4gICAgLy8gdXBkYXRlIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdG5lc3MuXG4gICAgbGV0IG5lZWRzRm9yY2VVcGRhdGUgPSAhIShyZW5kZXJDaGlsZHJlbiB8fCAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgICAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgLy8gaGFzIG9sZCBzdGF0aWMgc2xvdHNcbiAgICAgICAgaGFzRHluYW1pY1Njb3BlZFNsb3QpO1xuICAgIGNvbnN0IHByZXZWTm9kZSA9IHZtLiR2bm9kZTtcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICB2bS4kdm5vZGUgPSBwYXJlbnRWbm9kZTsgLy8gdXBkYXRlIHZtJ3MgcGxhY2Vob2xkZXIgbm9kZSB3aXRob3V0IHJlLXJlbmRlclxuICAgIGlmICh2bS5fdm5vZGUpIHtcbiAgICAgICAgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICAgICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICAgIH1cbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcbiAgICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICAgIGNvbnN0IGF0dHJzID0gcGFyZW50Vm5vZGUuZGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdDtcbiAgICBpZiAodm0uX2F0dHJzUHJveHkpIHtcbiAgICAgICAgLy8gZm9yY2UgdXBkYXRlIGlmIGF0dHJzIGFyZSBhY2Nlc3NlZCBhbmQgaGFzIGNoYW5nZWQgc2luY2UgaXQgbWF5IGJlXG4gICAgICAgIC8vIHBhc3NlZCB0byBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgICAgaWYgKHN5bmNTZXR1cFByb3h5KHZtLl9hdHRyc1Byb3h5LCBhdHRycywgKHByZXZWTm9kZS5kYXRhICYmIHByZXZWTm9kZS5kYXRhLmF0dHJzKSB8fCBlbXB0eU9iamVjdCwgdm0sICckYXR0cnMnKSkge1xuICAgICAgICAgICAgbmVlZHNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdm0uJGF0dHJzID0gYXR0cnM7XG4gICAgLy8gdXBkYXRlIGxpc3RlbmVyc1xuICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcbiAgICBjb25zdCBwcmV2TGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBpZiAodm0uX2xpc3RlbmVyc1Byb3h5KSB7XG4gICAgICAgIHN5bmNTZXR1cFByb3h5KHZtLl9saXN0ZW5lcnNQcm94eSwgbGlzdGVuZXJzLCBwcmV2TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCB2bSwgJyRsaXN0ZW5lcnMnKTtcbiAgICB9XG4gICAgdm0uJGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIHByZXZMaXN0ZW5lcnMpO1xuICAgIC8vIHVwZGF0ZSBwcm9wc1xuICAgIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgICAgIGNvbnN0IHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICAgIC8vIGtlZXAgYSBjb3B5IG9mIHJhdyBwcm9wc0RhdGFcbiAgICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICAgIH1cbiAgICAvLyByZXNvbHZlIHNsb3RzICsgZm9yY2UgdXBkYXRlIGlmIGhhcyBjaGlsZHJlblxuICAgIGlmIChuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSW5JbmFjdGl2ZVRyZWUodm0pIHtcbiAgICB3aGlsZSAodm0gJiYgKHZtID0gdm0uJHBhcmVudCkpIHtcbiAgICAgICAgaWYgKHZtLl9pbmFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLCBkaXJlY3QpIHtcbiAgICBpZiAoZGlyZWN0KSB7XG4gICAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoaXNJbkluYWN0aXZlVHJlZSh2bSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2bS5fZGlyZWN0SW5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodm0uX2luYWN0aXZlIHx8IHZtLl9pbmFjdGl2ZSA9PT0gbnVsbCkge1xuICAgICAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnYWN0aXZhdGVkJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHZtLCBkaXJlY3QpIHtcbiAgICBpZiAoZGlyZWN0KSB7XG4gICAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdm0uX2luYWN0aXZlKSB7XG4gICAgICAgIHZtLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsSG9vayQxKHZtLCAnZGVhY3RpdmF0ZWQnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxsSG9vayQxKHZtLCBob29rLCBhcmdzLCBzZXRDb250ZXh0ID0gdHJ1ZSkge1xuICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgY29uc3QgcHJldkluc3QgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgY29uc3QgcHJldlNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKCk7XG4gICAgc2V0Q29udGV4dCAmJiBzZXRDdXJyZW50SW5zdGFuY2Uodm0pO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gICAgY29uc3QgaW5mbyA9IGAke2hvb2t9IGhvb2tgO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBhcmdzIHx8IG51bGwsIHZtLCBpbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodm0uX2hhc0hvb2tFdmVudCkge1xuICAgICAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gICAgfVxuICAgIGlmIChzZXRDb250ZXh0KSB7XG4gICAgICAgIHNldEN1cnJlbnRJbnN0YW5jZShwcmV2SW5zdCk7XG4gICAgICAgIHByZXZTY29wZSAmJiBwcmV2U2NvcGUub24oKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG59XG5cbmNvbnN0IE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5jb25zdCBxdWV1ZSA9IFtdO1xuY29uc3QgYWN0aXZhdGVkQ2hpbGRyZW4gPSBbXTtcbmxldCBoYXMgPSB7fTtcbmxldCBjaXJjdWxhciA9IHt9O1xubGV0IHdhaXRpbmcgPSBmYWxzZTtcbmxldCBmbHVzaGluZyA9IGZhbHNlO1xubGV0IGluZGV4JDEgPSAwO1xuLyoqXG4gKiBSZXNldCB0aGUgc2NoZWR1bGVyJ3Mgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlc2V0U2NoZWR1bGVyU3RhdGUoKSB7XG4gICAgaW5kZXgkMSA9IHF1ZXVlLmxlbmd0aCA9IGFjdGl2YXRlZENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgaGFzID0ge307XG4gICAge1xuICAgICAgICBjaXJjdWxhciA9IHt9O1xuICAgIH1cbiAgICB3YWl0aW5nID0gZmx1c2hpbmcgPSBmYWxzZTtcbn1cbi8vIEFzeW5jIGVkZ2UgY2FzZSAjNjU2NiByZXF1aXJlcyBzYXZpbmcgdGhlIHRpbWVzdGFtcCB3aGVuIGV2ZW50IGxpc3RlbmVycyBhcmVcbi8vIGF0dGFjaGVkLiBIb3dldmVyLCBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIGhhcyBhIHBlcmYgb3ZlcmhlYWQgZXNwZWNpYWxseVxuLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbi8vIGV2ZXJ5IHRpbWUgdGhlIHNjaGVkdWxlciBmbHVzaGVzIGFuZCB1c2UgdGhhdCBmb3IgYWxsIGV2ZW50IGxpc3RlbmVyc1xuLy8gYXR0YWNoZWQgZHVyaW5nIHRoYXQgZmx1c2guXG5sZXQgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcbi8vIEFzeW5jIGVkZ2UgY2FzZSBmaXggcmVxdWlyZXMgc3RvcmluZyBhbiBldmVudCBsaXN0ZW5lcidzIGF0dGFjaCB0aW1lc3RhbXAuXG5sZXQgZ2V0Tm93ID0gRGF0ZS5ub3c7XG4vLyBEZXRlcm1pbmUgd2hhdCBldmVudCB0aW1lc3RhbXAgdGhlIGJyb3dzZXIgaXMgdXNpbmcuIEFubm95aW5nbHksIHRoZVxuLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcbi8vIChyZWxhdGl2ZSB0byBVTklYIGVwb2NoKSwgc28gaW4gb3JkZXIgdG8gY29tcGFyZSB0aW1lIHdlIGhhdmUgdG8gdXNlIHRoZVxuLy8gc2FtZSB0aW1lc3RhbXAgdHlwZSB3aGVuIHNhdmluZyB0aGUgZmx1c2ggdGltZXN0YW1wLlxuLy8gQWxsIElFIHZlcnNpb25zIHVzZSBsb3ctcmVzIGV2ZW50IHRpbWVzdGFtcHMsIGFuZCBoYXZlIHByb2JsZW1hdGljIGNsb2NrXG4vLyBpbXBsZW1lbnRhdGlvbnMgKCM5NjMyKVxuaWYgKGluQnJvd3NlciAmJiAhaXNJRSkge1xuICAgIGNvbnN0IHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlO1xuICAgIGlmIChwZXJmb3JtYW5jZSAmJlxuICAgICAgICB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIGdldE5vdygpID4gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50JykudGltZVN0YW1wKSB7XG4gICAgICAgIC8vIGlmIHRoZSBldmVudCB0aW1lc3RhbXAsIGFsdGhvdWdoIGV2YWx1YXRlZCBBRlRFUiB0aGUgRGF0ZS5ub3coKSwgaXNcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIGl0LCBpdCBtZWFucyB0aGUgZXZlbnQgaXMgdXNpbmcgYSBoaS1yZXMgdGltZXN0YW1wLFxuICAgICAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lciB0aW1lc3RhbXBzIGFzXG4gICAgICAgIC8vIHdlbGwuXG4gICAgICAgIGdldE5vdyA9ICgpID0+IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH1cbn1cbmNvbnN0IHNvcnRDb21wYXJlRm4gPSAoYSwgYikgPT4ge1xuICAgIGlmIChhLnBvc3QpIHtcbiAgICAgICAgaWYgKCFiLnBvc3QpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYi5wb3N0KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGEuaWQgLSBiLmlkO1xufTtcbi8qKlxuICogRmx1c2ggYm90aCBxdWV1ZXMgYW5kIHJ1biB0aGUgd2F0Y2hlcnMuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUoKSB7XG4gICAgY3VycmVudEZsdXNoVGltZXN0YW1wID0gZ2V0Tm93KCk7XG4gICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgIGxldCB3YXRjaGVyLCBpZDtcbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAgIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gICAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gICAgcXVldWUuc29ydChzb3J0Q29tcGFyZUZuKTtcbiAgICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgICBmb3IgKGluZGV4JDEgPSAwOyBpbmRleCQxIDwgcXVldWUubGVuZ3RoOyBpbmRleCQxKyspIHtcbiAgICAgICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4JDFdO1xuICAgICAgICBpZiAod2F0Y2hlci5iZWZvcmUpIHtcbiAgICAgICAgICAgIHdhdGNoZXIuYmVmb3JlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWQgPSB3YXRjaGVyLmlkO1xuICAgICAgICBoYXNbaWRdID0gbnVsbDtcbiAgICAgICAgd2F0Y2hlci5ydW4oKTtcbiAgICAgICAgLy8gaW4gZGV2IGJ1aWxkLCBjaGVjayBhbmQgc3RvcCBjaXJjdWxhciB1cGRhdGVzLlxuICAgICAgICBpZiAoaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgICAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKCdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArXG4gICAgICAgICAgICAgICAgICAgICh3YXRjaGVyLnVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYGluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFwiJHt3YXRjaGVyLmV4cHJlc3Npb259XCJgXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uYCksIHdhdGNoZXIudm0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgICBjb25zdCBhY3RpdmF0ZWRRdWV1ZSA9IGFjdGl2YXRlZENoaWxkcmVuLnNsaWNlKCk7XG4gICAgY29uc3QgdXBkYXRlZFF1ZXVlID0gcXVldWUuc2xpY2UoKTtcbiAgICByZXNldFNjaGVkdWxlclN0YXRlKCk7XG4gICAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gICAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG4gICAgY2xlYW51cERlcHMoKTtcbiAgICAvLyBkZXZ0b29sIGhvb2tcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICAgIGRldnRvb2xzLmVtaXQoJ2ZsdXNoJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsbFVwZGF0ZWRIb29rcyhxdWV1ZSkge1xuICAgIGxldCBpID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3Qgd2F0Y2hlciA9IHF1ZXVlW2ldO1xuICAgICAgICBjb25zdCB2bSA9IHdhdGNoZXIudm07XG4gICAgICAgIGlmICh2bSAmJiB2bS5fd2F0Y2hlciA9PT0gd2F0Y2hlciAmJiB2bS5faXNNb3VudGVkICYmICF2bS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGNhbGxIb29rJDEodm0sICd1cGRhdGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFF1ZXVlIGEga2VwdC1hbGl2ZSBjb21wb25lbnQgdGhhdCB3YXMgYWN0aXZhdGVkIGR1cmluZyBwYXRjaC5cbiAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gcXVldWVBY3RpdmF0ZWRDb21wb25lbnQodm0pIHtcbiAgICAvLyBzZXR0aW5nIF9pbmFjdGl2ZSB0byBmYWxzZSBoZXJlIHNvIHRoYXQgYSByZW5kZXIgZnVuY3Rpb24gY2FuXG4gICAgLy8gcmVseSBvbiBjaGVja2luZyB3aGV0aGVyIGl0J3MgaW4gYW4gaW5hY3RpdmUgdHJlZSAoZS5nLiByb3V0ZXItdmlldylcbiAgICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgICBhY3RpdmF0ZWRDaGlsZHJlbi5wdXNoKHZtKTtcbn1cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyhxdWV1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVldWVbaV0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgICB9XG59XG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIod2F0Y2hlcikge1xuICAgIGNvbnN0IGlkID0gd2F0Y2hlci5pZDtcbiAgICBpZiAoaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHdhdGNoZXIgPT09IERlcC50YXJnZXQgJiYgd2F0Y2hlci5ub1JlY3Vyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBoYXNbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICAgIGxldCBpID0gcXVldWUubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGkgPiBpbmRleCQxICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgfVxuICAgIC8vIHF1ZXVlIHRoZSBmbHVzaFxuICAgIGlmICghd2FpdGluZykge1xuICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFjb25maWcuYXN5bmMpIHtcbiAgICAgICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICB9XG59XG5cbmNvbnN0IFdBVENIRVIgPSBgd2F0Y2hlcmA7XG5jb25zdCBXQVRDSEVSX0NCID0gYCR7V0FUQ0hFUn0gY2FsbGJhY2tgO1xuY29uc3QgV0FUQ0hFUl9HRVRURVIgPSBgJHtXQVRDSEVSfSBnZXR0ZXJgO1xuY29uc3QgV0FUQ0hFUl9DTEVBTlVQID0gYCR7V0FUQ0hFUn0gY2xlYW51cGA7XG4vLyBTaW1wbGUgZWZmZWN0LlxuZnVuY3Rpb24gd2F0Y2hFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHdhdGNoUG9zdEVmZmVjdChlZmZlY3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZG9XYXRjaChlZmZlY3QsIG51bGwsIChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZsdXNoOiAncG9zdCcgfSkgKSk7XG59XG5mdW5jdGlvbiB3YXRjaFN5bmNFZmZlY3QoZWZmZWN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGRvV2F0Y2goZWZmZWN0LCBudWxsLCAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmbHVzaDogJ3N5bmMnIH0pICkpO1xufVxuLy8gaW5pdGlhbCB2YWx1ZSBmb3Igd2F0Y2hlcnMgdG8gdHJpZ2dlciBvbiB1bmRlZmluZWQgaW5pdGlhbCB2YWx1ZXNcbmNvbnN0IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA9IHt9O1xuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm4kMihgXFxgd2F0Y2goZm4sIG9wdGlvbnM/KVxcYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIGAgK1xuICAgICAgICAgICAgYFVzZSBcXGB3YXRjaEVmZmVjdChmbiwgb3B0aW9ucz8pXFxgIGluc3RlYWQuIFxcYHdhdGNoXFxgIG5vdyBvbmx5IGAgK1xuICAgICAgICAgICAgYHN1cHBvcnRzIFxcYHdhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XG4gICAgfVxuICAgIHJldHVybiBkb1dhdGNoKHNvdXJjZSwgY2IsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZG9XYXRjaChzb3VyY2UsIGNiLCB7IGltbWVkaWF0ZSwgZGVlcCwgZmx1c2ggPSAncHJlJywgb25UcmFjaywgb25UcmlnZ2VyIH0gPSBlbXB0eU9iamVjdCkge1xuICAgIGlmICghY2IpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3YXJuJDIoYHdhdGNoKCkgXCJpbW1lZGlhdGVcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgYCArXG4gICAgICAgICAgICAgICAgYHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2FybiQyKGB3YXRjaCgpIFwiZGVlcFwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSBgICtcbiAgICAgICAgICAgICAgICBgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB3YXJuSW52YWxpZFNvdXJjZSA9IChzKSA9PiB7XG4gICAgICAgIHdhcm4kMihgSW52YWxpZCB3YXRjaCBzb3VyY2U6ICR7c30uIEEgd2F0Y2ggc291cmNlIGNhbiBvbmx5IGJlIGEgZ2V0dGVyL2VmZmVjdCBgICtcbiAgICAgICAgICAgIGBmdW5jdGlvbiwgYSByZWYsIGEgcmVhY3RpdmUgb2JqZWN0LCBvciBhbiBhcnJheSBvZiB0aGVzZSB0eXBlcy5gKTtcbiAgICB9O1xuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgIGNvbnN0IGNhbGwgPSAoZm4sIHR5cGUsIGFyZ3MgPSBudWxsKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGZuLCBudWxsLCBhcmdzLCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICAgIGlmIChkZWVwICYmIHJlcyAmJiByZXMuX19vYl9fKVxuICAgICAgICAgICAgcmVzLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBsZXQgZ2V0dGVyO1xuICAgIGxldCBmb3JjZVRyaWdnZXIgPSBmYWxzZTtcbiAgICBsZXQgaXNNdWx0aVNvdXJjZSA9IGZhbHNlO1xuICAgIGlmIChpc1JlZihzb3VyY2UpKSB7XG4gICAgICAgIGdldHRlciA9ICgpID0+IHNvdXJjZS52YWx1ZTtcbiAgICAgICAgZm9yY2VUcmlnZ2VyID0gaXNTaGFsbG93KHNvdXJjZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVhY3RpdmUoc291cmNlKSkge1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBzb3VyY2UuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH07XG4gICAgICAgIGRlZXAgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgaXNNdWx0aVNvdXJjZSA9IHRydWU7XG4gICAgICAgIGZvcmNlVHJpZ2dlciA9IHNvdXJjZS5zb21lKHMgPT4gaXNSZWFjdGl2ZShzKSB8fCBpc1NoYWxsb3cocykpO1xuICAgICAgICBnZXR0ZXIgPSAoKSA9PiBzb3VyY2UubWFwKHMgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUmVmKHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlYWN0aXZlKHMpKSB7XG4gICAgICAgICAgICAgICAgcy5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmF2ZXJzZShzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbChzLCBXQVRDSEVSX0dFVFRFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuSW52YWxpZFNvdXJjZShzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgIC8vIGdldHRlciB3aXRoIGNiXG4gICAgICAgICAgICBnZXR0ZXIgPSAoKSA9PiBjYWxsKHNvdXJjZSwgV0FUQ0hFUl9HRVRURVIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gY2IgLT4gc2ltcGxlIGVmZmVjdFxuICAgICAgICAgICAgZ2V0dGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2xlYW51cCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsKHNvdXJjZSwgV0FUQ0hFUiwgW29uQ2xlYW51cF0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2V0dGVyID0gbm9vcDtcbiAgICAgICAgd2FybkludmFsaWRTb3VyY2Uoc291cmNlKTtcbiAgICB9XG4gICAgaWYgKGNiICYmIGRlZXApIHtcbiAgICAgICAgY29uc3QgYmFzZUdldHRlciA9IGdldHRlcjtcbiAgICAgICAgZ2V0dGVyID0gKCkgPT4gdHJhdmVyc2UoYmFzZUdldHRlcigpKTtcbiAgICB9XG4gICAgbGV0IGNsZWFudXA7XG4gICAgbGV0IG9uQ2xlYW51cCA9IChmbikgPT4ge1xuICAgICAgICBjbGVhbnVwID0gd2F0Y2hlci5vblN0b3AgPSAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsKGZuLCBXQVRDSEVSX0NMRUFOVVApO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gaW4gU1NSIHRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0dXAgYW4gYWN0dWFsIGVmZmVjdCwgYW5kIGl0IHNob3VsZCBiZSBub29wXG4gICAgLy8gdW5sZXNzIGl0J3MgZWFnZXJcbiAgICBpZiAoaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICAvLyB3ZSB3aWxsIGFsc28gbm90IGNhbGwgdGhlIGludmFsaWRhdGUgY2FsbGJhY2sgKCsgcnVubmVyIGlzIG5vdCBzZXQgdXApXG4gICAgICAgIG9uQ2xlYW51cCA9IG5vb3A7XG4gICAgICAgIGlmICghY2IpIHtcbiAgICAgICAgICAgIGdldHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgY2FsbChjYiwgV0FUQ0hFUl9DQiwgW1xuICAgICAgICAgICAgICAgIGdldHRlcigpLFxuICAgICAgICAgICAgICAgIGlzTXVsdGlTb3VyY2UgPyBbXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvbkNsZWFudXBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IFdhdGNoZXIoY3VycmVudEluc3RhbmNlLCBnZXR0ZXIsIG5vb3AsIHtcbiAgICAgICAgbGF6eTogdHJ1ZVxuICAgIH0pO1xuICAgIHdhdGNoZXIubm9SZWN1cnNlID0gIWNiO1xuICAgIGxldCBvbGRWYWx1ZSA9IGlzTXVsdGlTb3VyY2UgPyBbXSA6IElOSVRJQUxfV0FUQ0hFUl9WQUxVRTtcbiAgICAvLyBvdmVyd3JpdGUgZGVmYXVsdCBydW5cbiAgICB3YXRjaGVyLnJ1biA9ICgpID0+IHtcbiAgICAgICAgaWYgKCF3YXRjaGVyLmFjdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgLy8gd2F0Y2goc291cmNlLCBjYilcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gd2F0Y2hlci5nZXQoKTtcbiAgICAgICAgICAgIGlmIChkZWVwIHx8XG4gICAgICAgICAgICAgICAgZm9yY2VUcmlnZ2VyIHx8XG4gICAgICAgICAgICAgICAgKGlzTXVsdGlTb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgPyBuZXdWYWx1ZS5zb21lKCh2LCBpKSA9PiBoYXNDaGFuZ2VkKHYsIG9sZFZhbHVlW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgOiBoYXNDaGFuZ2VkKG5ld1ZhbHVlLCBvbGRWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCBiZWZvcmUgcnVubmluZyBjYiBhZ2FpblxuICAgICAgICAgICAgICAgIGlmIChjbGVhbnVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbChjYiwgV0FUQ0hFUl9DQiwgW1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB1bmRlZmluZWQgYXMgdGhlIG9sZCB2YWx1ZSB3aGVuIGl0J3MgY2hhbmdlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPT09IElOSVRJQUxfV0FUQ0hFUl9WQUxVRSA/IHVuZGVmaW5lZCA6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBvbkNsZWFudXBcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2F0Y2hFZmZlY3RcbiAgICAgICAgICAgIHdhdGNoZXIuZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChmbHVzaCA9PT0gJ3N5bmMnKSB7XG4gICAgICAgIHdhdGNoZXIudXBkYXRlID0gd2F0Y2hlci5ydW47XG4gICAgfVxuICAgIGVsc2UgaWYgKGZsdXNoID09PSAncG9zdCcpIHtcbiAgICAgICAgd2F0Y2hlci5wb3N0ID0gdHJ1ZTtcbiAgICAgICAgd2F0Y2hlci51cGRhdGUgPSAoKSA9PiBxdWV1ZVdhdGNoZXIod2F0Y2hlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBwcmVcbiAgICAgICAgd2F0Y2hlci51cGRhdGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UgPT09IGN1cnJlbnRJbnN0YW5jZSAmJiAhaW5zdGFuY2UuX2lzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIHByZS13YXRjaGVyIHRyaWdnZXJlZCBiZWZvcmVcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBpbnN0YW5jZS5fcHJlV2F0Y2hlcnMgfHwgKGluc3RhbmNlLl9wcmVXYXRjaGVycyA9IFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmluZGV4T2Yod2F0Y2hlcikgPCAwKVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaCh3YXRjaGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHF1ZXVlV2F0Y2hlcih3YXRjaGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAge1xuICAgICAgICB3YXRjaGVyLm9uVHJhY2sgPSBvblRyYWNrO1xuICAgICAgICB3YXRjaGVyLm9uVHJpZ2dlciA9IG9uVHJpZ2dlcjtcbiAgICB9XG4gICAgLy8gaW5pdGlhbCBydW5cbiAgICBpZiAoY2IpIHtcbiAgICAgICAgaWYgKGltbWVkaWF0ZSkge1xuICAgICAgICAgICAgd2F0Y2hlci5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gd2F0Y2hlci5nZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChmbHVzaCA9PT0gJ3Bvc3QnICYmIGluc3RhbmNlKSB7XG4gICAgICAgIGluc3RhbmNlLiRvbmNlKCdob29rOm1vdW50ZWQnLCAoKSA9PiB3YXRjaGVyLmdldCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhdGNoZXIuZ2V0KCk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwcm92aWRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICB7XG4gICAgICAgICAgICB3YXJuJDIoYHByb3ZpZGUoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXG4gICAgICAgIHJlc29sdmVQcm92aWRlZChjdXJyZW50SW5zdGFuY2UpW2tleV0gPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXNvbHZlUHJvdmlkZWQodm0pIHtcbiAgICAvLyBieSBkZWZhdWx0IGFuIGluc3RhbmNlIGluaGVyaXRzIGl0cyBwYXJlbnQncyBwcm92aWRlcyBvYmplY3RcbiAgICAvLyBidXQgd2hlbiBpdCBuZWVkcyB0byBwcm92aWRlIHZhbHVlcyBvZiBpdHMgb3duLCBpdCBjcmVhdGVzIGl0c1xuICAgIC8vIG93biBwcm92aWRlcyBvYmplY3QgdXNpbmcgcGFyZW50IHByb3ZpZGVzIG9iamVjdCBhcyBwcm90b3R5cGUuXG4gICAgLy8gdGhpcyB3YXkgaW4gYGluamVjdGAgd2UgY2FuIHNpbXBseSBsb29rIHVwIGluamVjdGlvbnMgZnJvbSBkaXJlY3RcbiAgICAvLyBwYXJlbnQgYW5kIGxldCB0aGUgcHJvdG90eXBlIGNoYWluIGRvIHRoZSB3b3JrLlxuICAgIGNvbnN0IGV4aXN0aW5nID0gdm0uX3Byb3ZpZGVkO1xuICAgIGNvbnN0IHBhcmVudFByb3ZpZGVzID0gdm0uJHBhcmVudCAmJiB2bS4kcGFyZW50Ll9wcm92aWRlZDtcbiAgICBpZiAocGFyZW50UHJvdmlkZXMgPT09IGV4aXN0aW5nKSB7XG4gICAgICAgIHJldHVybiAodm0uX3Byb3ZpZGVkID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRQcm92aWRlcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluamVjdChrZXksIGRlZmF1bHRWYWx1ZSwgdHJlYXREZWZhdWx0QXNGYWN0b3J5ID0gZmFsc2UpIHtcbiAgICAvLyBmYWxsYmFjayB0byBgY3VycmVudFJlbmRlcmluZ0luc3RhbmNlYCBzbyB0aGF0IHRoaXMgY2FuIGJlIGNhbGxlZCBpblxuICAgIC8vIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgICBjb25zdCBpbnN0YW5jZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gIzI0MDBcbiAgICAgICAgLy8gdG8gc3VwcG9ydCBgYXBwLnVzZWAgcGx1Z2lucyxcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gYXBwQ29udGV4dCdzIGBwcm92aWRlc2AgaWYgdGhlIGluc3RhbmNlIGlzIGF0IHJvb3RcbiAgICAgICAgY29uc3QgcHJvdmlkZXMgPSBpbnN0YW5jZS4kcGFyZW50ICYmIGluc3RhbmNlLiRwYXJlbnQuX3Byb3ZpZGVkO1xuICAgICAgICBpZiAocHJvdmlkZXMgJiYga2V5IGluIHByb3ZpZGVzKSB7XG4gICAgICAgICAgICAvLyBUUyBkb2Vzbid0IGFsbG93IHN5bWJvbCBhcyBpbmRleCB0eXBlXG4gICAgICAgICAgICByZXR1cm4gcHJvdmlkZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyZWF0RGVmYXVsdEFzRmFjdG9yeSAmJiBpc0Z1bmN0aW9uKGRlZmF1bHRWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZS5jYWxsKGluc3RhbmNlKVxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FybiQyKGBpbmplY3Rpb24gXCIke1N0cmluZyhrZXkpfVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd2FybiQyKGBpbmplY3QoKSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBzZXR1cCgpIG9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cy5gKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGludGVybmFsIHRoaXMgZnVuY3Rpb24gbmVlZHMgbWFudWFsIHB1YmxpYyB0eXBlIGRlY2xhcmF0aW9uIGJlY2F1c2UgaXQgcmVsaWVzXG4gKiBvbiBwcmV2aW91c2x5IG1hbnVhbGx5IGF1dGhvcmVkIHR5cGVzIGZyb20gVnVlIDJcbiAqL1xuZnVuY3Rpb24gaCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICB3YXJuJDIoYGdsb2JhbGx5IGltcG9ydGVkIGgoKSBjYW4gb25seSBiZSBpbnZva2VkIHdoZW4gdGhlcmUgaXMgYW4gYWN0aXZlIGAgK1xuICAgICAgICAgICAgICAgIGBjb21wb25lbnQgaW5zdGFuY2UsIGUuZy4gc3luY2hyb25vdXNseSBpbiBhIGNvbXBvbmVudCdzIHJlbmRlciBvciBzZXR1cCBmdW5jdGlvbi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQkMShjdXJyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgMiwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pIHtcbiAgICAvLyBEZWFjdGl2YXRlIGRlcHMgdHJhY2tpbmcgd2hpbGUgcHJvY2Vzc2luZyBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHBvc3NpYmxlIGluZmluaXRlIHJlbmRlcmluZy5cbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWV4L2lzc3Vlcy8xNTA1XG4gICAgcHVzaFRhcmdldCgpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh2bSkge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHZtO1xuICAgICAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgICAgICAgICAgIGlmIChob29rcykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlciwgY29udGV4dCwgYXJncywgdm0sIGluZm8pIHtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIHJlcyA9IGFyZ3MgPyBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpIDogaGFuZGxlci5jYWxsKGNvbnRleHQpO1xuICAgICAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpICYmICFyZXMuX2hhbmRsZWQpIHtcbiAgICAgICAgICAgIHJlcy5jYXRjaChlID0+IGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvICsgYCAoUHJvbWlzZS9hc3luYylgKSk7XG4gICAgICAgICAgICByZXMuX2hhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yKGVyciwgdm0sIGluZm8pIHtcbiAgICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgaW50ZW50aW9uYWxseSB0aHJvd3MgdGhlIG9yaWdpbmFsIGVycm9yIGluIHRoZSBoYW5kbGVyLFxuICAgICAgICAgICAgLy8gZG8gbm90IGxvZyBpdCB0d2ljZVxuICAgICAgICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5mdW5jdGlvbiBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKSB7XG4gICAge1xuICAgICAgICB3YXJuJDIoYEVycm9yIGluICR7aW5mb306IFwiJHtlcnIudG9TdHJpbmcoKX1cImAsIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaW5Ccm93c2VyICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cbmxldCBpc1VzaW5nTWljcm9UYXNrID0gZmFsc2U7XG5jb25zdCBjYWxsYmFja3MgPSBbXTtcbmxldCBwZW5kaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBmbHVzaENhbGxiYWNrcygpIHtcbiAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgY29uc3QgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbn1cbi8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbi8vIEluIDIuNSB3ZSB1c2VkIChtYWNybykgdGFza3MgKGluIGNvbWJpbmF0aW9uIHdpdGggbWljcm90YXNrcykuXG4vLyBIb3dldmVyLCBpdCBoYXMgc3VidGxlIHByb2JsZW1zIHdoZW4gc3RhdGUgaXMgY2hhbmdlZCByaWdodCBiZWZvcmUgcmVwYWludFxuLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBBbHNvLCB1c2luZyAobWFjcm8pIHRhc2tzIGluIGV2ZW50IGhhbmRsZXIgd291bGQgY2F1c2Ugc29tZSB3ZWlyZCBiZWhhdmlvcnNcbi8vIHRoYXQgY2Fubm90IGJlIGNpcmN1bXZlbnRlZCAoZS5nLiAjNzEwOSwgIzcxNTMsICM3NTQ2LCAjNzgzNCwgIzgxMDkpLlxuLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuLy8gQSBtYWpvciBkcmF3YmFjayBvZiB0aGlzIHRyYWRlb2ZmIGlzIHRoYXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zXG4vLyB3aGVyZSBtaWNyb3Rhc2tzIGhhdmUgdG9vIGhpZ2ggYSBwcmlvcml0eSBhbmQgZmlyZSBpbiBiZXR3ZWVuIHN1cHBvc2VkbHlcbi8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbi8vIG9yIGV2ZW4gYmV0d2VlbiBidWJibGluZyBvZiB0aGUgc2FtZSBldmVudCAoIzY1NjYpLlxubGV0IHRpbWVyRnVuYztcbi8vIFRoZSBuZXh0VGljayBiZWhhdmlvciBsZXZlcmFnZXMgdGhlIG1pY3JvdGFzayBxdWV1ZSwgd2hpY2ggY2FuIGJlIGFjY2Vzc2VkXG4vLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuLy8gVUlXZWJWaWV3IGluIGlPUyA+PSA5LjMuMyB3aGVuIHRyaWdnZXJlZCBpbiB0b3VjaCBldmVudCBoYW5kbGVycy4gSXRcbi8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbi8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgICBjb25zdCBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgICAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgICAgICAvLyBJbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgICAgLy8gaXQgY2FuIGdldCBzdHVjayBpbiBhIHdlaXJkIHN0YXRlIHdoZXJlIGNhbGxiYWNrcyBhcmUgcHVzaGVkIGludG8gdGhlXG4gICAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgICAvLyBcImZvcmNlXCIgdGhlIG1pY3JvdGFzayBxdWV1ZSB0byBiZSBmbHVzaGVkIGJ5IGFkZGluZyBhbiBlbXB0eSB0aW1lci5cbiAgICAgICAgaWYgKGlzSU9TKVxuICAgICAgICAgICAgc2V0VGltZW91dChub29wKTtcbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufVxuZWxzZSBpZiAoIWlzSUUgJiZcbiAgICB0eXBlb2YgTXV0YXRpb25PYnNlcnZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAoaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAgICAgLy8gUGhhbnRvbUpTIGFuZCBpT1MgNy54XG4gICAgICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXScpKSB7XG4gICAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgd2hlcmUgbmF0aXZlIFByb21pc2UgaXMgbm90IGF2YWlsYWJsZSxcbiAgICAvLyBlLmcuIFBoYW50b21KUywgaU9TNywgQW5kcm9pZCA0LjRcbiAgICAvLyAoIzY0NjYgTXV0YXRpb25PYnNlcnZlciBpcyB1bnJlbGlhYmxlIGluIElFMTEpXG4gICAgbGV0IGNvdW50ZXIgPSAxO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKGNvdW50ZXIpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHRleHROb2RlLCB7XG4gICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgICAgdGV4dE5vZGUuZGF0YSA9IFN0cmluZyhjb3VudGVyKTtcbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xufVxuZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoc2V0SW1tZWRpYXRlKSkge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldEltbWVkaWF0ZS5cbiAgICAvLyBUZWNobmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgICB0aW1lckZ1bmMgPSAoKSA9PiB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gICAgfTtcbn1cbmVsc2Uge1xuICAgIC8vIEZhbGxiYWNrIHRvIHNldFRpbWVvdXQuXG4gICAgdGltZXJGdW5jID0gKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgICB9O1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gbmV4dFRpY2soY2IsIGN0eCkge1xuICAgIGxldCBfcmVzb2x2ZTtcbiAgICBjYWxsYmFja3MucHVzaCgoKSA9PiB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYi5jYWxsKGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIGN0eCwgJ25leHRUaWNrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgICAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRpbWVyRnVuYygpO1xuICAgIH1cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBpZiAoIWNiICYmIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlQ3NzTW9kdWxlKG5hbWUgPSAnJHN0eWxlJykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAge1xuICAgICAgICBpZiAoIWN1cnJlbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgd2FybiQyKGB1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClgKTtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2QgPSBjdXJyZW50SW5zdGFuY2VbbmFtZV07XG4gICAgICAgIGlmICghbW9kKSB7XG4gICAgICAgICAgICB3YXJuJDIoYEN1cnJlbnQgaW5zdGFuY2UgZG9lcyBub3QgaGF2ZSBDU1MgbW9kdWxlIG5hbWVkIFwiJHtuYW1lfVwiLmApO1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2Q7XG4gICAgfVxufVxuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBTRkMncyBDU1MgdmFyaWFibGUgaW5qZWN0aW9uIGZlYXR1cmUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1c2VDc3NWYXJzKGdldHRlcikge1xuICAgIGlmICghaW5Ccm93c2VyICYmICFmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluc3RhbmNlID0gY3VycmVudEluc3RhbmNlO1xuICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgd2FybiQyKGB1c2VDc3NWYXJzIGlzIGNhbGxlZCB3aXRob3V0IGN1cnJlbnQgYWN0aXZlIGNvbXBvbmVudCBpbnN0YW5jZS5gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXRjaFBvc3RFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGluc3RhbmNlLiRlbDtcbiAgICAgICAgY29uc3QgdmFycyA9IGdldHRlcihpbnN0YW5jZSwgaW5zdGFuY2UuX3NldHVwUHJveHkpO1xuICAgICAgICBpZiAoZWwgJiYgZWwubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZWwuc3R5bGU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtrZXl9YCwgdmFyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIHYzLWNvbXBhdGlibGUgYXN5bmMgY29tcG9uZW50IEFQSS5cbiAqIEBpbnRlcm5hbCB0aGUgdHlwZSBpcyBtYW51YWxseSBkZWNsYXJlZCBpbiA8cm9vdD4vdHlwZXMvdjMtZGVmaW5lLWFzeW5jLWNvbXBvbmVudC5kLnRzXG4gKiBiZWNhdXNlIGl0IHJlbGllcyBvbiBleGlzdGluZyBtYW51YWwgdHlwZXNcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQXN5bmNDb21wb25lbnQoc291cmNlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oc291cmNlKSkge1xuICAgICAgICBzb3VyY2UgPSB7IGxvYWRlcjogc291cmNlIH07XG4gICAgfVxuICAgIGNvbnN0IHsgbG9hZGVyLCBsb2FkaW5nQ29tcG9uZW50LCBlcnJvckNvbXBvbmVudCwgZGVsYXkgPSAyMDAsIHRpbWVvdXQsIC8vIHVuZGVmaW5lZCA9IG5ldmVyIHRpbWVzIG91dFxuICAgIHN1c3BlbnNpYmxlID0gZmFsc2UsIC8vIGluIFZ1ZSAzIGRlZmF1bHQgaXMgdHJ1ZVxuICAgIG9uRXJyb3I6IHVzZXJPbkVycm9yIH0gPSBzb3VyY2U7XG4gICAgaWYgKHN1c3BlbnNpYmxlKSB7XG4gICAgICAgIHdhcm4kMihgVGhlIHN1c3BlbnNpYmxlIG9wdGlvbiBmb3IgYXN5bmMgY29tcG9uZW50cyBpcyBub3Qgc3VwcG9ydGVkIGluIFZ1ZTIuIEl0IGlzIGlnbm9yZWQuYCk7XG4gICAgfVxuICAgIGxldCBwZW5kaW5nUmVxdWVzdCA9IG51bGw7XG4gICAgbGV0IHJldHJpZXMgPSAwO1xuICAgIGNvbnN0IHJldHJ5ID0gKCkgPT4ge1xuICAgICAgICByZXRyaWVzKys7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGxvYWQoKTtcbiAgICB9O1xuICAgIGNvbnN0IGxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGxldCB0aGlzUmVxdWVzdDtcbiAgICAgICAgcmV0dXJuIChwZW5kaW5nUmVxdWVzdCB8fFxuICAgICAgICAgICAgKHRoaXNSZXF1ZXN0ID0gcGVuZGluZ1JlcXVlc3QgPVxuICAgICAgICAgICAgICAgIGxvYWRlcigpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyUmV0cnkgPSAoKSA9PiByZXNvbHZlKHJldHJ5KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGYWlsID0gKCkgPT4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck9uRXJyb3IoZXJyLCB1c2VyUmV0cnksIHVzZXJGYWlsLCByZXRyaWVzICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChjb21wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzUmVxdWVzdCAhPT0gcGVuZGluZ1JlcXVlc3QgJiYgcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwZW5kaW5nUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4kMihgQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHJldHJ5KCksIG1ha2Ugc3VyZSB0byByZXR1cm4gaXRzIHJldHVybiB2YWx1ZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnRlcm9wIG1vZHVsZSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcC5fX2VzTW9kdWxlIHx8IGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wID0gY29tcC5kZWZhdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICYmICFpc09iamVjdChjb21wKSAmJiAhaXNGdW5jdGlvbihjb21wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzeW5jIGNvbXBvbmVudCBsb2FkIHJlc3VsdDogJHtjb21wfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xuICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgfTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBsb2FkKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wb25lbnQsXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIHRpbWVvdXQsXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JDb21wb25lbnQsXG4gICAgICAgICAgICBsb2FkaW5nOiBsb2FkaW5nQ29tcG9uZW50XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlmZUN5Y2xlKGhvb2tOYW1lKSB7XG4gICAgcmV0dXJuIChmbiwgdGFyZ2V0ID0gY3VycmVudEluc3RhbmNlKSA9PiB7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB3YXJuJDIoYCR7Zm9ybWF0TmFtZShob29rTmFtZSl9IGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYCArXG4gICAgICAgICAgICAgICAgICAgIGBhc3NvY2lhdGVkIHdpdGguIGAgK1xuICAgICAgICAgICAgICAgICAgICBgTGlmZWN5Y2xlIGluamVjdGlvbiBBUElzIGNhbiBvbmx5IGJlIHVzZWQgZHVyaW5nIGV4ZWN1dGlvbiBvZiBzZXR1cCgpLmApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmplY3RIb29rKHRhcmdldCwgaG9va05hbWUsIGZuKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZm9ybWF0TmFtZShuYW1lKSB7XG4gICAgaWYgKG5hbWUgPT09ICdiZWZvcmVEZXN0cm95Jykge1xuICAgICAgICBuYW1lID0gJ2JlZm9yZVVubW91bnQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnZGVzdHJveWVkJykge1xuICAgICAgICBuYW1lID0gJ3VubW91bnRlZCc7XG4gICAgfVxuICAgIHJldHVybiBgb24ke25hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSl9YDtcbn1cbmZ1bmN0aW9uIGluamVjdEhvb2soaW5zdGFuY2UsIGhvb2tOYW1lLCBmbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBpbnN0YW5jZS4kb3B0aW9ucztcbiAgICBvcHRpb25zW2hvb2tOYW1lXSA9IG1lcmdlTGlmZWN5Y2xlSG9vayhvcHRpb25zW2hvb2tOYW1lXSwgZm4pO1xufVxuY29uc3Qgb25CZWZvcmVNb3VudCA9IGNyZWF0ZUxpZmVDeWNsZSgnYmVmb3JlTW91bnQnKTtcbmNvbnN0IG9uTW91bnRlZCA9IGNyZWF0ZUxpZmVDeWNsZSgnbW91bnRlZCcpO1xuY29uc3Qgb25CZWZvcmVVcGRhdGUgPSBjcmVhdGVMaWZlQ3ljbGUoJ2JlZm9yZVVwZGF0ZScpO1xuY29uc3Qgb25VcGRhdGVkID0gY3JlYXRlTGlmZUN5Y2xlKCd1cGRhdGVkJyk7XG5jb25zdCBvbkJlZm9yZVVubW91bnQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2JlZm9yZURlc3Ryb3knKTtcbmNvbnN0IG9uVW5tb3VudGVkID0gY3JlYXRlTGlmZUN5Y2xlKCdkZXN0cm95ZWQnKTtcbmNvbnN0IG9uQWN0aXZhdGVkID0gY3JlYXRlTGlmZUN5Y2xlKCdhY3RpdmF0ZWQnKTtcbmNvbnN0IG9uRGVhY3RpdmF0ZWQgPSBjcmVhdGVMaWZlQ3ljbGUoJ2RlYWN0aXZhdGVkJyk7XG5jb25zdCBvblNlcnZlclByZWZldGNoID0gY3JlYXRlTGlmZUN5Y2xlKCdzZXJ2ZXJQcmVmZXRjaCcpO1xuY29uc3Qgb25SZW5kZXJUcmFja2VkID0gY3JlYXRlTGlmZUN5Y2xlKCdyZW5kZXJUcmFja2VkJyk7XG5jb25zdCBvblJlbmRlclRyaWdnZXJlZCA9IGNyZWF0ZUxpZmVDeWNsZSgncmVuZGVyVHJpZ2dlcmVkJyk7XG5jb25zdCBpbmplY3RFcnJvckNhcHR1cmVkSG9vayA9IGNyZWF0ZUxpZmVDeWNsZSgnZXJyb3JDYXB0dXJlZCcpO1xuZnVuY3Rpb24gb25FcnJvckNhcHR1cmVkKGhvb2ssIHRhcmdldCA9IGN1cnJlbnRJbnN0YW5jZSkge1xuICAgIGluamVjdEVycm9yQ2FwdHVyZWRIb29rKGhvb2ssIHRhcmdldCk7XG59XG5cbi8qKlxuICogTm90ZTogYWxzbyB1cGRhdGUgZGlzdC92dWUucnVudGltZS5tanMgd2hlbiBhZGRpbmcgbmV3IGV4cG9ydHMgdG8gdGhpcyBmaWxlLlxuICovXG5jb25zdCB2ZXJzaW9uID0gJzIuNy4xNic7XG4vKipcbiAqIEBpbnRlcm5hbCB0eXBlIGlzIG1hbnVhbGx5IGRlY2xhcmVkIGluIDxyb290Pi90eXBlcy92My1kZWZpbmUtY29tcG9uZW50LmQudHNcbiAqL1xuZnVuY3Rpb24gZGVmaW5lQ29tcG9uZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cblxudmFyIHZjYSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICBkZWZpbmVDb21wb25lbnQ6IGRlZmluZUNvbXBvbmVudCxcbiAgcmVmOiByZWYkMSxcbiAgc2hhbGxvd1JlZjogc2hhbGxvd1JlZixcbiAgaXNSZWY6IGlzUmVmLFxuICB0b1JlZjogdG9SZWYsXG4gIHRvUmVmczogdG9SZWZzLFxuICB1bnJlZjogdW5yZWYsXG4gIHByb3h5UmVmczogcHJveHlSZWZzLFxuICBjdXN0b21SZWY6IGN1c3RvbVJlZixcbiAgdHJpZ2dlclJlZjogdHJpZ2dlclJlZixcbiAgcmVhY3RpdmU6IHJlYWN0aXZlLFxuICBpc1JlYWN0aXZlOiBpc1JlYWN0aXZlLFxuICBpc1JlYWRvbmx5OiBpc1JlYWRvbmx5LFxuICBpc1NoYWxsb3c6IGlzU2hhbGxvdyxcbiAgaXNQcm94eTogaXNQcm94eSxcbiAgc2hhbGxvd1JlYWN0aXZlOiBzaGFsbG93UmVhY3RpdmUsXG4gIG1hcmtSYXc6IG1hcmtSYXcsXG4gIHRvUmF3OiB0b1JhdyxcbiAgcmVhZG9ubHk6IHJlYWRvbmx5LFxuICBzaGFsbG93UmVhZG9ubHk6IHNoYWxsb3dSZWFkb25seSxcbiAgY29tcHV0ZWQ6IGNvbXB1dGVkLFxuICB3YXRjaDogd2F0Y2gsXG4gIHdhdGNoRWZmZWN0OiB3YXRjaEVmZmVjdCxcbiAgd2F0Y2hQb3N0RWZmZWN0OiB3YXRjaFBvc3RFZmZlY3QsXG4gIHdhdGNoU3luY0VmZmVjdDogd2F0Y2hTeW5jRWZmZWN0LFxuICBFZmZlY3RTY29wZTogRWZmZWN0U2NvcGUsXG4gIGVmZmVjdFNjb3BlOiBlZmZlY3RTY29wZSxcbiAgb25TY29wZURpc3Bvc2U6IG9uU2NvcGVEaXNwb3NlLFxuICBnZXRDdXJyZW50U2NvcGU6IGdldEN1cnJlbnRTY29wZSxcbiAgcHJvdmlkZTogcHJvdmlkZSxcbiAgaW5qZWN0OiBpbmplY3QsXG4gIGg6IGgsXG4gIGdldEN1cnJlbnRJbnN0YW5jZTogZ2V0Q3VycmVudEluc3RhbmNlLFxuICB1c2VTbG90czogdXNlU2xvdHMsXG4gIHVzZUF0dHJzOiB1c2VBdHRycyxcbiAgdXNlTGlzdGVuZXJzOiB1c2VMaXN0ZW5lcnMsXG4gIG1lcmdlRGVmYXVsdHM6IG1lcmdlRGVmYXVsdHMsXG4gIG5leHRUaWNrOiBuZXh0VGljayxcbiAgc2V0OiBzZXQsXG4gIGRlbDogZGVsLFxuICB1c2VDc3NNb2R1bGU6IHVzZUNzc01vZHVsZSxcbiAgdXNlQ3NzVmFyczogdXNlQ3NzVmFycyxcbiAgZGVmaW5lQXN5bmNDb21wb25lbnQ6IGRlZmluZUFzeW5jQ29tcG9uZW50LFxuICBvbkJlZm9yZU1vdW50OiBvbkJlZm9yZU1vdW50LFxuICBvbk1vdW50ZWQ6IG9uTW91bnRlZCxcbiAgb25CZWZvcmVVcGRhdGU6IG9uQmVmb3JlVXBkYXRlLFxuICBvblVwZGF0ZWQ6IG9uVXBkYXRlZCxcbiAgb25CZWZvcmVVbm1vdW50OiBvbkJlZm9yZVVubW91bnQsXG4gIG9uVW5tb3VudGVkOiBvblVubW91bnRlZCxcbiAgb25BY3RpdmF0ZWQ6IG9uQWN0aXZhdGVkLFxuICBvbkRlYWN0aXZhdGVkOiBvbkRlYWN0aXZhdGVkLFxuICBvblNlcnZlclByZWZldGNoOiBvblNlcnZlclByZWZldGNoLFxuICBvblJlbmRlclRyYWNrZWQ6IG9uUmVuZGVyVHJhY2tlZCxcbiAgb25SZW5kZXJUcmlnZ2VyZWQ6IG9uUmVuZGVyVHJpZ2dlcmVkLFxuICBvbkVycm9yQ2FwdHVyZWQ6IG9uRXJyb3JDYXB0dXJlZFxufSk7XG5cbmNvbnN0IHNlZW5PYmplY3RzID0gbmV3IF9TZXQoKTtcbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSh2YWwpIHtcbiAgICBfdHJhdmVyc2UodmFsLCBzZWVuT2JqZWN0cyk7XG4gICAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gX3RyYXZlcnNlKHZhbCwgc2Vlbikge1xuICAgIGxldCBpLCBrZXlzO1xuICAgIGNvbnN0IGlzQSA9IGlzQXJyYXkodmFsKTtcbiAgICBpZiAoKCFpc0EgJiYgIWlzT2JqZWN0KHZhbCkpIHx8XG4gICAgICAgIHZhbC5fX3Zfc2tpcCAvKiBSZWFjdGl2ZUZsYWdzLlNLSVAgKi8gfHxcbiAgICAgICAgT2JqZWN0LmlzRnJvemVuKHZhbCkgfHxcbiAgICAgICAgdmFsIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsLl9fb2JfXykge1xuICAgICAgICBjb25zdCBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgICAgICBpZiAoc2Vlbi5oYXMoZGVwSWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5hZGQoZGVwSWQpO1xuICAgIH1cbiAgICBpZiAoaXNBKSB7XG4gICAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVmKHZhbCkpIHtcbiAgICAgICAgX3RyYXZlcnNlKHZhbC52YWx1ZSwgc2Vlbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgaSA9IGtleXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7XG4gICAgfVxufVxuXG5sZXQgdWlkJDEgPSAwO1xuLyoqXG4gKiBBIHdhdGNoZXIgcGFyc2VzIGFuIGV4cHJlc3Npb24sIGNvbGxlY3RzIGRlcGVuZGVuY2llcyxcbiAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGJvdGggdGhlICR3YXRjaCgpIGFwaSBhbmQgZGlyZWN0aXZlcy5cbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBXYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMsIGlzUmVuZGVyV2F0Y2hlcikge1xuICAgICAgICByZWNvcmRFZmZlY3RTY29wZSh0aGlzLCBcbiAgICAgICAgLy8gaWYgdGhlIGFjdGl2ZSBlZmZlY3Qgc2NvcGUgaXMgbWFudWFsbHkgY3JlYXRlZCAobm90IGEgY29tcG9uZW50IHNjb3BlKSxcbiAgICAgICAgLy8gcHJpb3JpdGl6ZSBpdFxuICAgICAgICBhY3RpdmVFZmZlY3RTY29wZSAmJiAhYWN0aXZlRWZmZWN0U2NvcGUuX3ZtXG4gICAgICAgICAgICA/IGFjdGl2ZUVmZmVjdFNjb3BlXG4gICAgICAgICAgICA6IHZtXG4gICAgICAgICAgICAgICAgPyB2bS5fc2NvcGVcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgodGhpcy52bSA9IHZtKSAmJiBpc1JlbmRlcldhdGNoZXIpIHtcbiAgICAgICAgICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmRlZXAgPSAhIW9wdGlvbnMuZGVlcDtcbiAgICAgICAgICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgICAgICAgICAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gICAgICAgICAgICB0aGlzLnN5bmMgPSAhIW9wdGlvbnMuc3luYztcbiAgICAgICAgICAgIHRoaXMuYmVmb3JlID0gb3B0aW9ucy5iZWZvcmU7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYWNrID0gb3B0aW9ucy5vblRyYWNrO1xuICAgICAgICAgICAgICAgIHRoaXMub25UcmlnZ2VyID0gb3B0aW9ucy5vblRyaWdnZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNiID0gY2I7XG4gICAgICAgIHRoaXMuaWQgPSArK3VpZCQxOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3N0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gICAgICAgIHRoaXMuZGVwcyA9IFtdO1xuICAgICAgICB0aGlzLm5ld0RlcHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgICAgICB0aGlzLm5ld0RlcElkcyA9IG5ldyBfU2V0KCk7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cE9yRm4udG9TdHJpbmcoKSA7XG4gICAgICAgIC8vIHBhcnNlIGV4cHJlc3Npb24gZm9yIGdldHRlclxuICAgICAgICBpZiAoaXNGdW5jdGlvbihleHBPckZuKSkge1xuICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBwYXJzZVBhdGgoZXhwT3JGbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXR0ZXIgPSBub29wO1xuICAgICAgICAgICAgICAgIHdhcm4kMihgRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFwiJHtleHBPckZufVwiIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdGb3IgZnVsbCBjb250cm9sLCB1c2UgYSBmdW5jdGlvbiBpbnN0ZWFkLicsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5sYXp5ID8gdW5kZWZpbmVkIDogdGhpcy5nZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdGhlIGdldHRlciwgYW5kIHJlLWNvbGxlY3QgZGVwZW5kZW5jaWVzLlxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgcHVzaFRhcmdldCh0aGlzKTtcbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBjb25zdCB2bSA9IHRoaXMudm07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBgZ2V0dGVyIGZvciB3YXRjaGVyIFwiJHt0aGlzLmV4cHJlc3Npb259XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAvLyBcInRvdWNoXCIgZXZlcnkgcHJvcGVydHkgc28gdGhleSBhcmUgYWxsIHRyYWNrZWQgYXNcbiAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVlcCkge1xuICAgICAgICAgICAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcFRhcmdldCgpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBhZGREZXAoZGVwKSB7XG4gICAgICAgIGNvbnN0IGlkID0gZGVwLmlkO1xuICAgICAgICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgICAgICAgICB0aGlzLm5ld0RlcHMucHVzaChkZXApO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgZGVwLmFkZFN1Yih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIGNsZWFudXBEZXBzKCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcCA9IHRoaXMuZGVwc1tpXTtcbiAgICAgICAgICAgIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgICAgICAgICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0bXAgPSB0aGlzLmRlcElkcztcbiAgICAgICAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgICAgICAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gICAgICAgIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gICAgICAgIHRtcCA9IHRoaXMuZGVwcztcbiAgICAgICAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICAgICAgICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gICAgICAgIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAgICAgKiBXaWxsIGJlIGNhbGxlZCB3aGVuIGEgZGVwZW5kZW5jeSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zeW5jKSB7XG4gICAgICAgICAgICB0aGlzLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICAgICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAgICovXG4gICAgcnVuKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgICAgICAgICAgIC8vIERlZXAgd2F0Y2hlcnMgYW5kIHdhdGNoZXJzIG9uIE9iamVjdC9BcnJheXMgc2hvdWxkIGZpcmUgZXZlblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgICAgICAgICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5kZWVwKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gYGNhbGxiYWNrIGZvciB3YXRjaGVyIFwiJHt0aGlzLmV4cHJlc3Npb259XCJgO1xuICAgICAgICAgICAgICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyh0aGlzLmNiLCB0aGlzLnZtLCBbdmFsdWUsIG9sZFZhbHVlXSwgdGhpcy52bSwgaW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICAgICAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAgICAgKi9cbiAgICBldmFsdWF0ZSgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwZW5kIG9uIGFsbCBkZXBzIGNvbGxlY3RlZCBieSB0aGlzIHdhdGNoZXIuXG4gICAgICovXG4gICAgZGVwZW5kKCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRoaXMuZGVwc1tpXS5kZXBlbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgc2VsZiBmcm9tIGFsbCBkZXBlbmRlbmNpZXMnIHN1YnNjcmliZXIgbGlzdC5cbiAgICAgKi9cbiAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgaWYgKHRoaXMudm0gJiYgIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJlbW92ZSQyKHRoaXMudm0uX3Njb3BlLmVmZmVjdHMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLmRlcHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMub25TdG9wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3Qgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogbm9vcCxcbiAgICBzZXQ6IG5vb3Bcbn07XG5mdW5jdGlvbiBwcm94eSh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tzb3VyY2VLZXldW2tleV07XG4gICAgfTtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIodmFsKSB7XG4gICAgICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuZnVuY3Rpb24gaW5pdFN0YXRlKHZtKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZtLiRvcHRpb25zO1xuICAgIGlmIChvcHRzLnByb3BzKVxuICAgICAgICBpbml0UHJvcHMkMSh2bSwgb3B0cy5wcm9wcyk7XG4gICAgLy8gQ29tcG9zaXRpb24gQVBJXG4gICAgaW5pdFNldHVwKHZtKTtcbiAgICBpZiAob3B0cy5tZXRob2RzKVxuICAgICAgICBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTtcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICAgIGluaXREYXRhKHZtKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9iID0gb2JzZXJ2ZSgodm0uX2RhdGEgPSB7fSkpO1xuICAgICAgICBvYiAmJiBvYi52bUNvdW50Kys7XG4gICAgfVxuICAgIGlmIChvcHRzLmNvbXB1dGVkKVxuICAgICAgICBpbml0Q29tcHV0ZWQkMSh2bSwgb3B0cy5jb21wdXRlZCk7XG4gICAgaWYgKG9wdHMud2F0Y2ggJiYgb3B0cy53YXRjaCAhPT0gbmF0aXZlV2F0Y2gpIHtcbiAgICAgICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0UHJvcHMkMSh2bSwgcHJvcHNPcHRpb25zKSB7XG4gICAgY29uc3QgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICAgIGNvbnN0IHByb3BzID0gKHZtLl9wcm9wcyA9IHNoYWxsb3dSZWFjdGl2ZSh7fSkpO1xuICAgIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gICAgLy8gaW5zdGVhZCBvZiBkeW5hbWljIG9iamVjdCBrZXkgZW51bWVyYXRpb24uXG4gICAgY29uc3Qga2V5cyA9ICh2bS4kb3B0aW9ucy5fcHJvcEtleXMgPSBbXSk7XG4gICAgY29uc3QgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gICAgLy8gcm9vdCBpbnN0YW5jZSBwcm9wcyBzaG91bGQgYmUgY29udmVydGVkXG4gICAgaWYgKCFpc1Jvb3QpIHtcbiAgICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHNPcHRpb25zKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BzT3B0aW9ucywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGh5cGhlbmF0ZWRLZXkgPSBoeXBoZW5hdGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgICAgICAgY29uZmlnLmlzUmVzZXJ2ZWRBdHRyKGh5cGhlbmF0ZWRLZXkpKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBcIiR7aHlwaGVuYXRlZEtleX1cIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuYCwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUm9vdCAmJiAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm4kMihgQXZvaWQgbXV0YXRpbmcgYSBwcm9wIGRpcmVjdGx5IHNpbmNlIHRoZSB2YWx1ZSB3aWxsIGJlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYG92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYEluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB2YWx1ZS4gUHJvcCBiZWluZyBtdXRhdGVkOiBcIiR7a2V5fVwiYCwgdm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRydWUgLyogc2hhbGxvdyAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgICAgICAvLyBkdXJpbmcgVnVlLmV4dGVuZCgpLiBXZSBvbmx5IG5lZWQgdG8gcHJveHkgcHJvcHMgZGVmaW5lZCBhdFxuICAgICAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgICAgIHByb3h5KHZtLCBgX3Byb3BzYCwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG59XG5mdW5jdGlvbiBpbml0RGF0YSh2bSkge1xuICAgIGxldCBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgICBkYXRhID0gdm0uX2RhdGEgPSBpc0Z1bmN0aW9uKGRhdGEpID8gZ2V0RGF0YShkYXRhLCB2bSkgOiBkYXRhIHx8IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICAgIHdhcm4kMignZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAgICAgICAgICAgJ2h0dHBzOi8vdjIudnVlanMub3JnL3YyL2d1aWRlL2NvbXBvbmVudHMuaHRtbCNkYXRhLU11c3QtQmUtYS1GdW5jdGlvbicsIHZtKTtcbiAgICB9XG4gICAgLy8gcHJveHkgZGF0YSBvbiBpbnN0YW5jZVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICBjb25zdCBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIGNvbnN0IG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICAgIGxldCBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMihgTWV0aG9kIFwiJHtrZXl9XCIgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIGFzIGEgZGF0YSBwcm9wZXJ0eS5gLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICAgICAgd2FybiQyKGBUaGUgZGF0YSBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVjbGFyZWQgYXMgYSBwcm9wLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5gLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgICAgICAgcHJveHkodm0sIGBfZGF0YWAsIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb2JzZXJ2ZSBkYXRhXG4gICAgY29uc3Qgb2IgPSBvYnNlcnZlKGRhdGEpO1xuICAgIG9iICYmIG9iLnZtQ291bnQrKztcbn1cbmZ1bmN0aW9uIGdldERhdGEoZGF0YSwgdm0pIHtcbiAgICAvLyAjNzU3MyBkaXNhYmxlIGRlcCBjb2xsZWN0aW9uIHdoZW4gaW52b2tpbmcgZGF0YSBnZXR0ZXJzXG4gICAgcHVzaFRhcmdldCgpO1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkYXRhLmNhbGwodm0sIHZtKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIGBkYXRhKClgKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgfVxufVxuY29uc3QgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEodm0sIGNvbXB1dGVkKSB7XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgY29uc3Qgd2F0Y2hlcnMgPSAodm0uX2NvbXB1dGVkV2F0Y2hlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAvLyBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBqdXN0IGdldHRlcnMgZHVyaW5nIFNTUlxuICAgIGNvbnN0IGlzU1NSID0gaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb21wdXRlZCkge1xuICAgICAgICBjb25zdCB1c2VyRGVmID0gY29tcHV0ZWRba2V5XTtcbiAgICAgICAgY29uc3QgZ2V0dGVyID0gaXNGdW5jdGlvbih1c2VyRGVmKSA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICAgICAgaWYgKGdldHRlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB3YXJuJDIoYEdldHRlciBpcyBtaXNzaW5nIGZvciBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiLmAsIHZtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgaW50ZXJuYWwgd2F0Y2hlciBmb3IgdGhlIGNvbXB1dGVkIHByb3BlcnR5LlxuICAgICAgICAgICAgd2F0Y2hlcnNba2V5XSA9IG5ldyBXYXRjaGVyKHZtLCBnZXR0ZXIgfHwgbm9vcCwgbm9vcCwgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgICAgICAvLyBjb21wb25lbnQgcHJvdG90eXBlLiBXZSBvbmx5IG5lZWQgdG8gZGVmaW5lIGNvbXB1dGVkIHByb3BlcnRpZXMgZGVmaW5lZFxuICAgICAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgICAgIGRlZmluZUNvbXB1dGVkKHZtLCBrZXksIHVzZXJEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGtleSBpbiB2bS4kZGF0YSkge1xuICAgICAgICAgICAgICAgIHdhcm4kMihgVGhlIGNvbXB1dGVkIHByb3BlcnR5IFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGluIGRhdGEuYCwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBUaGUgY29tcHV0ZWQgcHJvcGVydHkgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLmAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZtLiRvcHRpb25zLm1ldGhvZHMgJiYga2V5IGluIHZtLiRvcHRpb25zLm1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYFRoZSBjb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGlzIGFscmVhZHkgZGVmaW5lZCBhcyBhIG1ldGhvZC5gLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCh0YXJnZXQsIGtleSwgdXNlckRlZikge1xuICAgIGNvbnN0IHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gICAgaWYgKGlzRnVuY3Rpb24odXNlckRlZikpIHtcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHNob3VsZENhY2hlXG4gICAgICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgICAgIDogY3JlYXRlR2V0dGVySW52b2tlcih1c2VyRGVmKTtcbiAgICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gdXNlckRlZi5nZXRcbiAgICAgICAgICAgID8gc2hvdWxkQ2FjaGUgJiYgdXNlckRlZi5jYWNoZSAhPT0gZmFsc2VcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZUdldHRlckludm9rZXIodXNlckRlZi5nZXQpXG4gICAgICAgICAgICA6IG5vb3A7XG4gICAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSB1c2VyRGVmLnNldCB8fCBub29wO1xuICAgIH1cbiAgICBpZiAoc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9PT0gbm9vcCkge1xuICAgICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgd2FybiQyKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5gLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyKCkge1xuICAgICAgICBjb25zdCB3YXRjaGVyID0gdGhpcy5fY29tcHV0ZWRXYXRjaGVycyAmJiB0aGlzLl9jb21wdXRlZFdhdGNoZXJzW2tleV07XG4gICAgICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICAgICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICAgICAgICAgIHdhdGNoZXIuZXZhbHVhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKERlcC50YXJnZXQub25UcmFjaykge1xuICAgICAgICAgICAgICAgICAgICBEZXAudGFyZ2V0Lm9uVHJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0OiBEZXAudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJnZXRcIiAvKiBUcmFja09wVHlwZXMuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlcigpIHtcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgdGhpcyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluaXRNZXRob2RzKHZtLCBtZXRob2RzKSB7XG4gICAgY29uc3QgcHJvcHMgPSB2bS4kb3B0aW9ucy5wcm9wcztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXRob2RzKSB7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBNZXRob2QgXCIke2tleX1cIiBoYXMgdHlwZSBcIiR7dHlwZW9mIG1ldGhvZHNba2V5XX1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIGAgK1xuICAgICAgICAgICAgICAgICAgICBgRGlkIHlvdSByZWZlcmVuY2UgdGhlIGZ1bmN0aW9uIGNvcnJlY3RseT9gLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBNZXRob2QgXCIke2tleX1cIiBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgYXMgYSBwcm9wLmAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkgaW4gdm0gJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgd2FybiQyKGBNZXRob2QgXCIke2tleX1cIiBjb25mbGljdHMgd2l0aCBhbiBleGlzdGluZyBWdWUgaW5zdGFuY2UgbWV0aG9kLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYEF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdm1ba2V5XSA9IHR5cGVvZiBtZXRob2RzW2tleV0gIT09ICdmdW5jdGlvbicgPyBub29wIDogYmluZCQxKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRXYXRjaCh2bSwgd2F0Y2gpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB3YXRjaCkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICAgICAgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlcih2bSwgZXhwT3JGbiwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgICB9XG4gICAgcmV0dXJuIHZtLiR3YXRjaChleHBPckZuLCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHN0YXRlTWl4aW4oVnVlKSB7XG4gICAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gICAgLy8gd2hlbiB1c2luZyBPYmplY3QuZGVmaW5lUHJvcGVydHksIHNvIHdlIGhhdmUgdG8gcHJvY2VkdXJhbGx5IGJ1aWxkIHVwXG4gICAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICAgIGNvbnN0IGRhdGFEZWYgPSB7fTtcbiAgICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgfTtcbiAgICBjb25zdCBwcm9wc0RlZiA9IHt9O1xuICAgIHByb3BzRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICAgIH07XG4gICAge1xuICAgICAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4kMignQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAgICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsIHRoaXMpO1xuICAgICAgICB9O1xuICAgICAgICBwcm9wc0RlZi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB3YXJuJDIoYCRwcm9wcyBpcyByZWFkb25seS5gLCB0aGlzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckZGF0YScsIGRhdGFEZWYpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuICAgIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG4gICAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoZXhwT3JGbiwgY2IsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIG9wdGlvbnMudXNlciA9IHRydWU7XG4gICAgICAgIGNvbnN0IHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBgY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFwiJHt3YXRjaGVyLmV4cHJlc3Npb259XCJgO1xuICAgICAgICAgICAgcHVzaFRhcmdldCgpO1xuICAgICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2IsIHZtLCBbd2F0Y2hlci52YWx1ZV0sIHZtLCBpbmZvKTtcbiAgICAgICAgICAgIHBvcFRhcmdldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB1bndhdGNoRm4oKSB7XG4gICAgICAgICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdFByb3ZpZGUodm0pIHtcbiAgICBjb25zdCBwcm92aWRlT3B0aW9uID0gdm0uJG9wdGlvbnMucHJvdmlkZTtcbiAgICBpZiAocHJvdmlkZU9wdGlvbikge1xuICAgICAgICBjb25zdCBwcm92aWRlZCA9IGlzRnVuY3Rpb24ocHJvdmlkZU9wdGlvbilcbiAgICAgICAgICAgID8gcHJvdmlkZU9wdGlvbi5jYWxsKHZtKVxuICAgICAgICAgICAgOiBwcm92aWRlT3B0aW9uO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3ZpZGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHJlc29sdmVQcm92aWRlZCh2bSk7XG4gICAgICAgIC8vIElFOSBkb2Vzbid0IHN1cHBvcnQgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgc28gd2UgaGF2ZSB0b1xuICAgICAgICAvLyBpdGVyYXRlIHRoZSBrZXlzIG91cnNlbHZlcy5cbiAgICAgICAgY29uc3Qga2V5cyA9IGhhc1N5bWJvbCA/IFJlZmxlY3Qub3duS2V5cyhwcm92aWRlZCkgOiBPYmplY3Qua2V5cyhwcm92aWRlZCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzb3VyY2UsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm92aWRlZCwga2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyh2bSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcoZmFsc2UpO1xuICAgICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0sICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKGBBdm9pZCBtdXRhdGluZyBhbiBpbmplY3RlZCB2YWx1ZSBkaXJlY3RseSBzaW5jZSB0aGUgY2hhbmdlcyB3aWxsIGJlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYG92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFwiJHtrZXl9XCJgLCB2bSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdChpbmplY3QsIHZtKSB7XG4gICAgaWYgKGluamVjdCkge1xuICAgICAgICAvLyBpbmplY3QgaXMgOmFueSBiZWNhdXNlIGZsb3cgaXMgbm90IHNtYXJ0IGVub3VnaCB0byBmaWd1cmUgb3V0IGNhY2hlZFxuICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCBrZXlzID0gaGFzU3ltYm9sID8gUmVmbGVjdC5vd25LZXlzKGluamVjdCkgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAvLyAjNjU3NCBpbiBjYXNlIHRoZSBpbmplY3Qgb2JqZWN0IGlzIG9ic2VydmVkLi4uXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnX19vYl9fJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgICAgICAgaWYgKHByb3ZpZGVLZXkgaW4gdm0uX3Byb3ZpZGVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2bS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm92aWRlRGVmYXVsdCA9IGluamVjdFtrZXldLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBpc0Z1bmN0aW9uKHByb3ZpZGVEZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICAgICAgICAgIDogcHJvdmlkZURlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuJDIoYEluamVjdGlvbiBcIiR7a2V5fVwiIG5vdCBmb3VuZGAsIHZtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxubGV0IHVpZCA9IDA7XG5mdW5jdGlvbiBpbml0TWl4aW4kMShWdWUpIHtcbiAgICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgdm0gPSB0aGlzO1xuICAgICAgICAvLyBhIHVpZFxuICAgICAgICB2bS5fdWlkID0gdWlkKys7XG4gICAgICAgIGxldCBzdGFydFRhZywgZW5kVGFnO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgICAgICBzdGFydFRhZyA9IGB2dWUtcGVyZi1zdGFydDoke3ZtLl91aWR9YDtcbiAgICAgICAgICAgIGVuZFRhZyA9IGB2dWUtcGVyZi1lbmQ6JHt2bS5fdWlkfWA7XG4gICAgICAgICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhIGZsYWcgdG8gbWFyayB0aGlzIGFzIGEgVnVlIGluc3RhbmNlIHdpdGhvdXQgaGF2aW5nIHRvIGRvIGluc3RhbmNlb2ZcbiAgICAgICAgLy8gY2hlY2tcbiAgICAgICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAgICAgLy8gYXZvaWQgaW5zdGFuY2VzIGZyb20gYmVpbmcgb2JzZXJ2ZWRcbiAgICAgICAgdm0uX192X3NraXAgPSB0cnVlO1xuICAgICAgICAvLyBlZmZlY3Qgc2NvcGVcbiAgICAgICAgdm0uX3Njb3BlID0gbmV3IEVmZmVjdFNjb3BlKHRydWUgLyogZGV0YWNoZWQgKi8pO1xuICAgICAgICAvLyAjMTMxMzQgZWRnZSBjYXNlIHdoZXJlIGEgY2hpbGQgY29tcG9uZW50IGlzIG1hbnVhbGx5IGNyZWF0ZWQgZHVyaW5nIHRoZVxuICAgICAgICAvLyByZW5kZXIgb2YgYSBwYXJlbnQgY29tcG9uZW50XG4gICAgICAgIHZtLl9zY29wZS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZtLl9zY29wZS5fdm0gPSB0cnVlO1xuICAgICAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm0uJG9wdGlvbnMgPSBtZXJnZU9wdGlvbnMocmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksIG9wdGlvbnMgfHwge30sIHZtKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBpbml0UHJveHkodm0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4cG9zZSByZWFsIHNlbGZcbiAgICAgICAgdm0uX3NlbGYgPSB2bTtcbiAgICAgICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgICAgIGluaXRFdmVudHModm0pO1xuICAgICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2JlZm9yZUNyZWF0ZScsIHVuZGVmaW5lZCwgZmFsc2UgLyogc2V0Q29udGV4dCAqLyk7XG4gICAgICAgIGluaXRJbmplY3Rpb25zKHZtKTsgLy8gcmVzb2x2ZSBpbmplY3Rpb25zIGJlZm9yZSBkYXRhL3Byb3BzXG4gICAgICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICAgICAgY2FsbEhvb2skMSh2bSwgJ2NyZWF0ZWQnKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgICAgdm0uX25hbWUgPSBmb3JtYXRDb21wb25lbnROYW1lKHZtLCBmYWxzZSk7XG4gICAgICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgICAgICBtZWFzdXJlKGB2dWUgJHt2bS5fbmFtZX0gaW5pdGAsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5lbCkge1xuICAgICAgICAgICAgdm0uJG1vdW50KHZtLiRvcHRpb25zLmVsKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRzID0gKHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKSk7XG4gICAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgICBjb25zdCBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICBjb25zdCB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICAgIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG4gICAgaWYgKG9wdGlvbnMucmVuZGVyKSB7XG4gICAgICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICAgICAgY29uc3Qgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICAgICAgY29uc3QgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgICAgIGlmIChzdXBlck9wdGlvbnMgIT09IGNhY2hlZFN1cGVyT3B0aW9ucykge1xuICAgICAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHJlc29sdmUgbmV3IG9wdGlvbnMuXG4gICAgICAgICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAgICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGV4dGVuZChDdG9yLmV4dGVuZE9wdGlvbnMsIG1vZGlmaWVkT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zID0gQ3Rvci5vcHRpb25zID0gbWVyZ2VPcHRpb25zKHN1cGVyT3B0aW9ucywgQ3Rvci5leHRlbmRPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zKEN0b3IpIHtcbiAgICBsZXQgbW9kaWZpZWQ7XG4gICAgY29uc3QgbGF0ZXN0ID0gQ3Rvci5vcHRpb25zO1xuICAgIGNvbnN0IHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsYXRlc3QpIHtcbiAgICAgICAgaWYgKGxhdGVzdFtrZXldICE9PSBzZWFsZWRba2V5XSkge1xuICAgICAgICAgICAgaWYgKCFtb2RpZmllZClcbiAgICAgICAgICAgICAgICBtb2RpZmllZCA9IHt9O1xuICAgICAgICAgICAgbW9kaWZpZWRba2V5XSA9IGxhdGVzdFtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZDtcbn1cblxuZnVuY3Rpb24gRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoZGF0YSwgcHJvcHMsIGNoaWxkcmVuLCBwYXJlbnQsIEN0b3IpIHtcbiAgICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIC8vIGVuc3VyZSB0aGUgY3JlYXRlRWxlbWVudCBmdW5jdGlvbiBpbiBmdW5jdGlvbmFsIGNvbXBvbmVudHNcbiAgICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gICAgbGV0IGNvbnRleHRWbTtcbiAgICBpZiAoaGFzT3duKHBhcmVudCwgJ191aWQnKSkge1xuICAgICAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGV4dCB2bSBwYXNzZWQgaW4gaXMgYSBmdW5jdGlvbmFsIGNvbnRleHQgYXMgd2VsbC5cbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgICAgIC8vIHJlYWwgY29udGV4dCBpbnN0YW5jZS5cbiAgICAgICAgY29udGV4dFZtID0gcGFyZW50O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gICAgfVxuICAgIGNvbnN0IGlzQ29tcGlsZWQgPSBpc1RydWUob3B0aW9ucy5fY29tcGlsZWQpO1xuICAgIGNvbnN0IG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMubGlzdGVuZXJzID0gZGF0YS5vbiB8fCBlbXB0eU9iamVjdDtcbiAgICB0aGlzLmluamVjdGlvbnMgPSByZXNvbHZlSW5qZWN0KG9wdGlvbnMuaW5qZWN0LCBwYXJlbnQpO1xuICAgIHRoaXMuc2xvdHMgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy4kc2xvdHMpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgKHRoaXMuJHNsb3RzID0gcmVzb2x2ZVNsb3RzKGNoaWxkcmVuLCBwYXJlbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuJHNsb3RzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKHBhcmVudCwgZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgICBpZiAoaXNDb21waWxlZCkge1xuICAgICAgICAvLyBleHBvc2luZyAkb3B0aW9ucyBmb3IgcmVuZGVyU3RhdGljKClcbiAgICAgICAgdGhpcy4kb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICAgICAgdGhpcy4kc2xvdHMgPSB0aGlzLnNsb3RzKCk7XG4gICAgICAgIHRoaXMuJHNjb3BlZFNsb3RzID0gbm9ybWFsaXplU2NvcGVkU2xvdHMocGFyZW50LCBkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLl9zY29wZUlkKSB7XG4gICAgICAgIHRoaXMuX2MgPSAoYSwgYiwgYywgZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBjcmVhdGVFbGVtZW50JDEoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7XG4gICAgICAgICAgICBpZiAodm5vZGUgJiYgIWlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdm5vZGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9jID0gKGEsIGIsIGMsIGQpID0+IGNyZWF0ZUVsZW1lbnQkMShjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICB9XG59XG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHRWbSwgY2hpbGRyZW4pIHtcbiAgICBjb25zdCBvcHRpb25zID0gQ3Rvci5vcHRpb25zO1xuICAgIGNvbnN0IHByb3BzID0ge307XG4gICAgY29uc3QgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wT3B0aW9ucywgcHJvcHNEYXRhIHx8IGVtcHR5T2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEuYXR0cnMpKVxuICAgICAgICAgICAgbWVyZ2VQcm9wcyhwcm9wcywgZGF0YS5hdHRycyk7XG4gICAgICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSlcbiAgICAgICAgICAgIG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJDb250ZXh0ID0gbmV3IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0KGRhdGEsIHByb3BzLCBjaGlsZHJlbiwgY29udGV4dFZtLCBDdG9yKTtcbiAgICBjb25zdCB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG4gICAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQodm5vZGUsIGRhdGEsIHJlbmRlckNvbnRleHQucGFyZW50LCBvcHRpb25zLCByZW5kZXJDb250ZXh0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgICAgY29uc3Qgdm5vZGVzID0gbm9ybWFsaXplQ2hpbGRyZW4odm5vZGUpIHx8IFtdO1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgY29udGV4dFZtLCBvcHRpb25zLCByZW5kZXJDb250ZXh0KSB7XG4gICAgLy8gIzc4MTcgY2xvbmUgbm9kZSBiZWZvcmUgc2V0dGluZyBmbkNvbnRleHQsIG90aGVyd2lzZSBpZiB0aGUgbm9kZSBpcyByZXVzZWRcbiAgICAvLyAoZS5nLiBpdCB3YXMgZnJvbSBhIGNhY2hlZCBub3JtYWwgc2xvdCkgdGhlIGZuQ29udGV4dCBjYXVzZXMgbmFtZWQgc2xvdHNcbiAgICAvLyB0aGF0IHNob3VsZCBub3QgYmUgbWF0Y2hlZCB0byBtYXRjaC5cbiAgICBjb25zdCBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHtcbiAgICAgICAgKGNsb25lLmRldnRvb2xzTWV0YSA9IGNsb25lLmRldnRvb2xzTWV0YSB8fCB7fSkucmVuZGVyQ29udGV4dCA9XG4gICAgICAgICAgICByZW5kZXJDb250ZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAgIChjbG9uZS5kYXRhIHx8IChjbG9uZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKHRvLCBmcm9tKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnJvbSkge1xuICAgICAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fX25hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xufVxuLy8gaW5saW5lIGhvb2tzIHRvIGJlIGludm9rZWQgb24gY29tcG9uZW50IFZOb2RlcyBkdXJpbmcgcGF0Y2hcbmNvbnN0IGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gICAgaW5pdCh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJlxuICAgICAgICAgICAgIXZub2RlLmNvbXBvbmVudEluc3RhbmNlLl9pc0Rlc3Ryb3llZCAmJlxuICAgICAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgICAgICAgY29uc3QgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgICAgICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKHZub2RlLCBhY3RpdmVJbnN0YW5jZSkpO1xuICAgICAgICAgICAgY2hpbGQuJG1vdW50KGh5ZHJhdGluZyA/IHZub2RlLmVsbSA6IHVuZGVmaW5lZCwgaHlkcmF0aW5nKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGF0Y2gob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBjb25zdCBjaGlsZCA9ICh2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlKTtcbiAgICAgICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoY2hpbGQsIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgICB2bm9kZSwgLy8gbmV3IHBhcmVudCB2bm9kZVxuICAgICAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICAgICAgICApO1xuICAgIH0sXG4gICAgaW5zZXJ0KHZub2RlKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgY29tcG9uZW50SW5zdGFuY2UgfSA9IHZub2RlO1xuICAgICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbEhvb2skMShjb21wb25lbnRJbnN0YW5jZSwgJ21vdW50ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgICAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgICAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAgICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3kodm5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBjb21wb25lbnRJbnN0YW5jZSB9ID0gdm5vZGU7XG4gICAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICBpZiAoIXZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpIHtcbiAgICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgICAvLyBwbGFpbiBvcHRpb25zIG9iamVjdDogdHVybiBpdCBpbnRvIGEgY29uc3RydWN0b3JcbiAgICBpZiAoaXNPYmplY3QoQ3RvcikpIHtcbiAgICAgICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgICB9XG4gICAgLy8gaWYgYXQgdGhpcyBzdGFnZSBpdCdzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIGFuIGFzeW5jIGNvbXBvbmVudCBmYWN0b3J5LFxuICAgIC8vIHJlamVjdC5cbiAgICBpZiAodHlwZW9mIEN0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgICAgd2FybiQyKGBJbnZhbGlkIENvbXBvbmVudCBkZWZpbml0aW9uOiAke1N0cmluZyhDdG9yKX1gLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFzeW5jIGNvbXBvbmVudFxuICAgIGxldCBhc3luY0ZhY3Rvcnk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGlmIChpc1VuZGVmKEN0b3IuY2lkKSkge1xuICAgICAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgICAgICBDdG9yID0gcmVzb2x2ZUFzeW5jQ29tcG9uZW50KGFzeW5jRmFjdG9yeSwgYmFzZUN0b3IpO1xuICAgICAgICBpZiAoQ3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gYSBwbGFjZWhvbGRlciBub2RlIGZvciBhc3luYyBjb21wb25lbnQsIHdoaWNoIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgICAgICAgIC8vIHRoZSBpbmZvcm1hdGlvbiB3aWxsIGJlIHVzZWQgZm9yIGFzeW5jIHNlcnZlci1yZW5kZXJpbmcgYW5kIGh5ZHJhdGlvbi5cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyKGFzeW5jRmFjdG9yeSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4sIHRhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAgIC8vIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBjcmVhdGlvblxuICAgIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvcik7XG4gICAgLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGRhdGEgaW50byBwcm9wcyAmIGV2ZW50c1xuICAgIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gICAgfVxuICAgIC8vIGV4dHJhY3QgcHJvcHNcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgcHJvcHNEYXRhID0gZXh0cmFjdFByb3BzRnJvbVZOb2RlRGF0YShkYXRhLCBDdG9yLCB0YWcpO1xuICAgIC8vIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50KEN0b3IsIHByb3BzRGF0YSwgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICAvLyBleHRyYWN0IGxpc3RlbmVycywgc2luY2UgdGhlc2UgbmVlZHMgdG8gYmUgdHJlYXRlZCBhc1xuICAgIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gICAgY29uc3QgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAgIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICAgIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAgICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgICAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuICAgICAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICAgIGNvbnN0IHNsb3QgPSBkYXRhLnNsb3Q7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgaWYgKHNsb3QpIHtcbiAgICAgICAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gICAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuICAgIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKEN0b3Iub3B0aW9ucykgfHwgdGFnO1xuICAgIGNvbnN0IHZub2RlID0gbmV3IFZOb2RlKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBgdnVlLWNvbXBvbmVudC0ke0N0b3IuY2lkfSR7bmFtZSA/IGAtJHtuYW1lfWAgOiAnJ31gLCBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LCBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgeyBDdG9yLCBwcm9wc0RhdGEsIGxpc3RlbmVycywgdGFnLCBjaGlsZHJlbiB9LCBhc3luY0ZhY3RvcnkpO1xuICAgIHJldHVybiB2bm9kZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4vLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbnZub2RlLCBcbi8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxucGFyZW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgX2lzQ29tcG9uZW50OiB0cnVlLFxuICAgICAgICBfcGFyZW50Vm5vZGU6IHZub2RlLFxuICAgICAgICBwYXJlbnRcbiAgICB9O1xuICAgIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gICAgY29uc3QgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICAgIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSBpbmxpbmVUZW1wbGF0ZS5yZW5kZXI7XG4gICAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHZub2RlLmNvbXBvbmVudE9wdGlvbnMuQ3RvcihvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGluc3RhbGxDb21wb25lbnRIb29rcyhkYXRhKSB7XG4gICAgY29uc3QgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gaG9va3Nba2V5XTtcbiAgICAgICAgY29uc3QgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoZXhpc3RpbmcgIT09IHRvTWVyZ2UgJiYgIShleGlzdGluZyAmJiBleGlzdGluZy5fbWVyZ2VkKSkge1xuICAgICAgICAgICAgaG9va3Nba2V5XSA9IGV4aXN0aW5nID8gbWVyZ2VIb29rKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZUhvb2soZjEsIGYyKSB7XG4gICAgY29uc3QgbWVyZ2VkID0gKGEsIGIpID0+IHtcbiAgICAgICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgICAgICBmMShhLCBiKTtcbiAgICAgICAgZjIoYSwgYik7XG4gICAgfTtcbiAgICBtZXJnZWQuX21lcmdlZCA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbi8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBpbmZvICh2YWx1ZSBhbmQgY2FsbGJhY2spIGludG9cbi8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuZnVuY3Rpb24gdHJhbnNmb3JtTW9kZWwob3B0aW9ucywgZGF0YSkge1xuICAgIGNvbnN0IHByb3AgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLnByb3ApIHx8ICd2YWx1ZSc7XG4gICAgY29uc3QgZXZlbnQgPSAob3B0aW9ucy5tb2RlbCAmJiBvcHRpb25zLm1vZGVsLmV2ZW50KSB8fCAnaW5wdXQnO1xuICAgIChkYXRhLmF0dHJzIHx8IChkYXRhLmF0dHJzID0ge30pKVtwcm9wXSA9IGRhdGEubW9kZWwudmFsdWU7XG4gICAgY29uc3Qgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgIGNvbnN0IGV4aXN0aW5nID0gb25bZXZlbnRdO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gZGF0YS5tb2RlbC5jYWxsYmFjaztcbiAgICBpZiAoaXNEZWYoZXhpc3RpbmcpKSB7XG4gICAgICAgIGlmIChpc0FycmF5KGV4aXN0aW5nKVxuICAgICAgICAgICAgPyBleGlzdGluZy5pbmRleE9mKGNhbGxiYWNrKSA9PT0gLTFcbiAgICAgICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvbltldmVudF0gPSBbY2FsbGJhY2tdLmNvbmNhdChleGlzdGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9uW2V2ZW50XSA9IGNhbGxiYWNrO1xuICAgIH1cbn1cblxubGV0IHdhcm4kMiA9IG5vb3A7XG5sZXQgdGlwID0gbm9vcDtcbmxldCBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG5sZXQgZm9ybWF0Q29tcG9uZW50TmFtZTtcbntcbiAgICBjb25zdCBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuICAgIGNvbnN0IGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gICAgY29uc3QgY2xhc3NpZnkgPSBzdHIgPT4gc3RyLnJlcGxhY2UoY2xhc3NpZnlSRSwgYyA9PiBjLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgJycpO1xuICAgIHdhcm4kMiA9IChtc2csIHZtID0gY3VycmVudEluc3RhbmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRyYWNlID0gdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnO1xuICAgICAgICBpZiAoY29uZmlnLndhcm5IYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzQ29uc29sZSAmJiAhY29uZmlnLnNpbGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgW1Z1ZSB3YXJuXTogJHttc2d9JHt0cmFjZX1gKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGlwID0gKG1zZywgdm0pID0+IHtcbiAgICAgICAgaWYgKGhhc0NvbnNvbGUgJiYgIWNvbmZpZy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1Z1ZSB0aXBdOiAke21zZ31gICsgKHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3JtYXRDb21wb25lbnROYW1lID0gKHZtLCBpbmNsdWRlRmlsZSkgPT4ge1xuICAgICAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICAgICAgICByZXR1cm4gJzxSb290Pic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGlzRnVuY3Rpb24odm0pICYmIHZtLmNpZCAhPSBudWxsXG4gICAgICAgICAgICA/IHZtLm9wdGlvbnNcbiAgICAgICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgICAgICAgICAgOiB2bTtcbiAgICAgICAgbGV0IG5hbWUgPSBnZXRDb21wb25lbnROYW1lKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgICAgIGlmICghbmFtZSAmJiBmaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKG5hbWUgPyBgPCR7Y2xhc3NpZnkobmFtZSl9PmAgOiBgPEFub255bW91cz5gKSArXG4gICAgICAgICAgICAoZmlsZSAmJiBpbmNsdWRlRmlsZSAhPT0gZmFsc2UgPyBgIGF0ICR7ZmlsZX1gIDogJycpKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGVhdCA9IChzdHIsIG4pID0+IHtcbiAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgaWYgKG4gJSAyID09PSAxKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHI7XG4gICAgICAgICAgICBpZiAobiA+IDEpXG4gICAgICAgICAgICAgICAgc3RyICs9IHN0cjtcbiAgICAgICAgICAgIG4gPj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAodm0pID0+IHtcbiAgICAgICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0cmVlID0gW107XG4gICAgICAgICAgICBsZXQgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgIHdoaWxlICh2bSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRyZWVbdHJlZS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QuY29uc3RydWN0b3IgPT09IHZtLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyZWVbdHJlZS5sZW5ndGggLSAxXSA9IFtsYXN0LCBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArXG4gICAgICAgICAgICAgICAgdHJlZVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh2bSwgaSkgPT4gYCR7aSA9PT0gMCA/ICctLS0+ICcgOiByZXBlYXQoJyAnLCA1ICsgaSAqIDIpfSR7aXNBcnJheSh2bSlcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKX0uLi4gKCR7dm1bMV19IHJlY3Vyc2l2ZSBjYWxscylgXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9YClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgXFxuXFxuKGZvdW5kIGluICR7Zm9ybWF0Q29tcG9uZW50TmFtZSh2bSl9KWA7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xuY29uc3Qgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG57XG4gICAgc3RyYXRzLmVsID0gc3RyYXRzLnByb3BzRGF0YSA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkLCB2bSwga2V5KSB7XG4gICAgICAgIGlmICghdm0pIHtcbiAgICAgICAgICAgIHdhcm4kMihgb3B0aW9uIFwiJHtrZXl9XCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgYCArXG4gICAgICAgICAgICAgICAgJ2NyZWF0aW9uIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJhdChwYXJlbnQsIGNoaWxkKTtcbiAgICB9O1xufVxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhKHRvLCBmcm9tLCByZWN1cnNpdmUgPSB0cnVlKSB7XG4gICAgaWYgKCFmcm9tKVxuICAgICAgICByZXR1cm4gdG87XG4gICAgbGV0IGtleSwgdG9WYWwsIGZyb21WYWw7XG4gICAgY29uc3Qga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhmcm9tKVxuICAgICAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBvYnNlcnZlZC4uLlxuICAgICAgICBpZiAoa2V5ID09PSAnX19vYl9fJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0b1ZhbCA9IHRvW2tleV07XG4gICAgICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgICAgIGlmICghcmVjdXJzaXZlIHx8ICFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgICAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgICAgICAgaXNQbGFpbk9iamVjdCh0b1ZhbCkgJiZcbiAgICAgICAgICAgIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgICAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvO1xufVxuLyoqXG4gKiBEYXRhXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRWYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmV0dXJuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAgICAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAgICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgICAgIC8vIGl0IGhhcyB0byBiZSBhIGZ1bmN0aW9uIHRvIHBhc3MgcHJldmlvdXMgbWVyZ2VzLlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpc0Z1bmN0aW9uKGNoaWxkVmFsKSA/IGNoaWxkVmFsLmNhbGwodGhpcywgdGhpcykgOiBjaGlsZFZhbCwgaXNGdW5jdGlvbihwYXJlbnRWYWwpID8gcGFyZW50VmFsLmNhbGwodGhpcywgdGhpcykgOiBwYXJlbnRWYWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuKCkge1xuICAgICAgICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlRGF0YSA9IGlzRnVuY3Rpb24oY2hpbGRWYWwpXG4gICAgICAgICAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdERhdGEgPSBpc0Z1bmN0aW9uKHBhcmVudFZhbClcbiAgICAgICAgICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtLCB2bSlcbiAgICAgICAgICAgICAgICA6IHBhcmVudFZhbDtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKSB7XG4gICAgaWYgKCF2bSkge1xuICAgICAgICBpZiAoY2hpbGRWYWwgJiYgdHlwZW9mIGNoaWxkVmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuJDIoJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICAgICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAnZGVmaW5pdGlvbnMuJywgdm0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudFZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhT3JGbihwYXJlbnRWYWwsIGNoaWxkVmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pO1xufTtcbi8qKlxuICogSG9va3MgYW5kIHByb3BzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUxpZmVjeWNsZUhvb2socGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIGNvbnN0IHJlcyA9IGNoaWxkVmFsXG4gICAgICAgID8gcGFyZW50VmFsXG4gICAgICAgICAgICA/IHBhcmVudFZhbC5jb25jYXQoY2hpbGRWYWwpXG4gICAgICAgICAgICA6IGlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgICAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICAgICAgICAgIDogW2NoaWxkVmFsXVxuICAgICAgICA6IHBhcmVudFZhbDtcbiAgICByZXR1cm4gcmVzID8gZGVkdXBlSG9va3MocmVzKSA6IHJlcztcbn1cbmZ1bmN0aW9uIGRlZHVwZUhvb2tzKGhvb2tzKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVzLmluZGV4T2YoaG9va3NbaV0pID09PSAtMSkge1xuICAgICAgICAgICAgcmVzLnB1c2goaG9va3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5MSUZFQ1lDTEVfSE9PS1MuZm9yRWFjaChob29rID0+IHtcbiAgICBzdHJhdHNbaG9va10gPSBtZXJnZUxpZmVjeWNsZUhvb2s7XG59KTtcbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcbiAgICBjb25zdCByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgICBpZiAoY2hpbGRWYWwpIHtcbiAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgICAgIHJldHVybiBleHRlbmQocmVzLCBjaGlsZFZhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbkFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuLyoqXG4gKiBXYXRjaGVycy5cbiAqXG4gKiBXYXRjaGVycyBoYXNoZXMgc2hvdWxkIG5vdCBvdmVyd3JpdGUgb25lXG4gKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAqL1xuc3RyYXRzLndhdGNoID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtLCBrZXkpIHtcbiAgICAvLyB3b3JrIGFyb3VuZCBGaXJlZm94J3MgT2JqZWN0LnByb3RvdHlwZS53YXRjaC4uLlxuICAgIC8vQHRzLWV4cGVjdC1lcnJvciB3b3JrIGFyb3VuZFxuICAgIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKVxuICAgICAgICBwYXJlbnRWYWwgPSB1bmRlZmluZWQ7XG4gICAgLy9AdHMtZXhwZWN0LWVycm9yIHdvcmsgYXJvdW5kXG4gICAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaClcbiAgICAgICAgY2hpbGRWYWwgPSB1bmRlZmluZWQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZFZhbClcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICAgIHtcbiAgICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgfVxuICAgIGlmICghcGFyZW50VmFsKVxuICAgICAgICByZXR1cm4gY2hpbGRWYWw7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjaGlsZFZhbCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gcmV0W2tleV07XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBbcGFyZW50XTtcbiAgICAgICAgfVxuICAgICAgICByZXRba2V5XSA9IHBhcmVudCA/IHBhcmVudC5jb25jYXQoY2hpbGQpIDogaXNBcnJheShjaGlsZCkgPyBjaGlsZCA6IFtjaGlsZF07XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuLyoqXG4gKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICovXG5zdHJhdHMucHJvcHMgPVxuICAgIHN0cmF0cy5tZXRob2RzID1cbiAgICAgICAgc3RyYXRzLmluamVjdCA9XG4gICAgICAgICAgICBzdHJhdHMuY29tcHV0ZWQgPVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsLCB2bSwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZFZhbCAmJiB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudFZhbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkVmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kKHJldCwgY2hpbGRWYWwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH07XG5zdHJhdHMucHJvdmlkZSA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gICAgaWYgKCFwYXJlbnRWYWwpXG4gICAgICAgIHJldHVybiBjaGlsZFZhbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBtZXJnZURhdGEocmV0LCBpc0Z1bmN0aW9uKHBhcmVudFZhbCkgPyBwYXJlbnRWYWwuY2FsbCh0aGlzKSA6IHBhcmVudFZhbCk7XG4gICAgICAgIGlmIChjaGlsZFZhbCkge1xuICAgICAgICAgICAgbWVyZ2VEYXRhKHJldCwgaXNGdW5jdGlvbihjaGlsZFZhbCkgPyBjaGlsZFZhbC5jYWxsKHRoaXMpIDogY2hpbGRWYWwsIGZhbHNlIC8vIG5vbi1yZWN1cnNpdmVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xufTtcbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xuY29uc3QgZGVmYXVsdFN0cmF0ID0gZnVuY3Rpb24gKHBhcmVudFZhbCwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZCA/IHBhcmVudFZhbCA6IGNoaWxkVmFsO1xufTtcbi8qKlxuICogVmFsaWRhdGUgY29tcG9uZW50IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyhvcHRpb25zKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5jb21wb25lbnRzKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKSB7XG4gICAgaWYgKCFuZXcgUmVnRXhwKGBeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV8ke3VuaWNvZGVSZWdFeHAuc291cmNlfV0qJGApLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybiQyKCdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgK1xuICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJyk7XG4gICAgfVxuICAgIGlmIChpc0J1aWx0SW5UYWcobmFtZSkgfHwgY29uZmlnLmlzUmVzZXJ2ZWRUYWcobmFtZSkpIHtcbiAgICAgICAgd2FybiQyKCdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgJ2lkOiAnICtcbiAgICAgICAgICAgIG5hbWUpO1xuICAgIH1cbn1cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyhvcHRpb25zLCB2bSkge1xuICAgIGNvbnN0IHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgbGV0IGksIHZhbCwgbmFtZTtcbiAgICBpZiAoaXNBcnJheShwcm9wcykpIHtcbiAgICAgICAgaSA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gY2FtZWxpemUodmFsKTtcbiAgICAgICAgICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdhcm4kMigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbCkgPyB2YWwgOiB7IHR5cGU6IHZhbCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuJDIoYEludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcInByb3BzXCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZShwcm9wcyl9LmAsIHZtKTtcbiAgICB9XG4gICAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbn1cbi8qKlxuICogTm9ybWFsaXplIGFsbCBpbmplY3Rpb25zIGludG8gT2JqZWN0LWJhc2VkIGZvcm1hdFxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJbmplY3Qob3B0aW9ucywgdm0pIHtcbiAgICBjb25zdCBpbmplY3QgPSBvcHRpb25zLmluamVjdDtcbiAgICBpZiAoIWluamVjdClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSAob3B0aW9ucy5pbmplY3QgPSB7fSk7XG4gICAgaWYgKGlzQXJyYXkoaW5qZWN0KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbm9ybWFsaXplZFtpbmplY3RbaV1dID0geyBmcm9tOiBpbmplY3RbaV0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBpbmplY3Rba2V5XTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRba2V5XSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICAgICAgICAgID8gZXh0ZW5kKHsgZnJvbToga2V5IH0sIHZhbClcbiAgICAgICAgICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhcm4kMihgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwiaW5qZWN0XCI6IGV4cGVjdGVkIGFuIEFycmF5IG9yIGFuIE9iamVjdCwgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCAke3RvUmF3VHlwZShpbmplY3QpfS5gLCB2bSk7XG4gICAgfVxufVxuLyoqXG4gKiBOb3JtYWxpemUgcmF3IGZ1bmN0aW9uIGRpcmVjdGl2ZXMgaW50byBvYmplY3QgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEob3B0aW9ucykge1xuICAgIGNvbnN0IGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGlycykge1xuICAgICAgICAgICAgY29uc3QgZGVmID0gZGlyc1trZXldO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oZGVmKSkge1xuICAgICAgICAgICAgICAgIGRpcnNba2V5XSA9IHsgYmluZDogZGVmLCB1cGRhdGU6IGRlZiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZShuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHdhcm4kMihgSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFwiJHtuYW1lfVwiOiBleHBlY3RlZCBhbiBPYmplY3QsIGAgK1xuICAgICAgICAgICAgYGJ1dCBnb3QgJHt0b1Jhd1R5cGUodmFsdWUpfS5gLCB2bSk7XG4gICAgfVxufVxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZCwgdm0pIHtcbiAgICB7XG4gICAgICAgIGNoZWNrQ29tcG9uZW50cyhjaGlsZCk7XG4gICAgfVxuICAgIGlmIChpc0Z1bmN0aW9uKGNoaWxkKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgICB9XG4gICAgbm9ybWFsaXplUHJvcHMoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVJbmplY3QoY2hpbGQsIHZtKTtcbiAgICBub3JtYWxpemVEaXJlY3RpdmVzJDEoY2hpbGQpO1xuICAgIC8vIEFwcGx5IGV4dGVuZHMgYW5kIG1peGlucyBvbiB0aGUgY2hpbGQgb3B0aW9ucyxcbiAgICAvLyBidXQgb25seSBpZiBpdCBpcyBhIHJhdyBvcHRpb25zIG9iamVjdCB0aGF0IGlzbid0XG4gICAgLy8gdGhlIHJlc3VsdCBvZiBhbm90aGVyIG1lcmdlT3B0aW9ucyBjYWxsLlxuICAgIC8vIE9ubHkgbWVyZ2VkIG9wdGlvbnMgaGFzIHRoZSBfYmFzZSBwcm9wZXJ0eS5cbiAgICBpZiAoIWNoaWxkLl9iYXNlKSB7XG4gICAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5leHRlbmRzLCB2bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkLm1peGlucykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBrZXk7XG4gICAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gY2hpbGQpIHtcbiAgICAgICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICAgICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbWVyZ2VGaWVsZChrZXkpIHtcbiAgICAgICAgY29uc3Qgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG4vKipcbiAqIFJlc29sdmUgYW4gYXNzZXQuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAqIHRvIGFzc2V0cyBkZWZpbmVkIGluIGl0cyBhbmNlc3RvciBjaGFpbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUFzc2V0KG9wdGlvbnMsIHR5cGUsIGlkLCB3YXJuTWlzc2luZykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICAgIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpXG4gICAgICAgIHJldHVybiBhc3NldHNbaWRdO1xuICAgIGNvbnN0IGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICAgIGlmIChoYXNPd24oYXNzZXRzLCBjYW1lbGl6ZWRJZCkpXG4gICAgICAgIHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdO1xuICAgIGNvbnN0IFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICAgIGlmIChoYXNPd24oYXNzZXRzLCBQYXNjYWxDYXNlSWQpKVxuICAgICAgICByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF07XG4gICAgLy8gZmFsbGJhY2sgdG8gcHJvdG90eXBlIGNoYWluXG4gICAgY29uc3QgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICAgIGlmICh3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICAgIHdhcm4kMignRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pIHtcbiAgICBjb25zdCBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgICBjb25zdCBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgICAvLyBib29sZWFuIGNhc3RpbmdcbiAgICBjb25zdCBib29sZWFuSW5kZXggPSBnZXRUeXBlSW5kZXgoQm9vbGVhbiwgcHJvcC50eXBlKTtcbiAgICBpZiAoYm9vbGVhbkluZGV4ID4gLTEpIHtcbiAgICAgICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgICAgICAgLy8gb25seSBjYXN0IGVtcHR5IHN0cmluZyAvIHNhbWUgbmFtZSB0byBib29sZWFuIGlmXG4gICAgICAgICAgICAvLyBib29sZWFuIGhhcyBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ0luZGV4ID0gZ2V0VHlwZUluZGV4KFN0cmluZywgcHJvcC50eXBlKTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAgICAgLy8gc2luY2UgdGhlIGRlZmF1bHQgdmFsdWUgaXMgYSBmcmVzaCBjb3B5LFxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICAgICAgY29uc3QgcHJldlNob3VsZE9ic2VydmUgPSBzaG91bGRPYnNlcnZlO1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICAgIG9ic2VydmUodmFsdWUpO1xuICAgICAgICB0b2dnbGVPYnNlcnZpbmcocHJldlNob3VsZE9ic2VydmUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGEgcHJvcC5cbiAqL1xuZnVuY3Rpb24gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KSB7XG4gICAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gcHJvcC5kZWZhdWx0O1xuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgICBpZiAoaXNPYmplY3QoZGVmKSkge1xuICAgICAgICB3YXJuJDIoJ0ludmFsaWQgZGVmYXVsdCB2YWx1ZSBmb3IgcHJvcCBcIicgK1xuICAgICAgICAgICAga2V5ICtcbiAgICAgICAgICAgICdcIjogJyArXG4gICAgICAgICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAgICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsIHZtKTtcbiAgICB9XG4gICAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyByZXR1cm4gcHJldmlvdXMgZGVmYXVsdCB2YWx1ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3YXRjaGVyIHRyaWdnZXJcbiAgICBpZiAodm0gJiZcbiAgICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhICYmXG4gICAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdm0uX3Byb3BzW2tleV07XG4gICAgfVxuICAgIC8vIGNhbGwgZmFjdG9yeSBmdW5jdGlvbiBmb3Igbm9uLUZ1bmN0aW9uIHR5cGVzXG4gICAgLy8gYSB2YWx1ZSBpcyBGdW5jdGlvbiBpZiBpdHMgcHJvdG90eXBlIGlzIGZ1bmN0aW9uIGV2ZW4gYWNyb3NzIGRpZmZlcmVudCBleGVjdXRpb24gY29udGV4dFxuICAgIHJldHVybiBpc0Z1bmN0aW9uKGRlZikgJiYgZ2V0VHlwZShwcm9wLnR5cGUpICE9PSAnRnVuY3Rpb24nXG4gICAgICAgID8gZGVmLmNhbGwodm0pXG4gICAgICAgIDogZGVmO1xufVxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AocHJvcCwgbmFtZSwgdmFsdWUsIHZtLCBhYnNlbnQpIHtcbiAgICBpZiAocHJvcC5yZXF1aXJlZCAmJiBhYnNlbnQpIHtcbiAgICAgICAgd2FybiQyKCdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLCB2bSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdHlwZSA9IHByb3AudHlwZTtcbiAgICBsZXQgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSwgdm0pO1xuICAgICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGF2ZUV4cGVjdGVkVHlwZXMgPSBleHBlY3RlZFR5cGVzLnNvbWUodCA9PiB0KTtcbiAgICBpZiAoIXZhbGlkICYmIGhhdmVFeHBlY3RlZFR5cGVzKSB7XG4gICAgICAgIHdhcm4kMihnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpLCB2bSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdG9yID0gcHJvcC52YWxpZGF0b3I7XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgICBpZiAoIXZhbGlkYXRvcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHdhcm4kMignSW52YWxpZCBwcm9wOiBjdXN0b20gdmFsaWRhdG9yIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicsIHZtKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sfEJpZ0ludCkkLztcbmZ1bmN0aW9uIGFzc2VydFR5cGUodmFsdWUsIHR5cGUsIHZtKSB7XG4gICAgbGV0IHZhbGlkO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGdldFR5cGUodHlwZSk7XG4gICAgaWYgKHNpbXBsZUNoZWNrUkUudGVzdChleHBlY3RlZFR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgIHZhbGlkID0gdCA9PT0gZXhwZWN0ZWRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgICAgIGlmICghdmFsaWQgJiYgdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnQXJyYXknKSB7XG4gICAgICAgIHZhbGlkID0gaXNBcnJheSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHdhcm4kMignSW52YWxpZCBwcm9wIHR5cGU6IFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBpcyBub3QgYSBjb25zdHJ1Y3RvcicsIHZtKTtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQsXG4gICAgICAgIGV4cGVjdGVkVHlwZVxuICAgIH07XG59XG5jb25zdCBmdW5jdGlvblR5cGVDaGVja1JFID0gL15cXHMqZnVuY3Rpb24gKFxcdyspLztcbi8qKlxuICogVXNlIGZ1bmN0aW9uIHN0cmluZyBuYW1lIHRvIGNoZWNrIGJ1aWx0LWluIHR5cGVzLFxuICogYmVjYXVzZSBhIHNpbXBsZSBlcXVhbGl0eSBjaGVjayB3aWxsIGZhaWwgd2hlbiBydW5uaW5nXG4gKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFR5cGUoZm4pIHtcbiAgICBjb25zdCBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goZnVuY3Rpb25UeXBlQ2hlY2tSRSk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJztcbn1cbmZ1bmN0aW9uIGlzU2FtZVR5cGUoYSwgYikge1xuICAgIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpO1xufVxuZnVuY3Rpb24gZ2V0VHlwZUluZGV4KHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBpZiAoIWlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZVR5cGUoZXhwZWN0ZWRUeXBlcywgdHlwZSkgPyAwIDogLTE7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXNbaV0sIHR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBnZXRJbnZhbGlkVHlwZU1lc3NhZ2UobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJHtuYW1lfVwiLmAgK1xuICAgICAgICBgIEV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKX1gO1xuICAgIGNvbnN0IGV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZXNbMF07XG4gICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdG9SYXdUeXBlKHZhbHVlKTtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgZXhwZWN0ZWQgdmFsdWVcbiAgICBpZiAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaXNFeHBsaWNhYmxlKGV4cGVjdGVkVHlwZSkgJiZcbiAgICAgICAgaXNFeHBsaWNhYmxlKHR5cGVvZiB2YWx1ZSkgJiZcbiAgICAgICAgIWlzQm9vbGVhbihleHBlY3RlZFR5cGUsIHJlY2VpdmVkVHlwZSkpIHtcbiAgICAgICAgbWVzc2FnZSArPSBgIHdpdGggdmFsdWUgJHtzdHlsZVZhbHVlKHZhbHVlLCBleHBlY3RlZFR5cGUpfWA7XG4gICAgfVxuICAgIG1lc3NhZ2UgKz0gYCwgZ290ICR7cmVjZWl2ZWRUeXBlfSBgO1xuICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gc3BlY2lmeSByZWNlaXZlZCB2YWx1ZVxuICAgIGlmIChpc0V4cGxpY2FibGUocmVjZWl2ZWRUeXBlKSkge1xuICAgICAgICBtZXNzYWdlICs9IGB3aXRoIHZhbHVlICR7c3R5bGVWYWx1ZSh2YWx1ZSwgcmVjZWl2ZWRUeXBlKX0uYDtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiBzdHlsZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gICAgaWYgKHR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGAke051bWJlcih2YWx1ZSl9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIH1cbn1cbmNvbnN0IEVYUExJQ0FCTEVfVFlQRVMgPSBbJ3N0cmluZycsICdudW1iZXInLCAnYm9vbGVhbiddO1xuZnVuY3Rpb24gaXNFeHBsaWNhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEVYUExJQ0FCTEVfVFlQRVMuc29tZShlbGVtID0+IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IGVsZW0pO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5zb21lKGVsZW0gPT4gZWxlbS50b0xvd2VyQ2FzZSgpID09PSAnYm9vbGVhbicpO1xufVxuXG5mdW5jdGlvbiBWdWUob3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWdWUpKSB7XG4gICAgICAgIHdhcm4kMignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xufVxuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxuaW5pdE1peGluJDEoVnVlKTtcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcbnN0YXRlTWl4aW4oVnVlKTtcbi8vQHRzLWV4cGVjdC1lcnJvciBWdWUgaGFzIGZ1bmN0aW9uIHR5cGVcbmV2ZW50c01peGluKFZ1ZSk7XG4vL0B0cy1leHBlY3QtZXJyb3IgVnVlIGhhcyBmdW5jdGlvbiB0eXBlXG5saWZlY3ljbGVNaXhpbihWdWUpO1xuLy9AdHMtZXhwZWN0LWVycm9yIFZ1ZSBoYXMgZnVuY3Rpb24gdHlwZVxucmVuZGVyTWl4aW4oVnVlKTtcblxuZnVuY3Rpb24gaW5pdFVzZShWdWUpIHtcbiAgICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICBjb25zdCBpbnN0YWxsZWRQbHVnaW5zID0gdGhpcy5faW5zdGFsbGVkUGx1Z2lucyB8fCAodGhpcy5faW5zdGFsbGVkUGx1Z2lucyA9IFtdKTtcbiAgICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgICAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHBsdWdpbi5pbnN0YWxsKSkge1xuICAgICAgICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHBsdWdpbikpIHtcbiAgICAgICAgICAgIHBsdWdpbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdE1peGluKFZ1ZSkge1xuICAgIFZ1ZS5taXhpbiA9IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQoVnVlKSB7XG4gICAgLyoqXG4gICAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAgICogY2lkLiBUaGlzIGVuYWJsZXMgdXMgdG8gY3JlYXRlIHdyYXBwZWQgXCJjaGlsZFxuICAgICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgICAqL1xuICAgIFZ1ZS5jaWQgPSAwO1xuICAgIGxldCBjaWQgPSAxO1xuICAgIC8qKlxuICAgICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAgICovXG4gICAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgICAgIGV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zIHx8IHt9O1xuICAgICAgICBjb25zdCBTdXBlciA9IHRoaXM7XG4gICAgICAgIGNvbnN0IFN1cGVySWQgPSBTdXBlci5jaWQ7XG4gICAgICAgIGNvbnN0IGNhY2hlZEN0b3JzID0gZXh0ZW5kT3B0aW9ucy5fQ3RvciB8fCAoZXh0ZW5kT3B0aW9ucy5fQ3RvciA9IHt9KTtcbiAgICAgICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoZXh0ZW5kT3B0aW9ucykgfHwgZ2V0Q29tcG9uZW50TmFtZShTdXBlci5vcHRpb25zKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgU3ViLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgICAgICAgU3ViLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN1YjtcbiAgICAgICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgICAgICBTdWIub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhTdXBlci5vcHRpb25zLCBleHRlbmRPcHRpb25zKTtcbiAgICAgICAgU3ViWydzdXBlciddID0gU3VwZXI7XG4gICAgICAgIC8vIEZvciBwcm9wcyBhbmQgY29tcHV0ZWQgcHJvcGVydGllcywgd2UgZGVmaW5lIHRoZSBwcm94eSBnZXR0ZXJzIG9uXG4gICAgICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICAgICAgaWYgKFN1Yi5vcHRpb25zLnByb3BzKSB7XG4gICAgICAgICAgICBpbml0UHJvcHMoU3ViKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3ViLm9wdGlvbnMuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGluaXRDb21wdXRlZChTdWIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgICAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgICAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICAgICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcbiAgICAgICAgLy8gY3JlYXRlIGFzc2V0IHJlZ2lzdGVycywgc28gZXh0ZW5kZWQgY2xhc3Nlc1xuICAgICAgICAvLyBjYW4gaGF2ZSB0aGVpciBwcml2YXRlIGFzc2V0cyB0b28uXG4gICAgICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZW5hYmxlIHJlY3Vyc2l2ZSBzZWxmLWxvb2t1cFxuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgICAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgICAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgICAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgICAgIFN1Yi5zZWFsZWRPcHRpb25zID0gZXh0ZW5kKHt9LCBTdWIub3B0aW9ucyk7XG4gICAgICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgICAgIGNhY2hlZEN0b3JzW1N1cGVySWRdID0gU3ViO1xuICAgICAgICByZXR1cm4gU3ViO1xuICAgIH07XG59XG5mdW5jdGlvbiBpbml0UHJvcHMoQ29tcCkge1xuICAgIGNvbnN0IHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIHByb3h5KENvbXAucHJvdG90eXBlLCBgX3Byb3BzYCwga2V5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQoQ29tcCkge1xuICAgIGNvbnN0IGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICAgIGRlZmluZUNvbXB1dGVkKENvbXAucHJvdG90eXBlLCBrZXksIGNvbXB1dGVkW2tleV0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICAgKi9cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGZ1bmN0aW9uIGlzIG5vdCBleGFjdCBzYW1lIHR5cGVcbiAgICAgICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKGlkLCBkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUNvbXBvbmVudE5hbWUoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZGlyZWN0aXZlJyAmJiBpc0Z1bmN0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb24gPSB7IGJpbmQ6IGRlZmluaXRpb24sIHVwZGF0ZTogZGVmaW5pdGlvbiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2dldENvbXBvbmVudE5hbWUob3B0cykge1xuICAgIHJldHVybiBvcHRzICYmIChnZXRDb21wb25lbnROYW1lKG9wdHMuQ3Rvci5vcHRpb25zKSB8fCBvcHRzLnRhZyk7XG59XG5mdW5jdGlvbiBtYXRjaGVzKHBhdHRlcm4sIG5hbWUpIHtcbiAgICBpZiAoaXNBcnJheShwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwcnVuZUNhY2hlKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgICBjb25zdCB7IGNhY2hlLCBrZXlzLCBfdm5vZGUsICR2bm9kZSB9ID0ga2VlcEFsaXZlSW5zdGFuY2U7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgY29uc3QgZW50cnkgPSBjYWNoZVtrZXldO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbnRyeS5uYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUgJiYgIWZpbHRlcihuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICR2bm9kZS5jb21wb25lbnRPcHRpb25zLmNoaWxkcmVuID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBlbnRyeSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGVudHJ5ICYmICghY3VycmVudCB8fCBlbnRyeS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbiBiZSB1bmRlZmluZWRcbiAgICAgICAgZW50cnkuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICB9XG4gICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgcmVtb3ZlJDIoa2V5cywga2V5KTtcbn1cbmNvbnN0IHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuLy8gVE9ETyBkZWZpbmVDb21wb25lbnRcbnZhciBLZWVwQWxpdmUgPSB7XG4gICAgbmFtZTogJ2tlZXAtYWxpdmUnLFxuICAgIGFic3RyYWN0OiB0cnVlLFxuICAgIHByb3BzOiB7XG4gICAgICAgIGluY2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICAgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgY2FjaGVWTm9kZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUsIGtleXMsIHZub2RlVG9DYWNoZSwga2V5VG9DYWNoZSB9ID0gdGhpcztcbiAgICAgICAgICAgIGlmICh2bm9kZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRhZywgY29tcG9uZW50SW5zdGFuY2UsIGNvbXBvbmVudE9wdGlvbnMgfSA9IHZub2RlVG9DYWNoZTtcbiAgICAgICAgICAgICAgICBjYWNoZVtrZXlUb0NhY2hlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogX2dldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50SW5zdGFuY2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXlUb0NhY2hlKTtcbiAgICAgICAgICAgICAgICAvLyBwcnVuZSBvbGRlc3QgZW50cnlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXggJiYga2V5cy5sZW5ndGggPiBwYXJzZUludCh0aGlzLm1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXlzWzBdLCBrZXlzLCB0aGlzLl92bm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudm5vZGVUb0NhY2hlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgIH0sXG4gICAgZGVzdHJveWVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmNhY2hlKSB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkodGhpcy5jYWNoZSwga2V5LCB0aGlzLmtleXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtb3VudGVkKCkge1xuICAgICAgICB0aGlzLmNhY2hlVk5vZGUoKTtcbiAgICAgICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCB2YWwgPT4ge1xuICAgICAgICAgICAgcHJ1bmVDYWNoZSh0aGlzLCBuYW1lID0+IG1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLiR3YXRjaCgnZXhjbHVkZScsIHZhbCA9PiB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlKHRoaXMsIG5hbWUgPT4gIW1hdGNoZXModmFsLCBuYW1lKSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgdXBkYXRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWNoZVZOb2RlKCk7XG4gICAgfSxcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgICBjb25zdCB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICBpZiAoY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgICAgICAgLy8gY2hlY2sgcGF0dGVyblxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IF9nZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgeyBpbmNsdWRlLCBleGNsdWRlIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gbm90IGluY2x1ZGVkXG4gICAgICAgICAgICAoaW5jbHVkZSAmJiAoIW5hbWUgfHwgIW1hdGNoZXMoaW5jbHVkZSwgbmFtZSkpKSB8fFxuICAgICAgICAgICAgICAgIC8vIGV4Y2x1ZGVkXG4gICAgICAgICAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2bm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGUsIGtleXMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB2bm9kZS5rZXkgPT0gbnVsbFxuICAgICAgICAgICAgICAgID8gLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb21wb25lbnRPcHRpb25zLnRhZyA/IGA6OiR7Y29tcG9uZW50T3B0aW9ucy50YWd9YCA6ICcnKVxuICAgICAgICAgICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgICAgICAgaWYgKGNhY2hlW2tleV0pIHtcbiAgICAgICAgICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgLy8gbWFrZSBjdXJyZW50IGtleSBmcmVzaGVzdFxuICAgICAgICAgICAgICAgIHJlbW92ZSQyKGtleXMsIGtleSk7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxheSBzZXR0aW5nIHRoZSBjYWNoZSB1bnRpbCB1cGRhdGVcbiAgICAgICAgICAgICAgICB0aGlzLnZub2RlVG9DYWNoZSA9IHZub2RlO1xuICAgICAgICAgICAgICAgIHRoaXMua2V5VG9DYWNoZSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY2FuIHZub2RlLmRhdGEgY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bm9kZSB8fCAoc2xvdCAmJiBzbG90WzBdKTtcbiAgICB9XG59O1xuXG52YXIgYnVpbHRJbkNvbXBvbmVudHMgPSB7XG4gICAgS2VlcEFsaXZlXG59O1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJKFZ1ZSkge1xuICAgIC8vIGNvbmZpZ1xuICAgIGNvbnN0IGNvbmZpZ0RlZiA9IHt9O1xuICAgIGNvbmZpZ0RlZi5nZXQgPSAoKSA9PiBjb25maWc7XG4gICAge1xuICAgICAgICBjb25maWdEZWYuc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgd2FybiQyKCdEbyBub3QgcmVwbGFjZSB0aGUgVnVlLmNvbmZpZyBvYmplY3QsIHNldCBpbmRpdmlkdWFsIGZpZWxkcyBpbnN0ZWFkLicpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcbiAgICAvLyBleHBvc2VkIHV0aWwgbWV0aG9kcy5cbiAgICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgICAvLyB0aGVtIHVubGVzcyB5b3UgYXJlIGF3YXJlIG9mIHRoZSByaXNrLlxuICAgIFZ1ZS51dGlsID0ge1xuICAgICAgICB3YXJuOiB3YXJuJDIsXG4gICAgICAgIGV4dGVuZCxcbiAgICAgICAgbWVyZ2VPcHRpb25zLFxuICAgICAgICBkZWZpbmVSZWFjdGl2ZVxuICAgIH07XG4gICAgVnVlLnNldCA9IHNldDtcbiAgICBWdWUuZGVsZXRlID0gZGVsO1xuICAgIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuICAgIC8vIDIuNiBleHBsaWNpdCBvYnNlcnZhYmxlIEFQSVxuICAgIFZ1ZS5vYnNlcnZhYmxlID0gKG9iaikgPT4ge1xuICAgICAgICBvYnNlcnZlKG9iaik7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgQVNTRVRfVFlQRVMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgVnVlLm9wdGlvbnNbdHlwZSArICdzJ10gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH0pO1xuICAgIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcbiAgICBleHRlbmQoVnVlLm9wdGlvbnMuY29tcG9uZW50cywgYnVpbHRJbkNvbXBvbmVudHMpO1xuICAgIGluaXRVc2UoVnVlKTtcbiAgICBpbml0TWl4aW4oVnVlKTtcbiAgICBpbml0RXh0ZW5kKFZ1ZSk7XG4gICAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG59XG5cbmluaXRHbG9iYWxBUEkoVnVlKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGlzU2VydmVyJywge1xuICAgIGdldDogaXNTZXJ2ZXJSZW5kZXJpbmdcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiB0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0O1xuICAgIH1cbn0pO1xuLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnRnVuY3Rpb25hbFJlbmRlckNvbnRleHQnLCB7XG4gICAgdmFsdWU6IEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0XG59KTtcblZ1ZS52ZXJzaW9uID0gdmVyc2lvbjtcblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbmNvbnN0IGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbmNvbnN0IGFjY2VwdFZhbHVlID0gbWFrZU1hcCgnaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzcycpO1xuY29uc3QgbXVzdFVzZVByb3AgPSAodGFnLCB0eXBlLCBhdHRyKSA9PiB7XG4gICAgcmV0dXJuICgoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpICYmIHR5cGUgIT09ICdidXR0b24nKSB8fFxuICAgICAgICAoYXR0ciA9PT0gJ3NlbGVjdGVkJyAmJiB0YWcgPT09ICdvcHRpb24nKSB8fFxuICAgICAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAgICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKSk7XG59O1xuY29uc3QgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuY29uc3QgaXNWYWxpZENvbnRlbnRFZGl0YWJsZVZhbHVlID0gbWFrZU1hcCgnZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seScpO1xuY29uc3QgY29udmVydEVudW1lcmF0ZWRWYWx1ZSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnXG4gICAgICAgID8gJ2ZhbHNlJ1xuICAgICAgICA6IC8vIGFsbG93IGFyYml0cmFyeSBzdHJpbmcgdmFsdWUgZm9yIGNvbnRlbnRlZGl0YWJsZVxuICAgICAgICAgICAga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICAgICAgICAgICAgPyB2YWx1ZVxuICAgICAgICAgICAgICAgIDogJ3RydWUnO1xufTtcbmNvbnN0IGlzQm9vbGVhbkF0dHIgPSBtYWtlTWFwKCdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAgICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICAgJ2VuYWJsZWQsZm9ybW5vdmFsaWRhdGUsaGlkZGVuLGluZGV0ZXJtaW5hdGUsaW5lcnQsaXNtYXAsaXRlbXNjb3BlLGxvb3AsbXVsdGlwbGUsJyArXG4gICAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSwnICtcbiAgICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZScpO1xuY29uc3QgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcbmNvbnN0IGlzWGxpbmsgPSAobmFtZSkgPT4ge1xuICAgIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluayc7XG59O1xuY29uc3QgZ2V0WGxpbmtQcm9wID0gKG5hbWUpID0+IHtcbiAgICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJyc7XG59O1xuY29uc3QgaXNGYWxzeUF0dHJWYWx1ZSA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpIHtcbiAgICBsZXQgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgbGV0IHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgICBsZXQgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgaWYgKGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHBhcmVudE5vZGUucGFyZW50IG5vdCBWTm9kZVdpdGhEYXRhXG4gICAgd2hpbGUgKGlzRGVmKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSkge1xuICAgICAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhKGNoaWxkLCBwYXJlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgICAgICBjbGFzczogaXNEZWYoY2hpbGQuY2xhc3MpID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdIDogcGFyZW50LmNsYXNzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlckNsYXNzKHN0YXRpY0NsYXNzLCBkeW5hbWljQ2xhc3MpIHtcbiAgICBpZiAoaXNEZWYoc3RhdGljQ2xhc3MpIHx8IGlzRGVmKGR5bmFtaWNDbGFzcykpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gY29uY2F0KGEsIGIpIHtcbiAgICByZXR1cm4gYSA/IChiID8gYSArICcgJyArIGIgOiBhKSA6IGIgfHwgJyc7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXkodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlPYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkodmFsdWUpIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgbGV0IHN0cmluZ2lmaWVkO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0RlZigoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChyZXMpXG4gICAgICAgICAgICAgICAgcmVzICs9ICcgJztcbiAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICAgICAgICBpZiAocmVzKVxuICAgICAgICAgICAgICAgIHJlcyArPSAnICc7XG4gICAgICAgICAgICByZXMgKz0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmNvbnN0IG5hbWVzcGFjZU1hcCA9IHtcbiAgICBzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gICAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuY29uc3QgaXNIVE1MVGFnID0gbWFrZU1hcCgnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAgICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAgICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290Jyk7XG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG5jb25zdCBpc1NWRyA9IG1ha2VNYXAoJ3N2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSwnICtcbiAgICAnZm9yZWlnbm9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLCB0cnVlKTtcbmNvbnN0IGlzUHJlVGFnID0gKHRhZykgPT4gdGFnID09PSAncHJlJztcbmNvbnN0IGlzUmVzZXJ2ZWRUYWcgPSAodGFnKSA9PiB7XG4gICAgcmV0dXJuIGlzSFRNTFRhZyh0YWcpIHx8IGlzU1ZHKHRhZyk7XG59O1xuZnVuY3Rpb24gZ2V0VGFnTmFtZXNwYWNlKHRhZykge1xuICAgIGlmIChpc1NWRyh0YWcpKSB7XG4gICAgICAgIHJldHVybiAnc3ZnJztcbiAgICB9XG4gICAgLy8gYmFzaWMgc3VwcG9ydCBmb3IgTWF0aE1MXG4gICAgLy8gbm90ZSBpdCBkb2Vzbid0IHN1cHBvcnQgb3RoZXIgTWF0aE1MIGVsZW1lbnRzIGJlaW5nIGNvbXBvbmVudCByb290c1xuICAgIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgICAgICByZXR1cm4gJ21hdGgnO1xuICAgIH1cbn1cbmNvbnN0IHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gaXNVbmtub3duRWxlbWVudCh0YWcpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3Nlcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddO1xuICAgIH1cbiAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yODIxMDM2NC8xMDcwMjQ0XG4gICAgICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID1cbiAgICAgICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICAgICAgICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MRWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKHVua25vd25FbGVtZW50Q2FjaGVbdGFnXSA9IC9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZWwudG9TdHJpbmcoKSkpO1xuICAgIH1cbn1cbmNvbnN0IGlzVGV4dElucHV0VHlwZSA9IG1ha2VNYXAoJ3RleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsJyk7XG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5KGVsKSB7XG4gICAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgd2FybiQyKCdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgZWwpO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RlZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgdm5vZGUpIHtcbiAgICBjb25zdCBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGlmICh0YWdOYW1lICE9PSAnc2VsZWN0Jykge1xuICAgICAgICByZXR1cm4gZWxtO1xuICAgIH1cbiAgICAvLyBmYWxzZSBvciBudWxsIHdpbGwgcmVtb3ZlIHRoZSBhdHRyaWJ1dGUgYnV0IHVuZGVmaW5lZCB3aWxsIG5vdFxuICAgIGlmICh2bm9kZS5kYXRhICYmXG4gICAgICAgIHZub2RlLmRhdGEuYXR0cnMgJiZcbiAgICAgICAgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gICAgfVxuICAgIHJldHVybiBlbG07XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29tbWVudCh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dCk7XG59XG5mdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZENoaWxkKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5mdW5jdGlvbiBwYXJlbnROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlO1xufVxuZnVuY3Rpb24gbmV4dFNpYmxpbmcobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xufVxuZnVuY3Rpb24gdGFnTmFtZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZTtcbn1cbmZ1bmN0aW9uIHNldFRleHRDb250ZW50KG5vZGUsIHRleHQpIHtcbiAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cbmZ1bmN0aW9uIHNldFN0eWxlU2NvcGUobm9kZSwgc2NvcGVJZCkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKHNjb3BlSWQsICcnKTtcbn1cblxudmFyIG5vZGVPcHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCxcbiAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gIGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcbiAgY3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcbiAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gIHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcbiAgYXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICBuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG4gIHRhZ05hbWU6IHRhZ05hbWUsXG4gIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgc2V0U3R5bGVTY29wZTogc2V0U3R5bGVTY29wZVxufSk7XG5cbnZhciByZWYgPSB7XG4gICAgY3JlYXRlKF8sIHZub2RlKSB7XG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICB9LFxuICAgIHVwZGF0ZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICAgICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95KHZub2RlKSB7XG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcmVnaXN0ZXJSZWYodm5vZGUsIGlzUmVtb3ZhbCkge1xuICAgIGNvbnN0IHJlZiA9IHZub2RlLmRhdGEucmVmO1xuICAgIGlmICghaXNEZWYocmVmKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZtID0gdm5vZGUuY29udGV4dDtcbiAgICBjb25zdCByZWZWYWx1ZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlIHx8IHZub2RlLmVsbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzUmVtb3ZhbCA/IG51bGwgOiByZWZWYWx1ZTtcbiAgICBjb25zdCAkcmVmc1ZhbHVlID0gaXNSZW1vdmFsID8gdW5kZWZpbmVkIDogcmVmVmFsdWU7XG4gICAgaWYgKGlzRnVuY3Rpb24ocmVmKSkge1xuICAgICAgICBpbnZva2VXaXRoRXJyb3JIYW5kbGluZyhyZWYsIHZtLCBbdmFsdWVdLCB2bSwgYHRlbXBsYXRlIHJlZiBmdW5jdGlvbmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzRm9yID0gdm5vZGUuZGF0YS5yZWZJbkZvcjtcbiAgICBjb25zdCBfaXNTdHJpbmcgPSB0eXBlb2YgcmVmID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcmVmID09PSAnbnVtYmVyJztcbiAgICBjb25zdCBfaXNSZWYgPSBpc1JlZihyZWYpO1xuICAgIGNvbnN0IHJlZnMgPSB2bS4kcmVmcztcbiAgICBpZiAoX2lzU3RyaW5nIHx8IF9pc1JlZikge1xuICAgICAgICBpZiAoaXNGb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gX2lzU3RyaW5nID8gcmVmc1tyZWZdIDogcmVmLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzUmVtb3ZhbCkge1xuICAgICAgICAgICAgICAgIGlzQXJyYXkoZXhpc3RpbmcpICYmIHJlbW92ZSQyKGV4aXN0aW5nLCByZWZWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQXJyYXkoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnNbcmVmXSA9IFtyZWZWYWx1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTZXR1cFJlZih2bSwgcmVmLCByZWZzW3JlZl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLnZhbHVlID0gW3JlZlZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZXhpc3RpbmcuaW5jbHVkZXMocmVmVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnB1c2gocmVmVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfaXNTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChpc1JlbW92YWwgJiYgcmVmc1tyZWZdICE9PSByZWZWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZnNbcmVmXSA9ICRyZWZzVmFsdWU7XG4gICAgICAgICAgICBzZXRTZXR1cFJlZih2bSwgcmVmLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX2lzUmVmKSB7XG4gICAgICAgICAgICBpZiAoaXNSZW1vdmFsICYmIHJlZi52YWx1ZSAhPT0gcmVmVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4kMihgSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTogJHt0eXBlb2YgcmVmfWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0U2V0dXBSZWYoeyBfc2V0dXBTdGF0ZSB9LCBrZXksIHZhbCkge1xuICAgIGlmIChfc2V0dXBTdGF0ZSAmJiBoYXNPd24oX3NldHVwU3RhdGUsIGtleSkpIHtcbiAgICAgICAgaWYgKGlzUmVmKF9zZXR1cFN0YXRlW2tleV0pKSB7XG4gICAgICAgICAgICBfc2V0dXBTdGF0ZVtrZXldLnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3NldHVwU3RhdGVba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cbmNvbnN0IGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcbmNvbnN0IGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5mdW5jdGlvbiBzYW1lVm5vZGUoYSwgYikge1xuICAgIHJldHVybiAoYS5rZXkgPT09IGIua2V5ICYmXG4gICAgICAgIGEuYXN5bmNGYWN0b3J5ID09PSBiLmFzeW5jRmFjdG9yeSAmJlxuICAgICAgICAoKGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICAgICAgYS5pc0NvbW1lbnQgPT09IGIuaXNDb21tZW50ICYmXG4gICAgICAgICAgICBpc0RlZihhLmRhdGEpID09PSBpc0RlZihiLmRhdGEpICYmXG4gICAgICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpKSB8fFxuICAgICAgICAgICAgKGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiYgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcikpKSk7XG59XG5mdW5jdGlvbiBzYW1lSW5wdXRUeXBlKGEsIGIpIHtcbiAgICBpZiAoYS50YWcgIT09ICdpbnB1dCcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IHR5cGVBID0gaXNEZWYoKGkgPSBhLmRhdGEpKSAmJiBpc0RlZigoaSA9IGkuYXR0cnMpKSAmJiBpLnR5cGU7XG4gICAgY29uc3QgdHlwZUIgPSBpc0RlZigoaSA9IGIuZGF0YSkpICYmIGlzRGVmKChpID0gaS5hdHRycykpICYmIGkudHlwZTtcbiAgICByZXR1cm4gdHlwZUEgPT09IHR5cGVCIHx8IChpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQikpO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHgoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgICBsZXQgaSwga2V5O1xuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAgICAgIGtleSA9IGNoaWxkcmVuW2ldLmtleTtcbiAgICAgICAgaWYgKGlzRGVmKGtleSkpXG4gICAgICAgICAgICBtYXBba2V5XSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uKGJhY2tlbmQpIHtcbiAgICBsZXQgaSwgajtcbiAgICBjb25zdCBjYnMgPSB7fTtcbiAgICBjb25zdCB7IG1vZHVsZXMsIG5vZGVPcHMgfSA9IGJhY2tlbmQ7XG4gICAgZm9yIChpID0gMDsgaSA8IGhvb2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGlmIChpc0RlZihtb2R1bGVzW2pdW2hvb2tzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0KGVsbSkge1xuICAgICAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVSbUNiKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgICAgaWYgKC0tcmVtb3ZlLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICAgIHJldHVybiByZW1vdmU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUoZWwpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAgICAgLy8gZWxlbWVudCBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gcmVtb3ZlZCBkdWUgdG8gdi1odG1sIC8gdi10ZXh0XG4gICAgICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICAgICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudCwgZWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVW5rbm93bkVsZW1lbnQodm5vZGUsIGluVlByZSkge1xuICAgICAgICByZXR1cm4gKCFpblZQcmUgJiZcbiAgICAgICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuc29tZShpZ25vcmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnO1xuICAgICAgICAgICAgICAgIH0pKSAmJlxuICAgICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodm5vZGUudGFnKSk7XG4gICAgfVxuICAgIGxldCBjcmVhdGluZ0VsbUluVlByZSA9IDA7XG4gICAgZnVuY3Rpb24gY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBuZXN0ZWQsIG93bmVyQXJyYXksIGluZGV4KSB7XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHZub2RlIHdhcyB1c2VkIGluIGEgcHJldmlvdXMgcmVuZGVyIVxuICAgICAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAgICAgICAvLyBwb3RlbnRpYWwgcGF0Y2ggZXJyb3JzIGRvd24gdGhlIHJvYWQgd2hlbiBpdCdzIHVzZWQgYXMgYW4gaW5zZXJ0aW9uXG4gICAgICAgICAgICAvLyByZWZlcmVuY2Ugbm9kZS4gSW5zdGVhZCwgd2UgY2xvbmUgdGhlIG5vZGUgb24tZGVtYW5kIGJlZm9yZSBjcmVhdGluZ1xuICAgICAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICAgICAgaWYgKGNyZWF0ZUNvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgdGFnID0gdm5vZGUudGFnO1xuICAgICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50KHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKCdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgICAgICAgICAgOiBub2RlT3BzLmNyZWF0ZUVsZW1lbnQodGFnLCB2bm9kZSk7XG4gICAgICAgICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICAgICAgbGV0IGkgPSB2bm9kZS5kYXRhO1xuICAgICAgICBpZiAoaXNEZWYoaSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUmVhY3RpdmF0ZWQgPSBpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkgJiYgaS5rZWVwQWxpdmU7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBpLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuaW5pdCkpKSB7XG4gICAgICAgICAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAgICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkpIHtcbiAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgICAgICAgIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUuZWxtID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuJGVsO1xuICAgICAgICBpZiAoaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgICAgIGxldCBpO1xuICAgICAgICAvLyBoYWNrIGZvciAjNDMzOTogYSByZWFjdGl2YXRlZCBjb21wb25lbnQgd2l0aCBpbm5lciB0cmFuc2l0aW9uXG4gICAgICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAgICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgICAgIC8vIHRoZXJlIGRvZXNuJ3Qgc2VlbSB0byBiZSBhIGJldHRlciB3YXkgdG8gZG8gaXQuXG4gICAgICAgIGxldCBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICAgICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGlubmVyTm9kZS5kYXRhKSkgJiYgaXNEZWYoKGkgPSBpLnRyYW5zaXRpb24pKSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY2JzLmFjdGl2YXRlW2ldKGVtcHR5Tm9kZSwgaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2goaW5uZXJOb2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB1bmxpa2UgYSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudCxcbiAgICAgICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnNlcnQocGFyZW50LCBlbG0sIHJlZikge1xuICAgICAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKHJlZikpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZU9wcy5wYXJlbnROb2RlKHJlZikgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIGVsbSwgcmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsbShjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5lbG0sIG51bGwsIHRydWUsIGNoaWxkcmVuLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ByaW1pdGl2ZSh2bm9kZS50ZXh0KSkge1xuICAgICAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaXNQYXRjaGFibGUodm5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNicy5jcmVhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICAgICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKVxuICAgICAgICAgICAgICAgIGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgICAgICAgaWYgKGlzRGVmKGkuaW5zZXJ0KSlcbiAgICAgICAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAgIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgICBmdW5jdGlvbiBzZXRTY29wZSh2bm9kZSkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKGlzRGVmKChpID0gdm5vZGUuZm5TY29wZUlkKSkpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBhbmNlc3Rvci5jb250ZXh0KSkgJiYgaXNEZWYoKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICAgICAgaWYgKGlzRGVmKChpID0gYWN0aXZlSW5zdGFuY2UpKSAmJlxuICAgICAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICAgICAgICBpc0RlZigoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSkge1xuICAgICAgICAgICAgbm9kZU9wcy5zZXRTdHlsZVNjb3BlKHZub2RlLmVsbSwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgZmFsc2UsIHZub2Rlcywgc3RhcnRJZHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludm9rZURlc3Ryb3lIb29rKHZub2RlKSB7XG4gICAgICAgIGxldCBpLCBqO1xuICAgICAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuZGVzdHJveSkpKVxuICAgICAgICAgICAgICAgIGkodm5vZGUpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoKGkgPSB2bm9kZS5jaGlsZHJlbikpKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzKHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgICAgICBjb25zdCBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICByZW1vdmVOb2RlKGNoLmVsbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sodm5vZGUsIHJtKSB7XG4gICAgICAgIGlmIChpc0RlZihybSkgfHwgaXNEZWYodm5vZGUuZGF0YSkpIHtcbiAgICAgICAgICAgIGxldCBpO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgICAgICAgICBybSA9IGNyZWF0ZVJtQ2Iodm5vZGUuZWxtLCBsaXN0ZW5lcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgaW52b2tlIGhvb2tzIG9uIGNoaWxkIGNvbXBvbmVudCByb290IG5vZGVcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkgJiZcbiAgICAgICAgICAgICAgICBpc0RlZigoaSA9IGkuX3Zub2RlKSkgJiZcbiAgICAgICAgICAgICAgICBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS5yZW1vdmUpKSkge1xuICAgICAgICAgICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4ocGFyZW50RWxtLCBvbGRDaCwgbmV3Q2gsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgICAgICBsZXQgb2xkU3RhcnRJZHggPSAwO1xuICAgICAgICBsZXQgbmV3U3RhcnRJZHggPSAwO1xuICAgICAgICBsZXQgb2xkRW5kSWR4ID0gb2xkQ2gubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICAgICAgbGV0IG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICAgICAgbGV0IG5ld0VuZElkeCA9IG5ld0NoLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgICAgIGxldCBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgICAgIGxldCBvbGRLZXlUb0lkeCwgaWR4SW5PbGQsIHZub2RlVG9Nb3ZlLCByZWZFbG07XG4gICAgICAgIC8vIHJlbW92ZU9ubHkgaXMgYSBzcGVjaWFsIGZsYWcgdXNlZCBvbmx5IGJ5IDx0cmFuc2l0aW9uLWdyb3VwPlxuICAgICAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgICAgIGNvbnN0IGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcbiAgICAgICAge1xuICAgICAgICAgICAgY2hlY2tEdXBsaWNhdGVLZXlzKG5ld0NoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAob2xkU3RhcnRJZHggPD0gb2xkRW5kSWR4ICYmIG5ld1N0YXJ0SWR4IDw9IG5ld0VuZElkeCkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWYob2xkU3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5kZWYob2xkRW5kVm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3RW5kSWR4KTtcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgICAgICAgY2FuTW92ZSAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgICAgIGNhbk1vdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpXG4gICAgICAgICAgICAgICAgICAgIG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICAgICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpXG4gICAgICAgICAgICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZENoW2lkeEluT2xkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbk1vdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIHZub2RlVG9Nb3ZlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSBrZXkgYnV0IGRpZmZlcmVudCBlbGVtZW50LiB0cmVhdCBhcyBuZXcgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgZmFsc2UsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdTdGFydElkeCA+IG5ld0VuZElkeCkge1xuICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3Qgc2VlbktleXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgdm5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHZub2RlLmtleTtcbiAgICAgICAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKGBEdXBsaWNhdGUga2V5cyBkZXRlY3RlZDogJyR7a2V5fScuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5gLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaW5kSWR4SW5PbGQobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBvbGRDaFtpXTtcbiAgICAgICAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGF0Y2hWbm9kZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgb3duZXJBcnJheSwgaW5kZXgsIHJlbW92ZU9ubHkpIHtcbiAgICAgICAgaWYgKG9sZFZub2RlID09PSB2bm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgICAgICAvLyBjbG9uZSByZXVzZWQgdm5vZGVcbiAgICAgICAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbG0gPSAodm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgICAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAgICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgICAgICBpc1RydWUob2xkVm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgICAgICB2bm9kZS5rZXkgPT09IG9sZFZub2RlLmtleSAmJlxuICAgICAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpKSB7XG4gICAgICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChpID0gZGF0YS5ob29rKSkgJiYgaXNEZWYoKGkgPSBpLnByZXBhdGNoKSkpIHtcbiAgICAgICAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnVwZGF0ZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjYnMudXBkYXRlW2ldKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkudXBkYXRlKSkpXG4gICAgICAgICAgICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvbGRDaCAhPT0gY2gpXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpXG4gICAgICAgICAgICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCAnJyk7XG4gICAgICAgICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRDaCkpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVWbm9kZXMob2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IGRhdGEuaG9vaykpICYmIGlzRGVmKChpID0gaS5wb3N0cGF0Y2gpKSlcbiAgICAgICAgICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAgICAgLy8gZGVsYXkgaW5zZXJ0IGhvb2tzIGZvciBjb21wb25lbnQgcm9vdCBub2RlcywgaW52b2tlIHRoZW0gYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgICAvLyBsaXN0IG9mIG1vZHVsZXMgdGhhdCBjYW4gc2tpcCBjcmVhdGUgaG9vayBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2UgdGhleVxuICAgIC8vIGFyZSBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBjbGllbnQgb3IgaGFzIG5vIG5lZWQgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gICAgLy8gZGVlcCB1cGRhdGVzICgjNzA2MykuXG4gICAgY29uc3QgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuICAgIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gICAgZnVuY3Rpb24gaHlkcmF0ZShlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGluVlByZSkge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgeyB0YWcsIGRhdGEsIGNoaWxkcmVuIH0gPSB2bm9kZTtcbiAgICAgICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICAgICAgdm5vZGUuZWxtID0gZWxtO1xuICAgICAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhLmhvb2spKSAmJiBpc0RlZigoaSA9IGkuaW5pdCkpKVxuICAgICAgICAgICAgICAgIGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTtcbiAgICAgICAgICAgIGlmIChpc0RlZigoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGlsZCBjb21wb25lbnQuIGl0IHNob3VsZCBoYXZlIGh5ZHJhdGVkIGl0cyBvd24gdHJlZS5cbiAgICAgICAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICAgICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEZWYoKGkgPSBkYXRhKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVmKChpID0gaS5kb21Qcm9wcykpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RlZigoaSA9IGkuaW5uZXJIVE1MKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9PSBlbG0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NlcnZlciBpbm5lckhUTUw6ICcsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIGFuZCBjb21wYXJlIGNoaWxkcmVuIGxpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGROb2RlID0gZWxtLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZE5vZGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWh5ZHJhdGUoY2hpbGROb2RlLCBjaGlsZHJlbltpXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaHlkcmF0aW9uQmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bGxJbnZva2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGNvbGxlY3RpbmcgZGVwcyBmb3IgZGVlcCBjbGFzcyBiaW5kaW5ncyBmb3IgZnV0dXJlIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgdHJhdmVyc2UoZGF0YVsnY2xhc3MnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsbS5kYXRhICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgICAgICBlbG0uZGF0YSA9IHZub2RlLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZub2RlLnRhZy5pbmRleE9mKCd2dWUtY29tcG9uZW50JykgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAoIWlzVW5rbm93bkVsZW1lbnQodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09ICh2bm9kZS5pc0NvbW1lbnQgPyA4IDogMyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgICAgICAgaWYgKGlzRGVmKG9sZFZub2RlKSlcbiAgICAgICAgICAgICAgICBpbnZva2VEZXN0cm95SG9vayhvbGRWbm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGluc2VydGVkVm5vZGVRdWV1ZSA9IFtdO1xuICAgICAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgICAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICAgICAgICBpZiAoIWlzUmVhbEVsZW1lbnQgJiYgc2FtZVZub2RlKG9sZFZub2RlLCB2bm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXRjaCBleGlzdGluZyByb290IG5vZGVcbiAgICAgICAgICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBudWxsLCBudWxsLCByZW1vdmVPbmx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1vdW50aW5nIHRvIGEgcmVhbCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQgYW5kIGlmIHdlIGNhbiBwZXJmb3JtXG4gICAgICAgICAgICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGRWbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBvbGRWbm9kZS5oYXNBdHRyaWJ1dGUoU1NSX0FUVFIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyKCdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0hUTUwgbWFya3VwLCBmb3IgZXhhbXBsZSBuZXN0aW5nIGJsb2NrLWxldmVsIGVsZW1lbnRzIGluc2lkZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVpdGhlciBub3Qgc2VydmVyLXJlbmRlcmVkLCBvciBoeWRyYXRpb24gZmFpbGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgICAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRFbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50RWxtID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIFxuICAgICAgICAgICAgICAgIC8vIGV4dHJlbWVseSByYXJlIGVkZ2UgY2FzZTogZG8gbm90IGluc2VydCBpZiBvbGQgZWxlbWVudCBpcyBpbiBhXG4gICAgICAgICAgICAgICAgLy8gbGVhdmluZyB0cmFuc2l0aW9uLiBPbmx5IGhhcHBlbnMgd2hlbiBjb21iaW5pbmcgdHJhbnNpdGlvbiArXG4gICAgICAgICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICAgICAgICBvbGRFbG0uX2xlYXZlQ2IgPyBudWxsIDogcGFyZW50RWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSkpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBwYXJlbnQgcGxhY2Vob2xkZXIgbm9kZSBlbGVtZW50LCByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIGlmIChpc0RlZih2bm9kZS5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hhYmxlID0gaXNQYXRjaGFibGUodm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYnMuZGVzdHJveVtpXShhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGF0Y2hhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICM2NTEzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcuIGZvciBkaXJlY3RpdmVzIHRoYXQgdXNlcyB0aGUgXCJpbnNlcnRlZFwiIGhvb2suXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xvbmUgaW5zZXJ0IGhvb2tzIHRvIGF2b2lkIGJlaW5nIG11dGF0ZWQgZHVyaW5nIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgY3VzdG9tZWQgZGlyZWN0aXZlcyB1bmRlciB0cmFuc2l0aW9uIGdyb3VwLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbG9uZWQgPSBpbnNlcnQuZm5zLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlclJlZihhbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgICAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlVm5vZGVzKFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgICAgIHJldHVybiB2bm9kZS5lbG07XG4gICAgfTtcbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gICAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXModm5vZGUpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBlbXB0eU5vZGUgaXMgbm90IFZOb2RlV2l0aERhdGFcbiAgICAgICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgICAgICBfdXBkYXRlKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBjb25zdCBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgY29uc3QgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgICBjb25zdCBvbGREaXJzID0gbm9ybWFsaXplRGlyZWN0aXZlcyhvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICAgIGNvbnN0IG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzKHZub2RlLmRhdGEuZGlyZWN0aXZlcywgdm5vZGUuY29udGV4dCk7XG4gICAgY29uc3QgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgICBjb25zdCBkaXJzV2l0aFBvc3RwYXRjaCA9IFtdO1xuICAgIGxldCBrZXksIG9sZERpciwgZGlyO1xuICAgIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICAgICAgb2xkRGlyID0gb2xkRGlyc1trZXldO1xuICAgICAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICAgICAgICBjYWxsSG9vayhkaXIsICdiaW5kJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBleGlzdGluZyBkaXJlY3RpdmUsIHVwZGF0ZVxuICAgICAgICAgICAgZGlyLm9sZFZhbHVlID0gb2xkRGlyLnZhbHVlO1xuICAgICAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICAgICAgICBjYWxsSG9vayhkaXIsICd1cGRhdGUnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgY2FsbEluc2VydCA9ICgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsSG9vayhkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGNhbGxJbnNlcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbEluc2VydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FsbEhvb2soZGlyc1dpdGhQb3N0cGF0Y2hbaV0sICdjb21wb25lbnRVcGRhdGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgICAgZm9yIChrZXkgaW4gb2xkRGlycykge1xuICAgICAgICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgICAgICAgICAgY2FsbEhvb2sob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gbm9ybWFsaXplRGlyZWN0aXZlcyhkaXJzLCB2bSkge1xuICAgIGNvbnN0IHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKCFkaXJzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBsZXQgaSwgZGlyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRpciA9IGRpcnNbaV07XG4gICAgICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgICAgIH1cbiAgICAgICAgcmVzW2dldFJhd0Rpck5hbWUoZGlyKV0gPSBkaXI7XG4gICAgICAgIGlmICh2bS5fc2V0dXBTdGF0ZSAmJiB2bS5fc2V0dXBTdGF0ZS5fX3NmYykge1xuICAgICAgICAgICAgY29uc3Qgc2V0dXBEZWYgPSBkaXIuZGVmIHx8IHJlc29sdmVBc3NldCh2bSwgJ19zZXR1cFN0YXRlJywgJ3YtJyArIGRpci5uYW1lKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dXBEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkaXIuZGVmID0ge1xuICAgICAgICAgICAgICAgICAgICBiaW5kOiBzZXR1cERlZixcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlOiBzZXR1cERlZixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyLmRlZiA9IHNldHVwRGVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpci5kZWYgPSBkaXIuZGVmIHx8IHJlc29sdmVBc3NldCh2bS4kb3B0aW9ucywgJ2RpcmVjdGl2ZXMnLCBkaXIubmFtZSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBnZXRSYXdEaXJOYW1lKGRpcikge1xuICAgIHJldHVybiAoZGlyLnJhd05hbWUgfHwgYCR7ZGlyLm5hbWV9LiR7T2JqZWN0LmtleXMoZGlyLm1vZGlmaWVycyB8fCB7fSkuam9pbignLicpfWApO1xufVxuZnVuY3Rpb24gY2FsbEhvb2soZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICAgIGNvbnN0IGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICAgIGlmIChmbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm5vZGUuY29udGV4dCwgYGRpcmVjdGl2ZSAke2Rpci5uYW1lfSAke2hvb2t9IGhvb2tgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGJhc2VNb2R1bGVzID0gW3JlZiwgZGlyZWN0aXZlcyQxXTtcblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgaWYgKGlzRGVmKG9wdHMpICYmIG9wdHMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmF0dHJzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuYXR0cnMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGtleSwgY3VyLCBvbGQ7XG4gICAgY29uc3QgZWxtID0gdm5vZGUuZWxtO1xuICAgIGNvbnN0IG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICBsZXQgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChpc0RlZihhdHRycy5fX29iX18pIHx8IGlzVHJ1ZShhdHRycy5fdl9hdHRyX3Byb3h5KSkge1xuICAgICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgICAgb2xkID0gb2xkQXR0cnNba2V5XTtcbiAgICAgICAgaWYgKG9sZCAhPT0gY3VyKSB7XG4gICAgICAgICAgICBzZXRBdHRyKGVsbSwga2V5LCBjdXIsIHZub2RlLmRhdGEucHJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAjNDM5MTogaW4gSUU5LCBzZXR0aW5nIHR5cGUgY2FuIHJlc2V0IHZhbHVlIGZvciBpbnB1dFt0eXBlPXJhZGlvXVxuICAgIC8vICM2NjY2OiBJRS9FZGdlIGZvcmNlcyBwcm9ncmVzcyB2YWx1ZSBkb3duIHRvIDEgYmVmb3JlIHNldHRpbmcgYSBtYXhcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoKGlzSUUgfHwgaXNFZGdlKSAmJiBhdHRycy52YWx1ZSAhPT0gb2xkQXR0cnMudmFsdWUpIHtcbiAgICAgICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICAgICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgICAgICAgIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQXR0cmlidXRlTlMoeGxpbmtOUywgZ2V0WGxpbmtQcm9wKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldEF0dHIoZWwsIGtleSwgdmFsdWUsIGlzSW5QcmUpIHtcbiAgICBpZiAoaXNJblByZSB8fCBlbC50YWdOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgICAgIC8vIHNldCBhdHRyaWJ1dGUgZm9yIGJsYW5rIHZhbHVlXG4gICAgICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAgICAgICAvLyBidXQgRmxhc2ggZXhwZWN0cyBhIHZhbHVlIG9mIFwidHJ1ZVwiIHdoZW4gdXNlZCBvbiA8ZW1iZWQ+IHRhZ1xuICAgICAgICAgICAgdmFsdWUgPSBrZXkgPT09ICdhbGxvd2Z1bGxzY3JlZW4nICYmIGVsLnRhZ05hbWUgPT09ICdFTUJFRCcgPyAndHJ1ZScgOiBrZXk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGVOUyh4bGlua05TLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYmFzZVNldEF0dHIoZWwsIGtleSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAgICAgLy8gPHRleHRhcmVhPi4uLiBibG9jayB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYW5kIHJlbW92ZSB0aGUgYmxvY2tlclxuICAgICAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFICYmXG4gICAgICAgICAgICAhaXNJRTkgJiZcbiAgICAgICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgICAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJlxuICAgICAgICAgICAgdmFsdWUgIT09ICcnICYmXG4gICAgICAgICAgICAhZWwuX19pZXBoKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja2VyID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIGJsb2NrZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgYmxvY2tlcik7XG4gICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgICAgfVxuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxufVxudmFyIGF0dHJzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlQXR0cnMsXG4gICAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3Mob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gICAgY29uc3QgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgY29uc3Qgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG4gICAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihkYXRhLmNsYXNzKSAmJlxuICAgICAgICAoaXNVbmRlZihvbGREYXRhKSB8fFxuICAgICAgICAgICAgKGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiYgaXNVbmRlZihvbGREYXRhLmNsYXNzKSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGNscyA9IGdlbkNsYXNzRm9yVm5vZGUodm5vZGUpO1xuICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIGNsYXNzZXNcbiAgICBjb25zdCB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gICAgaWYgKGlzRGVmKHRyYW5zaXRpb25DbGFzcykpIHtcbiAgICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgfVxuICAgIC8vIHNldCB0aGUgY2xhc3NcbiAgICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgICBlbC5fcHJldkNsYXNzID0gY2xzO1xuICAgIH1cbn1cbnZhciBrbGFzcyQxID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gICAgdXBkYXRlOiB1cGRhdGVDbGFzc1xufTtcblxuY29uc3QgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcbmZ1bmN0aW9uIHBhcnNlRmlsdGVycyhleHApIHtcbiAgICBsZXQgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICBsZXQgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICBsZXQgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIGxldCBpblJlZ2V4ID0gZmFsc2U7XG4gICAgbGV0IGN1cmx5ID0gMDtcbiAgICBsZXQgc3F1YXJlID0gMDtcbiAgICBsZXQgcGFyZW4gPSAwO1xuICAgIGxldCBsYXN0RmlsdGVySW5kZXggPSAwO1xuICAgIGxldCBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJldiA9IGM7XG4gICAgICAgIGMgPSBleHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVjKVxuICAgICAgICAgICAgICAgIGluU2luZ2xlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5Eb3VibGUpIHtcbiAgICAgICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NWMpXG4gICAgICAgICAgICAgICAgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMHg2MCAmJiBwcmV2ICE9PSAweDVjKVxuICAgICAgICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVjKVxuICAgICAgICAgICAgICAgIGluUmVnZXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjID09PSAweDdjICYmIC8vIHBpcGVcbiAgICAgICAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3YyAmJlxuICAgICAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdjICYmXG4gICAgICAgICAgICAhY3VybHkgJiZcbiAgICAgICAgICAgICFzcXVhcmUgJiZcbiAgICAgICAgICAgICFwYXJlbikge1xuICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGZpcnN0IGZpbHRlciwgZW5kIG9mIGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1c2hGaWx0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgMHgyMjpcbiAgICAgICAgICAgICAgICAgICAgaW5Eb3VibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXCJcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjc6XG4gICAgICAgICAgICAgICAgICAgIGluU2luZ2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vICdcbiAgICAgICAgICAgICAgICBjYXNlIDB4NjA6XG4gICAgICAgICAgICAgICAgICAgIGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gYFxuICAgICAgICAgICAgICAgIGNhc2UgMHgyODpcbiAgICAgICAgICAgICAgICAgICAgcGFyZW4rKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIChcbiAgICAgICAgICAgICAgICBjYXNlIDB4Mjk6XG4gICAgICAgICAgICAgICAgICAgIHBhcmVuLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyApXG4gICAgICAgICAgICAgICAgY2FzZSAweDViOlxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIFtcbiAgICAgICAgICAgICAgICBjYXNlIDB4NWQ6XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZS0tO1xuICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gXVxuICAgICAgICAgICAgICAgIGNhc2UgMHg3YjpcbiAgICAgICAgICAgICAgICAgICAgY3VybHkrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHtcbiAgICAgICAgICAgICAgICBjYXNlIDB4N2Q6XG4gICAgICAgICAgICAgICAgICAgIGN1cmx5LS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gMHgyZikge1xuICAgICAgICAgICAgICAgIC8vIC9cbiAgICAgICAgICAgICAgICBsZXQgaiA9IGkgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBwO1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgZmlyc3Qgbm9uLXdoaXRlc3BhY2UgcHJldiBjaGFyXG4gICAgICAgICAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBleHAuY2hhckF0KGopO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCAhPT0gJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcCB8fCAhdmFsaWREaXZpc2lvbkNoYXJSRS50ZXN0KHApKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXNoRmlsdGVyKCkge1xuICAgICAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9uO1xufVxuZnVuY3Rpb24gd3JhcEZpbHRlcihleHAsIGZpbHRlcikge1xuICAgIGNvbnN0IGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgICAgICByZXR1cm4gYF9mKFwiJHtmaWx0ZXJ9XCIpKCR7ZXhwfSlgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgICAgY29uc3QgYXJncyA9IGZpbHRlci5zbGljZShpICsgMSk7XG4gICAgICAgIHJldHVybiBgX2YoXCIke25hbWV9XCIpKCR7ZXhwfSR7YXJncyAhPT0gJyknID8gJywnICsgYXJncyA6IGFyZ3N9YDtcbiAgICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5mdW5jdGlvbiBiYXNlV2Fybihtc2csIHJhbmdlKSB7XG4gICAgY29uc29sZS5lcnJvcihgW1Z1ZSBjb21waWxlcl06ICR7bXNnfWApO1xufVxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbihtb2R1bGVzLCBrZXkpIHtcbiAgICByZXR1cm4gbW9kdWxlcyA/IG1vZHVsZXMubWFwKG0gPT4gbVtrZXldKS5maWx0ZXIoXyA9PiBfKSA6IFtdO1xufVxuZnVuY3Rpb24gYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIHJhbmdlLCBkeW5hbWljKSB7XG4gICAgKGVsLnByb3BzIHx8IChlbC5wcm9wcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSwgZHluYW1pYyB9LCByYW5nZSkpO1xuICAgIGVsLnBsYWluID0gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRBdHRyKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgICBjb25zdCBhdHRycyA9IGR5bmFtaWNcbiAgICAgICAgPyBlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKVxuICAgICAgICA6IGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKTtcbiAgICBhdHRycy5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWUsIHZhbHVlLCBkeW5hbWljIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbn1cbi8vIGFkZCBhIHJhdyBhdHRyICh1c2UgdGhpcyBpbiBwcmVUcmFuc2Zvcm1zKVxuZnVuY3Rpb24gYWRkUmF3QXR0cihlbCwgbmFtZSwgdmFsdWUsIHJhbmdlKSB7XG4gICAgZWwuYXR0cnNNYXBbbmFtZV0gPSB2YWx1ZTtcbiAgICBlbC5hdHRyc0xpc3QucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lLCB2YWx1ZSB9LCByYW5nZSkpO1xufVxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWNBcmcsIG1vZGlmaWVycywgcmFuZ2UpIHtcbiAgICAoZWwuZGlyZWN0aXZlcyB8fCAoZWwuZGlyZWN0aXZlcyA9IFtdKSkucHVzaChyYW5nZVNldEl0ZW0oe1xuICAgICAgICBuYW1lLFxuICAgICAgICByYXdOYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgYXJnLFxuICAgICAgICBpc0R5bmFtaWNBcmcsXG4gICAgICAgIG1vZGlmaWVyc1xuICAgIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHByZXBlbmRNb2RpZmllck1hcmtlcihzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgICByZXR1cm4gZHluYW1pYyA/IGBfcCgke25hbWV9LFwiJHtzeW1ib2x9XCIpYCA6IHN5bWJvbCArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIGNhcHR1cmVkXG59XG5mdW5jdGlvbiBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBpbXBvcnRhbnQsIHdhcm4sIHJhbmdlLCBkeW5hbWljKSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh3YXJuICYmIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgICAgIHdhcm4oXCJwYXNzaXZlIGFuZCBwcmV2ZW50IGNhbid0IGJlIHVzZWQgdG9nZXRoZXIuIFwiICtcbiAgICAgICAgICAgIFwiUGFzc2l2ZSBoYW5kbGVyIGNhbid0IHByZXZlbnQgZGVmYXVsdCBldmVudC5cIiwgcmFuZ2UpO1xuICAgIH1cbiAgICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgICAvLyB0aGlzIGlzIHRlY2huaWNhbGx5IGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBhdCBsZWFzdCBmb3Igbm93IGJyb3dzZXJzIGFyZVxuICAgIC8vIHRoZSBvbmx5IHRhcmdldCBlbnZzIHRoYXQgaGF2ZSByaWdodC9taWRkbGUgY2xpY2tzLlxuICAgIGlmIChtb2RpZmllcnMucmlnaHQpIHtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nY29udGV4dG1lbnUnOigke25hbWV9KWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICAgICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZGlmaWVycy5taWRkbGUpIHtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBgKCR7bmFtZX0pPT09J2NsaWNrJz8nbW91c2V1cCc6KCR7bmFtZX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICBuYW1lID0gJ21vdXNldXAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGNhcHR1cmUgbW9kaWZpZXJcbiAgICBpZiAobW9kaWZpZXJzLmNhcHR1cmUpIHtcbiAgICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCchJywgbmFtZSwgZHluYW1pYyk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllcnMub25jZSkge1xuICAgICAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucGFzc2l2ZTtcbiAgICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignJicsIG5hbWUsIGR5bmFtaWMpO1xuICAgIH1cbiAgICBsZXQgZXZlbnRzO1xuICAgIGlmIChtb2RpZmllcnMubmF0aXZlKSB7XG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICAgIH1cbiAgICBjb25zdCBuZXdIYW5kbGVyID0gcmFuZ2VTZXRJdGVtKHsgdmFsdWU6IHZhbHVlLnRyaW0oKSwgZHluYW1pYyB9LCByYW5nZSk7XG4gICAgaWYgKG1vZGlmaWVycyAhPT0gZW1wdHlPYmplY3QpIHtcbiAgICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgICBpbXBvcnRhbnQgPyBoYW5kbGVycy51bnNoaWZ0KG5ld0hhbmRsZXIpIDogaGFuZGxlcnMucHVzaChuZXdIYW5kbGVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICAgICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICAgIH1cbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UmF3QmluZGluZ0F0dHIoZWwsIG5hbWUpIHtcbiAgICByZXR1cm4gKGVsLnJhd0F0dHJzTWFwWyc6JyArIG5hbWVdIHx8XG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LWJpbmQ6JyArIG5hbWVdIHx8XG4gICAgICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdKTtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyKGVsLCBuYW1lLCBnZXRTdGF0aWMpIHtcbiAgICBjb25zdCBkeW5hbWljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fCBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1iaW5kOicgKyBuYW1lKTtcbiAgICBpZiAoZHluYW1pY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmlsdGVycyhkeW5hbWljVmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChnZXRTdGF0aWMgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY1ZhbHVlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSk7XG4gICAgICAgIGlmIChzdGF0aWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RhdGljVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gbm90ZTogdGhpcyBvbmx5IHJlbW92ZXMgdGhlIGF0dHIgZnJvbSB0aGUgQXJyYXkgKGF0dHJzTGlzdCkgc28gdGhhdCBpdFxuLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbi8vIEJ5IGRlZmF1bHQgaXQgZG9lcyBOT1QgcmVtb3ZlIGl0IGZyb20gdGhlIG1hcCAoYXR0cnNNYXApIGJlY2F1c2UgdGhlIG1hcCBpc1xuLy8gbmVlZGVkIGR1cmluZyBjb2RlZ2VuLlxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgbmFtZSwgcmVtb3ZlRnJvbU1hcCkge1xuICAgIGxldCB2YWw7XG4gICAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGlzdFtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICAgICAgZGVsZXRlIGVsLmF0dHJzTWFwW25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIG5hbWUpIHtcbiAgICBjb25zdCBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IGxpc3RbaV07XG4gICAgICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJhbmdlU2V0SXRlbShpdGVtLCByYW5nZSkge1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlbS5zdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICovXG5mdW5jdGlvbiBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycykge1xuICAgIGNvbnN0IHsgbnVtYmVyLCB0cmltIH0gPSBtb2RpZmllcnMgfHwge307XG4gICAgY29uc3QgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICAgIGxldCB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICAgIGlmICh0cmltKSB7XG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbiA9XG4gICAgICAgICAgICBgKHR5cGVvZiAke2Jhc2VWYWx1ZUV4cHJlc3Npb259ID09PSAnc3RyaW5nJ2AgK1xuICAgICAgICAgICAgICAgIGA/ICR7YmFzZVZhbHVlRXhwcmVzc2lvbn0udHJpbSgpYCArXG4gICAgICAgICAgICAgICAgYDogJHtiYXNlVmFsdWVFeHByZXNzaW9ufSlgO1xuICAgIH1cbiAgICBpZiAobnVtYmVyKSB7XG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgICB9XG4gICAgY29uc3QgYXNzaWdubWVudCA9IGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCB2YWx1ZUV4cHJlc3Npb24pO1xuICAgIGVsLm1vZGVsID0ge1xuICAgICAgICB2YWx1ZTogYCgke3ZhbHVlfSlgLFxuICAgICAgICBleHByZXNzaW9uOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSksXG4gICAgICAgIGNhbGxiYWNrOiBgZnVuY3Rpb24gKCR7YmFzZVZhbHVlRXhwcmVzc2lvbn0pIHske2Fzc2lnbm1lbnR9fWBcbiAgICB9O1xufVxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlZ2VuIGhlbHBlciBmb3IgZ2VuZXJhdGluZyB2LW1vZGVsIHZhbHVlIGFzc2lnbm1lbnQgY29kZS5cbiAqL1xuZnVuY3Rpb24gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpIHtcbiAgICBjb25zdCByZXMgPSBwYXJzZU1vZGVsKHZhbHVlKTtcbiAgICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYCR7dmFsdWV9PSR7YXNzaWdubWVudH1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGAkc2V0KCR7cmVzLmV4cH0sICR7cmVzLmtleX0sICR7YXNzaWdubWVudH0pYDtcbiAgICB9XG59XG4vKipcbiAqIFBhcnNlIGEgdi1tb2RlbCBleHByZXNzaW9uIGludG8gYSBiYXNlIHBhdGggYW5kIGEgZmluYWwga2V5IHNlZ21lbnQuXG4gKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBQb3NzaWJsZSBjYXNlczpcbiAqXG4gKiAtIHRlc3RcbiAqIC0gdGVzdFtrZXldXG4gKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAqIC0gdGVzdFtcImFcIl1ba2V5XVxuICogLSB4eHgudGVzdFthW2FdLnRlc3QxW2tleV1dXG4gKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAqXG4gKi9cbmxldCBsZW4sIHN0ciwgY2hyLCBpbmRleCwgZXhwcmVzc2lvblBvcywgZXhwcmVzc2lvbkVuZFBvcztcbmZ1bmN0aW9uIHBhcnNlTW9kZWwodmFsKSB7XG4gICAgLy8gRml4IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUvcHVsbC83NzMwXG4gICAgLy8gYWxsb3cgdi1tb2RlbD1cIm9iai52YWwgXCIgKHRyYWlsaW5nIHdoaXRlc3BhY2UpXG4gICAgdmFsID0gdmFsLnRyaW0oKTtcbiAgICBsZW4gPSB2YWwubGVuZ3RoO1xuICAgIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICAgICAgaW5kZXggPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCArIDEpICsgJ1wiJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXhwOiB2YWwsXG4gICAgICAgICAgICAgICAga2V5OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0ciA9IHZhbDtcbiAgICBpbmRleCA9IGV4cHJlc3Npb25Qb3MgPSBleHByZXNzaW9uRW5kUG9zID0gMDtcbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICAgIGNociA9IG5leHQoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgICAgICAgIHBhcnNlU3RyaW5nKGNocik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hyID09PSAweDViKSB7XG4gICAgICAgICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICAgICAga2V5OiB2YWwuc2xpY2UoZXhwcmVzc2lvblBvcyArIDEsIGV4cHJlc3Npb25FbmRQb3MpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5leHQoKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xufVxuZnVuY3Rpb24gZW9mKCkge1xuICAgIHJldHVybiBpbmRleCA+PSBsZW47XG59XG5mdW5jdGlvbiBpc1N0cmluZ1N0YXJ0KGNocikge1xuICAgIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3O1xufVxuZnVuY3Rpb24gcGFyc2VCcmFja2V0KGNocikge1xuICAgIGxldCBpbkJyYWNrZXQgPSAxO1xuICAgIGV4cHJlc3Npb25Qb3MgPSBpbmRleDtcbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICAgIGNociA9IG5leHQoKTtcbiAgICAgICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHIgPT09IDB4NWIpXG4gICAgICAgICAgICBpbkJyYWNrZXQrKztcbiAgICAgICAgaWYgKGNociA9PT0gMHg1ZClcbiAgICAgICAgICAgIGluQnJhY2tldC0tO1xuICAgICAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICAgICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nKGNocikge1xuICAgIGNvbnN0IHN0cmluZ1F1b3RlID0gY2hyO1xuICAgIHdoaWxlICghZW9mKCkpIHtcbiAgICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgICBpZiAoY2hyID09PSBzdHJpbmdRdW90ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmxldCB3YXJuJDE7XG4vLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4vLyBzbyB3ZSB1c2VkIHNvbWUgcmVzZXJ2ZWQgdG9rZW5zIGR1cmluZyBjb21waWxlLlxuY29uc3QgUkFOR0VfVE9LRU4gPSAnX19yJztcbmNvbnN0IENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5mdW5jdGlvbiBtb2RlbCQxKGVsLCBkaXIsIF93YXJuKSB7XG4gICAgd2FybiQxID0gX3dhcm47XG4gICAgY29uc3QgdmFsdWUgPSBkaXIudmFsdWU7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgICBjb25zdCB0YWcgPSBlbC50YWc7XG4gICAgY29uc3QgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gICAge1xuICAgICAgICAvLyBpbnB1dHMgd2l0aCB0eXBlPVwiZmlsZVwiIGFyZSByZWFkIG9ubHkgYW5kIHNldHRpbmcgdGhlIGlucHV0J3NcbiAgICAgICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgIHdhcm4kMShgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIiB0eXBlPVwiZmlsZVwiPjpcXG5gICtcbiAgICAgICAgICAgICAgICBgRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5gLCBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIGdlblNlbGVjdChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgIGdlbkNoZWNrYm94TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgICAgICBnZW5EZWZhdWx0TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgICBnZW5Db21wb25lbnRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsIGRvZXNuJ3QgbmVlZCBleHRyYSBydW50aW1lXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhcm4kMShgPCR7ZWwudGFnfSB2LW1vZGVsPVwiJHt2YWx1ZX1cIj46IGAgK1xuICAgICAgICAgICAgYHYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gYCArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXQncyByZWNvbW1lbmRlZCB0byBcIiArXG4gICAgICAgICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nLCBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddKTtcbiAgICB9XG4gICAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XG4gICAgY29uc3QgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gICAgY29uc3QgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgICBjb25zdCB0cnVlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0cnVlLXZhbHVlJykgfHwgJ3RydWUnO1xuICAgIGNvbnN0IGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCBgQXJyYXkuaXNBcnJheSgke3ZhbHVlfSlgICtcbiAgICAgICAgYD9faSgke3ZhbHVlfSwke3ZhbHVlQmluZGluZ30pPi0xYCArXG4gICAgICAgICh0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICAgID8gYDooJHt2YWx1ZX0pYFxuICAgICAgICAgICAgOiBgOl9xKCR7dmFsdWV9LCR7dHJ1ZVZhbHVlQmluZGluZ30pYCkpO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBgdmFyICQkYT0ke3ZhbHVlfSxgICtcbiAgICAgICAgJyQkZWw9JGV2ZW50LnRhcmdldCwnICtcbiAgICAgICAgYCQkYz0kJGVsLmNoZWNrZWQ/KCR7dHJ1ZVZhbHVlQmluZGluZ30pOigke2ZhbHNlVmFsdWVCaW5kaW5nfSk7YCArXG4gICAgICAgICdpZihBcnJheS5pc0FycmF5KCQkYSkpeycgK1xuICAgICAgICBgdmFyICQkdj0ke251bWJlciA/ICdfbignICsgdmFsdWVCaW5kaW5nICsgJyknIDogdmFsdWVCaW5kaW5nfSxgICtcbiAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgICAgYGlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJigke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLmNvbmNhdChbJCR2XSknKX0pfWAgK1xuICAgICAgICBgZWxzZXskJGk+LTEmJigke2dlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKX0pfWAgK1xuICAgICAgICBgfWVsc2V7JHtnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpfX1gLCBudWxsLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpIHtcbiAgICBjb25zdCBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgICBsZXQgdmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd2YWx1ZScpIHx8ICdudWxsJztcbiAgICB2YWx1ZUJpbmRpbmcgPSBudW1iZXIgPyBgX24oJHt2YWx1ZUJpbmRpbmd9KWAgOiB2YWx1ZUJpbmRpbmc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLCBgX3EoJHt2YWx1ZX0sJHt2YWx1ZUJpbmRpbmd9KWApO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpIHtcbiAgICBjb25zdCBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgICBjb25zdCBzZWxlY3RlZFZhbCA9IGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCArXG4gICAgICAgIGAuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KWAgK1xuICAgICAgICBgLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO2AgK1xuICAgICAgICBgcmV0dXJuICR7bnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCd9fSlgO1xuICAgIGNvbnN0IGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgICBsZXQgY29kZSA9IGB2YXIgJCRzZWxlY3RlZFZhbCA9ICR7c2VsZWN0ZWRWYWx9O2A7XG4gICAgY29kZSA9IGAke2NvZGV9ICR7Z2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpfWA7XG4gICAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuZnVuY3Rpb24gZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKSB7XG4gICAgY29uc3QgdHlwZSA9IGVsLmF0dHJzTWFwLnR5cGU7XG4gICAgLy8gd2FybiBpZiB2LWJpbmQ6dmFsdWUgY29uZmxpY3RzIHdpdGggdi1tb2RlbFxuICAgIC8vIGV4Y2VwdCBmb3IgaW5wdXRzIHdpdGggdi1iaW5kOnR5cGVcbiAgICB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp2YWx1ZSddIHx8IGVsLmF0dHJzTWFwWyc6dmFsdWUnXTtcbiAgICAgICAgY29uc3QgdHlwZUJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnR5cGUnXSB8fCBlbC5hdHRyc01hcFsnOnR5cGUnXTtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0eXBlQmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICAgICAgICB3YXJuJDEoYCR7YmluZGluZ309XCIke3ZhbHVlfVwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBgICtcbiAgICAgICAgICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsIGVsLnJhd0F0dHJzTWFwW2JpbmRpbmddKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGxhenksIG51bWJlciwgdHJpbSB9ID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIGNvbnN0IG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgICBjb25zdCBldmVudCA9IGxhenkgPyAnY2hhbmdlJyA6IHR5cGUgPT09ICdyYW5nZScgPyBSQU5HRV9UT0tFTiA6ICdpbnB1dCc7XG4gICAgbGV0IHZhbHVlRXhwcmVzc2lvbiA9ICckZXZlbnQudGFyZ2V0LnZhbHVlJztcbiAgICBpZiAodHJpbSkge1xuICAgICAgICB2YWx1ZUV4cHJlc3Npb24gPSBgJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClgO1xuICAgIH1cbiAgICBpZiAobnVtYmVyKSB7XG4gICAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IGBfbigke3ZhbHVlRXhwcmVzc2lvbn0pYDtcbiAgICB9XG4gICAgbGV0IGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgICBpZiAobmVlZENvbXBvc2l0aW9uR3VhcmQpIHtcbiAgICAgICAgY29kZSA9IGBpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47JHtjb2RlfWA7XG4gICAgfVxuICAgIGFkZFByb3AoZWwsICd2YWx1ZScsIGAoJHt2YWx1ZX0pYCk7XG4gICAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICAgIGlmICh0cmltIHx8IG51bWJlcikge1xuICAgICAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICAgIH1cbn1cblxuLy8gbm9ybWFsaXplIHYtbW9kZWwgZXZlbnQgdG9rZW5zIHRoYXQgY2FuIG9ubHkgYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lLlxuLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuLy8gdGhlIHdob2xlIHBvaW50IGlzIGVuc3VyaW5nIHRoZSB2LW1vZGVsIGNhbGxiYWNrIGdldHMgY2FsbGVkIGJlZm9yZVxuLy8gdXNlci1hdHRhY2hlZCBoYW5kbGVycy5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyhvbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbltSQU5HRV9UT0tFTl0pKSB7XG4gICAgICAgIC8vIElFIGlucHV0W3R5cGU9cmFuZ2VdIG9ubHkgc3VwcG9ydHMgYGNoYW5nZWAgZXZlbnRcbiAgICAgICAgY29uc3QgZXZlbnQgPSBpc0lFID8gJ2NoYW5nZScgOiAnaW5wdXQnO1xuICAgICAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgICAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICAgIH1cbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAgIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgICAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgICAgICBkZWxldGUgb25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dO1xuICAgIH1cbn1cbmxldCB0YXJnZXQ7XG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlcihldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgIGNvbnN0IF90YXJnZXQgPSB0YXJnZXQ7IC8vIHNhdmUgY3VycmVudCB0YXJnZXQgZWxlbWVudCBpbiBjbG9zdXJlXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCByZXMgPSBoYW5kbGVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW92ZShldmVudCwgb25jZUhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vICM5NDQ2OiBGaXJlZm94IDw9IDUzIChpbiBwYXJ0aWN1bGFyLCBFU1IgNTIpIGhhcyBpbmNvcnJlY3QgRXZlbnQudGltZVN0YW1wXG4vLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4vLyBzYWZlIHRvIGV4Y2x1ZGUuXG5jb25zdCB1c2VNaWNyb3Rhc2tGaXggPSBpc1VzaW5nTWljcm9UYXNrICYmICEoaXNGRiAmJiBOdW1iZXIoaXNGRlsxXSkgPD0gNTMpO1xuZnVuY3Rpb24gYWRkKG5hbWUsIGhhbmRsZXIsIGNhcHR1cmUsIHBhc3NpdmUpIHtcbiAgICAvLyBhc3luYyBlZGdlIGNhc2UgIzY1NjY6IGlubmVyIGNsaWNrIGV2ZW50IHRyaWdnZXJzIHBhdGNoLCBldmVudCBoYW5kbGVyXG4gICAgLy8gYXR0YWNoZWQgdG8gb3V0ZXIgZWxlbWVudCBkdXJpbmcgcGF0Y2gsIGFuZCB0cmlnZ2VyZWQgYWdhaW4uIFRoaXNcbiAgICAvLyBoYXBwZW5zIGJlY2F1c2UgYnJvd3NlcnMgZmlyZSBtaWNyb3Rhc2sgdGlja3MgYmV0d2VlbiBldmVudCBwcm9wYWdhdGlvbi5cbiAgICAvLyB0aGUgc29sdXRpb24gaXMgc2ltcGxlOiB3ZSBzYXZlIHRoZSB0aW1lc3RhbXAgd2hlbiBhIGhhbmRsZXIgaXMgYXR0YWNoZWQsXG4gICAgLy8gYW5kIHRoZSBoYW5kbGVyIHdvdWxkIG9ubHkgZmlyZSBpZiB0aGUgZXZlbnQgcGFzc2VkIHRvIGl0IHdhcyBmaXJlZFxuICAgIC8vIEFGVEVSIGl0IHdhcyBhdHRhY2hlZC5cbiAgICBpZiAodXNlTWljcm90YXNrRml4KSB7XG4gICAgICAgIGNvbnN0IGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGhhbmRsZXI7XG4gICAgICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBoYW5kbGVyID0gb3JpZ2luYWwuX3dyYXBwZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gbm8gYnViYmxpbmcsIHNob3VsZCBhbHdheXMgZmlyZS5cbiAgICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAgICAgLy8gY2VydGFpbiB3ZWlyZCBlbnZpcm9ubWVudHMuLi5cbiAgICAgICAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgfHxcbiAgICAgICAgICAgICAgICAvLyBldmVudCBpcyBmaXJlZCBhZnRlciBoYW5kbGVyIGF0dGFjaG1lbnRcbiAgICAgICAgICAgICAgICBlLnRpbWVTdGFtcCA+PSBhdHRhY2hlZFRpbWVzdGFtcCB8fFxuICAgICAgICAgICAgICAgIC8vIGJhaWwgZm9yIGVudmlyb25tZW50cyB0aGF0IGhhdmUgYnVnZ3kgZXZlbnQudGltZVN0YW1wIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgICAgIC8vICM5NDYyIGlPUyA5IGJ1ZzogZXZlbnQudGltZVN0YW1wIGlzIDAgYWZ0ZXIgaGlzdG9yeS5wdXNoU3RhdGVcbiAgICAgICAgICAgICAgICAvLyAjOTY4MSBRdFdlYkVuZ2luZSBldmVudC50aW1lU3RhbXAgaXMgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgICAgICAgICBlLnRpbWVTdGFtcCA8PSAwIHx8XG4gICAgICAgICAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAgICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgICAvLyBzdGFydGluZyByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCBzdXBwb3J0c1Bhc3NpdmUgPyB7IGNhcHR1cmUsIHBhc3NpdmUgfSA6IGNhcHR1cmUpO1xufVxuZnVuY3Rpb24gcmVtb3ZlKG5hbWUsIGhhbmRsZXIsIGNhcHR1cmUsIF90YXJnZXQpIHtcbiAgICAoX3RhcmdldCB8fCB0YXJnZXQpLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLCBjYXB0dXJlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURPTUxpc3RlbmVycyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgIGNvbnN0IG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgICAvLyB2bm9kZSBpcyBlbXB0eSB3aGVuIHJlbW92aW5nIGFsbCBsaXN0ZW5lcnMsXG4gICAgLy8gYW5kIHVzZSBvbGQgdm5vZGUgZG9tIGVsZW1lbnRcbiAgICB0YXJnZXQgPSB2bm9kZS5lbG0gfHwgb2xkVm5vZGUuZWxtO1xuICAgIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gICAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkLCByZW1vdmUsIGNyZWF0ZU9uY2VIYW5kbGVyLCB2bm9kZS5jb250ZXh0KTtcbiAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG59XG52YXIgZXZlbnRzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICAgIHVwZGF0ZTogdXBkYXRlRE9NTGlzdGVuZXJzLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZW1wdHlOb2RlIGhhcyBhY3R1YWxseSBkYXRhXG4gICAgZGVzdHJveTogKHZub2RlKSA9PiB1cGRhdGVET01MaXN0ZW5lcnModm5vZGUsIGVtcHR5Tm9kZSlcbn07XG5cbmxldCBzdmdDb250YWluZXI7XG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyhvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLmRvbVByb3BzKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEuZG9tUHJvcHMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGtleSwgY3VyO1xuICAgIGNvbnN0IGVsbSA9IHZub2RlLmVsbTtcbiAgICBjb25zdCBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgbGV0IHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSB8fCBpc1RydWUocHJvcHMuX3ZfYXR0cl9wcm94eSkpIHtcbiAgICAgICAgcHJvcHMgPSB2bm9kZS5kYXRhLmRvbVByb3BzID0gZXh0ZW5kKHt9LCBwcm9wcyk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBwcm9wcykpIHtcbiAgICAgICAgICAgIGVsbVtrZXldID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAgICAgLy8gaWdub3JlIGNoaWxkcmVuIGlmIHRoZSBub2RlIGhhcyB0ZXh0Q29udGVudCBvciBpbm5lckhUTUwsXG4gICAgICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgICAgIGlmIChrZXkgPT09ICd0ZXh0Q29udGVudCcgfHwga2V5ID09PSAnaW5uZXJIVE1MJykge1xuICAgICAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gIzY2MDEgd29yayBhcm91bmQgQ2hyb21lIHZlcnNpb24gPD0gNTUgYnVnIHdoZXJlIHNpbmdsZSB0ZXh0Tm9kZVxuICAgICAgICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgICAgICAgIGlmIChlbG0uY2hpbGROb2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlQ2hpbGQoZWxtLmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICd2YWx1ZScgJiYgZWxtLnRhZ05hbWUgIT09ICdQUk9HUkVTUycpIHtcbiAgICAgICAgICAgIC8vIHN0b3JlIHZhbHVlIGFzIF92YWx1ZSBhcyB3ZWxsIHNpbmNlXG4gICAgICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICAgICAgICBlbG0uX3ZhbHVlID0gY3VyO1xuICAgICAgICAgICAgLy8gYXZvaWQgcmVzZXR0aW5nIGN1cnNvciBwb3NpdGlvbiB3aGVuIHZhbHVlIGlzIHRoZSBzYW1lXG4gICAgICAgICAgICBjb25zdCBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICAgICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmXG4gICAgICAgICAgICBpc1NWRyhlbG0udGFnTmFtZSkgJiZcbiAgICAgICAgICAgIGlzVW5kZWYoZWxtLmlubmVySFRNTCkpIHtcbiAgICAgICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgICAgICAgc3ZnQ29udGFpbmVyID0gc3ZnQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IGA8c3ZnPiR7Y3VyfTwvc3ZnPmA7XG4gICAgICAgICAgICBjb25zdCBzdmcgPSBzdmdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoc3ZnLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBlbG0uYXBwZW5kQ2hpbGQoc3ZnLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBza2lwIHRoZSB1cGRhdGUgaWYgb2xkIGFuZCBuZXcgVkRPTSBzdGF0ZSBpcyB0aGUgc2FtZS5cbiAgICAgICAgLy8gYHZhbHVlYCBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgYmVjYXVzZSB0aGUgRE9NIHZhbHVlIG1heSBiZSB0ZW1wb3JhcmlseVxuICAgICAgICAvLyBvdXQgb2Ygc3luYyB3aXRoIFZET00gc3RhdGUgZHVlIHRvIGZvY3VzLCBjb21wb3NpdGlvbiBhbmQgbW9kaWZpZXJzLlxuICAgICAgICAvLyBUaGlzICAjNDUyMSBieSBza2lwcGluZyB0aGUgdW5uZWNlc3NhcnkgYGNoZWNrZWRgIHVwZGF0ZS5cbiAgICAgICAgY3VyICE9PSBvbGRQcm9wc1trZXldKSB7XG4gICAgICAgICAgICAvLyBzb21lIHByb3BlcnR5IHVwZGF0ZXMgY2FuIHRocm93XG4gICAgICAgICAgICAvLyBlLmcuIGB2YWx1ZWAgb24gPHByb2dyZXNzPiB3LyBub24tZmluaXRlIHZhbHVlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUoZWxtLCBjaGVja1ZhbCkge1xuICAgIHJldHVybiAoXG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgIWVsbS5jb21wb3NpbmcgJiZcbiAgICAgICAgKGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgICAgICAgICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICAgICAgICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpKSk7XG59XG5mdW5jdGlvbiBpc05vdEluRm9jdXNBbmREaXJ0eShlbG0sIGNoZWNrVmFsKSB7XG4gICAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAgIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICAgIGxldCBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgICAvLyAjNjE1N1xuICAgIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICAgIHRyeSB7XG4gICAgICAgIG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07XG4gICAgfVxuICAgIGNhdGNoIChlKSB7IH1cbiAgICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsO1xufVxuZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMoZWxtLCBuZXdWYWwpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGVsbS52YWx1ZTtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICAgIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgICAgIGlmIChtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RpZmllcnMudHJpbSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbDtcbn1cbnZhciBkb21Qcm9wcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICAgIHVwZGF0ZTogdXBkYXRlRE9NUHJvcHNcbn07XG5cbmNvbnN0IHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gICAgY29uc3QgcmVzID0ge307XG4gICAgY29uc3QgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gICAgY29uc3QgcHJvcGVydHlEZWxpbWl0ZXIgPSAvOiguKykvO1xuICAgIGNzc1RleHQuc3BsaXQobGlzdERlbGltaXRlcikuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gaXRlbS5zcGxpdChwcm9wZXJ0eURlbGltaXRlcik7XG4gICAgICAgICAgICB0bXAubGVuZ3RoID4gMSAmJiAocmVzW3RtcFswXS50cmltKCldID0gdG1wWzFdLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xufSk7XG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhKGRhdGEpIHtcbiAgICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgICAvLyBzdGF0aWMgc3R5bGUgaXMgcHJlLXByb2Nlc3NlZCBpbnRvIGFuIG9iamVjdCBkdXJpbmcgY29tcGlsYXRpb25cbiAgICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICAgIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKSA6IHN0eWxlO1xufVxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGJpbmRpbmdTdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpbmRpbmdTdHlsZTtcbn1cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBsZXQgc3R5bGVEYXRhO1xuICAgIGlmIChjaGVja0NoaWxkKSB7XG4gICAgICAgIGxldCBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICAgICAgd2hpbGUgKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUgJiZcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAgICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICAgIGxldCBwYXJlbnROb2RlID0gdm5vZGU7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBwYXJlbnROb2RlLnBhcmVudCBub3QgVk5vZGVXaXRoRGF0YVxuICAgIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgICAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuY29uc3QgY3NzVmFyUkUgPSAvXi0tLztcbmNvbnN0IGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG5jb25zdCBzZXRQcm9wID0gKGVsLCBuYW1lLCB2YWwpID0+IHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkoaHlwaGVuYXRlKG5hbWUpLCB2YWwucmVwbGFjZShpbXBvcnRhbnRSRSwgJycpLCAnaW1wb3J0YW50Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgLy8gU3VwcG9ydCB2YWx1ZXMgYXJyYXkgY3JlYXRlZCBieSBhdXRvcHJlZml4ZXIsIGUuZy5cbiAgICAgICAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgICAgICAgIC8vIFNldCB0aGVtIG9uZSBieSBvbmUsIGFuZCB0aGUgYnJvd3NlciB3aWxsIG9ubHkgc2V0IHRob3NlIGl0IGNhbiByZWNvZ25pemVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgdmVuZG9yTmFtZXMgPSBbJ1dlYmtpdCcsICdNb3onLCAnbXMnXTtcbmxldCBlbXB0eVN0eWxlO1xuY29uc3Qgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gICAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICAgIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiBwcm9wIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICAgIGNvbnN0IGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5mdW5jdGlvbiB1cGRhdGVTdHlsZShvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBjb25zdCBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICBjb25zdCBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgICBpZiAoaXNVbmRlZihkYXRhLnN0YXRpY1N0eWxlKSAmJlxuICAgICAgICBpc1VuZGVmKGRhdGEuc3R5bGUpICYmXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNTdHlsZSkgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLnN0eWxlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjdXIsIG5hbWU7XG4gICAgY29uc3QgZWwgPSB2bm9kZS5lbG07XG4gICAgY29uc3Qgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICAgIGNvbnN0IG9sZFN0eWxlQmluZGluZyA9IG9sZERhdGEubm9ybWFsaXplZFN0eWxlIHx8IG9sZERhdGEuc3R5bGUgfHwge307XG4gICAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgICBjb25zdCBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcbiAgICBjb25zdCBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyh2bm9kZS5kYXRhLnN0eWxlKSB8fCB7fTtcbiAgICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gICAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAgIC8vIHRvIG11dGF0ZSBpdC5cbiAgICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXykgPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xuICAgIGNvbnN0IG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuICAgIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgICAgICBpZiAoaXNVbmRlZihuZXdTdHlsZVtuYW1lXSkpIHtcbiAgICAgICAgICAgIHNldFByb3AoZWwsIG5hbWUsICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICAgICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgICAgIC8vIGllOSBzZXR0aW5nIHRvIG51bGwgaGFzIG5vIGVmZmVjdCwgbXVzdCB1c2UgZW1wdHkgc3RyaW5nXG4gICAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbn1cbnZhciBzdHlsZSQxID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gICAgdXBkYXRlOiB1cGRhdGVTdHlsZVxufTtcblxuY29uc3Qgd2hpdGVzcGFjZVJFJDEgPSAvXFxzKy87XG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUkMSkuZm9yRWFjaChjID0+IGVsLmNsYXNzTGlzdC5hZGQoYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBjdXIgPSBgICR7ZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnfSBgO1xuICAgICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgICAgICBjbHMuc3BsaXQod2hpdGVzcGFjZVJFJDEpLmZvckVhY2goYyA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVsLmNsYXNzTGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGN1ciA9IGAgJHtlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyd9IGA7XG4gICAgICAgIGNvbnN0IHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICAgICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbihkZWYpIHtcbiAgICBpZiAoIWRlZikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBpZiAoZGVmLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuZChyZXMsIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZi5uYW1lIHx8ICd2JykpO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuZChyZXMsIGRlZik7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYpO1xuICAgIH1cbn1cbmNvbnN0IGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKG5hbWUgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVudGVyQ2xhc3M6IGAke25hbWV9LWVudGVyYCxcbiAgICAgICAgZW50ZXJUb0NsYXNzOiBgJHtuYW1lfS1lbnRlci10b2AsXG4gICAgICAgIGVudGVyQWN0aXZlQ2xhc3M6IGAke25hbWV9LWVudGVyLWFjdGl2ZWAsXG4gICAgICAgIGxlYXZlQ2xhc3M6IGAke25hbWV9LWxlYXZlYCxcbiAgICAgICAgbGVhdmVUb0NsYXNzOiBgJHtuYW1lfS1sZWF2ZS10b2AsXG4gICAgICAgIGxlYXZlQWN0aXZlQ2xhc3M6IGAke25hbWV9LWxlYXZlLWFjdGl2ZWBcbiAgICB9O1xufSk7XG5jb25zdCBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbmNvbnN0IFRSQU5TSVRJT04gPSAndHJhbnNpdGlvbic7XG5jb25zdCBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcbi8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbmxldCB0cmFuc2l0aW9uUHJvcCA9ICd0cmFuc2l0aW9uJztcbmxldCB0cmFuc2l0aW9uRW5kRXZlbnQgPSAndHJhbnNpdGlvbmVuZCc7XG5sZXQgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xubGV0IGFuaW1hdGlvbkVuZEV2ZW50ID0gJ2FuaW1hdGlvbmVuZCc7XG5pZiAoaGFzVHJhbnNpdGlvbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgICAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gICAgfVxuICAgIGlmICh3aW5kb3cub25hbmltYXRpb25lbmQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgICAgIGFuaW1hdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdEFuaW1hdGlvbkVuZCc7XG4gICAgfVxufVxuLy8gYmluZGluZyB0byB3aW5kb3cgaXMgbmVjZXNzYXJ5IHRvIG1ha2UgaG90IHJlbG9hZCB3b3JrIGluIElFIGluIHN0cmljdCBtb2RlXG5jb25zdCByYWYgPSBpbkJyb3dzZXJcbiAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgICAgICA6IHNldFRpbWVvdXRcbiAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZuID0+IGZuKCk7XG5mdW5jdGlvbiBuZXh0RnJhbWUoZm4pIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJhZihmbik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICAgIGNvbnN0IHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gICAgaWYgKHRyYW5zaXRpb25DbGFzc2VzLmluZGV4T2YoY2xzKSA8IDApIHtcbiAgICAgICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgICBhZGRDbGFzcyhlbCwgY2xzKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGNscykge1xuICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgcmVtb3ZlJDIoZWwuX3RyYW5zaXRpb25DbGFzc2VzLCBjbHMpO1xuICAgIH1cbiAgICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cbmZ1bmN0aW9uIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgZXhwZWN0ZWRUeXBlLCBjYikge1xuICAgIGNvbnN0IHsgdHlwZSwgdGltZW91dCwgcHJvcENvdW50IH0gPSBnZXRUcmFuc2l0aW9uSW5mbyhlbCwgZXhwZWN0ZWRUeXBlKTtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHJldHVybiBjYigpO1xuICAgIGNvbnN0IGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgIGxldCBlbmRlZCA9IDA7XG4gICAgY29uc3QgZW5kID0gKCkgPT4ge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBvbkVuZCk7XG4gICAgICAgIGNiKCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkVuZCA9IGUgPT4ge1xuICAgICAgICBpZiAoZS50YXJnZXQgPT09IGVsKSB7XG4gICAgICAgICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgICAgICAgICBlbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChlbmRlZCA8IHByb3BDb3VudCkge1xuICAgICAgICAgICAgZW5kKCk7XG4gICAgICAgIH1cbiAgICB9LCB0aW1lb3V0ICsgMSk7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuY29uc3QgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICAvLyBKU0RPTSBtYXkgcmV0dXJuIHVuZGVmaW5lZCBmb3IgdHJhbnNpdGlvbiBwcm9wZXJ0aWVzXG4gICAgY29uc3QgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgY29uc3QgYW5pbWF0aW9uVGltZW91dCA9IGdldFRpbWVvdXQoYW5pbWF0aW9uRGVsYXlzLCBhbmltYXRpb25EdXJhdGlvbnMpO1xuICAgIGxldCB0eXBlO1xuICAgIGxldCB0aW1lb3V0ID0gMDtcbiAgICBsZXQgcHJvcENvdW50ID0gMDtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgICAgIHR5cGUgPSBUUkFOU0lUSU9OO1xuICAgICAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgcHJvcENvdW50ID0gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB0eXBlID0gQU5JTUFUSU9OO1xuICAgICAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICAgICAgICBwcm9wQ291bnQgPSBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gTWF0aC5tYXgodHJhbnNpdGlvblRpbWVvdXQsIGFuaW1hdGlvblRpbWVvdXQpO1xuICAgICAgICB0eXBlID1cbiAgICAgICAgICAgIHRpbWVvdXQgPiAwXG4gICAgICAgICAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgICAgICAgICAgICAgPyBUUkFOU0lUSU9OXG4gICAgICAgICAgICAgICAgICAgIDogQU5JTUFUSU9OXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICAgICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICAgICAgOiBhbmltYXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgICAgICA6IDA7XG4gICAgfVxuICAgIGNvbnN0IGhhc1RyYW5zZm9ybSA9IHR5cGUgPT09IFRSQU5TSVRJT04gJiYgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGltZW91dCxcbiAgICAgICAgcHJvcENvdW50LFxuICAgICAgICBoYXNUcmFuc2Zvcm1cbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VGltZW91dChkZWxheXMsIGR1cmF0aW9ucykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGRlbGF5cyA9IGRlbGF5cy5jb25jYXQoZGVsYXlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoKGQsIGkpID0+IHtcbiAgICAgICAgcmV0dXJuIHRvTXMoZCkgKyB0b01zKGRlbGF5c1tpXSk7XG4gICAgfSkpO1xufVxuLy8gT2xkIHZlcnNpb25zIG9mIENocm9taXVtIChiZWxvdyA2MS4wLjMxNjMuMTAwKSBmb3JtYXRzIGZsb2F0aW5nIHBvaW50ZXIgbnVtYmVyc1xuLy8gaW4gYSBsb2NhbGUtZGVwZW5kZW50IHdheSwgdXNpbmcgYSBjb21tYSBpbnN0ZWFkIG9mIGEgZG90LlxuLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3Rpbmdcbi8vIGFzIGEgZmxvb3IgZnVuY3Rpb24pIGNhdXNpbmcgdW5leHBlY3RlZCBiZWhhdmlvcnNcbmZ1bmN0aW9uIHRvTXMocykge1xuICAgIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkucmVwbGFjZSgnLCcsICcuJykpICogMTAwMDtcbn1cblxuZnVuY3Rpb24gZW50ZXIodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgICBjb25zdCBlbCA9IHZub2RlLmVsbTtcbiAgICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgICAgZWwuX2xlYXZlQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZWwuX2xlYXZlQ2IoKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gICAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjc3MsIHR5cGUsIGVudGVyQ2xhc3MsIGVudGVyVG9DbGFzcywgZW50ZXJBY3RpdmVDbGFzcywgYXBwZWFyQ2xhc3MsIGFwcGVhclRvQ2xhc3MsIGFwcGVhckFjdGl2ZUNsYXNzLCBiZWZvcmVFbnRlciwgZW50ZXIsIGFmdGVyRW50ZXIsIGVudGVyQ2FuY2VsbGVkLCBiZWZvcmVBcHBlYXIsIGFwcGVhciwgYWZ0ZXJBcHBlYXIsIGFwcGVhckNhbmNlbGxlZCwgZHVyYXRpb24gfSA9IGRhdGE7XG4gICAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAgIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAgIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gICAgbGV0IGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBsZXQgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gICAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgICAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICAgICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgfVxuICAgIGNvbnN0IGlzQXBwZWFyID0gIWNvbnRleHQuX2lzTW91bnRlZCB8fCAhdm5vZGUuaXNSb290SW5zZXJ0O1xuICAgIGlmIChpc0FwcGVhciAmJiAhYXBwZWFyICYmIGFwcGVhciAhPT0gJycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydENsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQ2xhc3MgPyBhcHBlYXJDbGFzcyA6IGVudGVyQ2xhc3M7XG4gICAgY29uc3QgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciAmJiBhcHBlYXJBY3RpdmVDbGFzcyA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgICBjb25zdCB0b0NsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyVG9DbGFzcyA/IGFwcGVhclRvQ2xhc3MgOiBlbnRlclRvQ2xhc3M7XG4gICAgY29uc3QgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXIgPyBiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIgOiBiZWZvcmVFbnRlcjtcbiAgICBjb25zdCBlbnRlckhvb2sgPSBpc0FwcGVhciA/IChpc0Z1bmN0aW9uKGFwcGVhcikgPyBhcHBlYXIgOiBlbnRlcikgOiBlbnRlcjtcbiAgICBjb25zdCBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyID8gYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlciA6IGFmdGVyRW50ZXI7XG4gICAgY29uc3QgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXJcbiAgICAgICAgPyBhcHBlYXJDYW5jZWxsZWQgfHwgZW50ZXJDYW5jZWxsZWRcbiAgICAgICAgOiBlbnRlckNhbmNlbGxlZDtcbiAgICBjb25zdCBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihpc09iamVjdChkdXJhdGlvbikgPyBkdXJhdGlvbi5lbnRlciA6IGR1cmF0aW9uKTtcbiAgICBpZiAoZXhwbGljaXRFbnRlckR1cmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdEVudGVyRHVyYXRpb24sICdlbnRlcicsIHZub2RlKTtcbiAgICB9XG4gICAgY29uc3QgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICAgIGNvbnN0IHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG4gICAgY29uc3QgY2IgPSAoZWwuX2VudGVyQ2IgPSBvbmNlKCgpID0+IHtcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudGVyQ2FuY2VsbGVkSG9vayAmJiBlbnRlckNhbmNlbGxlZEhvb2soZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgICB9KSk7XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgY29uc3QgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgICAgICAgaWYgKHBlbmRpbmdOb2RlICYmXG4gICAgICAgICAgICAgICAgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiZcbiAgICAgICAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgICAgbmV4dEZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgdG9DbGFzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRFbnRlckR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHZub2RlLmRhdGEuc2hvdykge1xuICAgICAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH1cbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsZWF2ZSh2bm9kZSwgcm0pIHtcbiAgICBjb25zdCBlbCA9IHZub2RlLmVsbTtcbiAgICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICAgIGlmIChpc0RlZihlbC5fZW50ZXJDYikpIHtcbiAgICAgICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZWwuX2VudGVyQ2IoKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gICAgaWYgKGlzVW5kZWYoZGF0YSkgfHwgZWwubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJtKCk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNzcywgdHlwZSwgbGVhdmVDbGFzcywgbGVhdmVUb0NsYXNzLCBsZWF2ZUFjdGl2ZUNsYXNzLCBiZWZvcmVMZWF2ZSwgbGVhdmUsIGFmdGVyTGVhdmUsIGxlYXZlQ2FuY2VsbGVkLCBkZWxheUxlYXZlLCBkdXJhdGlvbiB9ID0gZGF0YTtcbiAgICBjb25zdCBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgY29uc3QgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuICAgIGNvbnN0IGV4cGxpY2l0TGVhdmVEdXJhdGlvbiA9IHRvTnVtYmVyKGlzT2JqZWN0KGR1cmF0aW9uKSA/IGR1cmF0aW9uLmxlYXZlIDogZHVyYXRpb24pO1xuICAgIGlmIChpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGNiID0gKGVsLl9sZWF2ZUNiID0gb25jZSgoKSA9PiB7XG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgICAgICAgIGVsLnBhcmVudE5vZGUuX3BlbmRpbmdbdm5vZGUua2V5XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBybSgpO1xuICAgICAgICAgICAgYWZ0ZXJMZWF2ZSAmJiBhZnRlckxlYXZlKGVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gICAgfSkpO1xuICAgIGlmIChkZWxheUxlYXZlKSB7XG4gICAgICAgIGRlbGF5TGVhdmUocGVyZm9ybUxlYXZlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBlcmZvcm1MZWF2ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUoKSB7XG4gICAgICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgICAgICBpZiAoIXZub2RlLmRhdGEuc2hvdyAmJiBlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbdm5vZGUua2V5XSA9XG4gICAgICAgICAgICAgICAgdm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdExlYXZlRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgICAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBvbmx5IHVzZWQgaW4gZGV2IG1vZGVcbmZ1bmN0aW9uIGNoZWNrRHVyYXRpb24odmFsLCBuYW1lLCB2bm9kZSkge1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSAnbnVtYmVyJykge1xuICAgICAgICB3YXJuJDIoYDx0cmFuc2l0aW9uPiBleHBsaWNpdCAke25hbWV9IGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIGAgK1xuICAgICAgICAgICAgYGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmAsIHZub2RlLmNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgIHdhcm4kMihgPHRyYW5zaXRpb24+IGV4cGxpY2l0ICR7bmFtZX0gZHVyYXRpb24gaXMgTmFOIC0gYCArXG4gICAgICAgICAgICAndGhlIGR1cmF0aW9uIGV4cHJlc3Npb24gbWlnaHQgYmUgaW5jb3JyZWN0LicsIHZub2RlLmNvbnRleHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbCk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBhIHRyYW5zaXRpb24gaG9vaydzIGFyZ3VtZW50IGxlbmd0aC4gVGhlIGhvb2sgbWF5IGJlOlxuICogLSBhIG1lcmdlZCBob29rIChpbnZva2VyKSB3aXRoIHRoZSBvcmlnaW5hbCBpbiAuZm5zXG4gKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAqIC0gYSBwbGFpbiBmdW5jdGlvbiAoLmxlbmd0aClcbiAqL1xuZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aChmbikge1xuICAgIGlmIChpc1VuZGVmKGZuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBpbnZva2VyRm5zID0gZm4uZm5zO1xuICAgIGlmIChpc0RlZihpbnZva2VyRm5zKSkge1xuICAgICAgICAvLyBpbnZva2VyXG4gICAgICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKEFycmF5LmlzQXJyYXkoaW52b2tlckZucykgPyBpbnZva2VyRm5zWzBdIDogaW52b2tlckZucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMTtcbiAgICB9XG59XG5mdW5jdGlvbiBfZW50ZXIoXywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICAgIGVudGVyKHZub2RlKTtcbiAgICB9XG59XG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlclxuICAgID8ge1xuICAgICAgICBjcmVhdGU6IF9lbnRlcixcbiAgICAgICAgYWN0aXZhdGU6IF9lbnRlcixcbiAgICAgICAgcmVtb3ZlKHZub2RlLCBybSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgbGVhdmUodm5vZGUsIHJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgOiB7fTtcblxudmFyIHBsYXRmb3JtTW9kdWxlcyA9IFthdHRycywga2xhc3MkMSwgZXZlbnRzLCBkb21Qcm9wcywgc3R5bGUkMSwgdHJhbnNpdGlvbl07XG5cbi8vIHRoZSBkaXJlY3RpdmUgbW9kdWxlIHNob3VsZCBiZSBhcHBsaWVkIGxhc3QsIGFmdGVyIGFsbFxuLy8gYnVpbHQtaW4gbW9kdWxlcyBoYXZlIGJlZW4gYXBwbGllZC5cbmNvbnN0IG1vZHVsZXMkMSA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuY29uc3QgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyQxIH0pO1xuXG4vKipcbiAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICogcHJvcGVydGllcyB0byBFbGVtZW50cy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgICAvLyBodHRwOi8vd3d3Lm1hdHRzNDExLmNvbS9wb3N0L2ludGVybmV0LWV4cGxvcmVyLTktb25pbnB1dC9cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoZWwgJiYgZWwudm1vZGVsKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnaW5wdXQnKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY29uc3QgZGlyZWN0aXZlID0ge1xuICAgIGluc2VydGVkKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUpIHtcbiAgICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgIC8vICM2OTAzXG4gICAgICAgICAgICBpZiAob2xkVm5vZGUuZWxtICYmICFvbGRWbm9kZS5lbG0uX3ZPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZS5jb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5fdk9wdGlvbnMgPSBbXS5tYXAuY2FsbChlbC5vcHRpb25zLCBnZXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGlzVGV4dElucHV0VHlwZShlbC50eXBlKSkge1xuICAgICAgICAgICAgZWwuX3ZNb2RpZmllcnMgPSBiaW5kaW5nLm1vZGlmaWVycztcbiAgICAgICAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRVcGRhdGVkKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAgICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAgICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgICAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgICAgICAgY29uc3QgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBjdXJPcHRpb25zID0gKGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKSk7XG4gICAgICAgICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKChvLCBpKSA9PiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgICAgICAgICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKHYgPT4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKSlcbiAgICAgICAgICAgICAgICAgICAgOiBiaW5kaW5nLnZhbHVlICE9PSBiaW5kaW5nLm9sZFZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNOb01hdGNoaW5nT3B0aW9uKGJpbmRpbmcudmFsdWUsIGN1ck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5mdW5jdGlvbiBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pIHtcbiAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSkge1xuICAgIGNvbnN0IHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgICBjb25zdCBpc011bHRpcGxlID0gZWwubXVsdGlwbGU7XG4gICAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHdhcm4kMihgPHNlbGVjdCBtdWx0aXBsZSB2LW1vZGVsPVwiJHtiaW5kaW5nLmV4cHJlc3Npb259XCI+IGAgK1xuICAgICAgICAgICAgICAgIGBleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgLmNhbGwodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSg4LCAtMSl9YCwgdm0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzZWxlY3RlZCwgb3B0aW9uO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICAgICAgaWYgKGlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gbG9vc2VJbmRleE9mKHZhbHVlLCBnZXRWYWx1ZShvcHRpb24pKSA+IC0xO1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsb29zZUVxdWFsKGdldFZhbHVlKG9wdGlvbiksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZXZlcnkobyA9PiAhbG9vc2VFcXVhbChvLCB2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWUob3B0aW9uKSB7XG4gICAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvbiA/IG9wdGlvbi5fdmFsdWUgOiBvcHRpb24udmFsdWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZSkge1xuICAgIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGUpIHtcbiAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICAgIGlmICghZS50YXJnZXQuY29tcG9zaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5mdW5jdGlvbiB0cmlnZ2VyKGVsLCB0eXBlKSB7XG4gICAgY29uc3QgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZWwuZGlzcGF0Y2hFdmVudChlKTtcbn1cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSh2bm9kZSkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgICAgIDogdm5vZGU7XG59XG52YXIgc2hvdyA9IHtcbiAgICBiaW5kKGVsLCB7IHZhbHVlIH0sIHZub2RlKSB7XG4gICAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxEaXNwbGF5ID0gKGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXkpO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbikge1xuICAgICAgICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIGVudGVyKHZub2RlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGUoZWwsIHsgdmFsdWUsIG9sZFZhbHVlIH0sIHZub2RlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIHZub2RlLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbnRlcih2bm9kZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVhdmUodm5vZGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdW5iaW5kKGVsLCBiaW5kaW5nLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICAgICAgICBpZiAoIWlzRGVzdHJveSkge1xuICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBwbGF0Zm9ybURpcmVjdGl2ZXMgPSB7XG4gICAgbW9kZWw6IGRpcmVjdGl2ZSxcbiAgICBzaG93XG59O1xuXG4vLyBQcm92aWRlcyB0cmFuc2l0aW9uIHN1cHBvcnQgZm9yIGEgc2luZ2xlIGVsZW1lbnQvY29tcG9uZW50LlxuY29uc3QgdHJhbnNpdGlvblByb3BzID0ge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBhcHBlYXI6IEJvb2xlYW4sXG4gICAgY3NzOiBCb29sZWFuLFxuICAgIG1vZGU6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZW50ZXJDbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcbi8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuLy8gd2Ugd2FudCB0byByZWN1cnNpdmVseSByZXRyaWV2ZSB0aGUgcmVhbCBjb21wb25lbnQgdG8gYmUgcmVuZGVyZWRcbmZ1bmN0aW9uIGdldFJlYWxDaGlsZCh2bm9kZSkge1xuICAgIGNvbnN0IGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICAgIHJldHVybiBnZXRSZWFsQ2hpbGQoZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChjb21wT3B0aW9ucy5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZub2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YShjb21wKSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIGNvbnN0IG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAgIC8vIHByb3BzXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICAgICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICAgIH1cbiAgICAvLyBldmVudHMuXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gICAgY29uc3QgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGxpc3RlbmVycykge1xuICAgICAgICBkYXRhW2NhbWVsaXplKGtleSldID0gbGlzdGVuZXJzW2tleV07XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgICAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgICAgICAgIHByb3BzOiByYXdDaGlsZC5jb21wb25lbnRPcHRpb25zLnByb3BzRGF0YVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uKHZub2RlKSB7XG4gICAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgaWYgKHZub2RlLmRhdGEudHJhbnNpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgICByZXR1cm4gb2xkQ2hpbGQua2V5ID09PSBjaGlsZC5rZXkgJiYgb2xkQ2hpbGQudGFnID09PSBjaGlsZC50YWc7XG59XG5jb25zdCBpc05vdFRleHROb2RlID0gKGMpID0+IGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTtcbmNvbnN0IGlzVlNob3dEaXJlY3RpdmUgPSBkID0+IGQubmFtZSA9PT0gJ3Nob3cnO1xudmFyIFRyYW5zaXRpb24gPSB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICAgIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG4gICAgcmVuZGVyKGgpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdDtcbiAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKGlzTm90VGV4dE5vZGUpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB3YXJuJDIoJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLCB0aGlzLiRwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgICAgIGlmIChtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICAgICAgICB3YXJuJDIoJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLCB0aGlzLiRwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0NoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAgICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgICAgIGlmIChoYXNQYXJlbnRUcmFuc2l0aW9uKHRoaXMuJHZub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhd0NoaWxkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgICAgICAvLyB1c2UgZ2V0UmVhbENoaWxkKCkgdG8gaWdub3JlIGFic3RyYWN0IGNvbXBvbmVudHMgZS5nLiBrZWVwLWFsaXZlXG4gICAgICAgIGNvbnN0IGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgICAgIHJldHVybiByYXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGVhdmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgICAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgICAgIC8vIGR1cmluZyBlbnRlcmluZy5cbiAgICAgICAgY29uc3QgaWQgPSBgX190cmFuc2l0aW9uLSR7dGhpcy5fdWlkfS1gO1xuICAgICAgICBjaGlsZC5rZXkgPVxuICAgICAgICAgICAgY2hpbGQua2V5ID09IG51bGxcbiAgICAgICAgICAgICAgICA/IGNoaWxkLmlzQ29tbWVudFxuICAgICAgICAgICAgICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgICAgICAgICAgICAgIDogaWQgKyBjaGlsZC50YWdcbiAgICAgICAgICAgICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgICAgICAgICAgICAgPyBTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaWQgKyBjaGlsZC5rZXlcbiAgICAgICAgICAgICAgICAgICAgOiBjaGlsZC5rZXk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoKGNoaWxkLmRhdGEgfHwgKGNoaWxkLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPVxuICAgICAgICAgICAgZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpKTtcbiAgICAgICAgY29uc3Qgb2xkUmF3Q2hpbGQgPSB0aGlzLl92bm9kZTtcbiAgICAgICAgY29uc3Qgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuICAgICAgICAvLyBtYXJrIHYtc2hvd1xuICAgICAgICAvLyBzbyB0aGF0IHRoZSB0cmFuc2l0aW9uIG1vZHVsZSBjYW4gaGFuZCBvdmVyIHRoZSBjb250cm9sIHRvIHRoZSBkaXJlY3RpdmVcbiAgICAgICAgaWYgKGNoaWxkLmRhdGEuZGlyZWN0aXZlcyAmJiBjaGlsZC5kYXRhLmRpcmVjdGl2ZXMuc29tZShpc1ZTaG93RGlyZWN0aXZlKSkge1xuICAgICAgICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkQ2hpbGQgJiZcbiAgICAgICAgICAgIG9sZENoaWxkLmRhdGEgJiZcbiAgICAgICAgICAgICFpc1NhbWVDaGlsZChjaGlsZCwgb2xkQ2hpbGQpICYmXG4gICAgICAgICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgICAgICAgLy8gIzY2ODcgY29tcG9uZW50IHJvb3QgaXMgYSBjb21tZW50IG5vZGVcbiAgICAgICAgICAgICEob2xkQ2hpbGQuY29tcG9uZW50SW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICAgICAgICBjb25zdCBvbGREYXRhID0gKG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSkpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpb24gbW9kZVxuICAgICAgICAgICAgaWYgKG1vZGUgPT09ICdvdXQtaW4nKSB7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2FmdGVyTGVhdmUnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gJ2luLW91dCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBc3luY1BsYWNlaG9sZGVyKGNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2xkUmF3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkZWxheWVkTGVhdmU7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVyZm9ybUxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWxheWVkTGVhdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgbGVhdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkZWxheWVkTGVhdmUgPSBsZWF2ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmF3Q2hpbGQ7XG4gICAgfVxufTtcblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuY29uc3QgcHJvcHMgPSBleHRlbmQoe1xuICAgIHRhZzogU3RyaW5nLFxuICAgIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuZGVsZXRlIHByb3BzLm1vZGU7XG52YXIgVHJhbnNpdGlvbkdyb3VwID0ge1xuICAgIHByb3BzLFxuICAgIGJlZm9yZU1vdW50KCkge1xuICAgICAgICBjb25zdCB1cGRhdGUgPSB0aGlzLl91cGRhdGU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSA9ICh2bm9kZSwgaHlkcmF0aW5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgICAgICAgIHRoaXMuX19wYXRjaF9fKHRoaXMuX3Zub2RlLCB0aGlzLmtlcHQsIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRoaXMuX3Zub2RlID0gdGhpcy5rZXB0O1xuICAgICAgICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICAgICAgICB1cGRhdGUuY2FsbCh0aGlzLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHJlbmRlcihoKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICAgICAgY29uc3QgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgcHJldkNoaWxkcmVuID0gKHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbik7XG4gICAgICAgIGNvbnN0IHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSAodGhpcy5jaGlsZHJlbiA9IFtdKTtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSByYXdDaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjLnRhZykge1xuICAgICAgICAgICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goYyk7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtjLmtleV0gPSBjO1xuICAgICAgICAgICAgICAgICAgICAoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBvcHRzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldENvbXBvbmVudE5hbWUob3B0cy5DdG9yLm9wdGlvbnMpIHx8IG9wdHMudGFnIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGMudGFnO1xuICAgICAgICAgICAgICAgICAgICB3YXJuJDIoYDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8JHtuYW1lfT5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3Qga2VwdCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gcHJldkNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGMuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIG5vdCB0eXBlZCBpbiBOb2RlXG4gICAgICAgICAgICAgICAgYy5kYXRhLnBvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGlmIChtYXBbYy5rZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGtlcHQucHVzaChjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmtlcHQgPSBoKHRhZywgbnVsbCwga2VwdCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZWQgPSByZW1vdmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoKHRhZywgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH0sXG4gICAgdXBkYXRlZCgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICAgICAgY29uc3QgbW92ZUNsYXNzID0gdGhpcy5tb3ZlQ2xhc3MgfHwgKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJztcbiAgICAgICAgaWYgKCFjaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMuaGFzTW92ZShjaGlsZHJlblswXS5lbG0sIG1vdmVDbGFzcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBkaXZpZGUgdGhlIHdvcmsgaW50byB0aHJlZSBsb29wcyB0byBhdm9pZCBtaXhpbmcgRE9NIHJlYWRzIGFuZCB3cml0ZXNcbiAgICAgICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKHJlY29yZFBvc2l0aW9uKTtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcbiAgICAgICAgLy8gZm9yY2UgcmVmbG93IHRvIHB1dCBldmVyeXRoaW5nIGluIHBvc2l0aW9uXG4gICAgICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICB0aGlzLl9yZWZsb3cgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodDtcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKGMuZGF0YS5tb3ZlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gYy5lbG07XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGVsLnN0eWxlO1xuICAgICAgICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgKGVsLl9tb3ZlQ2IgPSBmdW5jdGlvbiBjYihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlICYmIGUudGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZSB8fCAvdHJhbnNmb3JtJC8udGVzdChlLnByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5fbW92ZUNiID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGhhc01vdmUoZWwsIG1vdmVDbGFzcykge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLl9oYXNNb3ZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc01vdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZXRlY3Qgd2hldGhlciBhbiBlbGVtZW50IHdpdGggdGhlIG1vdmUgY2xhc3MgYXBwbGllZCBoYXNcbiAgICAgICAgICAgIC8vIENTUyB0cmFuc2l0aW9ucy4gU2luY2UgdGhlIGVsZW1lbnQgbWF5IGJlIGluc2lkZSBhbiBlbnRlcmluZ1xuICAgICAgICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgICAgICAgLy8gYWxsIG90aGVyIHRyYW5zaXRpb24gY2xhc3NlcyBhcHBsaWVkIHRvIGVuc3VyZSBvbmx5IHRoZSBtb3ZlIGNsYXNzXG4gICAgICAgICAgICAvLyBpcyBhcHBsaWVkLlxuICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUoKTtcbiAgICAgICAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaCgoY2xzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQ2xhc3MoY2xvbmUsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICBjbG9uZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgICAgICAgIHRoaXMuJGVsLnJlbW92ZUNoaWxkKGNsb25lKTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyhjKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICAgICAgYy5lbG0uX21vdmVDYigpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICAgICAgYy5lbG0uX2VudGVyQ2IoKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWNvcmRQb3NpdGlvbihjKSB7XG4gICAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbihjKSB7XG4gICAgY29uc3Qgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgICBjb25zdCBuZXdQb3MgPSBjLmRhdGEubmV3UG9zO1xuICAgIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgICBjb25zdCBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICAgIGlmIChkeCB8fCBkeSkge1xuICAgICAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBzID0gYy5lbG0uc3R5bGU7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgICAgICBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICAgIFRyYW5zaXRpb24sXG4gICAgVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vLyBpbnN0YWxsIHBsYXRmb3JtIHNwZWNpZmljIHV0aWxzXG5WdWUuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuVnVlLmNvbmZpZy5pc1Jlc2VydmVkQXR0ciA9IGlzUmVzZXJ2ZWRBdHRyO1xuVnVlLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBwbGF0Zm9ybUNvbXBvbmVudHMpO1xuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG4vLyBwdWJsaWMgbW91bnQgbWV0aG9kXG5WdWUucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChlbCwgaHlkcmF0aW5nKSB7XG4gICAgZWwgPSBlbCAmJiBpbkJyb3dzZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpO1xufTtcbi8vIGRldnRvb2xzIGdsb2JhbCBob29rXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGluQnJvd3Nlcikge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICAgICAgICBpZiAoZGV2dG9vbHMpIHtcbiAgICAgICAgICAgICAgICBkZXZ0b29scy5lbWl0KCdpbml0JywgVnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXSgnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShgWW91IGFyZSBydW5uaW5nIFZ1ZSBpbiBkZXZlbG9wbWVudCBtb2RlLlxcbmAgK1xuICAgICAgICAgICAgICAgIGBNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuYCArXG4gICAgICAgICAgICAgICAgYFNlZSBtb3JlIHRpcHMgYXQgaHR0cHM6Ly92dWVqcy5vcmcvZ3VpZGUvZGVwbG95bWVudC5odG1sYCk7XG4gICAgICAgIH1cbiAgICB9LCAwKTtcbn1cblxuY29uc3QgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxccj9cXG4pKz8pXFx9XFx9L2c7XG5jb25zdCByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcbmNvbnN0IGJ1aWxkUmVnZXggPSBjYWNoZWQoZGVsaW1pdGVycyA9PiB7XG4gICAgY29uc3Qgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gICAgY29uc3QgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyAnKCg/Oi58XFxcXG4pKz8pJyArIGNsb3NlLCAnZycpO1xufSk7XG5mdW5jdGlvbiBwYXJzZVRleHQodGV4dCwgZGVsaW1pdGVycykge1xuICAgIC8vQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gICAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgY29uc3QgcmF3VG9rZW5zID0gW107XG4gICAgbGV0IGxhc3RJbmRleCA9ICh0YWdSRS5sYXN0SW5kZXggPSAwKTtcbiAgICBsZXQgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICAgIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICAgICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICByYXdUb2tlbnMucHVzaCgodG9rZW5WYWx1ZSA9IHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0YWcgdG9rZW5cbiAgICAgICAgY29uc3QgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgICAgIHRva2Vucy5wdXNoKGBfcygke2V4cH0pYCk7XG4gICAgICAgIHJhd1Rva2Vucy5wdXNoKHsgJ0BiaW5kaW5nJzogZXhwIH0pO1xuICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIHJhd1Rva2Vucy5wdXNoKCh0b2tlblZhbHVlID0gdGV4dC5zbGljZShsYXN0SW5kZXgpKSk7XG4gICAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRva2VuVmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICAgICAgdG9rZW5zOiByYXdUb2tlbnNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Ob2RlJDEoZWwsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIGNvbnN0IHN0YXRpY0NsYXNzID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2NsYXNzJyk7XG4gICAgaWYgKHN0YXRpY0NsYXNzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHBhcnNlVGV4dChzdGF0aWNDbGFzcywgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgd2FybihgY2xhc3M9XCIke3N0YXRpY0NsYXNzfVwiOiBgICtcbiAgICAgICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IGNsYXNzPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6Y2xhc3M9XCJ2YWxcIj4uJywgZWwucmF3QXR0cnNNYXBbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0aWNDbGFzcykge1xuICAgICAgICBlbC5zdGF0aWNDbGFzcyA9IEpTT04uc3RyaW5naWZ5KHN0YXRpY0NsYXNzLnJlcGxhY2UoL1xccysvZywgJyAnKS50cmltKCkpO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5EYXRhJDIoZWwpIHtcbiAgICBsZXQgZGF0YSA9ICcnO1xuICAgIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgICAgICBkYXRhICs9IGBzdGF0aWNDbGFzczoke2VsLnN0YXRpY0NsYXNzfSxgO1xuICAgIH1cbiAgICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgICAgIGRhdGEgKz0gYGNsYXNzOiR7ZWwuY2xhc3NCaW5kaW5nfSxgO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbnZhciBrbGFzcyA9IHtcbiAgICBzdGF0aWNLZXlzOiBbJ3N0YXRpY0NsYXNzJ10sXG4gICAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSQxLFxuICAgIGdlbkRhdGE6IGdlbkRhdGEkMlxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZShlbCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gICAgY29uc3Qgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHBhcnNlVGV4dChzdGF0aWNTdHlsZSwgb3B0aW9ucy5kZWxpbWl0ZXJzKTtcbiAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICB3YXJuKGBzdHlsZT1cIiR7c3RhdGljU3R5bGV9XCI6IGAgK1xuICAgICAgICAgICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgc3R5bGU9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpzdHlsZT1cInZhbFwiPi4nLCBlbC5yYXdBdHRyc01hcFsnc3R5bGUnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgICAgIGVsLnN0eWxlQmluZGluZyA9IHN0eWxlQmluZGluZztcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5EYXRhJDEoZWwpIHtcbiAgICBsZXQgZGF0YSA9ICcnO1xuICAgIGlmIChlbC5zdGF0aWNTdHlsZSkge1xuICAgICAgICBkYXRhICs9IGBzdGF0aWNTdHlsZToke2VsLnN0YXRpY1N0eWxlfSxgO1xuICAgIH1cbiAgICBpZiAoZWwuc3R5bGVCaW5kaW5nKSB7XG4gICAgICAgIGRhdGEgKz0gYHN0eWxlOigke2VsLnN0eWxlQmluZGluZ30pLGA7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxudmFyIHN0eWxlID0ge1xuICAgIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgICB0cmFuc2Zvcm1Ob2RlLFxuICAgIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxubGV0IGRlY29kZXI7XG52YXIgaGUgPSB7XG4gICAgZGVjb2RlKGh0bWwpIHtcbiAgICAgICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgcmV0dXJuIGRlY29kZXIudGV4dENvbnRlbnQ7XG4gICAgfVxufTtcblxuY29uc3QgaXNVbmFyeVRhZyA9IG1ha2VNYXAoJ2FyZWEsYmFzZSxicixjb2wsZW1iZWQsZnJhbWUsaHIsaW1nLGlucHV0LGlzaW5kZXgsa2V5Z2VuLCcgK1xuICAgICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicicpO1xuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG5jb25zdCBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcCgnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZScpO1xuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG5jb25zdCBpc05vblBocmFzaW5nVGFnID0gbWFrZU1hcCgnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAgICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICAgJ2gxLGgyLGgzLGg0LGg1LGg2LGhlYWQsaGVhZGVyLGhncm91cCxocixodG1sLGxlZ2VuZCxsaSxtZW51aXRlbSxtZXRhLCcgK1xuICAgICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICAgJ3RpdGxlLHRyLHRyYWNrJyk7XG5cbi8qKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gKi9cbi8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuY29uc3QgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG5jb25zdCBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XSs/XFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LztcbmNvbnN0IG5jbmFtZSA9IGBbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVoke3VuaWNvZGVSZWdFeHAuc291cmNlfV0qYDtcbmNvbnN0IHFuYW1lQ2FwdHVyZSA9IGAoKD86JHtuY25hbWV9XFxcXDopPyR7bmNuYW1lfSlgO1xuY29uc3Qgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cChgXjwke3FuYW1lQ2FwdHVyZX1gKTtcbmNvbnN0IHN0YXJ0VGFnQ2xvc2UgPSAvXlxccyooXFwvPyk+LztcbmNvbnN0IGVuZFRhZyA9IG5ldyBSZWdFeHAoYF48XFxcXC8ke3FuYW1lQ2FwdHVyZX1bXj5dKj5gKTtcbmNvbnN0IGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbi8vICM3Mjk4OiBlc2NhcGUgLSB0byBhdm9pZCBiZWluZyBwYXNzZWQgYXMgSFRNTCBjb21tZW50IHdoZW4gaW5saW5lZCBpbiBwYWdlXG5jb25zdCBjb21tZW50ID0gL148IVxcLS0vO1xuY29uc3QgY29uZGl0aW9uYWxDb21tZW50ID0gL148IVxcWy87XG4vLyBTcGVjaWFsIEVsZW1lbnRzIChjYW4gY29udGFpbiBhbnl0aGluZylcbmNvbnN0IGlzUGxhaW5UZXh0RWxlbWVudCA9IG1ha2VNYXAoJ3NjcmlwdCxzdHlsZSx0ZXh0YXJlYScsIHRydWUpO1xuY29uc3QgcmVDYWNoZSA9IHt9O1xuY29uc3QgZGVjb2RpbmdNYXAgPSB7XG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyZhbXA7JzogJyYnLFxuICAgICcmIzEwOyc6ICdcXG4nLFxuICAgICcmIzk7JzogJ1xcdCcsXG4gICAgJyYjMzk7JzogXCInXCJcbn07XG5jb25zdCBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbmNvbnN0IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcbi8vICM1OTkyXG5jb25zdCBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbmNvbnN0IHNob3VsZElnbm9yZUZpcnN0TmV3bGluZSA9ICh0YWcsIGh0bWwpID0+IHRhZyAmJiBpc0lnbm9yZU5ld2xpbmVUYWcodGFnKSAmJiBodG1sWzBdID09PSAnXFxuJztcbmZ1bmN0aW9uIGRlY29kZUF0dHIodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gICAgY29uc3QgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmUsIG1hdGNoID0+IGRlY29kaW5nTWFwW21hdGNoXSk7XG59XG5mdW5jdGlvbiBwYXJzZUhUTUwoaHRtbCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgY29uc3QgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgICBjb25zdCBpc1VuYXJ5VGFnID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICAgIGNvbnN0IGNhbkJlTGVmdE9wZW5UYWcgPSBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcgfHwgbm87XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgbGFzdCwgbGFzdFRhZztcbiAgICB3aGlsZSAoaHRtbCkge1xuICAgICAgICBsYXN0ID0gaHRtbDtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICAgICAgaWYgKCFsYXN0VGFnIHx8ICFpc1BsYWluVGV4dEVsZW1lbnQobGFzdFRhZykpIHtcbiAgICAgICAgICAgIGxldCB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICAgICAgICBpZiAodGV4dEVuZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENvbW1lbnQ6XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnRFbmQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQgJiYgb3B0aW9ucy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5jb21tZW50KGh0bWwuc3Vic3RyaW5nKDQsIGNvbW1lbnRFbmQpLCBpbmRleCwgaW5kZXggKyBjb21tZW50RW5kICsgMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uYWxFbmQgPSBodG1sLmluZGV4T2YoJ10+Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBEb2N0eXBlOlxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlKGRvY3R5cGVNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRUYWdNYXRjaCA9IGh0bWwubWF0Y2goZW5kVGFnKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZShlbmRUYWdNYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUVuZFRhZyhlbmRUYWdNYXRjaFsxXSwgY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFRhZ01hdGNoID0gcGFyc2VTdGFydFRhZygpO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YXJ0VGFnTWF0Y2gudGFnTmFtZSwgaHRtbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRleHQsIHJlc3QsIG5leHQ7XG4gICAgICAgICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFlbmRUYWcudGVzdChyZXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWNvbW1lbnQudGVzdChyZXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAhY29uZGl0aW9uYWxDb21tZW50LnRlc3QocmVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICAgICAgICBjb25zdCBzdGFja2VkVGFnID0gbGFzdFRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgY29uc3QgcmVTdGFja2VkVGFnID0gcmVDYWNoZVtzdGFja2VkVGFnXSB8fFxuICAgICAgICAgICAgICAgIChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgICAgICAgICBlbmRUYWdMZW5ndGggPSBlbmRUYWcubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICghaXNQbGFpblRleHRFbGVtZW50KHN0YWNrZWRUYWcpICYmIHN0YWNrZWRUYWcgIT09ICdub3NjcmlwdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcLS0oW1xcc1xcU10qPyktLT4vZywgJyQxJykgLy8gIzcyOThcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lKHN0YWNrZWRUYWcsIHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jaGFycykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdC5sZW5ndGg7XG4gICAgICAgICAgICBodG1sID0gcmVzdDtcbiAgICAgICAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgICAgICAgIGlmICghc3RhY2subGVuZ3RoICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMud2FybihgTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcIiR7aHRtbH1cImAsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4ICsgaHRtbC5sZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIGFueSByZW1haW5pbmcgdGFnc1xuICAgIHBhcnNlRW5kVGFnKCk7XG4gICAgZnVuY3Rpb24gYWR2YW5jZShuKSB7XG4gICAgICAgIGluZGV4ICs9IG47XG4gICAgICAgIGh0bWwgPSBodG1sLnN1YnN0cmluZyhuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZygpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB7XG4gICAgICAgICAgICAgICAgdGFnTmFtZTogc3RhcnRbMV0sXG4gICAgICAgICAgICAgICAgYXR0cnM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBlbmQsIGF0dHI7XG4gICAgICAgICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJlxuICAgICAgICAgICAgICAgIChhdHRyID0gaHRtbC5tYXRjaChkeW5hbWljQXJnQXR0cmlidXRlKSB8fCBodG1sLm1hdGNoKGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgICAgICAgICAgYXR0ci5zdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoYXR0clswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGF0dHIuZW5kID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgbWF0Y2guYXR0cnMucHVzaChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICBtYXRjaC51bmFyeVNsYXNoID0gZW5kWzFdO1xuICAgICAgICAgICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbWF0Y2guZW5kID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgICAgICBjb25zdCB1bmFyeVNsYXNoID0gbWF0Y2gudW5hcnlTbGFzaDtcbiAgICAgICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgICAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlRW5kVGFnKGxhc3RUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJlTGVmdE9wZW5UYWcodGFnTmFtZSkgJiYgbGFzdFRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICAgICAgICAgIHBhcnNlRW5kVGFnKHRhZ05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuYXJ5ID0gaXNVbmFyeVRhZyh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG4gICAgICAgIGNvbnN0IGwgPSBtYXRjaC5hdHRycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IG1hdGNoLmF0dHJzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhcmdzWzNdIHx8IGFyZ3NbNF0gfHwgYXJnc1s1XSB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZERlY29kZU5ld2xpbmVzID0gdGFnTmFtZSA9PT0gJ2EnICYmIGFyZ3NbMV0gPT09ICdocmVmJ1xuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXM7XG4gICAgICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gYXJncy5zdGFydCArIGFyZ3NbMF0ubWF0Y2goL15cXHMqLykubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGF0dHJzW2ldLmVuZCA9IGFyZ3MuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdW5hcnkpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIHRhZzogdGFnTmFtZSxcbiAgICAgICAgICAgICAgICBsb3dlckNhc2VkVGFnOiB0YWdOYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgYXR0cnM6IGF0dHJzLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBtYXRjaC5zdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IG1hdGNoLmVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlRW5kVGFnKHRhZ05hbWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgbGV0IHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKVxuICAgICAgICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICAgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICAgICAgZW5kID0gaW5kZXg7XG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgICAgICBsb3dlckNhc2VkVGFnTmFtZSA9IHRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgbm8gdGFnIG5hbWUgaXMgcHJvdmlkZWQsIGNsZWFuIHNob3BcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgICAgICAvLyBDbG9zZSBhbGwgdGhlIG9wZW4gZWxlbWVudHMsIHVwIHRoZSBzdGFja1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpZiAoKGkgPiBwb3MgfHwgIXRhZ05hbWUpICYmIG9wdGlvbnMud2Fybikge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLndhcm4oYHRhZyA8JHtzdGFja1tpXS50YWd9PiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5gLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhY2tbaV0uc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHN0YWNrW2ldLmVuZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZW5kKHN0YWNrW2ldLnRhZywgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvcGVuIGVsZW1lbnRzIGZyb20gdGhlIHN0YWNrXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggPSBwb3M7XG4gICAgICAgICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhcnQodGFnTmFtZSwgW10sIGZhbHNlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBvblJFID0gL15AfF52LW9uOi87XG5jb25zdCBkaXJSRSA9IC9edi18XkB8Xjp8XiMvO1xuY29uc3QgZm9yQWxpYXNSRSA9IC8oW1xcc1xcU10qPylcXHMrKD86aW58b2YpXFxzKyhbXFxzXFxTXSopLztcbmNvbnN0IGZvckl0ZXJhdG9yUkUgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC87XG5jb25zdCBzdHJpcFBhcmVuc1JFID0gL15cXCh8XFwpJC9nO1xuY29uc3QgZHluYW1pY0FyZ1JFID0gL15cXFsuKlxcXSQvO1xuY29uc3QgYXJnUkUgPSAvOiguKikkLztcbmNvbnN0IGJpbmRSRSA9IC9eOnxeXFwufF52LWJpbmQ6LztcbmNvbnN0IG1vZGlmaWVyUkUgPSAvXFwuW14uXFxdXSsoPz1bXlxcXV0qJCkvZztcbmNvbnN0IHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuY29uc3QgbGluZUJyZWFrUkUgPSAvW1xcclxcbl0vO1xuY29uc3Qgd2hpdGVzcGFjZVJFID0gL1sgXFxmXFx0XFxyXFxuXSsvZztcbmNvbnN0IGludmFsaWRBdHRyaWJ1dGVSRSA9IC9bXFxzXCInPD5cXC89XS87XG5jb25zdCBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5jb25zdCBlbXB0eVNsb3RTY29wZVRva2VuID0gYF9lbXB0eV9gO1xuLy8gY29uZmlndXJhYmxlIHN0YXRlXG5sZXQgd2FybjtcbmxldCBkZWxpbWl0ZXJzO1xubGV0IHRyYW5zZm9ybXM7XG5sZXQgcHJlVHJhbnNmb3JtcztcbmxldCBwb3N0VHJhbnNmb3JtcztcbmxldCBwbGF0Zm9ybUlzUHJlVGFnO1xubGV0IHBsYXRmb3JtTXVzdFVzZVByb3A7XG5sZXQgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5sZXQgbWF5YmVDb21wb25lbnQ7XG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIHBhcmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDEsXG4gICAgICAgIHRhZyxcbiAgICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgICAgIHJhd0F0dHJzTWFwOiB7fSxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgICB3YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHBsYXRmb3JtSXNQcmVUYWcgPSBvcHRpb25zLmlzUHJlVGFnIHx8IG5vO1xuICAgIHBsYXRmb3JtTXVzdFVzZVByb3AgPSBvcHRpb25zLm11c3RVc2VQcm9wIHx8IG5vO1xuICAgIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG4gICAgY29uc3QgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICBtYXliZUNvbXBvbmVudCA9IChlbCkgPT4gISEoZWwuY29tcG9uZW50IHx8XG4gICAgICAgIGVsLmF0dHJzTWFwWyc6aXMnXSB8fFxuICAgICAgICBlbC5hdHRyc01hcFsndi1iaW5kOmlzJ10gfHxcbiAgICAgICAgIShlbC5hdHRyc01hcC5pcyA/IGlzUmVzZXJ2ZWRUYWcoZWwuYXR0cnNNYXAuaXMpIDogaXNSZXNlcnZlZFRhZyhlbC50YWcpKSk7XG4gICAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICAgIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcbiAgICBkZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzO1xuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgY29uc3QgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICAgIGNvbnN0IHdoaXRlc3BhY2VPcHRpb24gPSBvcHRpb25zLndoaXRlc3BhY2U7XG4gICAgbGV0IHJvb3Q7XG4gICAgbGV0IGN1cnJlbnRQYXJlbnQ7XG4gICAgbGV0IGluVlByZSA9IGZhbHNlO1xuICAgIGxldCBpblByZSA9IGZhbHNlO1xuICAgIGxldCB3YXJuZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiB3YXJuT25jZShtc2csIHJhbmdlKSB7XG4gICAgICAgIGlmICghd2FybmVkKSB7XG4gICAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgd2Fybihtc2csIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjbG9zZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gcHJvY2Vzc0VsZW1lbnQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICAgIGlmICghc3RhY2subGVuZ3RoICYmIGVsZW1lbnQgIT09IHJvb3QpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICAgICAgaWYgKHJvb3QuaWYgJiYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkpIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cDogZWxlbWVudC5lbHNlaWYsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZShgQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIGAgK1xuICAgICAgICAgICAgICAgICAgICBgdXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuYCwgeyBzdGFydDogZWxlbWVudC5zdGFydCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzSWZDb25kaXRpb25zKGVsZW1lbnQsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNjb3BlZCBzbG90XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgaXQgaW4gdGhlIGNoaWxkcmVuIGxpc3Qgc28gdGhhdCB2LWVsc2UoLWlmKSBjb25kaXRpb25zIGNhblxuICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlbGVtZW50LnNsb3RUYXJnZXQgfHwgJ1wiZGVmYXVsdFwiJztcbiAgICAgICAgICAgICAgICAgICAgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgICAgIC8vIGZpbHRlciBvdXQgc2NvcGVkIHNsb3RzXG4gICAgICAgIGVsZW1lbnQuY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuLmZpbHRlcihjID0+ICFjLnNsb3RTY29wZSk7XG4gICAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGUgYWdhaW5cbiAgICAgICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG4gICAgICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICAgIGluVlByZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhcHBseSBwb3N0LXRyYW5zZm9ybXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcG9zdFRyYW5zZm9ybXNbaV0oZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpbUVuZGluZ1doaXRlc3BhY2UoZWwpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2Ugbm9kZVxuICAgICAgICBpZiAoIWluUHJlKSB7XG4gICAgICAgICAgICBsZXQgbGFzdE5vZGU7XG4gICAgICAgICAgICB3aGlsZSAoKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgICAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICAgICAgICAgIGxhc3ROb2RlLnRleHQgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGVsLmNoaWxkcmVuLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsKSB7XG4gICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90JyB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKGBDYW5ub3QgdXNlIDwke2VsLnRhZ30+IGFzIGNvbXBvbmVudCByb290IGVsZW1lbnQgYmVjYXVzZSBpdCBtYXkgYCArXG4gICAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJywgeyBzdGFydDogZWwuc3RhcnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZSgnQ2Fubm90IHVzZSB2LWZvciBvbiBzdGF0ZWZ1bCBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgJyArXG4gICAgICAgICAgICAgICAgJ2l0IHJlbmRlcnMgbXVsdGlwbGUgZWxlbWVudHMuJywgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlSFRNTCh0ZW1wbGF0ZSwge1xuICAgICAgICB3YXJuLFxuICAgICAgICBleHBlY3RIVE1MOiBvcHRpb25zLmV4cGVjdEhUTUwsXG4gICAgICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICAgICAgY2FuQmVMZWZ0T3BlblRhZzogb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lczogb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgc2hvdWxkS2VlcENvbW1lbnQ6IG9wdGlvbnMuY29tbWVudHMsXG4gICAgICAgIG91dHB1dFNvdXJjZVJhbmdlOiBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlLFxuICAgICAgICBzdGFydCh0YWcsIGF0dHJzLCB1bmFyeSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgLy8gY2hlY2sgbmFtZXNwYWNlLlxuICAgICAgICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgICBjb25zdCBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgSUUgc3ZnIGJ1Z1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoaXNJRSAmJiBucyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVBU1RFbGVtZW50KHRhZywgYXR0cnMsIGN1cnJlbnRQYXJlbnQpO1xuICAgICAgICAgICAgaWYgKG5zKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmF3QXR0cnNNYXAgPSBlbGVtZW50LmF0dHJzTGlzdC5yZWR1Y2UoKGN1bXVsYXRlZCwgYXR0cikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1bXVsYXRlZDtcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdHRycy5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW52YWxpZEF0dHJpYnV0ZVJFLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybihgSW52YWxpZCBkeW5hbWljIGFyZ3VtZW50IGV4cHJlc3Npb246IGF0dHJpYnV0ZSBuYW1lcyBjYW5ub3QgY29udGFpbiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgc3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5gLCBvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmluZGV4T2YoYFtgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBhdHRyLnN0YXJ0ICsgYXR0ci5uYW1lLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZvcmJpZGRlblRhZyhlbGVtZW50KSAmJiAhaXNTZXJ2ZXJSZW5kZXJpbmcoKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9yYmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3YXJuKCdUZW1wbGF0ZXMgc2hvdWxkIG9ubHkgYmUgcmVzcG9uc2libGUgZm9yIG1hcHBpbmcgdGhlIHN0YXRlIHRvIHRoZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdVSS4gQXZvaWQgcGxhY2luZyB0YWdzIHdpdGggc2lkZS1lZmZlY3RzIGluIHlvdXIgdGVtcGxhdGVzLCBzdWNoIGFzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYDwke3RhZ30+YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnLCBhcyB0aGV5IHdpbGwgbm90IGJlIHBhcnNlZC4nLCB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmVUcmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NQcmUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQucHJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluVlByZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgICAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NSYXdBdHRycyhlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyYWwgZGlyZWN0aXZlc1xuICAgICAgICAgICAgICAgIHByb2Nlc3NGb3IoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHByb2Nlc3NPbmNlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb290KSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kKHRhZywgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgLy8gcG9wIHN0YWNrXG4gICAgICAgICAgICBzdGFjay5sZW5ndGggLT0gMTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYXJzKHRleHQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFBhcmVudCkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuT25jZSgnQ29tcG9uZW50IHRlbXBsYXRlIHJlcXVpcmVzIGEgcm9vdCBlbGVtZW50LCByYXRoZXIgdGhhbiBqdXN0IHRleHQuJywgeyBzdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2Fybk9uY2UoYHRleHQgXCIke3RleHR9XCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLmAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSUUgdGV4dGFyZWEgcGxhY2Vob2xkZXIgYnVnXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChpc0lFICYmXG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC50YWcgPT09ICd0ZXh0YXJlYScgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KVxuICAgICAgICAgICAgICAgICAgICA/IHRleHRcbiAgICAgICAgICAgICAgICAgICAgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgd2hpdGVzcGFjZS1vbmx5IG5vZGUgcmlnaHQgYWZ0ZXIgYW4gb3BlbmluZyB0YWdcbiAgICAgICAgICAgICAgICB0ZXh0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3aGl0ZXNwYWNlT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gbGluZSBicmVhaywgb3RoZXJ3aXNlIGNvbmRlbnNlIHRvIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSBsaW5lQnJlYWtSRS50ZXN0KHRleHQpID8gJycgOiAnICc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBwcmVzZXJ2ZVdoaXRlc3BhY2UgPyAnICcgOiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpblByZSAmJiB3aGl0ZXNwYWNlT3B0aW9uID09PSAnY29uZGVuc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2Uod2hpdGVzcGFjZVJFLCAnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogcmVzLmV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IHJlcy50b2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHQgIT09ICcgJyB8fFxuICAgICAgICAgICAgICAgICAgICAhY2hpbGRyZW4ubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLnRleHQgIT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1lbnQodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgICAgLy8gYWRkaW5nIGFueXRoaW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgICAgICAgLy8gY29tbWVudHMgc2hvdWxkIHN0aWxsIGJlIGFsbG93ZWQsIGJ1dCBpZ25vcmVkXG4gICAgICAgICAgICBpZiAoY3VycmVudFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmVuZCA9IGVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gcHJvY2Vzc1ByZShlbCkge1xuICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgICAgIGVsLnByZSA9IHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc1Jhd0F0dHJzKGVsKSB7XG4gICAgY29uc3QgbGlzdCA9IGVsLmF0dHJzTGlzdDtcbiAgICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gKGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbikpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBsaXN0W2ldLm5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IEpTT04uc3RyaW5naWZ5KGxpc3RbaV0udmFsdWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICghZWwucHJlKSB7XG4gICAgICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICAgICAgZWwucGxhaW4gPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBwcm9jZXNzS2V5KGVsZW1lbnQpO1xuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgZWxlbWVudC5wbGFpbiA9XG4gICAgICAgICFlbGVtZW50LmtleSAmJiAhZWxlbWVudC5zY29wZWRTbG90cyAmJiAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoO1xuICAgIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gICAgcHJvY2Vzc1Nsb3RDb250ZW50KGVsZW1lbnQpO1xuICAgIHByb2Nlc3NTbG90T3V0bGV0KGVsZW1lbnQpO1xuICAgIHByb2Nlc3NDb21wb25lbnQoZWxlbWVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgfVxuICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NLZXkoZWwpIHtcbiAgICBjb25zdCBleHAgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2tleScpO1xuICAgIGlmIChleHApIHtcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgICAgIHdhcm4oYDx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5gLCBnZXRSYXdCaW5kaW5nQXR0cihlbCwgJ2tleScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IGVsLml0ZXJhdG9yMiB8fCBlbC5pdGVyYXRvcjE7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRvciAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRvciA9PT0gZXhwICYmXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQudGFnID09PSAndHJhbnNpdGlvbi1ncm91cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgRG8gbm90IHVzZSB2LWZvciBpbmRleCBhcyBrZXkgb24gPHRyYW5zaXRpb24tZ3JvdXA+IGNoaWxkcmVuLCBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGB0aGlzIGlzIHRoZSBzYW1lIGFzIG5vdCB1c2luZyBrZXlzLmAsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksIHRydWUgLyogdGlwICovKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWwua2V5ID0gZXhwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NSZWYoZWwpIHtcbiAgICBjb25zdCByZWYgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3JlZicpO1xuICAgIGlmIChyZWYpIHtcbiAgICAgICAgZWwucmVmID0gcmVmO1xuICAgICAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NGb3IoZWwpIHtcbiAgICBsZXQgZXhwO1xuICAgIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHBhcnNlRm9yKGV4cCk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIGV4dGVuZChlbCwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdhcm4oYEludmFsaWQgdi1mb3IgZXhwcmVzc2lvbjogJHtleHB9YCwgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VGb3IoZXhwKSB7XG4gICAgY29uc3QgaW5NYXRjaCA9IGV4cC5tYXRjaChmb3JBbGlhc1JFKTtcbiAgICBpZiAoIWluTWF0Y2gpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgY29uc3QgYWxpYXMgPSBpbk1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKHN0cmlwUGFyZW5zUkUsICcnKTtcbiAgICBjb25zdCBpdGVyYXRvck1hdGNoID0gYWxpYXMubWF0Y2goZm9ySXRlcmF0b3JSRSk7XG4gICAgaWYgKGl0ZXJhdG9yTWF0Y2gpIHtcbiAgICAgICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgICAgICByZXMuaXRlcmF0b3IxID0gaXRlcmF0b3JNYXRjaFsxXS50cmltKCk7XG4gICAgICAgIGlmIChpdGVyYXRvck1hdGNoWzJdKSB7XG4gICAgICAgICAgICByZXMuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFsyXS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcy5hbGlhcyA9IGFsaWFzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0lmKGVsKSB7XG4gICAgY29uc3QgZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnKTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICAgIGVsLmlmID0gZXhwO1xuICAgICAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgICAgICAgZXhwOiBleHAsXG4gICAgICAgICAgICBibG9jazogZWxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsc2VpZiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnKTtcbiAgICAgICAgaWYgKGVsc2VpZikge1xuICAgICAgICAgICAgZWwuZWxzZWlmID0gZWxzZWlmO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbCwgcGFyZW50KSB7XG4gICAgY29uc3QgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICAgIGlmIChwcmV2ICYmIHByZXYuaWYpIHtcbiAgICAgICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICAgICAgICBibG9jazogZWxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuKGB2LSR7ZWwuZWxzZWlmID8gJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJyA6ICdlbHNlJ30gYCArXG4gICAgICAgICAgICBgdXNlZCBvbiBlbGVtZW50IDwke2VsLnRhZ30+IHdpdGhvdXQgY29ycmVzcG9uZGluZyB2LWlmLmAsIGVsLnJhd0F0dHJzTWFwW2VsLmVsc2VpZiA/ICd2LWVsc2UtaWYnIDogJ3YtZWxzZSddKTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kUHJldkVsZW1lbnQoY2hpbGRyZW4pIHtcbiAgICBsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgd2FybihgdGV4dCBcIiR7Y2hpbGRyZW5baV0udGV4dC50cmltKCl9XCIgYmV0d2VlbiB2LWlmIGFuZCB2LWVsc2UoLWlmKSBgICtcbiAgICAgICAgICAgICAgICAgICAgYHdpbGwgYmUgaWdub3JlZC5gLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uKGVsLCBjb25kaXRpb24pIHtcbiAgICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgICAgICBlbC5pZkNvbmRpdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NPbmNlKGVsKSB7XG4gICAgY29uc3Qgb25jZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgICBpZiAob25jZSAhPSBudWxsKSB7XG4gICAgICAgIGVsLm9uY2UgPSB0cnVlO1xuICAgIH1cbn1cbi8vIGhhbmRsZSBjb250ZW50IGJlaW5nIHBhc3NlZCB0byBhIGNvbXBvbmVudCBhcyBzbG90LFxuLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG5mdW5jdGlvbiBwcm9jZXNzU2xvdENvbnRlbnQoZWwpIHtcbiAgICBsZXQgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Njb3BlJyk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICB3YXJuKGB0aGUgXCJzY29wZVwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBgICtcbiAgICAgICAgICAgICAgICBgcmVwbGFjZWQgYnkgXCJzbG90LXNjb3BlXCIgc2luY2UgMi41LiBUaGUgbmV3IFwic2xvdC1zY29wZVwiIGF0dHJpYnV0ZSBgICtcbiAgICAgICAgICAgICAgICBgY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIGAgK1xuICAgICAgICAgICAgICAgIGBkZW5vdGUgc2NvcGVkIHNsb3RzLmAsIGVsLnJhd0F0dHJzTWFwWydzY29wZSddLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJykpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZWwuYXR0cnNNYXBbJ3YtZm9yJ10pIHtcbiAgICAgICAgICAgIHdhcm4oYEFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8JHtlbC50YWd9PiBgICtcbiAgICAgICAgICAgICAgICBgKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIGAgK1xuICAgICAgICAgICAgICAgIGBzY29wZWQgc2xvdCB0byBtYWtlIGl0IGNsZWFyZXIuYCwgZWwucmF3QXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgIH1cbiAgICAvLyBzbG90PVwieHh4XCJcbiAgICBjb25zdCBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgICAgZWwuc2xvdFRhcmdldCA9IHNsb3RUYXJnZXQgPT09ICdcIlwiJyA/ICdcImRlZmF1bHRcIicgOiBzbG90VGFyZ2V0O1xuICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9ICEhKGVsLmF0dHJzTWFwWyc6c2xvdCddIHx8IGVsLmF0dHJzTWFwWyd2LWJpbmQ6c2xvdCddKTtcbiAgICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzLlxuICAgICAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgIGFkZEF0dHIoZWwsICdzbG90Jywgc2xvdFRhcmdldCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdzbG90JykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDIuNiB2LXNsb3Qgc3ludGF4XG4gICAge1xuICAgICAgICBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICAvLyB2LXNsb3Qgb24gPHRlbXBsYXRlPlxuICAgICAgICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgICAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnNsb3RUYXJnZXQgfHwgZWwuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGA8dGVtcGxhdGUgdi1zbG90PiBjYW4gb25seSBhcHBlYXIgYXQgdGhlIHJvb3QgbGV2ZWwgaW5zaWRlIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB0aGUgcmVjZWl2aW5nIGNvbXBvbmVudGAsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR5bmFtaWMgfSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICBlbC5zbG90VGFyZ2V0ID0gbmFtZTtcbiAgICAgICAgICAgICAgICBlbC5zbG90VGFyZ2V0RHluYW1pYyA9IGR5bmFtaWM7XG4gICAgICAgICAgICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmcudmFsdWUgfHwgZW1wdHlTbG90U2NvcGVUb2tlbjsgLy8gZm9yY2UgaXQgaW50byBhIHNjb3BlZCBzbG90IGZvciBwZXJmXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgICAgICAgY29uc3Qgc2xvdEJpbmRpbmcgPSBnZXRBbmRSZW1vdmVBdHRyQnlSZWdleChlbCwgc2xvdFJFKTtcbiAgICAgICAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXliZUNvbXBvbmVudChlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYHYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5gLCBzbG90QmluZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnNsb3RTY29wZSB8fCBlbC5zbG90VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuKGBVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLmAsIGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuc2NvcGVkU2xvdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYFRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYDx0ZW1wbGF0ZT4gc3ludGF4IHdoZW4gdGhlcmUgYXJlIG90aGVyIG5hbWVkIHNsb3RzLmAsIHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90cyA9IGVsLnNjb3BlZFNsb3RzIHx8IChlbC5zY29wZWRTbG90cyA9IHt9KTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR5bmFtaWMgfSA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90Q29udGFpbmVyID0gKHNsb3RzW25hbWVdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpKTtcbiAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXQgPSBuYW1lO1xuICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICAgICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGFzIHRoZXkgYXJlIHJldHVybmVkIGZyb20gc2NvcGVkU2xvdHMgbm93XG4gICAgICAgICAgICAgICAgZWwuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGVsIG5vbi1wbGFpbiBzbyBkYXRhIGdldHMgZ2VuZXJhdGVkXG4gICAgICAgICAgICAgICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNsb3ROYW1lKGJpbmRpbmcpIHtcbiAgICBsZXQgbmFtZSA9IGJpbmRpbmcubmFtZS5yZXBsYWNlKHNsb3RSRSwgJycpO1xuICAgIGlmICghbmFtZSkge1xuICAgICAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgICAgICAgIG5hbWUgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3YXJuKGB2LXNsb3Qgc2hvcnRoYW5kIHN5bnRheCByZXF1aXJlcyBhIHNsb3QgbmFtZS5gLCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHluYW1pY0FyZ1JFLnRlc3QobmFtZSlcbiAgICAgICAgPyAvLyBkeW5hbWljIFtuYW1lXVxuICAgICAgICAgICAgeyBuYW1lOiBuYW1lLnNsaWNlKDEsIC0xKSwgZHluYW1pYzogdHJ1ZSB9XG4gICAgICAgIDogLy8gc3RhdGljIG5hbWVcbiAgICAgICAgICAgIHsgbmFtZTogYFwiJHtuYW1lfVwiYCwgZHluYW1pYzogZmFsc2UgfTtcbn1cbi8vIGhhbmRsZSA8c2xvdC8+IG91dGxldHNcbmZ1bmN0aW9uIHByb2Nlc3NTbG90T3V0bGV0KGVsKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgICAgIGlmIChlbC5rZXkpIHtcbiAgICAgICAgICAgIHdhcm4oYFxcYGtleVxcYCBkb2VzIG5vdCB3b3JrIG9uIDxzbG90PiBiZWNhdXNlIHNsb3RzIGFyZSBhYnN0cmFjdCBvdXRsZXRzIGAgK1xuICAgICAgICAgICAgICAgIGBhbmQgY2FuIHBvc3NpYmx5IGV4cGFuZCBpbnRvIG11bHRpcGxlIGVsZW1lbnRzLiBgICtcbiAgICAgICAgICAgICAgICBgVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuYCwgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzQ29tcG9uZW50KGVsKSB7XG4gICAgbGV0IGJpbmRpbmc7XG4gICAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgICAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICAgIH1cbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ2lubGluZS10ZW1wbGF0ZScpICE9IG51bGwpIHtcbiAgICAgICAgZWwuaW5saW5lVGVtcGxhdGUgPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NBdHRycyhlbCkge1xuICAgIGNvbnN0IGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgbGV0IGksIGwsIG5hbWUsIHJhd05hbWUsIHZhbHVlLCBtb2RpZmllcnMsIHN5bmNHZW4sIGlzRHluYW1pYztcbiAgICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbmFtZSA9IHJhd05hbWUgPSBsaXN0W2ldLm5hbWU7XG4gICAgICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICAgICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAgICAgICAvLyBtb2RpZmllcnNcbiAgICAgICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgLmZvbyBzaG9ydGhhbmQgc3ludGF4IGZvciB0aGUgLnByb3AgbW9kaWZpZXJcbiAgICAgICAgICAgIGlmIChtb2RpZmllcnMpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIHYtYmluZFxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcInYtYmluZDoke25hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnByb3AgJiYgIWlzRHluYW1pYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpbm5lckh0bWwnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnaW5uZXJIVE1MJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYCRldmVudGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBgdXBkYXRlOiR7Y2FtZWxpemUobmFtZSl9YCwgc3luY0dlbiwgbnVsbCwgZmFsc2UsIHdhcm4sIGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeXBoZW5hdGUobmFtZSkgIT09IGNhbWVsaXplKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoZWwsIGB1cGRhdGU6JHtoeXBoZW5hdGUobmFtZSl9YCwgc3luY0dlbiwgbnVsbCwgZmFsc2UsIHdhcm4sIGxpc3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkSGFuZGxlcihlbCwgYFwidXBkYXRlOlwiKygke25hbWV9KWAsIHN5bmNHZW4sIG51bGwsIGZhbHNlLCB3YXJuLCBsaXN0W2ldLCB0cnVlIC8vIGR5bmFtaWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgobW9kaWZpZXJzICYmIG1vZGlmaWVycy5wcm9wKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIWVsLmNvbXBvbmVudCAmJiBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFByb3AoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkQXR0cihlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob25SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gdi1vblxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRIYW5kbGVyKGVsLCBuYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBmYWxzZSwgd2FybiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbCBkaXJlY3RpdmVzXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShkaXJSRSwgJycpO1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgICAgICAgICAgbGV0IGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHluYW1pY0FyZ1JFLnRlc3QoYXJnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkRGlyZWN0aXZlKGVsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgYXJnLCBpc0R5bmFtaWMsIG1vZGlmaWVycywgbGlzdFtpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbGl0ZXJhbCBhdHRyaWJ1dGVcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBwYXJzZVRleHQodmFsdWUsIGRlbGltaXRlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybihgJHtuYW1lfT1cIiR7dmFsdWV9XCI6IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0ludGVycG9sYXRpb24gaW5zaWRlIGF0dHJpYnV0ZXMgaGFzIGJlZW4gcmVtb3ZlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLCBsaXN0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICAgICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRQcm9wKGVsLCBuYW1lLCAndHJ1ZScsIGxpc3RbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbkZvcihlbCkge1xuICAgIGxldCBwYXJlbnQgPSBlbDtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKG5hbWUpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gobW9kaWZpZXJSRSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHt9O1xuICAgICAgICBtYXRjaC5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgICAgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUF0dHJzTWFwKGF0dHJzKSB7XG4gICAgY29uc3QgbWFwID0ge307XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhdHRycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlKSB7XG4gICAgICAgICAgICB3YXJuKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSA9IGF0dHJzW2ldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuLy8gZm9yIHNjcmlwdCAoZS5nLiB0eXBlPVwieC90ZW1wbGF0ZVwiKSBvciBzdHlsZSwgZG8gbm90IGRlY29kZSBjb250ZW50XG5mdW5jdGlvbiBpc1RleHRUYWcoZWwpIHtcbiAgICByZXR1cm4gZWwudGFnID09PSAnc2NyaXB0JyB8fCBlbC50YWcgPT09ICdzdHlsZSc7XG59XG5mdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyhlbCkge1xuICAgIHJldHVybiAoZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmXG4gICAgICAgICAgICAoIWVsLmF0dHJzTWFwLnR5cGUgfHwgZWwuYXR0cnNNYXAudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpKSk7XG59XG5jb25zdCBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xuY29uc3QgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyhhdHRycykge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJzW2ldO1xuICAgICAgICBpZiAoIWllTlNCdWcudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICBhdHRyLm5hbWUgPSBhdHRyLm5hbWUucmVwbGFjZShpZU5TUHJlZml4LCAnJyk7XG4gICAgICAgICAgICByZXMucHVzaChhdHRyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsKGVsLCB2YWx1ZSkge1xuICAgIGxldCBfZWwgPSBlbDtcbiAgICB3aGlsZSAoX2VsKSB7XG4gICAgICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHdhcm4oYDwke2VsLnRhZ30gdi1tb2RlbD1cIiR7dmFsdWV9XCI+OiBgICtcbiAgICAgICAgICAgICAgICBgWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIGAgK1xuICAgICAgICAgICAgICAgIGBUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBgICtcbiAgICAgICAgICAgICAgICBgd3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gYCArXG4gICAgICAgICAgICAgICAgYENvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLmAsIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ10pO1xuICAgICAgICB9XG4gICAgICAgIF9lbCA9IF9lbC5wYXJlbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEV4cGFuZCBpbnB1dFt2LW1vZGVsXSB3aXRoIGR5bmFtaWMgdHlwZSBiaW5kaW5ncyBpbnRvIHYtaWYtZWxzZSBjaGFpbnNcbiAqIFR1cm4gdGhpczpcbiAqICAgPGlucHV0IHYtbW9kZWw9XCJkYXRhW3R5cGVdXCIgOnR5cGU9XCJ0eXBlXCI+XG4gKiBpbnRvIHRoaXM6XG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UtaWY9XCJ0eXBlID09PSAncmFkaW8nXCIgdHlwZT1cInJhZGlvXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZSA6dHlwZT1cInR5cGVcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICovXG5mdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlKGVsLCBvcHRpb25zKSB7XG4gICAgaWYgKGVsLnRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAgICBjb25zdCBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICAgICAgaWYgKCFtYXBbJ3YtbW9kZWwnXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0eXBlQmluZGluZztcbiAgICAgICAgaWYgKG1hcFsnOnR5cGUnXSB8fCBtYXBbJ3YtYmluZDp0eXBlJ10pIHtcbiAgICAgICAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXAudHlwZSAmJiAhdHlwZUJpbmRpbmcgJiYgbWFwWyd2LWJpbmQnXSkge1xuICAgICAgICAgICAgdHlwZUJpbmRpbmcgPSBgKCR7bWFwWyd2LWJpbmQnXX0pLnR5cGVgO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlQmluZGluZykge1xuICAgICAgICAgICAgY29uc3QgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgICAgICAgY29uc3QgaWZDb25kaXRpb25FeHRyYSA9IGlmQ29uZGl0aW9uID8gYCYmKCR7aWZDb25kaXRpb259KWAgOiBgYDtcbiAgICAgICAgICAgIGNvbnN0IGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGVsc2VJZkNvbmRpdGlvbiA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UtaWYnLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIDEuIGNoZWNrYm94XG4gICAgICAgICAgICBjb25zdCBicmFuY2gwID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgICAgICAgIHByb2Nlc3NGb3IoYnJhbmNoMCk7XG4gICAgICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDAsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyYW5jaDAucHJvY2Vzc2VkID0gdHJ1ZTsgLy8gcHJldmVudCBpdCBmcm9tIGRvdWJsZS1wcm9jZXNzZWRcbiAgICAgICAgICAgIGJyYW5jaDAuaWYgPSBgKCR7dHlwZUJpbmRpbmd9KT09PSdjaGVja2JveCdgICsgaWZDb25kaXRpb25FeHRyYTtcbiAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgICAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gMi4gYWRkIHJhZGlvIGVsc2UtaWYgY29uZGl0aW9uXG4gICAgICAgICAgICBjb25zdCBicmFuY2gxID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDEsICd0eXBlJywgJ3JhZGlvJyk7XG4gICAgICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gxLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICAgICAgICBleHA6IGAoJHt0eXBlQmluZGluZ30pPT09J3JhZGlvJ2AgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICAgICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIDMuIG90aGVyXG4gICAgICAgICAgICBjb25zdCBicmFuY2gyID0gY2xvbmVBU1RFbGVtZW50KGVsKTtcbiAgICAgICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgICAgICBhZGRSYXdBdHRyKGJyYW5jaDIsICc6dHlwZScsIHR5cGVCaW5kaW5nKTtcbiAgICAgICAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgICAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgYnJhbmNoMC5lbHNlaWYgPSBlbHNlSWZDb25kaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnJhbmNoMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb25lQVNURWxlbWVudChlbCkge1xuICAgIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudCk7XG59XG52YXIgbW9kZWwgPSB7XG4gICAgcHJlVHJhbnNmb3JtTm9kZVxufTtcblxudmFyIG1vZHVsZXMgPSBba2xhc3MsIHN0eWxlLCBtb2RlbF07XG5cbmZ1bmN0aW9uIHRleHQoZWwsIGRpcikge1xuICAgIGlmIChkaXIudmFsdWUpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaHRtbChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgYF9zKCR7ZGlyLnZhbHVlfSlgLCBkaXIpO1xuICAgIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMgPSB7XG4gICAgbW9kZWw6IG1vZGVsJDEsXG4gICAgdGV4dCxcbiAgICBodG1sXG59O1xuXG5jb25zdCBiYXNlT3B0aW9ucyA9IHtcbiAgICBleHBlY3RIVE1MOiB0cnVlLFxuICAgIG1vZHVsZXMsXG4gICAgZGlyZWN0aXZlcyxcbiAgICBpc1ByZVRhZyxcbiAgICBpc1VuYXJ5VGFnLFxuICAgIG11c3RVc2VQcm9wLFxuICAgIGNhbkJlTGVmdE9wZW5UYWcsXG4gICAgaXNSZXNlcnZlZFRhZyxcbiAgICBnZXRUYWdOYW1lc3BhY2UsXG4gICAgc3RhdGljS2V5czogZ2VuU3RhdGljS2V5cyQxKG1vZHVsZXMpXG59O1xuXG5sZXQgaXNTdGF0aWNLZXk7XG5sZXQgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuY29uc3QgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzKTtcbi8qKlxuICogR29hbCBvZiB0aGUgb3B0aW1pemVyOiB3YWxrIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgQVNUIHRyZWVcbiAqIGFuZCBkZXRlY3Qgc3ViLXRyZWVzIHRoYXQgYXJlIHB1cmVseSBzdGF0aWMsIGkuZS4gcGFydHMgb2ZcbiAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gKlxuICogT25jZSB3ZSBkZXRlY3QgdGhlc2Ugc3ViLXRyZWVzLCB3ZSBjYW46XG4gKlxuICogMS4gSG9pc3QgdGhlbSBpbnRvIGNvbnN0YW50cywgc28gdGhhdCB3ZSBubyBsb25nZXIgbmVlZCB0b1xuICogICAgY3JlYXRlIGZyZXNoIG5vZGVzIGZvciB0aGVtIG9uIGVhY2ggcmUtcmVuZGVyO1xuICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gKi9cbmZ1bmN0aW9uIG9wdGltaXplKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXJvb3QpXG4gICAgICAgIHJldHVybjtcbiAgICBpc1N0YXRpY0tleSA9IGdlblN0YXRpY0tleXNDYWNoZWQob3B0aW9ucy5zdGF0aWNLZXlzIHx8ICcnKTtcbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gICAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgICBtYXJrU3RhdGljKHJvb3QpO1xuICAgIC8vIHNlY29uZCBwYXNzOiBtYXJrIHN0YXRpYyByb290cy5cbiAgICBtYXJrU3RhdGljUm9vdHMocm9vdCwgZmFsc2UpO1xufVxuZnVuY3Rpb24gZ2VuU3RhdGljS2V5cyhrZXlzKSB7XG4gICAgcmV0dXJuIG1ha2VNYXAoJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKSk7XG59XG5mdW5jdGlvbiBtYXJrU3RhdGljKG5vZGUpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgICAgIC8vIDEuIGNvbXBvbmVudHMgbm90IGFibGUgdG8gbXV0YXRlIHNsb3Qgbm9kZXNcbiAgICAgICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgICAgICBpZiAoIWlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiZcbiAgICAgICAgICAgIG5vZGUudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgICAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBtYXJrU3RhdGljKGNoaWxkKTtcbiAgICAgICAgICAgIGlmICghY2hpbGQuc3RhdGljKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxLCBsID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSBub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaztcbiAgICAgICAgICAgICAgICBtYXJrU3RhdGljKGJsb2NrKTtcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrLnN0YXRpYykge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyhub2RlLCBpc0luRm9yKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICBpZiAobm9kZS5zdGF0aWMgfHwgbm9kZS5vbmNlKSB7XG4gICAgICAgICAgICBub2RlLnN0YXRpY0luRm9yID0gaXNJbkZvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgICAgICAvLyBhcmUgbm90IGp1c3Qgc3RhdGljIHRleHQuIE90aGVyd2lzZSB0aGUgY29zdCBvZiBob2lzdGluZyBvdXQgd2lsbFxuICAgICAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgICAgIGlmIChub2RlLnN0YXRpYyAmJlxuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5sZW5ndGggJiZcbiAgICAgICAgICAgICEobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzKSkge1xuICAgICAgICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUuc3RhdGljUm9vdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMSwgbCA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpXS5ibG9jaywgaXNJbkZvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBpc1N0YXRpYyhub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMikge1xuICAgICAgICAvLyBleHByZXNzaW9uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMykge1xuICAgICAgICAvLyB0ZXh0XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gISEobm9kZS5wcmUgfHxcbiAgICAgICAgKCFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAgICAgICAgICFub2RlLmlmICYmXG4gICAgICAgICAgICAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgICAgICAgICAhaXNCdWlsdEluVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBidWlsdC1pblxuICAgICAgICAgICAgaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJiAvLyBub3QgYSBjb21wb25lbnRcbiAgICAgICAgICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXMobm9kZSkuZXZlcnkoaXNTdGF0aWNLZXkpKSk7XG59XG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICAgICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvbig/OlxccytbXFx3JF0rKT9cXHMqXFwoLztcbmNvbnN0IGZuSW52b2tlUkUgPSAvXFwoW14pXSo/XFwpOyokLztcbmNvbnN0IHNpbXBsZVBhdGhSRSA9IC9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC87XG4vLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xuY29uc3Qga2V5Q29kZXMgPSB7XG4gICAgZXNjOiAyNyxcbiAgICB0YWI6IDksXG4gICAgZW50ZXI6IDEzLFxuICAgIHNwYWNlOiAzMixcbiAgICB1cDogMzgsXG4gICAgbGVmdDogMzcsXG4gICAgcmlnaHQ6IDM5LFxuICAgIGRvd246IDQwLFxuICAgIGRlbGV0ZTogWzgsIDQ2XVxufTtcbi8vIEtleWJvYXJkRXZlbnQua2V5IGFsaWFzZXNcbmNvbnN0IGtleU5hbWVzID0ge1xuICAgIC8vICM3ODgwOiBJRTExIGFuZCBFZGdlIHVzZSBgRXNjYCBmb3IgRXNjYXBlIGtleSBuYW1lLlxuICAgIGVzYzogWydFc2MnLCAnRXNjYXBlJ10sXG4gICAgdGFiOiAnVGFiJyxcbiAgICBlbnRlcjogJ0VudGVyJyxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBTcGFjZWJhcmAgZm9yIFNwYWNlIGtleSBuYW1lLlxuICAgIHNwYWNlOiBbJyAnLCAnU3BhY2ViYXInXSxcbiAgICAvLyAjNzgwNjogSUUxMSB1c2VzIGtleSBuYW1lcyB3aXRob3V0IGBBcnJvd2AgcHJlZml4IGZvciBhcnJvdyBrZXlzLlxuICAgIHVwOiBbJ1VwJywgJ0Fycm93VXAnXSxcbiAgICBsZWZ0OiBbJ0xlZnQnLCAnQXJyb3dMZWZ0J10sXG4gICAgcmlnaHQ6IFsnUmlnaHQnLCAnQXJyb3dSaWdodCddLFxuICAgIGRvd246IFsnRG93bicsICdBcnJvd0Rvd24nXSxcbiAgICAvLyAjOTExMjogSUUxMSB1c2VzIGBEZWxgIGZvciBEZWxldGUga2V5IG5hbWUuXG4gICAgZGVsZXRlOiBbJ0JhY2tzcGFjZScsICdEZWxldGUnLCAnRGVsJ11cbn07XG4vLyAjNDg2ODogbW9kaWZpZXJzIHRoYXQgcHJldmVudCB0aGUgZXhlY3V0aW9uIG9mIHRoZSBsaXN0ZW5lclxuLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuLy8gdGhlIGxpc3RlbmVyIGZvciAub25jZVxuY29uc3QgZ2VuR3VhcmQgPSBjb25kaXRpb24gPT4gYGlmKCR7Y29uZGl0aW9ufSlyZXR1cm4gbnVsbDtgO1xuY29uc3QgbW9kaWZpZXJDb2RlID0ge1xuICAgIHN0b3A6ICckZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7JyxcbiAgICBwcmV2ZW50OiAnJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7JyxcbiAgICBzZWxmOiBnZW5HdWFyZChgJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRgKSxcbiAgICBjdHJsOiBnZW5HdWFyZChgISRldmVudC5jdHJsS2V5YCksXG4gICAgc2hpZnQ6IGdlbkd1YXJkKGAhJGV2ZW50LnNoaWZ0S2V5YCksXG4gICAgYWx0OiBnZW5HdWFyZChgISRldmVudC5hbHRLZXlgKSxcbiAgICBtZXRhOiBnZW5HdWFyZChgISRldmVudC5tZXRhS2V5YCksXG4gICAgbGVmdDogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAwYCksXG4gICAgbWlkZGxlOiBnZW5HdWFyZChgJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFgKSxcbiAgICByaWdodDogZ2VuR3VhcmQoYCdidXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyYClcbn07XG5mdW5jdGlvbiBnZW5IYW5kbGVycyhldmVudHMsIGlzTmF0aXZlKSB7XG4gICAgY29uc3QgcHJlZml4ID0gaXNOYXRpdmUgPyAnbmF0aXZlT246JyA6ICdvbjonO1xuICAgIGxldCBzdGF0aWNIYW5kbGVycyA9IGBgO1xuICAgIGxldCBkeW5hbWljSGFuZGxlcnMgPSBgYDtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZXZlbnRzKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgICAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgICAgICAgZHluYW1pY0hhbmRsZXJzICs9IGAke25hbWV9LCR7aGFuZGxlckNvZGV9LGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0aWNIYW5kbGVycyArPSBgXCIke25hbWV9XCI6JHtoYW5kbGVyQ29kZX0sYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNIYW5kbGVycyA9IGB7JHtzdGF0aWNIYW5kbGVycy5zbGljZSgwLCAtMSl9fWA7XG4gICAgaWYgKGR5bmFtaWNIYW5kbGVycykge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgYF9kKCR7c3RhdGljSGFuZGxlcnN9LFske2R5bmFtaWNIYW5kbGVycy5zbGljZSgwLCAtMSl9XSlgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbkhhbmRsZXIoaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uKCl7fSc7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICAgIHJldHVybiBgWyR7aGFuZGxlci5tYXAoaGFuZGxlciA9PiBnZW5IYW5kbGVyKGhhbmRsZXIpKS5qb2luKCcsJyl9XWA7XG4gICAgfVxuICAgIGNvbnN0IGlzTWV0aG9kUGF0aCA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIGNvbnN0IGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIGNvbnN0IGlzRnVuY3Rpb25JbnZvY2F0aW9uID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZS5yZXBsYWNlKGZuSW52b2tlUkUsICcnKSk7XG4gICAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgICBpZiAoaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYGZ1bmN0aW9uKCRldmVudCl7JHtpc0Z1bmN0aW9uSW52b2NhdGlvbiA/IGByZXR1cm4gJHtoYW5kbGVyLnZhbHVlfWAgOiBoYW5kbGVyLnZhbHVlfX1gOyAvLyBpbmxpbmUgc3RhdGVtZW50XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgY29kZSA9ICcnO1xuICAgICAgICBsZXQgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgICAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICAgICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBtb2RpZmllckNvZGVba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBsZWZ0L3JpZ2h0XG4gICAgICAgICAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZXJzID0gaGFuZGxlci5tb2RpZmllcnM7XG4gICAgICAgICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFsnY3RybCcsICdzaGlmdCcsICdhbHQnLCAnbWV0YSddXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoa2V5TW9kaWZpZXIgPT4gIW1vZGlmaWVyc1trZXlNb2RpZmllcl0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoa2V5TW9kaWZpZXIgPT4gYCRldmVudC4ke2tleU1vZGlmaWVyfUtleWApXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCd8fCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIG1vZGlmaWVycyBsaWtlIHByZXZlbnQgYW5kIHN0b3AgZ2V0IGV4ZWN1dGVkIGFmdGVyIGtleSBmaWx0ZXJpbmdcbiAgICAgICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlckNvZGUgPSBpc01ldGhvZFBhdGhcbiAgICAgICAgICAgID8gYHJldHVybiAke2hhbmRsZXIudmFsdWV9LmFwcGx5KG51bGwsIGFyZ3VtZW50cylgXG4gICAgICAgICAgICA6IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgPyBgcmV0dXJuICgke2hhbmRsZXIudmFsdWV9KS5hcHBseShudWxsLCBhcmd1bWVudHMpYFxuICAgICAgICAgICAgICAgIDogaXNGdW5jdGlvbkludm9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgPyBgcmV0dXJuICR7aGFuZGxlci52YWx1ZX1gXG4gICAgICAgICAgICAgICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGBmdW5jdGlvbigkZXZlbnQpeyR7Y29kZX0ke2hhbmRsZXJDb2RlfX1gO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbktleUZpbHRlcihrZXlzKSB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcbiAgICAvLyAjOTQ0MTogY2FuJ3QgdXNlICdrZXlDb2RlJyBpbiAkZXZlbnQgYmVjYXVzZSBDaHJvbWUgYXV0b2ZpbGwgZmlyZXMgZmFrZVxuICAgIC8vIGtleSBldmVudHMgdGhhdCBkbyBub3QgaGF2ZSBrZXlDb2RlIHByb3BlcnR5Li4uXG4gICAgYGlmKCEkZXZlbnQudHlwZS5pbmRleE9mKCdrZXknKSYmYCArXG4gICAgICAgIGAke2tleXMubWFwKGdlbkZpbHRlckNvZGUpLmpvaW4oJyYmJyl9KXJldHVybiBudWxsO2ApO1xufVxuZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZShrZXkpIHtcbiAgICBjb25zdCBrZXlWYWwgPSBwYXJzZUludChrZXksIDEwKTtcbiAgICBpZiAoa2V5VmFsKSB7XG4gICAgICAgIHJldHVybiBgJGV2ZW50LmtleUNvZGUhPT0ke2tleVZhbH1gO1xuICAgIH1cbiAgICBjb25zdCBrZXlDb2RlID0ga2V5Q29kZXNba2V5XTtcbiAgICBjb25zdCBrZXlOYW1lID0ga2V5TmFtZXNba2V5XTtcbiAgICByZXR1cm4gKGBfaygkZXZlbnQua2V5Q29kZSxgICtcbiAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkoa2V5KX0sYCArXG4gICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGtleUNvZGUpfSxgICtcbiAgICAgICAgYCRldmVudC5rZXksYCArXG4gICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGtleU5hbWUpfWAgK1xuICAgICAgICBgKWApO1xufVxuXG5mdW5jdGlvbiBvbihlbCwgZGlyKSB7XG4gICAgaWYgKGRpci5tb2RpZmllcnMpIHtcbiAgICAgICAgd2FybiQyKGB2LW9uIHdpdGhvdXQgYXJndW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBtb2RpZmllcnMuYCk7XG4gICAgfVxuICAgIGVsLndyYXBMaXN0ZW5lcnMgPSAoY29kZSkgPT4gYF9nKCR7Y29kZX0sJHtkaXIudmFsdWV9KWA7XG59XG5cbmZ1bmN0aW9uIGJpbmQoZWwsIGRpcikge1xuICAgIGVsLndyYXBEYXRhID0gKGNvZGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGBfYigke2NvZGV9LCcke2VsLnRhZ30nLCR7ZGlyLnZhbHVlfSwke2Rpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJ30ke2Rpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnfSlgO1xuICAgIH07XG59XG5cbnZhciBiYXNlRGlyZWN0aXZlcyA9IHtcbiAgICBvbixcbiAgICBiaW5kLFxuICAgIGNsb2FrOiBub29wXG59O1xuXG5jbGFzcyBDb2RlZ2VuU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgICAgICAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICAgICAgY29uc3QgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICAgICAgdGhpcy5tYXliZUNvbXBvbmVudCA9IChlbCkgPT4gISFlbC5jb21wb25lbnQgfHwgIWlzUmVzZXJ2ZWRUYWcoZWwudGFnKTtcbiAgICAgICAgdGhpcy5vbmNlSWQgPSAwO1xuICAgICAgICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICAgICAgICB0aGlzLnByZSA9IGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlbmVyYXRlKGFzdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gbmV3IENvZGVnZW5TdGF0ZShvcHRpb25zKTtcbiAgICAvLyBmaXggIzExNDgzLCBSb290IGxldmVsIDxzY3JpcHQ+IHRhZ3Mgc2hvdWxkIG5vdCBiZSByZW5kZXJlZC5cbiAgICBjb25zdCBjb2RlID0gYXN0XG4gICAgICAgID8gYXN0LnRhZyA9PT0gJ3NjcmlwdCdcbiAgICAgICAgICAgID8gJ251bGwnXG4gICAgICAgICAgICA6IGdlbkVsZW1lbnQoYXN0LCBzdGF0ZSlcbiAgICAgICAgOiAnX2MoXCJkaXZcIiknO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlbmRlcjogYHdpdGgodGhpcyl7cmV0dXJuICR7Y29kZX19YCxcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuRWxlbWVudChlbCwgc3RhdGUpIHtcbiAgICBpZiAoZWwucGFyZW50KSB7XG4gICAgICAgIGVsLnByZSA9IGVsLnByZSB8fCBlbC5wYXJlbnQucHJlO1xuICAgIH1cbiAgICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWwub25jZSAmJiAhZWwub25jZVByb2Nlc3NlZCkge1xuICAgICAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWwudGFnID09PSAndGVtcGxhdGUnICYmICFlbC5zbG90VGFyZ2V0ICYmICFzdGF0ZS5wcmUpIHtcbiAgICAgICAgcmV0dXJuIGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3ZvaWQgMCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBjb21wb25lbnQgb3IgZWxlbWVudFxuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgICAgICAgY29kZSA9IGdlbkNvbXBvbmVudChlbC5jb21wb25lbnQsIGVsLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG1heWJlQ29tcG9uZW50ID0gc3RhdGUubWF5YmVDb21wb25lbnQoZWwpO1xuICAgICAgICAgICAgaWYgKCFlbC5wbGFpbiB8fCAoZWwucHJlICYmIG1heWJlQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZW5EYXRhKGVsLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFnO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIGNvbXBvbmVudCBpbiA8c2NyaXB0IHNldHVwPlxuICAgICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBzdGF0ZS5vcHRpb25zLmJpbmRpbmdzO1xuICAgICAgICAgICAgaWYgKG1heWJlQ29tcG9uZW50ICYmIGJpbmRpbmdzICYmIGJpbmRpbmdzLl9faXNTY3JpcHRTZXR1cCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0YWcgPSBjaGVja0JpbmRpbmdUeXBlKGJpbmRpbmdzLCBlbC50YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0YWcpXG4gICAgICAgICAgICAgICAgdGFnID0gYCcke2VsLnRhZ30nYDtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICAgICAgICAgIGNvZGUgPSBgX2MoJHt0YWd9JHtkYXRhID8gYCwke2RhdGF9YCA6ICcnIC8vIGRhdGFcbiAgICAgICAgICAgIH0ke2NoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJyAvLyBjaGlsZHJlblxuICAgICAgICAgICAgfSlgO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1vZHVsZSB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUudHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29kZSA9IHN0YXRlLnRyYW5zZm9ybXNbaV0oZWwsIGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrQmluZGluZ1R5cGUoYmluZGluZ3MsIGtleSkge1xuICAgIGNvbnN0IGNhbWVsTmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgY29uc3QgUGFzY2FsTmFtZSA9IGNhcGl0YWxpemUoY2FtZWxOYW1lKTtcbiAgICBjb25zdCBjaGVja1R5cGUgPSAodHlwZSkgPT4ge1xuICAgICAgICBpZiAoYmluZGluZ3Nba2V5XSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZGluZ3NbY2FtZWxOYW1lXSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbWVsTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmluZGluZ3NbUGFzY2FsTmFtZV0gPT09IHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXNjYWxOYW1lO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBmcm9tQ29uc3QgPSBjaGVja1R5cGUoXCJzZXR1cC1jb25zdFwiIC8qIEJpbmRpbmdUeXBlcy5TRVRVUF9DT05TVCAqLykgfHxcbiAgICAgICAgY2hlY2tUeXBlKFwic2V0dXAtcmVhY3RpdmUtY29uc3RcIiAvKiBCaW5kaW5nVHlwZXMuU0VUVVBfUkVBQ1RJVkVfQ09OU1QgKi8pO1xuICAgIGlmIChmcm9tQ29uc3QpIHtcbiAgICAgICAgcmV0dXJuIGZyb21Db25zdDtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heWJlUmVmID0gY2hlY2tUeXBlKFwic2V0dXAtbGV0XCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX0xFVCAqLykgfHxcbiAgICAgICAgY2hlY2tUeXBlKFwic2V0dXAtcmVmXCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX1JFRiAqLykgfHxcbiAgICAgICAgY2hlY2tUeXBlKFwic2V0dXAtbWF5YmUtcmVmXCIgLyogQmluZGluZ1R5cGVzLlNFVFVQX01BWUJFX1JFRiAqLyk7XG4gICAgaWYgKGZyb21NYXliZVJlZikge1xuICAgICAgICByZXR1cm4gZnJvbU1heWJlUmVmO1xuICAgIH1cbn1cbi8vIGhvaXN0IHN0YXRpYyBzdWItdHJlZXMgb3V0XG5mdW5jdGlvbiBnZW5TdGF0aWMoZWwsIHN0YXRlKSB7XG4gICAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAvLyBTb21lIGVsZW1lbnRzICh0ZW1wbGF0ZXMpIG5lZWQgdG8gYmVoYXZlIGRpZmZlcmVudGx5IGluc2lkZSBvZiBhIHYtcHJlXG4gICAgLy8gbm9kZS4gIEFsbCBwcmUgbm9kZXMgYXJlIHN0YXRpYyByb290cywgc28gd2UgY2FuIHVzZSB0aGlzIGFzIGEgbG9jYXRpb24gdG9cbiAgICAvLyB3cmFwIGEgc3RhdGUgY2hhbmdlIGFuZCByZXNldCBpdCB1cG9uIGV4aXRpbmcgdGhlIHByZSBub2RlLlxuICAgIGNvbnN0IG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gICAgaWYgKGVsLnByZSkge1xuICAgICAgICBzdGF0ZS5wcmUgPSBlbC5wcmU7XG4gICAgfVxuICAgIHN0YXRlLnN0YXRpY1JlbmRlckZucy5wdXNoKGB3aXRoKHRoaXMpe3JldHVybiAke2dlbkVsZW1lbnQoZWwsIHN0YXRlKX19YCk7XG4gICAgc3RhdGUucHJlID0gb3JpZ2luYWxQcmVTdGF0ZTtcbiAgICByZXR1cm4gYF9tKCR7c3RhdGUuc3RhdGljUmVuZGVyRm5zLmxlbmd0aCAtIDF9JHtlbC5zdGF0aWNJbkZvciA/ICcsdHJ1ZScgOiAnJ30pYDtcbn1cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZShlbCwgc3RhdGUpIHtcbiAgICBlbC5vbmNlUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgICAgIHJldHVybiBnZW5JZihlbCwgc3RhdGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgICAgICBsZXQga2V5ID0gJyc7XG4gICAgICAgIGxldCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gcGFyZW50LmtleTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHN0YXRlLndhcm4oYHYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBgLCBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ10pO1xuICAgICAgICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYF9vKCR7Z2VuRWxlbWVudChlbCwgc3RhdGUpfSwke3N0YXRlLm9uY2VJZCsrfSwke2tleX0pYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5JZihlbCwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpIHtcbiAgICBlbC5pZlByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIHJldHVybiBnZW5JZkNvbmRpdGlvbnMoZWwuaWZDb25kaXRpb25zLnNsaWNlKCksIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KTtcbn1cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSkge1xuICAgIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGFsdEVtcHR5IHx8ICdfZSgpJztcbiAgICB9XG4gICAgY29uc3QgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICAgIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgICAgIHJldHVybiBgKCR7Y29uZGl0aW9uLmV4cH0pPyR7Z2VuVGVybmFyeUV4cChjb25kaXRpb24uYmxvY2spfToke2dlbklmQ29uZGl0aW9ucyhjb25kaXRpb25zLCBzdGF0ZSwgYWx0R2VuLCBhbHRFbXB0eSl9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHtnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jayl9YDtcbiAgICB9XG4gICAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICAgIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGFsdEdlblxuICAgICAgICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgICAgICAgOiBlbC5vbmNlXG4gICAgICAgICAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZW5Gb3IoZWwsIHN0YXRlLCBhbHRHZW4sIGFsdEhlbHBlcikge1xuICAgIGNvbnN0IGV4cCA9IGVsLmZvcjtcbiAgICBjb25zdCBhbGlhcyA9IGVsLmFsaWFzO1xuICAgIGNvbnN0IGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IGAsJHtlbC5pdGVyYXRvcjF9YCA6ICcnO1xuICAgIGNvbnN0IGl0ZXJhdG9yMiA9IGVsLml0ZXJhdG9yMiA/IGAsJHtlbC5pdGVyYXRvcjJ9YCA6ICcnO1xuICAgIGlmIChzdGF0ZS5tYXliZUNvbXBvbmVudChlbCkgJiZcbiAgICAgICAgZWwudGFnICE9PSAnc2xvdCcgJiZcbiAgICAgICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAgICFlbC5rZXkpIHtcbiAgICAgICAgc3RhdGUud2FybihgPCR7ZWwudGFnfSB2LWZvcj1cIiR7YWxpYXN9IGluICR7ZXhwfVwiPjogY29tcG9uZW50IGxpc3RzIHJlbmRlcmVkIHdpdGggYCArXG4gICAgICAgICAgICBgdi1mb3Igc2hvdWxkIGhhdmUgZXhwbGljaXQga2V5cy4gYCArXG4gICAgICAgICAgICBgU2VlIGh0dHBzOi8vdjIudnVlanMub3JnL3YyL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5gLCBlbC5yYXdBdHRyc01hcFsndi1mb3InXSwgdHJ1ZSAvKiB0aXAgKi8pO1xuICAgIH1cbiAgICBlbC5mb3JQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgICByZXR1cm4gKGAke2FsdEhlbHBlciB8fCAnX2wnfSgoJHtleHB9KSxgICtcbiAgICAgICAgYGZ1bmN0aW9uKCR7YWxpYXN9JHtpdGVyYXRvcjF9JHtpdGVyYXRvcjJ9KXtgICtcbiAgICAgICAgYHJldHVybiAkeyhhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKX1gICtcbiAgICAgICAgJ30pJyk7XG59XG5mdW5jdGlvbiBnZW5EYXRhKGVsLCBzdGF0ZSkge1xuICAgIGxldCBkYXRhID0gJ3snO1xuICAgIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gICAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgICBjb25zdCBkaXJzID0gZ2VuRGlyZWN0aXZlcyhlbCwgc3RhdGUpO1xuICAgIGlmIChkaXJzKVxuICAgICAgICBkYXRhICs9IGRpcnMgKyAnLCc7XG4gICAgLy8ga2V5XG4gICAgaWYgKGVsLmtleSkge1xuICAgICAgICBkYXRhICs9IGBrZXk6JHtlbC5rZXl9LGA7XG4gICAgfVxuICAgIC8vIHJlZlxuICAgIGlmIChlbC5yZWYpIHtcbiAgICAgICAgZGF0YSArPSBgcmVmOiR7ZWwucmVmfSxgO1xuICAgIH1cbiAgICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICAgICAgZGF0YSArPSBgcmVmSW5Gb3I6dHJ1ZSxgO1xuICAgIH1cbiAgICAvLyBwcmVcbiAgICBpZiAoZWwucHJlKSB7XG4gICAgICAgIGRhdGEgKz0gYHByZTp0cnVlLGA7XG4gICAgfVxuICAgIC8vIHJlY29yZCBvcmlnaW5hbCB0YWcgbmFtZSBmb3IgY29tcG9uZW50cyB1c2luZyBcImlzXCIgYXR0cmlidXRlXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgICBkYXRhICs9IGB0YWc6XCIke2VsLnRhZ31cIixgO1xuICAgIH1cbiAgICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZGF0YUdlbkZucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICAgIH1cbiAgICAvLyBhdHRyaWJ1dGVzXG4gICAgaWYgKGVsLmF0dHJzKSB7XG4gICAgICAgIGRhdGEgKz0gYGF0dHJzOiR7Z2VuUHJvcHMoZWwuYXR0cnMpfSxgO1xuICAgIH1cbiAgICAvLyBET00gcHJvcHNcbiAgICBpZiAoZWwucHJvcHMpIHtcbiAgICAgICAgZGF0YSArPSBgZG9tUHJvcHM6JHtnZW5Qcm9wcyhlbC5wcm9wcyl9LGA7XG4gICAgfVxuICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKGVsLmV2ZW50cykge1xuICAgICAgICBkYXRhICs9IGAke2dlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UpfSxgO1xuICAgIH1cbiAgICBpZiAoZWwubmF0aXZlRXZlbnRzKSB7XG4gICAgICAgIGRhdGEgKz0gYCR7Z2VuSGFuZGxlcnMoZWwubmF0aXZlRXZlbnRzLCB0cnVlKX0sYDtcbiAgICB9XG4gICAgLy8gc2xvdCB0YXJnZXRcbiAgICAvLyBvbmx5IGZvciBub24tc2NvcGVkIHNsb3RzXG4gICAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBkYXRhICs9IGBzbG90OiR7ZWwuc2xvdFRhcmdldH0sYDtcbiAgICB9XG4gICAgLy8gc2NvcGVkIHNsb3RzXG4gICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgIGRhdGEgKz0gYCR7Z2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSl9LGA7XG4gICAgfVxuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gICAgaWYgKGVsLm1vZGVsKSB7XG4gICAgICAgIGRhdGEgKz0gYG1vZGVsOnt2YWx1ZToke2VsLm1vZGVsLnZhbHVlfSxjYWxsYmFjazoke2VsLm1vZGVsLmNhbGxiYWNrfSxleHByZXNzaW9uOiR7ZWwubW9kZWwuZXhwcmVzc2lvbn19LGA7XG4gICAgfVxuICAgIC8vIGlubGluZS10ZW1wbGF0ZVxuICAgIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICBjb25zdCBpbmxpbmVUZW1wbGF0ZSA9IGdlbklubGluZVRlbXBsYXRlKGVsLCBzdGF0ZSk7XG4gICAgICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICAgICAgZGF0YSArPSBgJHtpbmxpbmVUZW1wbGF0ZX0sYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgICAvLyB2LWJpbmQgZHluYW1pYyBhcmd1bWVudCB3cmFwXG4gICAgLy8gdi1iaW5kIHdpdGggZHluYW1pYyBhcmd1bWVudHMgbXVzdCBiZSBhcHBsaWVkIHVzaW5nIHRoZSBzYW1lIHYtYmluZCBvYmplY3RcbiAgICAvLyBtZXJnZSBoZWxwZXIgc28gdGhhdCBjbGFzcy9zdHlsZS9tdXN0VXNlUHJvcCBhdHRycyBhcmUgaGFuZGxlZCBjb3JyZWN0bHkuXG4gICAgaWYgKGVsLmR5bmFtaWNBdHRycykge1xuICAgICAgICBkYXRhID0gYF9iKCR7ZGF0YX0sXCIke2VsLnRhZ31cIiwke2dlblByb3BzKGVsLmR5bmFtaWNBdHRycyl9KWA7XG4gICAgfVxuICAgIC8vIHYtYmluZCBkYXRhIHdyYXBcbiAgICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICAgICAgZGF0YSA9IGVsLndyYXBEYXRhKGRhdGEpO1xuICAgIH1cbiAgICAvLyB2LW9uIGRhdGEgd3JhcFxuICAgIGlmIChlbC53cmFwTGlzdGVuZXJzKSB7XG4gICAgICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKSB7XG4gICAgY29uc3QgZGlycyA9IGVsLmRpcmVjdGl2ZXM7XG4gICAgaWYgKCFkaXJzKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICAgIGxldCBoYXNSdW50aW1lID0gZmFsc2U7XG4gICAgbGV0IGksIGwsIGRpciwgbmVlZFJ1bnRpbWU7XG4gICAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGRpciA9IGRpcnNbaV07XG4gICAgICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZ2VuID0gc3RhdGUuZGlyZWN0aXZlc1tkaXIubmFtZV07XG4gICAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAgICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICAgICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkUnVudGltZSkge1xuICAgICAgICAgICAgaGFzUnVudGltZSA9IHRydWU7XG4gICAgICAgICAgICByZXMgKz0gYHtuYW1lOlwiJHtkaXIubmFtZX1cIixyYXdOYW1lOlwiJHtkaXIucmF3TmFtZX1cIiR7ZGlyLnZhbHVlXG4gICAgICAgICAgICAgICAgPyBgLHZhbHVlOigke2Rpci52YWx1ZX0pLGV4cHJlc3Npb246JHtKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpfWBcbiAgICAgICAgICAgICAgICA6ICcnfSR7ZGlyLmFyZyA/IGAsYXJnOiR7ZGlyLmlzRHluYW1pY0FyZyA/IGRpci5hcmcgOiBgXCIke2Rpci5hcmd9XCJgfWAgOiAnJ30ke2Rpci5tb2RpZmllcnMgPyBgLG1vZGlmaWVyczoke0pTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpfWAgOiAnJ319LGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1J1bnRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSc7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKSB7XG4gICAgY29uc3QgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gICAgaWYgKChlbC5jaGlsZHJlbi5sZW5ndGggIT09IDEgfHwgYXN0LnR5cGUgIT09IDEpKSB7XG4gICAgICAgIHN0YXRlLndhcm4oJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsIHsgc3RhcnQ6IGVsLnN0YXJ0IH0pO1xuICAgIH1cbiAgICBpZiAoYXN0ICYmIGFzdC50eXBlID09PSAxKSB7XG4gICAgICAgIGNvbnN0IGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBgaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpeyR7aW5saW5lUmVuZGVyRm5zLnJlbmRlcn19LHN0YXRpY1JlbmRlckZuczpbJHtpbmxpbmVSZW5kZXJGbnMuc3RhdGljUmVuZGVyRm5zXG4gICAgICAgICAgICAubWFwKGNvZGUgPT4gYGZ1bmN0aW9uKCl7JHtjb2RlfX1gKVxuICAgICAgICAgICAgLmpvaW4oJywnKX1dfWA7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdHMoZWwsIHNsb3RzLCBzdGF0ZSkge1xuICAgIC8vIGJ5IGRlZmF1bHQgc2NvcGVkIHNsb3RzIGFyZSBjb25zaWRlcmVkIFwic3RhYmxlXCIsIHRoaXMgYWxsb3dzIGNoaWxkXG4gICAgLy8gY29tcG9uZW50cyB3aXRoIG9ubHkgc2NvcGVkIHNsb3RzIHRvIHNraXAgZm9yY2VkIHVwZGF0ZXMgZnJvbSBwYXJlbnQuXG4gICAgLy8gYnV0IGluIHNvbWUgY2FzZXMgd2UgaGF2ZSB0byBiYWlsLW91dCBvZiB0aGlzIG9wdGltaXphdGlvblxuICAgIC8vIGZvciBleGFtcGxlIGlmIHRoZSBzbG90IGNvbnRhaW5zIGR5bmFtaWMgbmFtZXMsIGhhcyB2LWlmIG9yIHYtZm9yIG9uIHRoZW0uLi5cbiAgICBsZXQgbmVlZHNGb3JjZVVwZGF0ZSA9IGVsLmZvciB8fFxuICAgICAgICBPYmplY3Qua2V5cyhzbG90cykuc29tZShrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2xvdCA9IHNsb3RzW2tleV07XG4gICAgICAgICAgICByZXR1cm4gKHNsb3Quc2xvdFRhcmdldER5bmFtaWMgfHwgc2xvdC5pZiB8fCBzbG90LmZvciB8fCBjb250YWluc1Nsb3RDaGlsZChzbG90KSAvLyBpcyBwYXNzaW5nIGRvd24gc2xvdCBmcm9tIHBhcmVudCB3aGljaCBtYXkgYmUgZHluYW1pY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgLy8gIzk1MzQ6IGlmIGEgY29tcG9uZW50IHdpdGggc2NvcGVkIHNsb3RzIGlzIGluc2lkZSBhIGNvbmRpdGlvbmFsIGJyYW5jaCxcbiAgICAvLyBpdCdzIHBvc3NpYmxlIGZvciB0aGUgc2FtZSBjb21wb25lbnQgdG8gYmUgcmV1c2VkIGJ1dCB3aXRoIGRpZmZlcmVudFxuICAgIC8vIGNvbXBpbGVkIHNsb3QgY29udGVudC4gVG8gYXZvaWQgdGhhdCwgd2UgZ2VuZXJhdGUgYSB1bmlxdWUga2V5IGJhc2VkIG9uXG4gICAgLy8gdGhlIGdlbmVyYXRlZCBjb2RlIG9mIGFsbCB0aGUgc2xvdCBjb250ZW50cy5cbiAgICBsZXQgbmVlZHNLZXkgPSAhIWVsLmlmO1xuICAgIC8vIE9SIHdoZW4gaXQgaXMgaW5zaWRlIGFub3RoZXIgc2NvcGVkIHNsb3Qgb3Igdi1mb3IgKHRoZSByZWFjdGl2aXR5IG1heSBiZVxuICAgIC8vIGRpc2Nvbm5lY3RlZCBkdWUgdG8gdGhlIGludGVybWVkaWF0ZSBzY29wZSB2YXJpYWJsZSlcbiAgICAvLyAjOTQzOCwgIzk1MDZcbiAgICAvLyBUT0RPOiB0aGlzIGNhbiBiZSBmdXJ0aGVyIG9wdGltaXplZCBieSBwcm9wZXJseSBhbmFseXppbmcgaW4tc2NvcGUgYmluZGluZ3NcbiAgICAvLyBhbmQgc2tpcCBmb3JjZSB1cGRhdGluZyBvbmVzIHRoYXQgZG8gbm90IGFjdHVhbGx5IHVzZSBzY29wZSB2YXJpYWJsZXMuXG4gICAgaWYgKCFuZWVkc0ZvcmNlVXBkYXRlKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmICgocGFyZW50LnNsb3RTY29wZSAmJiBwYXJlbnQuc2xvdFNjb3BlICE9PSBlbXB0eVNsb3RTY29wZVRva2VuKSB8fFxuICAgICAgICAgICAgICAgIHBhcmVudC5mb3IpIHtcbiAgICAgICAgICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQuaWYpIHtcbiAgICAgICAgICAgICAgICBuZWVkc0tleSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGdlbmVyYXRlZFNsb3RzID0gT2JqZWN0LmtleXMoc2xvdHMpXG4gICAgICAgIC5tYXAoa2V5ID0+IGdlblNjb3BlZFNsb3Qoc2xvdHNba2V5XSwgc3RhdGUpKVxuICAgICAgICAuam9pbignLCcpO1xuICAgIHJldHVybiBgc2NvcGVkU2xvdHM6X3UoWyR7Z2VuZXJhdGVkU2xvdHN9XSR7bmVlZHNGb3JjZVVwZGF0ZSA/IGAsbnVsbCx0cnVlYCA6IGBgfSR7IW5lZWRzRm9yY2VVcGRhdGUgJiYgbmVlZHNLZXkgPyBgLG51bGwsZmFsc2UsJHtoYXNoKGdlbmVyYXRlZFNsb3RzKX1gIDogYGB9KWA7XG59XG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIGxldCBoYXNoID0gNTM4MTtcbiAgICBsZXQgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGkpIHtcbiAgICAgICAgaGFzaCA9IChoYXNoICogMzMpIF4gc3RyLmNoYXJDb2RlQXQoLS1pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5mdW5jdGlvbiBjb250YWluc1Nsb3RDaGlsZChlbCkge1xuICAgIGlmIChlbC50eXBlID09PSAxKSB7XG4gICAgICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZW5TY29wZWRTbG90KGVsLCBzdGF0ZSkge1xuICAgIGNvbnN0IGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgICAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlLCBnZW5TY29wZWRTbG90LCBgbnVsbGApO1xuICAgIH1cbiAgICBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICAgICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpO1xuICAgIH1cbiAgICBjb25zdCBzbG90U2NvcGUgPSBlbC5zbG90U2NvcGUgPT09IGVtcHR5U2xvdFNjb3BlVG9rZW4gPyBgYCA6IFN0cmluZyhlbC5zbG90U2NvcGUpO1xuICAgIGNvbnN0IGZuID0gYGZ1bmN0aW9uKCR7c2xvdFNjb3BlfSl7YCArXG4gICAgICAgIGByZXR1cm4gJHtlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgICAgICAgID8gZWwuaWYgJiYgaXNMZWdhY3lTeW50YXhcbiAgICAgICAgICAgICAgICA/IGAoJHtlbC5pZn0pPyR7Z2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ306dW5kZWZpbmVkYFxuICAgICAgICAgICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSl9fWA7XG4gICAgLy8gcmV2ZXJzZSBwcm94eSB2LXNsb3Qgd2l0aG91dCBzY29wZSBvbiB0aGlzLiRzbG90c1xuICAgIGNvbnN0IHJldmVyc2VQcm94eSA9IHNsb3RTY29wZSA/IGBgIDogYCxwcm94eTp0cnVlYDtcbiAgICByZXR1cm4gYHtrZXk6JHtlbC5zbG90VGFyZ2V0IHx8IGBcImRlZmF1bHRcImB9LGZuOiR7Zm59JHtyZXZlcnNlUHJveHl9fWA7XG59XG5mdW5jdGlvbiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIGNoZWNrU2tpcCwgYWx0R2VuRWxlbWVudCwgYWx0R2VuTm9kZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlbCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgZWwuZm9yICYmXG4gICAgICAgICAgICBlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgICAgICAgIGVsLnRhZyAhPT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemF0aW9uVHlwZSA9IGNoZWNrU2tpcFxuICAgICAgICAgICAgICAgID8gc3RhdGUubWF5YmVDb21wb25lbnQoZWwpXG4gICAgICAgICAgICAgICAgICAgID8gYCwxYFxuICAgICAgICAgICAgICAgICAgICA6IGAsMGBcbiAgICAgICAgICAgICAgICA6IGBgO1xuICAgICAgICAgICAgcmV0dXJuIGAkeyhhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsLCBzdGF0ZSl9JHtub3JtYWxpemF0aW9uVHlwZX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgY29uc3QgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgICAgICByZXR1cm4gYFske2NoaWxkcmVuLm1hcChjID0+IGdlbihjLCBzdGF0ZSkpLmpvaW4oJywnKX1dJHtub3JtYWxpemF0aW9uVHlwZSA/IGAsJHtub3JtYWxpemF0aW9uVHlwZX1gIDogJyd9YDtcbiAgICB9XG59XG4vLyBkZXRlcm1pbmUgdGhlIG5vcm1hbGl6YXRpb24gbmVlZGVkIGZvciB0aGUgY2hpbGRyZW4gYXJyYXkuXG4vLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuLy8gMTogc2ltcGxlIG5vcm1hbGl6YXRpb24gbmVlZGVkIChwb3NzaWJsZSAxLWxldmVsIGRlZXAgbmVzdGVkIGFycmF5KVxuLy8gMjogZnVsbCBub3JtYWxpemF0aW9uIG5lZWRlZFxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIG1heWJlQ29tcG9uZW50KSB7XG4gICAgbGV0IHJlcyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiZcbiAgICAgICAgICAgICAgICBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG5lZWRzTm9ybWFsaXphdGlvbihjLmJsb2NrKSkpKSB7XG4gICAgICAgICAgICByZXMgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heWJlQ29tcG9uZW50KGVsKSB8fFxuICAgICAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShjID0+IG1heWJlQ29tcG9uZW50KGMuYmxvY2spKSkpIHtcbiAgICAgICAgICAgIHJlcyA9IDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbihlbCkge1xuICAgIHJldHVybiBlbC5mb3IgIT09IHVuZGVmaW5lZCB8fCBlbC50YWcgPT09ICd0ZW1wbGF0ZScgfHwgZWwudGFnID09PSAnc2xvdCc7XG59XG5mdW5jdGlvbiBnZW5Ob2RlKG5vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gMyAmJiBub2RlLmlzQ29tbWVudCkge1xuICAgICAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBnZW5UZXh0KG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdlblRleHQodGV4dCkge1xuICAgIHJldHVybiBgX3YoJHt0ZXh0LnR5cGUgPT09IDJcbiAgICAgICAgPyB0ZXh0LmV4cHJlc3Npb24gLy8gbm8gbmVlZCBmb3IgKCkgYmVjYXVzZSBhbHJlYWR5IHdyYXBwZWQgaW4gX3MoKVxuICAgICAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKX0pYDtcbn1cbmZ1bmN0aW9uIGdlbkNvbW1lbnQoY29tbWVudCkge1xuICAgIHJldHVybiBgX2UoJHtKU09OLnN0cmluZ2lmeShjb21tZW50LnRleHQpfSlgO1xufVxuZnVuY3Rpb24gZ2VuU2xvdChlbCwgc3RhdGUpIHtcbiAgICBjb25zdCBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBnZW5DaGlsZHJlbihlbCwgc3RhdGUpO1xuICAgIGxldCByZXMgPSBgX3QoJHtzbG90TmFtZX0ke2NoaWxkcmVuID8gYCxmdW5jdGlvbigpe3JldHVybiAke2NoaWxkcmVufX1gIDogJyd9YDtcbiAgICBjb25zdCBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xuICAgICAgICA/IGdlblByb3BzKChlbC5hdHRycyB8fCBbXSkuY29uY2F0KGVsLmR5bmFtaWNBdHRycyB8fCBbXSkubWFwKGF0dHIgPT4gKHtcbiAgICAgICAgICAgIC8vIHNsb3QgcHJvcHMgYXJlIGNhbWVsaXplZFxuICAgICAgICAgICAgbmFtZTogY2FtZWxpemUoYXR0ci5uYW1lKSxcbiAgICAgICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICAgICAgZHluYW1pYzogYXR0ci5keW5hbWljXG4gICAgICAgIH0pKSlcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGJpbmQgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gICAgaWYgKChhdHRycyB8fCBiaW5kKSAmJiAhY2hpbGRyZW4pIHtcbiAgICAgICAgcmVzICs9IGAsbnVsbGA7XG4gICAgfVxuICAgIGlmIChhdHRycykge1xuICAgICAgICByZXMgKz0gYCwke2F0dHJzfWA7XG4gICAgfVxuICAgIGlmIChiaW5kKSB7XG4gICAgICAgIHJlcyArPSBgJHthdHRycyA/ICcnIDogJyxudWxsJ30sJHtiaW5kfWA7XG4gICAgfVxuICAgIHJldHVybiByZXMgKyAnKSc7XG59XG4vLyBjb21wb25lbnROYW1lIGlzIGVsLmNvbXBvbmVudCwgdGFrZSBpdCBhcyBhcmd1bWVudCB0byBzaHVuIGZsb3cncyBwZXNzaW1pc3RpYyByZWZpbmVtZW50XG5mdW5jdGlvbiBnZW5Db21wb25lbnQoY29tcG9uZW50TmFtZSwgZWwsIHN0YXRlKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgIHJldHVybiBgX2MoJHtjb21wb25lbnROYW1lfSwke2dlbkRhdGEoZWwsIHN0YXRlKX0ke2NoaWxkcmVuID8gYCwke2NoaWxkcmVufWAgOiAnJ30pYDtcbn1cbmZ1bmN0aW9uIGdlblByb3BzKHByb3BzKSB7XG4gICAgbGV0IHN0YXRpY1Byb3BzID0gYGA7XG4gICAgbGV0IGR5bmFtaWNQcm9wcyA9IGBgO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhwcm9wLnZhbHVlKTtcbiAgICAgICAgaWYgKHByb3AuZHluYW1pYykge1xuICAgICAgICAgICAgZHluYW1pY1Byb3BzICs9IGAke3Byb3AubmFtZX0sJHt2YWx1ZX0sYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRpY1Byb3BzICs9IGBcIiR7cHJvcC5uYW1lfVwiOiR7dmFsdWV9LGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljUHJvcHMgPSBgeyR7c3RhdGljUHJvcHMuc2xpY2UoMCwgLTEpfX1gO1xuICAgIGlmIChkeW5hbWljUHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGBfZCgke3N0YXRpY1Byb3BzfSxbJHtkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpfV0pYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGF0aWNQcm9wcztcbiAgICB9XG59XG4vLyAjMzg5NSwgIzQyNjhcbmZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JykucmVwbGFjZSgvXFx1MjAyOS9nLCAnXFxcXHUyMDI5Jyk7XG59XG5cbi8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4vLyB0eXBlb2YsIGluc3RhbmNlb2YgYW5kIGluIGFyZSBhbGxvd2VkXG5jb25zdCBwcm9oaWJpdGVkS2V5d29yZFJFID0gbmV3IFJlZ0V4cCgnXFxcXGInICtcbiAgICAoJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICAgICAgICdzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsJyArXG4gICAgICAgICdleHRlbmRzLGZpbmFsbHksY29udGludWUsZGVidWdnZXIsZnVuY3Rpb24sYXJndW1lbnRzJylcbiAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgLmpvaW4oJ1xcXFxifFxcXFxiJykgK1xuICAgICdcXFxcYicpO1xuLy8gdGhlc2UgdW5hcnkgb3BlcmF0b3JzIHNob3VsZCBub3QgYmUgdXNlZCBhcyBwcm9wZXJ0eS9tZXRob2QgbmFtZXNcbmNvbnN0IHVuYXJ5T3BlcmF0b3JzUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgK1xuICAgICdkZWxldGUsdHlwZW9mLHZvaWQnLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICtcbiAgICAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuLy8gc3RyaXAgc3RyaW5ncyBpbiBleHByZXNzaW9uc1xuY29uc3Qgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbmZ1bmN0aW9uIGRldGVjdEVycm9ycyhhc3QsIHdhcm4pIHtcbiAgICBpZiAoYXN0KSB7XG4gICAgICAgIGNoZWNrTm9kZShhc3QsIHdhcm4pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrTm9kZShub2RlLCB3YXJuKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbm9kZS5hdHRyc01hcCkge1xuICAgICAgICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICd2LWZvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIGB2LWZvcj1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ3Ytc2xvdCcgfHwgbmFtZVswXSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uUGFyYW1ldGVyRXhwcmVzc2lvbih2YWx1ZSwgYCR7bmFtZX09XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgYCR7bmFtZX09XCIke3ZhbHVlfVwiYCwgd2FybiwgcmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCBgJHtuYW1lfT1cIiR7dmFsdWV9XCJgLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICAgICAgY2hlY2tFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50ZXh0LCB3YXJuLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0V2ZW50KGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICBjb25zdCBzdHJpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgICBjb25zdCBrZXl3b3JkTWF0Y2ggPSBzdHJpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoICYmIHN0cmlwcGVkLmNoYXJBdChrZXl3b3JkTWF0Y2guaW5kZXggLSAxKSAhPT0gJyQnKSB7XG4gICAgICAgIHdhcm4oYGF2b2lkIHVzaW5nIEphdmFTY3JpcHQgdW5hcnkgb3BlcmF0b3IgYXMgcHJvcGVydHkgbmFtZTogYCArXG4gICAgICAgICAgICBgXCIke2tleXdvcmRNYXRjaFswXX1cIiBpbiBleHByZXNzaW9uICR7dGV4dC50cmltKCl9YCwgcmFuZ2UpO1xuICAgIH1cbiAgICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5mdW5jdGlvbiBjaGVja0Zvcihub2RlLCB0ZXh0LCB3YXJuLCByYW5nZSkge1xuICAgIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLmFsaWFzLCAndi1mb3IgYWxpYXMnLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IxLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gICAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG59XG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIoaWRlbnQsIHR5cGUsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbihgdmFyICR7aWRlbnR9PV9gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgd2FybihgaW52YWxpZCAke3R5cGV9IFwiJHtpZGVudH1cIiBpbiBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfWAsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbihleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKGByZXR1cm4gJHtleHB9YCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGtleXdvcmRNYXRjaCA9IGV4cFxuICAgICAgICAgICAgLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpXG4gICAgICAgICAgICAubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgICAgIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICAgICAgICAgIHdhcm4oYGF2b2lkIHVzaW5nIEphdmFTY3JpcHQga2V5d29yZCBhcyBwcm9wZXJ0eSBuYW1lOiBgICtcbiAgICAgICAgICAgICAgICBgXCIke2tleXdvcmRNYXRjaFswXX1cIlxcbiAgUmF3IGV4cHJlc3Npb246ICR7dGV4dC50cmltKCl9YCwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2FybihgaW52YWxpZCBleHByZXNzaW9uOiAke2UubWVzc2FnZX0gaW5cXG5cXG5gICtcbiAgICAgICAgICAgICAgICBgICAgICR7ZXhwfVxcblxcbmAgK1xuICAgICAgICAgICAgICAgIGAgIFJhdyBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfVxcbmAsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrRnVuY3Rpb25QYXJhbWV0ZXJFeHByZXNzaW9uKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICB0cnkge1xuICAgICAgICBuZXcgRnVuY3Rpb24oZXhwLCAnJyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oYGludmFsaWQgZnVuY3Rpb24gcGFyYW1ldGVyIGV4cHJlc3Npb246ICR7ZS5tZXNzYWdlfSBpblxcblxcbmAgK1xuICAgICAgICAgICAgYCAgICAke2V4cH1cXG5cXG5gICtcbiAgICAgICAgICAgIGAgIFJhdyBleHByZXNzaW9uOiAke3RleHQudHJpbSgpfVxcbmAsIHJhbmdlKTtcbiAgICB9XG59XG5cbmNvbnN0IHJhbmdlID0gMjtcbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lKHNvdXJjZSwgc3RhcnQgPSAwLCBlbmQgPSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2Uuc3BsaXQoL1xccj9cXG4vKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY291bnQgKz0gbGluZXNbaV0ubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGNvdW50ID49IHN0YXJ0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSAtIHJhbmdlOyBqIDw9IGkgKyByYW5nZSB8fCBlbmQgPiBjb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGogPCAwIHx8IGogPj0gbGluZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICByZXMucHVzaChgJHtqICsgMX0ke3JlcGVhdChgIGAsIDMgLSBTdHJpbmcoaiArIDEpLmxlbmd0aCl9fCAgJHtsaW5lc1tqXX1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZXNbal0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChqID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZCA9IHN0YXJ0IC0gKGNvdW50IC0gbGluZUxlbmd0aCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBlbmQgPiBjb3VudCA/IGxpbmVMZW5ndGggLSBwYWQgOiBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyByZXBlYXQoYCBgLCBwYWQpICsgcmVwZWF0KGBeYCwgbGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogPiBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPiBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5taW4oZW5kIC0gY291bnQsIGxpbmVMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goYCAgIHwgIGAgKyByZXBlYXQoYF5gLCBsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBsaW5lTGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLmpvaW4oJ1xcbicpO1xufVxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgbikge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBpZiAobiA+IDApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgaWYgKG4gJiAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHI7XG4gICAgICAgICAgICBuID4+Pj0gMTtcbiAgICAgICAgICAgIGlmIChuIDw9IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdHIgKz0gc3RyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGVycm9ycykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oY29kZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goeyBlcnIsIGNvZGUgfSk7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4oY29tcGlsZSkge1xuICAgIGNvbnN0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCBvcHRpb25zLCB2bSkge1xuICAgICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgd2FybiA9IG9wdGlvbnMud2FybiB8fCB3YXJuJDI7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICB7XG4gICAgICAgICAgICAvLyBkZXRlY3QgcG9zc2libGUgQ1NQIHJlc3RyaWN0aW9uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5tYXRjaCgvdW5zYWZlLWV2YWx8Q1NQLykpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybignSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGNhY2hlXG4gICAgICAgIGNvbnN0IGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgICAgICAgPyBTdHJpbmcob3B0aW9ucy5kZWxpbWl0ZXJzKSArIHRlbXBsYXRlXG4gICAgICAgICAgICA6IHRlbXBsYXRlO1xuICAgICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29tcGlsZVxuICAgICAgICBjb25zdCBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuICAgICAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21waWxlZC5lcnJvcnMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm4oYEVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG4ke2UubXNnfVxcblxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlQ29kZUZyYW1lKHRlbXBsYXRlLCBlLnN0YXJ0LCBlLmVuZCksIHZtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3YXJuKGBFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuJHt0ZW1wbGF0ZX1cXG5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycy5tYXAoZSA9PiBgLSAke2V9YCkuam9pbignXFxuJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicsIHZtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChlID0+IHRpcChlLm1zZywgdm0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMuZm9yRWFjaChtc2cgPT4gdGlwKG1zZywgdm0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBjb2RlIGludG8gZnVuY3Rpb25zXG4gICAgICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgICAgICBjb25zdCBmbkdlbkVycm9ycyA9IFtdO1xuICAgICAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGNvZGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uKGNvZGUsIGZuR2VuRXJyb3JzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNoZWNrIGZ1bmN0aW9uIGdlbmVyYXRpb24gZXJyb3JzLlxuICAgICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgICAgICAvLyBtb3N0bHkgZm9yIGNvZGVnZW4gZGV2ZWxvcG1lbnQgdXNlXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKCFjb21waWxlZC5lcnJvcnMgfHwgIWNvbXBpbGVkLmVycm9ycy5sZW5ndGgpICYmIGZuR2VuRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHdhcm4oYEZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuYCArXG4gICAgICAgICAgICAgICAgICAgIGZuR2VuRXJyb3JzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGVyciwgY29kZSB9KSA9PiBgJHtlcnIudG9TdHJpbmcoKX0gaW5cXG5cXG4ke2NvZGV9XFxuYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSwgdm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcyk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcGlsZXJDcmVhdG9yKGJhc2VDb21waWxlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICBjb25zdCB0aXBzID0gW107XG4gICAgICAgICAgICBsZXQgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChtc2cpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdTcGFjZUxlbmd0aCA9IHRlbXBsYXRlLm1hdGNoKC9eXFxzKi8pWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2FybiA9IChtc2csIHJhbmdlLCB0aXApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgbXNnID09PSAnc3RyaW5nJyA/IHsgbXNnIH0gOiBtc2c7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQgKyBsZWFkaW5nU3BhY2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmVuZCA9IHJhbmdlLmVuZCArIGxlYWRpbmdTcGFjZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbWVyZ2UgY3VzdG9tIG1vZHVsZXNcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsT3B0aW9ucy5tb2R1bGVzID0gKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBjdXN0b20gZGlyZWN0aXZlc1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoT2JqZWN0LmNyZWF0ZShiYXNlT3B0aW9ucy5kaXJlY3RpdmVzIHx8IG51bGwpLCBvcHRpb25zLmRpcmVjdGl2ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbE9wdGlvbnMud2FybiA9IHdhcm47XG4gICAgICAgICAgICBjb25zdCBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLnRyaW0oKSwgZmluYWxPcHRpb25zKTtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBpbGVkLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBpbGVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21waWxlLFxuICAgICAgICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgICAgIH07XG4gICAgfTtcbn1cblxuLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuLy8gcGFyc2VyL29wdGltaXplci9jb2RlZ2VuLCBlLmcgdGhlIFNTUiBvcHRpbWl6aW5nIGNvbXBpbGVyLlxuLy8gSGVyZSB3ZSBqdXN0IGV4cG9ydCBhIGRlZmF1bHQgY29tcGlsZXIgdXNpbmcgdGhlIGRlZmF1bHQgcGFydHMuXG5jb25zdCBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgICAgIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGNvZGUgPSBnZW5lcmF0ZShhc3QsIG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFzdCxcbiAgICAgICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBjb2RlLnN0YXRpY1JlbmRlckZuc1xuICAgIH07XG59KTtcblxuY29uc3QgeyBjb21waWxlLCBjb21waWxlVG9GdW5jdGlvbnMgfSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbmxldCBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUoaHJlZikge1xuICAgIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IGA8YSBocmVmPVwiXFxuXCIvPmAgOiBgPGRpdiBhPVwiXFxuXCIvPmA7XG4gICAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDA7XG59XG4vLyAjMzY2MzogSUUgZW5jb2RlcyBuZXdsaW5lcyBpbnNpZGUgYXR0cmlidXRlIHZhbHVlcyB3aGlsZSBvdGhlciBicm93c2VycyBkb24ndFxuY29uc3Qgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG5jb25zdCBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYgPSBpbkJyb3dzZXJcbiAgICA/IGdldFNob3VsZERlY29kZSh0cnVlKVxuICAgIDogZmFsc2U7XG5cbmNvbnN0IGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChpZCA9PiB7XG4gICAgY29uc3QgZWwgPSBxdWVyeShpZCk7XG4gICAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTDtcbn0pO1xuY29uc3QgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcblZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKGVsLCBoeWRyYXRpbmcpIHtcbiAgICBlbCA9IGVsICYmIHF1ZXJ5KGVsKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICB3YXJuJDIoYERvIG5vdCBtb3VudCBWdWUgdG8gPGh0bWw+IG9yIDxib2R5PiAtIG1vdW50IHRvIG5vcm1hbCBlbGVtZW50cyBpbnN0ZWFkLmApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gICAgLy8gcmVzb2x2ZSB0ZW1wbGF0ZS9lbCBhbmQgY29udmVydCB0byByZW5kZXIgZnVuY3Rpb25cbiAgICBpZiAoIW9wdGlvbnMucmVuZGVyKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FybiQyKGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHtvcHRpb25zLnRlbXBsYXRlfWAsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmlubmVySFRNTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybiQyKCdpbnZhbGlkIHRlbXBsYXRlIG9wdGlvbjonICsgdGVtcGxhdGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTb3VyY2VSYW5nZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsXG4gICAgICAgICAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICAgICAgICAgIGNvbW1lbnRzOiBvcHRpb25zLmNvbW1lbnRzXG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyO1xuICAgICAgICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnM7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICAgICAgICAgIG1hcmsoJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgbWVhc3VyZShgdnVlICR7dGhpcy5fbmFtZX0gY29tcGlsZWAsICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1vdW50LmNhbGwodGhpcywgZWwsIGh5ZHJhdGluZyk7XG59O1xuLyoqXG4gKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICogb2YgU1ZHIGVsZW1lbnRzIGluIElFIGFzIHdlbGwuXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVySFRNTChlbCkge1xuICAgIGlmIChlbC5vdXRlckhUTUwpIHtcbiAgICAgICAgcmV0dXJuIGVsLm91dGVySFRNTDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG4gICAgfVxufVxuVnVlLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbi8vIGV4cG9ydCB0eXBlIEVmZmVjdFNjaGVkdWxlciA9ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55XG4vKipcbiAqIEBpbnRlcm5hbCBzaW5jZSB3ZSBhcmUgbm90IGV4cG9zaW5nIHRoaXMgaW4gVnVlIDIsIGl0J3MgdXNlZCBvbmx5IGZvclxuICogaW50ZXJuYWwgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZWZmZWN0KGZuLCBzY2hlZHVsZXIpIHtcbiAgICBjb25zdCB3YXRjaGVyID0gbmV3IFdhdGNoZXIoY3VycmVudEluc3RhbmNlLCBmbiwgbm9vcCwge1xuICAgICAgICBzeW5jOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICB3YXRjaGVyLnVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHNjaGVkdWxlcigoKSA9PiB3YXRjaGVyLnJ1bigpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4dGVuZChWdWUsIHZjYSk7XG5WdWUuZWZmZWN0ID0gZWZmZWN0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZ1ZTtcbiIsImlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi92dWUuY29tbW9uLnByb2QuanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Z1ZS5jb21tb24uZGV2LmpzJylcbn1cbiIsIi8qIVxuICogVnVlLmpzIHYyLjcuMTZcbiAqIChjKSAyMDE0LTIwMjMgRXZhbiBZb3VcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuLyohXG4gKiBWdWUuanMgdjIuNy4xNlxuICogKGMpIDIwMTQtMjAyMyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cInVzZSBzdHJpY3RcIjtjb25zdCB0PU9iamVjdC5mcmVlemUoe30pLGU9QXJyYXkuaXNBcnJheTtmdW5jdGlvbiBuKHQpe3JldHVybiBudWxsPT10fWZ1bmN0aW9uIG8odCl7cmV0dXJuIG51bGwhPXR9ZnVuY3Rpb24gcih0KXtyZXR1cm4hMD09PXR9ZnVuY3Rpb24gcyh0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdHx8XCJudW1iZXJcIj09dHlwZW9mIHR8fFwic3ltYm9sXCI9PXR5cGVvZiB0fHxcImJvb2xlYW5cIj09dHlwZW9mIHR9ZnVuY3Rpb24gaSh0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0fWZ1bmN0aW9uIGModCl7cmV0dXJuIG51bGwhPT10JiZcIm9iamVjdFwiPT10eXBlb2YgdH1jb25zdCBhPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gbCh0KXtyZXR1cm5cIltvYmplY3QgT2JqZWN0XVwiPT09YS5jYWxsKHQpfWZ1bmN0aW9uIHUodCl7Y29uc3QgZT1wYXJzZUZsb2F0KFN0cmluZyh0KSk7cmV0dXJuIGU+PTAmJk1hdGguZmxvb3IoZSk9PT1lJiZpc0Zpbml0ZSh0KX1mdW5jdGlvbiBmKHQpe3JldHVybiBvKHQpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRoZW4mJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuY2F0Y2h9ZnVuY3Rpb24gZCh0KXtyZXR1cm4gbnVsbD09dD9cIlwiOkFycmF5LmlzQXJyYXkodCl8fGwodCkmJnQudG9TdHJpbmc9PT1hP0pTT04uc3RyaW5naWZ5KHQscCwyKTpTdHJpbmcodCl9ZnVuY3Rpb24gcCh0LGUpe3JldHVybiBlJiZlLl9fdl9pc1JlZj9lLnZhbHVlOmV9ZnVuY3Rpb24gaCh0KXtjb25zdCBlPXBhcnNlRmxvYXQodCk7cmV0dXJuIGlzTmFOKGUpP3Q6ZX1mdW5jdGlvbiBtKHQsZSl7Y29uc3Qgbj1PYmplY3QuY3JlYXRlKG51bGwpLG89dC5zcGxpdChcIixcIik7Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDt0KyspbltvW3RdXT0hMDtyZXR1cm4gZT90PT5uW3QudG9Mb3dlckNhc2UoKV06dD0+blt0XX1jb25zdCBnPW0oXCJzbG90LGNvbXBvbmVudFwiLCEwKSx2PW0oXCJrZXkscmVmLHNsb3Qsc2xvdC1zY29wZSxpc1wiKTtmdW5jdGlvbiB5KHQsZSl7Y29uc3Qgbj10Lmxlbmd0aDtpZihuKXtpZihlPT09dFtuLTFdKXJldHVybiB2b2lkKHQubGVuZ3RoPW4tMSk7Y29uc3Qgbz10LmluZGV4T2YoZSk7aWYobz4tMSlyZXR1cm4gdC5zcGxpY2UobywxKX19Y29uc3QgXz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Z1bmN0aW9uICQodCxlKXtyZXR1cm4gXy5jYWxsKHQsZSl9ZnVuY3Rpb24gYih0KXtjb25zdCBlPU9iamVjdC5jcmVhdGUobnVsbCk7cmV0dXJuIGZ1bmN0aW9uKG4pe3JldHVybiBlW25dfHwoZVtuXT10KG4pKX19Y29uc3Qgdz0vLShcXHcpL2cseD1iKCh0PT50LnJlcGxhY2UodywoKHQsZSk9PmU/ZS50b1VwcGVyQ2FzZSgpOlwiXCIpKSkpLEM9YigodD0+dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpKSksaz0vXFxCKFtBLVpdKS9nLFM9YigodD0+dC5yZXBsYWNlKGssXCItJDFcIikudG9Mb3dlckNhc2UoKSkpO2NvbnN0IE89RnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ/ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5iaW5kKGUpfTpmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4obil7Y29uc3Qgbz1hcmd1bWVudHMubGVuZ3RoO3JldHVybiBvP28+MT90LmFwcGx5KGUsYXJndW1lbnRzKTp0LmNhbGwoZSxuKTp0LmNhbGwoZSl9cmV0dXJuIG4uX2xlbmd0aD10Lmxlbmd0aCxufTtmdW5jdGlvbiBUKHQsZSl7ZT1lfHwwO2xldCBuPXQubGVuZ3RoLWU7Y29uc3Qgbz1uZXcgQXJyYXkobik7Zm9yKDtuLS07KW9bbl09dFtuK2VdO3JldHVybiBvfWZ1bmN0aW9uIEEodCxlKXtmb3IoY29uc3QgbiBpbiBlKXRbbl09ZVtuXTtyZXR1cm4gdH1mdW5jdGlvbiBqKHQpe2NvbnN0IGU9e307Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspdFtuXSYmQShlLHRbbl0pO3JldHVybiBlfWZ1bmN0aW9uIEUodCxlLG4pe31jb25zdCBOPSh0LGUsbik9PiExLFA9dD0+dDtmdW5jdGlvbiBEKHQsZSl7aWYodD09PWUpcmV0dXJuITA7Y29uc3Qgbj1jKHQpLG89YyhlKTtpZighbnx8IW8pcmV0dXJuIW4mJiFvJiZTdHJpbmcodCk9PT1TdHJpbmcoZSk7dHJ5e2NvbnN0IG49QXJyYXkuaXNBcnJheSh0KSxvPUFycmF5LmlzQXJyYXkoZSk7aWYobiYmbylyZXR1cm4gdC5sZW5ndGg9PT1lLmxlbmd0aCYmdC5ldmVyeSgoKHQsbik9PkQodCxlW25dKSkpO2lmKHQgaW5zdGFuY2VvZiBEYXRlJiZlIGluc3RhbmNlb2YgRGF0ZSlyZXR1cm4gdC5nZXRUaW1lKCk9PT1lLmdldFRpbWUoKTtpZihufHxvKXJldHVybiExO3tjb25zdCBuPU9iamVjdC5rZXlzKHQpLG89T2JqZWN0LmtleXMoZSk7cmV0dXJuIG4ubGVuZ3RoPT09by5sZW5ndGgmJm4uZXZlcnkoKG49PkQodFtuXSxlW25dKSkpfX1jYXRjaCh0KXtyZXR1cm4hMX19ZnVuY3Rpb24gTSh0LGUpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWlmKEQodFtuXSxlKSlyZXR1cm4gbjtyZXR1cm4tMX1mdW5jdGlvbiBJKHQpe2xldCBlPSExO3JldHVybiBmdW5jdGlvbigpe2V8fChlPSEwLHQuYXBwbHkodGhpcyxhcmd1bWVudHMpKX19ZnVuY3Rpb24gTCh0LGUpe3JldHVybiB0PT09ZT8wPT09dCYmMS90IT0xL2U6dD09dHx8ZT09ZX1jb25zdCBSPVwiZGF0YS1zZXJ2ZXItcmVuZGVyZWRcIixGPVtcImNvbXBvbmVudFwiLFwiZGlyZWN0aXZlXCIsXCJmaWx0ZXJcIl0sSD1bXCJiZWZvcmVDcmVhdGVcIixcImNyZWF0ZWRcIixcImJlZm9yZU1vdW50XCIsXCJtb3VudGVkXCIsXCJiZWZvcmVVcGRhdGVcIixcInVwZGF0ZWRcIixcImJlZm9yZURlc3Ryb3lcIixcImRlc3Ryb3llZFwiLFwiYWN0aXZhdGVkXCIsXCJkZWFjdGl2YXRlZFwiLFwiZXJyb3JDYXB0dXJlZFwiLFwic2VydmVyUHJlZmV0Y2hcIixcInJlbmRlclRyYWNrZWRcIixcInJlbmRlclRyaWdnZXJlZFwiXTt2YXIgQj17b3B0aW9uTWVyZ2VTdHJhdGVnaWVzOk9iamVjdC5jcmVhdGUobnVsbCksc2lsZW50OiExLHByb2R1Y3Rpb25UaXA6ITEsZGV2dG9vbHM6ITEscGVyZm9ybWFuY2U6ITEsZXJyb3JIYW5kbGVyOm51bGwsd2FybkhhbmRsZXI6bnVsbCxpZ25vcmVkRWxlbWVudHM6W10sa2V5Q29kZXM6T2JqZWN0LmNyZWF0ZShudWxsKSxpc1Jlc2VydmVkVGFnOk4saXNSZXNlcnZlZEF0dHI6Tixpc1Vua25vd25FbGVtZW50Ok4sZ2V0VGFnTmFtZXNwYWNlOkUscGFyc2VQbGF0Zm9ybVRhZ05hbWU6UCxtdXN0VXNlUHJvcDpOLGFzeW5jOiEwLF9saWZlY3ljbGVIb29rczpIfTtjb25zdCBVPS9hLXpBLVpcXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZELztmdW5jdGlvbiB6KHQpe2NvbnN0IGU9KHQrXCJcIikuY2hhckNvZGVBdCgwKTtyZXR1cm4gMzY9PT1lfHw5NT09PWV9ZnVuY3Rpb24gVih0LGUsbixvKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpuLGVudW1lcmFibGU6ISFvLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH0pfWNvbnN0IEs9bmV3IFJlZ0V4cChgW14ke1Uuc291cmNlfS4kX1xcXFxkXWApO2NvbnN0IEo9XCJfX3Byb3RvX19cImlue30scT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93LFc9cSYmd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxaPVcmJi9tc2llfHRyaWRlbnQvLnRlc3QoVyksRz1XJiZXLmluZGV4T2YoXCJtc2llIDkuMFwiKT4wLFg9VyYmVy5pbmRleE9mKFwiZWRnZS9cIik+MDtXJiZXLmluZGV4T2YoXCJhbmRyb2lkXCIpO2NvbnN0IFk9VyYmL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFcpO1cmJi9jaHJvbWVcXC9cXGQrLy50ZXN0KFcpLFcmJi9waGFudG9tanMvLnRlc3QoVyk7Y29uc3QgUT1XJiZXLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLyksdHQ9e30ud2F0Y2g7bGV0IGV0LG50PSExO2lmKHEpdHJ5e2NvbnN0IHQ9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJwYXNzaXZlXCIse2dldCgpe250PSEwfX0pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidGVzdC1wYXNzaXZlXCIsbnVsbCx0KX1jYXRjaCh0KXt9Y29uc3Qgb3Q9KCk9Pih2b2lkIDA9PT1ldCYmKGV0PSFxJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsJiYoZ2xvYmFsLnByb2Nlc3MmJlwic2VydmVyXCI9PT1nbG9iYWwucHJvY2Vzcy5lbnYuVlVFX0VOVikpLGV0KSxydD1xJiZ3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztmdW5jdGlvbiBzdCh0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYvbmF0aXZlIGNvZGUvLnRlc3QodC50b1N0cmluZygpKX1jb25zdCBpdD1cInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZzdChTeW1ib2wpJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmc3QoUmVmbGVjdC5vd25LZXlzKTtsZXQgY3Q7Y3Q9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldCYmc3QoU2V0KT9TZXQ6Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLnNldD1PYmplY3QuY3JlYXRlKG51bGwpfWhhcyh0KXtyZXR1cm4hMD09PXRoaXMuc2V0W3RdfWFkZCh0KXt0aGlzLnNldFt0XT0hMH1jbGVhcigpe3RoaXMuc2V0PU9iamVjdC5jcmVhdGUobnVsbCl9fTtsZXQgYXQ9bnVsbDtmdW5jdGlvbiBsdCh0PW51bGwpe3R8fGF0JiZhdC5fc2NvcGUub2ZmKCksYXQ9dCx0JiZ0Ll9zY29wZS5vbigpfWNsYXNzIHV0e2NvbnN0cnVjdG9yKHQsZSxuLG8scixzLGksYyl7dGhpcy50YWc9dCx0aGlzLmRhdGE9ZSx0aGlzLmNoaWxkcmVuPW4sdGhpcy50ZXh0PW8sdGhpcy5lbG09cix0aGlzLm5zPXZvaWQgMCx0aGlzLmNvbnRleHQ9cyx0aGlzLmZuQ29udGV4dD12b2lkIDAsdGhpcy5mbk9wdGlvbnM9dm9pZCAwLHRoaXMuZm5TY29wZUlkPXZvaWQgMCx0aGlzLmtleT1lJiZlLmtleSx0aGlzLmNvbXBvbmVudE9wdGlvbnM9aSx0aGlzLmNvbXBvbmVudEluc3RhbmNlPXZvaWQgMCx0aGlzLnBhcmVudD12b2lkIDAsdGhpcy5yYXc9ITEsdGhpcy5pc1N0YXRpYz0hMSx0aGlzLmlzUm9vdEluc2VydD0hMCx0aGlzLmlzQ29tbWVudD0hMSx0aGlzLmlzQ2xvbmVkPSExLHRoaXMuaXNPbmNlPSExLHRoaXMuYXN5bmNGYWN0b3J5PWMsdGhpcy5hc3luY01ldGE9dm9pZCAwLHRoaXMuaXNBc3luY1BsYWNlaG9sZGVyPSExfWdldCBjaGlsZCgpe3JldHVybiB0aGlzLmNvbXBvbmVudEluc3RhbmNlfX1jb25zdCBmdD0odD1cIlwiKT0+e2NvbnN0IGU9bmV3IHV0O3JldHVybiBlLnRleHQ9dCxlLmlzQ29tbWVudD0hMCxlfTtmdW5jdGlvbiBkdCh0KXtyZXR1cm4gbmV3IHV0KHZvaWQgMCx2b2lkIDAsdm9pZCAwLFN0cmluZyh0KSl9ZnVuY3Rpb24gcHQodCl7Y29uc3QgZT1uZXcgdXQodC50YWcsdC5kYXRhLHQuY2hpbGRyZW4mJnQuY2hpbGRyZW4uc2xpY2UoKSx0LnRleHQsdC5lbG0sdC5jb250ZXh0LHQuY29tcG9uZW50T3B0aW9ucyx0LmFzeW5jRmFjdG9yeSk7cmV0dXJuIGUubnM9dC5ucyxlLmlzU3RhdGljPXQuaXNTdGF0aWMsZS5rZXk9dC5rZXksZS5pc0NvbW1lbnQ9dC5pc0NvbW1lbnQsZS5mbkNvbnRleHQ9dC5mbkNvbnRleHQsZS5mbk9wdGlvbnM9dC5mbk9wdGlvbnMsZS5mblNjb3BlSWQ9dC5mblNjb3BlSWQsZS5hc3luY01ldGE9dC5hc3luY01ldGEsZS5pc0Nsb25lZD0hMCxlfWxldCBodD0wO2NvbnN0IG10PVtdLGd0PSgpPT57Zm9yKGxldCB0PTA7dDxtdC5sZW5ndGg7dCsrKXtjb25zdCBlPW10W3RdO2Uuc3Vicz1lLnN1YnMuZmlsdGVyKCh0PT50KSksZS5fcGVuZGluZz0hMX1tdC5sZW5ndGg9MH07Y2xhc3MgdnR7Y29uc3RydWN0b3IoKXt0aGlzLl9wZW5kaW5nPSExLHRoaXMuaWQ9aHQrKyx0aGlzLnN1YnM9W119YWRkU3ViKHQpe3RoaXMuc3Vicy5wdXNoKHQpfXJlbW92ZVN1Yih0KXt0aGlzLnN1YnNbdGhpcy5zdWJzLmluZGV4T2YodCldPW51bGwsdGhpcy5fcGVuZGluZ3x8KHRoaXMuX3BlbmRpbmc9ITAsbXQucHVzaCh0aGlzKSl9ZGVwZW5kKHQpe3Z0LnRhcmdldCYmdnQudGFyZ2V0LmFkZERlcCh0aGlzKX1ub3RpZnkodCl7Y29uc3QgZT10aGlzLnN1YnMuZmlsdGVyKCh0PT50KSk7Zm9yKGxldCB0PTAsbj1lLmxlbmd0aDt0PG47dCsrKXtlW3RdLnVwZGF0ZSgpfX19dnQudGFyZ2V0PW51bGw7Y29uc3QgeXQ9W107ZnVuY3Rpb24gX3QodCl7eXQucHVzaCh0KSx2dC50YXJnZXQ9dH1mdW5jdGlvbiAkdCgpe3l0LnBvcCgpLHZ0LnRhcmdldD15dFt5dC5sZW5ndGgtMV19Y29uc3QgYnQ9QXJyYXkucHJvdG90eXBlLHd0PU9iamVjdC5jcmVhdGUoYnQpO1tcInB1c2hcIixcInBvcFwiLFwic2hpZnRcIixcInVuc2hpZnRcIixcInNwbGljZVwiLFwic29ydFwiLFwicmV2ZXJzZVwiXS5mb3JFYWNoKChmdW5jdGlvbih0KXtjb25zdCBlPWJ0W3RdO1Yod3QsdCwoZnVuY3Rpb24oLi4ubil7Y29uc3Qgbz1lLmFwcGx5KHRoaXMsbikscj10aGlzLl9fb2JfXztsZXQgcztzd2l0Y2godCl7Y2FzZVwicHVzaFwiOmNhc2VcInVuc2hpZnRcIjpzPW47YnJlYWs7Y2FzZVwic3BsaWNlXCI6cz1uLnNsaWNlKDIpfXJldHVybiBzJiZyLm9ic2VydmVBcnJheShzKSxyLmRlcC5ub3RpZnkoKSxvfSkpfSkpO2NvbnN0IHh0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHd0KSxDdD17fTtsZXQga3Q9ITA7ZnVuY3Rpb24gU3QodCl7a3Q9dH1jb25zdCBPdD17bm90aWZ5OkUsZGVwZW5kOkUsYWRkU3ViOkUscmVtb3ZlU3ViOkV9O2NsYXNzIFR0e2NvbnN0cnVjdG9yKHQsbj0hMSxvPSExKXtpZih0aGlzLnZhbHVlPXQsdGhpcy5zaGFsbG93PW4sdGhpcy5tb2NrPW8sdGhpcy5kZXA9bz9PdDpuZXcgdnQsdGhpcy52bUNvdW50PTAsVih0LFwiX19vYl9fXCIsdGhpcyksZSh0KSl7aWYoIW8paWYoSil0Ll9fcHJvdG9fXz13dDtlbHNlIGZvcihsZXQgZT0wLG49eHQubGVuZ3RoO2U8bjtlKyspe2NvbnN0IG49eHRbZV07Vih0LG4sd3Rbbl0pfW58fHRoaXMub2JzZXJ2ZUFycmF5KHQpfWVsc2V7Y29uc3QgZT1PYmplY3Qua2V5cyh0KTtmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7anQodCxlW3JdLEN0LHZvaWQgMCxuLG8pfX19b2JzZXJ2ZUFycmF5KHQpe2ZvcihsZXQgZT0wLG49dC5sZW5ndGg7ZTxuO2UrKylBdCh0W2VdLCExLHRoaXMubW9jayl9fWZ1bmN0aW9uIEF0KHQsbixvKXtyZXR1cm4gdCYmJCh0LFwiX19vYl9fXCIpJiZ0Ll9fb2JfXyBpbnN0YW5jZW9mIFR0P3QuX19vYl9fOiFrdHx8IW8mJm90KCl8fCFlKHQpJiYhbCh0KXx8IU9iamVjdC5pc0V4dGVuc2libGUodCl8fHQuX192X3NraXB8fEh0KHQpfHx0IGluc3RhbmNlb2YgdXQ/dm9pZCAwOm5ldyBUdCh0LG4sbyl9ZnVuY3Rpb24ganQodCxuLG8scixzLGksYz0hMSl7Y29uc3QgYT1uZXcgdnQsbD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbik7aWYobCYmITE9PT1sLmNvbmZpZ3VyYWJsZSlyZXR1cm47Y29uc3QgdT1sJiZsLmdldCxmPWwmJmwuc2V0O3UmJiFmfHxvIT09Q3QmJjIhPT1hcmd1bWVudHMubGVuZ3RofHwobz10W25dKTtsZXQgZD1zP28mJm8uX19vYl9fOkF0KG8sITEsaSk7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4se2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe2NvbnN0IG49dT91LmNhbGwodCk6bztyZXR1cm4gdnQudGFyZ2V0JiYoYS5kZXBlbmQoKSxkJiYoZC5kZXAuZGVwZW5kKCksZShuKSYmUHQobikpKSxIdChuKSYmIXM/bi52YWx1ZTpufSxzZXQ6ZnVuY3Rpb24oZSl7Y29uc3Qgbj11P3UuY2FsbCh0KTpvO2lmKEwobixlKSl7aWYoZilmLmNhbGwodCxlKTtlbHNle2lmKHUpcmV0dXJuO2lmKCFzJiZIdChuKSYmIUh0KGUpKXJldHVybiB2b2lkKG4udmFsdWU9ZSk7bz1lfWQ9cz9lJiZlLl9fb2JfXzpBdChlLCExLGkpLGEubm90aWZ5KCl9fX0pLGF9ZnVuY3Rpb24gRXQodCxuLG8pe2lmKFJ0KHQpKXJldHVybjtjb25zdCByPXQuX19vYl9fO3JldHVybiBlKHQpJiZ1KG4pPyh0Lmxlbmd0aD1NYXRoLm1heCh0Lmxlbmd0aCxuKSx0LnNwbGljZShuLDEsbyksciYmIXIuc2hhbGxvdyYmci5tb2NrJiZBdChvLCExLCEwKSxvKTpuIGluIHQmJiEobiBpbiBPYmplY3QucHJvdG90eXBlKT8odFtuXT1vLG8pOnQuX2lzVnVlfHxyJiZyLnZtQ291bnQ/bzpyPyhqdChyLnZhbHVlLG4sbyx2b2lkIDAsci5zaGFsbG93LHIubW9jayksci5kZXAubm90aWZ5KCksbyk6KHRbbl09byxvKX1mdW5jdGlvbiBOdCh0LG4pe2lmKGUodCkmJnUobikpcmV0dXJuIHZvaWQgdC5zcGxpY2UobiwxKTtjb25zdCBvPXQuX19vYl9fO3QuX2lzVnVlfHxvJiZvLnZtQ291bnR8fFJ0KHQpfHwkKHQsbikmJihkZWxldGUgdFtuXSxvJiZvLmRlcC5ub3RpZnkoKSl9ZnVuY3Rpb24gUHQodCl7Zm9yKGxldCBuLG89MCxyPXQubGVuZ3RoO288cjtvKyspbj10W29dLG4mJm4uX19vYl9fJiZuLl9fb2JfXy5kZXAuZGVwZW5kKCksZShuKSYmUHQobil9ZnVuY3Rpb24gRHQodCl7cmV0dXJuIE10KHQsITApLFYodCxcIl9fdl9pc1NoYWxsb3dcIiwhMCksdH1mdW5jdGlvbiBNdCh0LGUpe1J0KHQpfHxBdCh0LGUsb3QoKSl9ZnVuY3Rpb24gSXQodCl7cmV0dXJuIFJ0KHQpP0l0KHQuX192X3Jhdyk6ISghdHx8IXQuX19vYl9fKX1mdW5jdGlvbiBMdCh0KXtyZXR1cm4hKCF0fHwhdC5fX3ZfaXNTaGFsbG93KX1mdW5jdGlvbiBSdCh0KXtyZXR1cm4hKCF0fHwhdC5fX3ZfaXNSZWFkb25seSl9Y29uc3QgRnQ9XCJfX3ZfaXNSZWZcIjtmdW5jdGlvbiBIdCh0KXtyZXR1cm4hKCF0fHwhMCE9PXQuX192X2lzUmVmKX1mdW5jdGlvbiBCdCh0LGUpe2lmKEh0KHQpKXJldHVybiB0O2NvbnN0IG49e307cmV0dXJuIFYobixGdCwhMCksVihuLFwiX192X2lzU2hhbGxvd1wiLGUpLFYobixcImRlcFwiLGp0KG4sXCJ2YWx1ZVwiLHQsbnVsbCxlLG90KCkpKSxufWZ1bmN0aW9uIFV0KHQsZSxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6KCk9Pntjb25zdCB0PWVbbl07aWYoSHQodCkpcmV0dXJuIHQudmFsdWU7e2NvbnN0IGU9dCYmdC5fX29iX187cmV0dXJuIGUmJmUuZGVwLmRlcGVuZCgpLHR9fSxzZXQ6dD0+e2NvbnN0IG89ZVtuXTtIdChvKSYmIUh0KHQpP28udmFsdWU9dDplW25dPXR9fSl9ZnVuY3Rpb24genQodCxlLG4pe2NvbnN0IG89dFtlXTtpZihIdChvKSlyZXR1cm4gbztjb25zdCByPXtnZXQgdmFsdWUoKXtjb25zdCBvPXRbZV07cmV0dXJuIHZvaWQgMD09PW8/bjpvfSxzZXQgdmFsdWUobil7dFtlXT1ufX07cmV0dXJuIFYocixGdCwhMCkscn1jb25zdCBWdD1cIl9fdl9yYXdUb1JlYWRvbmx5XCIsS3Q9XCJfX3ZfcmF3VG9TaGFsbG93UmVhZG9ubHlcIjtmdW5jdGlvbiBKdCh0KXtyZXR1cm4gcXQodCwhMSl9ZnVuY3Rpb24gcXQodCxlKXtpZighbCh0KSlyZXR1cm4gdDtpZihSdCh0KSlyZXR1cm4gdDtjb25zdCBuPWU/S3Q6VnQsbz10W25dO2lmKG8pcmV0dXJuIG87Y29uc3Qgcj1PYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0KSk7Vih0LG4sciksVihyLFwiX192X2lzUmVhZG9ubHlcIiwhMCksVihyLFwiX192X3Jhd1wiLHQpLEh0KHQpJiZWKHIsRnQsITApLChlfHxMdCh0KSkmJlYocixcIl9fdl9pc1NoYWxsb3dcIiwhMCk7Y29uc3Qgcz1PYmplY3Qua2V5cyh0KTtmb3IobGV0IG49MDtuPHMubGVuZ3RoO24rKylXdChyLHQsc1tuXSxlKTtyZXR1cm4gcn1mdW5jdGlvbiBXdCh0LGUsbixvKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQoKXtjb25zdCB0PWVbbl07cmV0dXJuIG98fCFsKHQpP3Q6SnQodCl9LHNldCgpe319KX1jb25zdCBadD1iKCh0PT57Y29uc3QgZT1cIiZcIj09PXQuY2hhckF0KDApLG49XCJ+XCI9PT0odD1lP3Quc2xpY2UoMSk6dCkuY2hhckF0KDApLG89XCIhXCI9PT0odD1uP3Quc2xpY2UoMSk6dCkuY2hhckF0KDApO3JldHVybntuYW1lOnQ9bz90LnNsaWNlKDEpOnQsb25jZTpuLGNhcHR1cmU6byxwYXNzaXZlOmV9fSkpO2Z1bmN0aW9uIEd0KHQsbil7ZnVuY3Rpb24gbygpe2NvbnN0IHQ9by5mbnM7aWYoIWUodCkpcmV0dXJuIHZuKHQsbnVsbCxhcmd1bWVudHMsbixcInYtb24gaGFuZGxlclwiKTt7Y29uc3QgZT10LnNsaWNlKCk7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0Kyspdm4oZVt0XSxudWxsLGFyZ3VtZW50cyxuLFwidi1vbiBoYW5kbGVyXCIpfX1yZXR1cm4gby5mbnM9dCxvfWZ1bmN0aW9uIFh0KHQsZSxvLHMsaSxjKXtsZXQgYSxsLHUsZjtmb3IoYSBpbiB0KWw9dFthXSx1PWVbYV0sZj1adChhKSxuKGwpfHwobih1KT8obihsLmZucykmJihsPXRbYV09R3QobCxjKSkscihmLm9uY2UpJiYobD10W2FdPWkoZi5uYW1lLGwsZi5jYXB0dXJlKSksbyhmLm5hbWUsbCxmLmNhcHR1cmUsZi5wYXNzaXZlLGYucGFyYW1zKSk6bCE9PXUmJih1LmZucz1sLHRbYV09dSkpO2ZvcihhIGluIGUpbih0W2FdKSYmKGY9WnQoYSkscyhmLm5hbWUsZVthXSxmLmNhcHR1cmUpKX1mdW5jdGlvbiBZdCh0LGUscyl7bGV0IGk7dCBpbnN0YW5jZW9mIHV0JiYodD10LmRhdGEuaG9va3x8KHQuZGF0YS5ob29rPXt9KSk7Y29uc3QgYz10W2VdO2Z1bmN0aW9uIGEoKXtzLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx5KGkuZm5zLGEpfW4oYyk/aT1HdChbYV0pOm8oYy5mbnMpJiZyKGMubWVyZ2VkKT8oaT1jLGkuZm5zLnB1c2goYSkpOmk9R3QoW2MsYV0pLGkubWVyZ2VkPSEwLHRbZV09aX1mdW5jdGlvbiBRdCh0LGUsbixyLHMpe2lmKG8oZSkpe2lmKCQoZSxuKSlyZXR1cm4gdFtuXT1lW25dLHN8fGRlbGV0ZSBlW25dLCEwO2lmKCQoZSxyKSlyZXR1cm4gdFtuXT1lW3JdLHN8fGRlbGV0ZSBlW3JdLCEwfXJldHVybiExfWZ1bmN0aW9uIHRlKHQpe3JldHVybiBzKHQpP1tkdCh0KV06ZSh0KT9uZSh0KTp2b2lkIDB9ZnVuY3Rpb24gZWUodCl7cmV0dXJuIG8odCkmJm8odC50ZXh0KSYmITE9PT10LmlzQ29tbWVudH1mdW5jdGlvbiBuZSh0LGkpe2NvbnN0IGM9W107bGV0IGEsbCx1LGY7Zm9yKGE9MDthPHQubGVuZ3RoO2ErKylsPXRbYV0sbihsKXx8XCJib29sZWFuXCI9PXR5cGVvZiBsfHwodT1jLmxlbmd0aC0xLGY9Y1t1XSxlKGwpP2wubGVuZ3RoPjAmJihsPW5lKGwsYCR7aXx8XCJcIn1fJHthfWApLGVlKGxbMF0pJiZlZShmKSYmKGNbdV09ZHQoZi50ZXh0K2xbMF0udGV4dCksbC5zaGlmdCgpKSxjLnB1c2guYXBwbHkoYyxsKSk6cyhsKT9lZShmKT9jW3VdPWR0KGYudGV4dCtsKTpcIlwiIT09bCYmYy5wdXNoKGR0KGwpKTplZShsKSYmZWUoZik/Y1t1XT1kdChmLnRleHQrbC50ZXh0KToocih0Ll9pc1ZMaXN0KSYmbyhsLnRhZykmJm4obC5rZXkpJiZvKGkpJiYobC5rZXk9YF9fdmxpc3Qke2l9XyR7YX1fX2ApLGMucHVzaChsKSkpO3JldHVybiBjfWNvbnN0IG9lPTEscmU9MjtmdW5jdGlvbiBzZSh0LG4sYSxsLHUsZil7cmV0dXJuKGUoYSl8fHMoYSkpJiYodT1sLGw9YSxhPXZvaWQgMCkscihmKSYmKHU9cmUpLGZ1bmN0aW9uKHQsbixyLHMsYSl7aWYobyhyKSYmbyhyLl9fb2JfXykpcmV0dXJuIGZ0KCk7byhyKSYmbyhyLmlzKSYmKG49ci5pcyk7aWYoIW4pcmV0dXJuIGZ0KCk7ZShzKSYmaShzWzBdKSYmKChyPXJ8fHt9KS5zY29wZWRTbG90cz17ZGVmYXVsdDpzWzBdfSxzLmxlbmd0aD0wKTthPT09cmU/cz10ZShzKTphPT09b2UmJihzPWZ1bmN0aW9uKHQpe2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWlmKGUodFtuXSkpcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sdCk7cmV0dXJuIHR9KHMpKTtsZXQgbCx1O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBuKXtsZXQgZTt1PXQuJHZub2RlJiZ0LiR2bm9kZS5uc3x8Qi5nZXRUYWdOYW1lc3BhY2UobiksbD1CLmlzUmVzZXJ2ZWRUYWcobik/bmV3IHV0KEIucGFyc2VQbGF0Zm9ybVRhZ05hbWUobikscixzLHZvaWQgMCx2b2lkIDAsdCk6ciYmci5wcmV8fCFvKGU9JG8odC4kb3B0aW9ucyxcImNvbXBvbmVudHNcIixuKSk/bmV3IHV0KG4scixzLHZvaWQgMCx2b2lkIDAsdCk6bG8oZSxyLHQscyxuKX1lbHNlIGw9bG8obixyLHQscyk7cmV0dXJuIGUobCk/bDpvKGwpPyhvKHUpJiZpZShsLHUpLG8ocikmJmZ1bmN0aW9uKHQpe2ModC5zdHlsZSkmJlVuKHQuc3R5bGUpO2ModC5jbGFzcykmJlVuKHQuY2xhc3MpfShyKSxsKTpmdCgpfSh0LG4sYSxsLHUpfWZ1bmN0aW9uIGllKHQsZSxzKXtpZih0Lm5zPWUsXCJmb3JlaWduT2JqZWN0XCI9PT10LnRhZyYmKGU9dm9pZCAwLHM9ITApLG8odC5jaGlsZHJlbikpZm9yKGxldCBpPTAsYz10LmNoaWxkcmVuLmxlbmd0aDtpPGM7aSsrKXtjb25zdCBjPXQuY2hpbGRyZW5baV07byhjLnRhZykmJihuKGMubnMpfHxyKHMpJiZcInN2Z1wiIT09Yy50YWcpJiZpZShjLGUscyl9fWZ1bmN0aW9uIGNlKHQsbil7bGV0IHIscyxpLGEsbD1udWxsO2lmKGUodCl8fFwic3RyaW5nXCI9PXR5cGVvZiB0KWZvcihsPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wLHM9dC5sZW5ndGg7cjxzO3IrKylsW3JdPW4odFtyXSxyKTtlbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiB0KWZvcihsPW5ldyBBcnJheSh0KSxyPTA7cjx0O3IrKylsW3JdPW4ocisxLHIpO2Vsc2UgaWYoYyh0KSlpZihpdCYmdFtTeW1ib2wuaXRlcmF0b3JdKXtsPVtdO2NvbnN0IGU9dFtTeW1ib2wuaXRlcmF0b3JdKCk7bGV0IG89ZS5uZXh0KCk7Zm9yKDshby5kb25lOylsLnB1c2gobihvLnZhbHVlLGwubGVuZ3RoKSksbz1lLm5leHQoKX1lbHNlIGZvcihpPU9iamVjdC5rZXlzKHQpLGw9bmV3IEFycmF5KGkubGVuZ3RoKSxyPTAscz1pLmxlbmd0aDtyPHM7cisrKWE9aVtyXSxsW3JdPW4odFthXSxhLHIpO3JldHVybiBvKGwpfHwobD1bXSksbC5faXNWTGlzdD0hMCxsfWZ1bmN0aW9uIGFlKHQsZSxuLG8pe2NvbnN0IHI9dGhpcy4kc2NvcGVkU2xvdHNbdF07bGV0IHM7cj8obj1ufHx7fSxvJiYobj1BKEEoe30sbyksbikpLHM9cihuKXx8KGkoZSk/ZSgpOmUpKTpzPXRoaXMuJHNsb3RzW3RdfHwoaShlKT9lKCk6ZSk7Y29uc3QgYz1uJiZuLnNsb3Q7cmV0dXJuIGM/dGhpcy4kY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIse3Nsb3Q6Y30scyk6c31mdW5jdGlvbiBsZSh0KXtyZXR1cm4gJG8odGhpcy4kb3B0aW9ucyxcImZpbHRlcnNcIix0KXx8UH1mdW5jdGlvbiB1ZSh0LG4pe3JldHVybiBlKHQpPy0xPT09dC5pbmRleE9mKG4pOnQhPT1ufWZ1bmN0aW9uIGZlKHQsZSxuLG8scil7Y29uc3Qgcz1CLmtleUNvZGVzW2VdfHxuO3JldHVybiByJiZvJiYhQi5rZXlDb2Rlc1tlXT91ZShyLG8pOnM/dWUocyx0KTpvP1MobykhPT1lOnZvaWQgMD09PXR9ZnVuY3Rpb24gZGUodCxuLG8scixzKXtpZihvKWlmKGMobykpe2xldCBpO2UobykmJihvPWoobykpO2Zvcihjb25zdCBlIGluIG8pe2lmKFwiY2xhc3NcIj09PWV8fFwic3R5bGVcIj09PWV8fHYoZSkpaT10O2Vsc2V7Y29uc3Qgbz10LmF0dHJzJiZ0LmF0dHJzLnR5cGU7aT1yfHxCLm11c3RVc2VQcm9wKG4sbyxlKT90LmRvbVByb3BzfHwodC5kb21Qcm9wcz17fSk6dC5hdHRyc3x8KHQuYXR0cnM9e30pfWNvbnN0IGM9eChlKSxhPVMoZSk7aWYoIShjIGluIGkpJiYhKGEgaW4gaSkmJihpW2VdPW9bZV0scykpeyh0Lm9ufHwodC5vbj17fSkpW2B1cGRhdGU6JHtlfWBdPWZ1bmN0aW9uKHQpe29bZV09dH19fX1lbHNlO3JldHVybiB0fWZ1bmN0aW9uIHBlKHQsZSl7Y29uc3Qgbj10aGlzLl9zdGF0aWNUcmVlc3x8KHRoaXMuX3N0YXRpY1RyZWVzPVtdKTtsZXQgbz1uW3RdO3JldHVybiBvJiYhZXx8KG89blt0XT10aGlzLiRvcHRpb25zLnN0YXRpY1JlbmRlckZuc1t0XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5LHRoaXMuX2MsdGhpcyksbWUobyxgX19zdGF0aWNfXyR7dH1gLCExKSksb31mdW5jdGlvbiBoZSh0LGUsbil7cmV0dXJuIG1lKHQsYF9fb25jZV9fJHtlfSR7bj9gXyR7bn1gOlwiXCJ9YCwhMCksdH1mdW5jdGlvbiBtZSh0LG4sbyl7aWYoZSh0KSlmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdJiZcInN0cmluZ1wiIT10eXBlb2YgdFtlXSYmZ2UodFtlXSxgJHtufV8ke2V9YCxvKTtlbHNlIGdlKHQsbixvKX1mdW5jdGlvbiBnZSh0LGUsbil7dC5pc1N0YXRpYz0hMCx0LmtleT1lLHQuaXNPbmNlPW59ZnVuY3Rpb24gdmUodCxlKXtpZihlKWlmKGwoZSkpe2NvbnN0IG49dC5vbj10Lm9uP0Eoe30sdC5vbik6e307Zm9yKGNvbnN0IHQgaW4gZSl7Y29uc3Qgbz1uW3RdLHI9ZVt0XTtuW3RdPW8/W10uY29uY2F0KG8scik6cn19ZWxzZTtyZXR1cm4gdH1mdW5jdGlvbiB5ZSh0LG4sbyxyKXtuPW58fHskc3RhYmxlOiFvfTtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7Y29uc3Qgcz10W3JdO2Uocyk/eWUocyxuLG8pOnMmJihzLnByb3h5JiYocy5mbi5wcm94eT0hMCksbltzLmtleV09cy5mbil9cmV0dXJuIHImJihuLiRrZXk9ciksbn1mdW5jdGlvbiBfZSh0LGUpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bis9Mil7Y29uc3Qgbz1lW25dO1wic3RyaW5nXCI9PXR5cGVvZiBvJiZvJiYodFtlW25dXT1lW24rMV0pfXJldHVybiB0fWZ1bmN0aW9uICRlKHQsZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/ZSt0OnR9ZnVuY3Rpb24gYmUodCl7dC5fbz1oZSx0Ll9uPWgsdC5fcz1kLHQuX2w9Y2UsdC5fdD1hZSx0Ll9xPUQsdC5faT1NLHQuX209cGUsdC5fZj1sZSx0Ll9rPWZlLHQuX2I9ZGUsdC5fdj1kdCx0Ll9lPWZ0LHQuX3U9eWUsdC5fZz12ZSx0Ll9kPV9lLHQuX3A9JGV9ZnVuY3Rpb24gd2UodCxlKXtpZighdHx8IXQubGVuZ3RoKXJldHVybnt9O2NvbnN0IG49e307Zm9yKGxldCBvPTAscj10Lmxlbmd0aDtvPHI7bysrKXtjb25zdCByPXRbb10scz1yLmRhdGE7aWYocyYmcy5hdHRycyYmcy5hdHRycy5zbG90JiZkZWxldGUgcy5hdHRycy5zbG90LHIuY29udGV4dCE9PWUmJnIuZm5Db250ZXh0IT09ZXx8IXN8fG51bGw9PXMuc2xvdCkobi5kZWZhdWx0fHwobi5kZWZhdWx0PVtdKSkucHVzaChyKTtlbHNle2NvbnN0IHQ9cy5zbG90LGU9blt0XXx8KG5bdF09W10pO1widGVtcGxhdGVcIj09PXIudGFnP2UucHVzaC5hcHBseShlLHIuY2hpbGRyZW58fFtdKTplLnB1c2gocil9fWZvcihjb25zdCB0IGluIG4pblt0XS5ldmVyeSh4ZSkmJmRlbGV0ZSBuW3RdO3JldHVybiBufWZ1bmN0aW9uIHhlKHQpe3JldHVybiB0LmlzQ29tbWVudCYmIXQuYXN5bmNGYWN0b3J5fHxcIiBcIj09PXQudGV4dH1mdW5jdGlvbiBDZSh0KXtyZXR1cm4gdC5pc0NvbW1lbnQmJnQuYXN5bmNGYWN0b3J5fWZ1bmN0aW9uIGtlKGUsbixvLHIpe2xldCBzO2NvbnN0IGk9T2JqZWN0LmtleXMobykubGVuZ3RoPjAsYz1uPyEhbi4kc3RhYmxlOiFpLGE9biYmbi4ka2V5O2lmKG4pe2lmKG4uX25vcm1hbGl6ZWQpcmV0dXJuIG4uX25vcm1hbGl6ZWQ7aWYoYyYmciYmciE9PXQmJmE9PT1yLiRrZXkmJiFpJiYhci4kaGFzTm9ybWFsKXJldHVybiByO3M9e307Zm9yKGNvbnN0IHQgaW4gbiluW3RdJiZcIiRcIiE9PXRbMF0mJihzW3RdPVNlKGUsbyx0LG5bdF0pKX1lbHNlIHM9e307Zm9yKGNvbnN0IHQgaW4gbyl0IGluIHN8fChzW3RdPU9lKG8sdCkpO3JldHVybiBuJiZPYmplY3QuaXNFeHRlbnNpYmxlKG4pJiYobi5fbm9ybWFsaXplZD1zKSxWKHMsXCIkc3RhYmxlXCIsYyksVihzLFwiJGtleVwiLGEpLFYocyxcIiRoYXNOb3JtYWxcIixpKSxzfWZ1bmN0aW9uIFNlKHQsbixvLHIpe2NvbnN0IHM9ZnVuY3Rpb24oKXtjb25zdCBuPWF0O2x0KHQpO2xldCBvPWFyZ3VtZW50cy5sZW5ndGg/ci5hcHBseShudWxsLGFyZ3VtZW50cyk6cih7fSk7bz1vJiZcIm9iamVjdFwiPT10eXBlb2YgbyYmIWUobyk/W29dOnRlKG8pO2NvbnN0IHM9byYmb1swXTtyZXR1cm4gbHQobiksbyYmKCFzfHwxPT09by5sZW5ndGgmJnMuaXNDb21tZW50JiYhQ2UocykpP3ZvaWQgMDpvfTtyZXR1cm4gci5wcm94eSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sbyx7Z2V0OnMsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KSxzfWZ1bmN0aW9uIE9lKHQsZSl7cmV0dXJuKCk9PnRbZV19ZnVuY3Rpb24gVGUoZSl7cmV0dXJue2dldCBhdHRycygpe2lmKCFlLl9hdHRyc1Byb3h5KXtjb25zdCBuPWUuX2F0dHJzUHJveHk9e307VihuLFwiX3ZfYXR0cl9wcm94eVwiLCEwKSxBZShuLGUuJGF0dHJzLHQsZSxcIiRhdHRyc1wiKX1yZXR1cm4gZS5fYXR0cnNQcm94eX0sZ2V0IGxpc3RlbmVycygpe2lmKCFlLl9saXN0ZW5lcnNQcm94eSl7QWUoZS5fbGlzdGVuZXJzUHJveHk9e30sZS4kbGlzdGVuZXJzLHQsZSxcIiRsaXN0ZW5lcnNcIil9cmV0dXJuIGUuX2xpc3RlbmVyc1Byb3h5fSxnZXQgc2xvdHMoKXtyZXR1cm4gZnVuY3Rpb24odCl7dC5fc2xvdHNQcm94eXx8RWUodC5fc2xvdHNQcm94eT17fSx0LiRzY29wZWRTbG90cyk7cmV0dXJuIHQuX3Nsb3RzUHJveHl9KGUpfSxlbWl0Ok8oZS4kZW1pdCxlKSxleHBvc2UodCl7dCYmT2JqZWN0LmtleXModCkuZm9yRWFjaCgobj0+VXQoZSx0LG4pKSl9fX1mdW5jdGlvbiBBZSh0LGUsbixvLHIpe2xldCBzPSExO2Zvcihjb25zdCBpIGluIGUpaSBpbiB0P2VbaV0hPT1uW2ldJiYocz0hMCk6KHM9ITAsamUodCxpLG8scikpO2Zvcihjb25zdCBuIGluIHQpbiBpbiBlfHwocz0hMCxkZWxldGUgdFtuXSk7cmV0dXJuIHN9ZnVuY3Rpb24gamUodCxlLG4sbyl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OigpPT5uW29dW2VdfSl9ZnVuY3Rpb24gRWUodCxlKXtmb3IoY29uc3QgbiBpbiBlKXRbbl09ZVtuXTtmb3IoY29uc3QgbiBpbiB0KW4gaW4gZXx8ZGVsZXRlIHRbbl19ZnVuY3Rpb24gTmUoKXtjb25zdCB0PWF0O3JldHVybiB0Ll9zZXR1cENvbnRleHR8fCh0Ll9zZXR1cENvbnRleHQ9VGUodCkpfWxldCBQZSxEZSxNZT1udWxsO2Z1bmN0aW9uIEllKHQsZSl7cmV0dXJuKHQuX19lc01vZHVsZXx8aXQmJlwiTW9kdWxlXCI9PT10W1N5bWJvbC50b1N0cmluZ1RhZ10pJiYodD10LmRlZmF1bHQpLGModCk/ZS5leHRlbmQodCk6dH1mdW5jdGlvbiBMZSh0KXtpZihlKHQpKWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtjb25zdCBuPXRbZV07aWYobyhuKSYmKG8obi5jb21wb25lbnRPcHRpb25zKXx8Q2UobikpKXJldHVybiBufX1mdW5jdGlvbiBSZSh0LGUpe1BlLiRvbih0LGUpfWZ1bmN0aW9uIEZlKHQsZSl7UGUuJG9mZih0LGUpfWZ1bmN0aW9uIEhlKHQsZSl7Y29uc3Qgbj1QZTtyZXR1cm4gZnVuY3Rpb24gbygpe251bGwhPT1lLmFwcGx5KG51bGwsYXJndW1lbnRzKSYmbi4kb2ZmKHQsbyl9fWZ1bmN0aW9uIEJlKHQsZSxuKXtQZT10LFh0KGUsbnx8e30sUmUsRmUsSGUsdCksUGU9dm9pZCAwfWNsYXNzIFVle2NvbnN0cnVjdG9yKHQ9ITEpe3RoaXMuZGV0YWNoZWQ9dCx0aGlzLmFjdGl2ZT0hMCx0aGlzLmVmZmVjdHM9W10sdGhpcy5jbGVhbnVwcz1bXSx0aGlzLnBhcmVudD1EZSwhdCYmRGUmJih0aGlzLmluZGV4PShEZS5zY29wZXN8fChEZS5zY29wZXM9W10pKS5wdXNoKHRoaXMpLTEpfXJ1bih0KXtpZih0aGlzLmFjdGl2ZSl7Y29uc3QgZT1EZTt0cnl7cmV0dXJuIERlPXRoaXMsdCgpfWZpbmFsbHl7RGU9ZX19fW9uKCl7RGU9dGhpc31vZmYoKXtEZT10aGlzLnBhcmVudH1zdG9wKHQpe2lmKHRoaXMuYWN0aXZlKXtsZXQgZSxuO2ZvcihlPTAsbj10aGlzLmVmZmVjdHMubGVuZ3RoO2U8bjtlKyspdGhpcy5lZmZlY3RzW2VdLnRlYXJkb3duKCk7Zm9yKGU9MCxuPXRoaXMuY2xlYW51cHMubGVuZ3RoO2U8bjtlKyspdGhpcy5jbGVhbnVwc1tlXSgpO2lmKHRoaXMuc2NvcGVzKWZvcihlPTAsbj10aGlzLnNjb3Blcy5sZW5ndGg7ZTxuO2UrKyl0aGlzLnNjb3Blc1tlXS5zdG9wKCEwKTtpZighdGhpcy5kZXRhY2hlZCYmdGhpcy5wYXJlbnQmJiF0KXtjb25zdCB0PXRoaXMucGFyZW50LnNjb3Blcy5wb3AoKTt0JiZ0IT09dGhpcyYmKHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XT10LHQuaW5kZXg9dGhpcy5pbmRleCl9dGhpcy5wYXJlbnQ9dm9pZCAwLHRoaXMuYWN0aXZlPSExfX19ZnVuY3Rpb24gemUoKXtyZXR1cm4gRGV9bGV0IFZlPW51bGw7ZnVuY3Rpb24gS2UodCl7Y29uc3QgZT1WZTtyZXR1cm4gVmU9dCwoKT0+e1ZlPWV9fWZ1bmN0aW9uIEplKHQpe2Zvcig7dCYmKHQ9dC4kcGFyZW50KTspaWYodC5faW5hY3RpdmUpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gcWUodCxlKXtpZihlKXtpZih0Ll9kaXJlY3RJbmFjdGl2ZT0hMSxKZSh0KSlyZXR1cm59ZWxzZSBpZih0Ll9kaXJlY3RJbmFjdGl2ZSlyZXR1cm47aWYodC5faW5hY3RpdmV8fG51bGw9PT10Ll9pbmFjdGl2ZSl7dC5faW5hY3RpdmU9ITE7Zm9yKGxldCBlPTA7ZTx0LiRjaGlsZHJlbi5sZW5ndGg7ZSsrKXFlKHQuJGNoaWxkcmVuW2VdKTtaZSh0LFwiYWN0aXZhdGVkXCIpfX1mdW5jdGlvbiBXZSh0LGUpe2lmKCEoZSYmKHQuX2RpcmVjdEluYWN0aXZlPSEwLEplKHQpKXx8dC5faW5hY3RpdmUpKXt0Ll9pbmFjdGl2ZT0hMDtmb3IobGV0IGU9MDtlPHQuJGNoaWxkcmVuLmxlbmd0aDtlKyspV2UodC4kY2hpbGRyZW5bZV0pO1plKHQsXCJkZWFjdGl2YXRlZFwiKX19ZnVuY3Rpb24gWmUodCxlLG4sbz0hMCl7X3QoKTtjb25zdCByPWF0LHM9emUoKTtvJiZsdCh0KTtjb25zdCBpPXQuJG9wdGlvbnNbZV0sYz1gJHtlfSBob29rYDtpZihpKWZvcihsZXQgZT0wLG89aS5sZW5ndGg7ZTxvO2UrKyl2bihpW2VdLHQsbnx8bnVsbCx0LGMpO3QuX2hhc0hvb2tFdmVudCYmdC4kZW1pdChcImhvb2s6XCIrZSksbyYmKGx0KHIpLHMmJnMub24oKSksJHQoKX1jb25zdCBHZT1bXSxYZT1bXTtsZXQgWWU9e30sUWU9ITEsdG49ITEsZW49MDtsZXQgbm49MCxvbj1EYXRlLm5vdztpZihxJiYhWil7Y29uc3QgdD13aW5kb3cucGVyZm9ybWFuY2U7dCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5ub3cmJm9uKCk+ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKS50aW1lU3RhbXAmJihvbj0oKT0+dC5ub3coKSl9Y29uc3Qgcm49KHQsZSk9PntpZih0LnBvc3Qpe2lmKCFlLnBvc3QpcmV0dXJuIDF9ZWxzZSBpZihlLnBvc3QpcmV0dXJuLTE7cmV0dXJuIHQuaWQtZS5pZH07ZnVuY3Rpb24gc24oKXtsZXQgdCxlO2Zvcihubj1vbigpLHRuPSEwLEdlLnNvcnQocm4pLGVuPTA7ZW48R2UubGVuZ3RoO2VuKyspdD1HZVtlbl0sdC5iZWZvcmUmJnQuYmVmb3JlKCksZT10LmlkLFllW2VdPW51bGwsdC5ydW4oKTtjb25zdCBuPVhlLnNsaWNlKCksbz1HZS5zbGljZSgpO2VuPUdlLmxlbmd0aD1YZS5sZW5ndGg9MCxZZT17fSxRZT10bj0hMSxmdW5jdGlvbih0KXtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdLl9pbmFjdGl2ZT0hMCxxZSh0W2VdLCEwKX0obiksZnVuY3Rpb24odCl7bGV0IGU9dC5sZW5ndGg7Zm9yKDtlLS07KXtjb25zdCBuPXRbZV0sbz1uLnZtO28mJm8uX3dhdGNoZXI9PT1uJiZvLl9pc01vdW50ZWQmJiFvLl9pc0Rlc3Ryb3llZCYmWmUobyxcInVwZGF0ZWRcIil9fShvKSxndCgpLHJ0JiZCLmRldnRvb2xzJiZydC5lbWl0KFwiZmx1c2hcIil9ZnVuY3Rpb24gY24odCl7Y29uc3QgZT10LmlkO2lmKG51bGw9PVllW2VdJiYodCE9PXZ0LnRhcmdldHx8IXQubm9SZWN1cnNlKSl7aWYoWWVbZV09ITAsdG4pe2xldCBlPUdlLmxlbmd0aC0xO2Zvcig7ZT5lbiYmR2VbZV0uaWQ+dC5pZDspZS0tO0dlLnNwbGljZShlKzEsMCx0KX1lbHNlIEdlLnB1c2godCk7UWV8fChRZT0hMCxrbihzbikpfX1jb25zdCBhbj1cIndhdGNoZXJcIixsbj1gJHthbn0gY2FsbGJhY2tgLHVuPWAke2FufSBnZXR0ZXJgLGZuPWAke2FufSBjbGVhbnVwYDtmdW5jdGlvbiBkbih0LGUpe3JldHVybiBobih0LG51bGwse2ZsdXNoOlwicG9zdFwifSl9Y29uc3QgcG49e307ZnVuY3Rpb24gaG4obixvLHtpbW1lZGlhdGU6cixkZWVwOnMsZmx1c2g6Yz1cInByZVwiLG9uVHJhY2s6YSxvblRyaWdnZXI6bH09dCl7Y29uc3QgdT1hdCxmPSh0LGUsbj1udWxsKT0+e2NvbnN0IG89dm4odCxudWxsLG4sdSxlKTtyZXR1cm4gcyYmbyYmby5fX29iX18mJm8uX19vYl9fLmRlcC5kZXBlbmQoKSxvfTtsZXQgZCxwLGg9ITEsbT0hMTtpZihIdChuKT8oZD0oKT0+bi52YWx1ZSxoPUx0KG4pKTpJdChuKT8oZD0oKT0+KG4uX19vYl9fLmRlcC5kZXBlbmQoKSxuKSxzPSEwKTplKG4pPyhtPSEwLGg9bi5zb21lKCh0PT5JdCh0KXx8THQodCkpKSxkPSgpPT5uLm1hcCgodD0+SHQodCk/dC52YWx1ZTpJdCh0KT8odC5fX29iX18uZGVwLmRlcGVuZCgpLFVuKHQpKTppKHQpP2YodCx1bik6dm9pZCAwKSkpOmQ9aShuKT9vPygpPT5mKG4sdW4pOigpPT57aWYoIXV8fCF1Ll9pc0Rlc3Ryb3llZClyZXR1cm4gcCYmcCgpLGYobixhbixbZ10pfTpFLG8mJnMpe2NvbnN0IHQ9ZDtkPSgpPT5Vbih0KCkpfWxldCBnPXQ9PntwPXYub25TdG9wPSgpPT57Zih0LGZuKX19O2lmKG90KCkpcmV0dXJuIGc9RSxvP3ImJmYobyxsbixbZCgpLG0/W106dm9pZCAwLGddKTpkKCksRTtjb25zdCB2PW5ldyBLbihhdCxkLEUse2xhenk6ITB9KTt2Lm5vUmVjdXJzZT0hbztsZXQgeT1tP1tdOnBuO3JldHVybiB2LnJ1bj0oKT0+e2lmKHYuYWN0aXZlKWlmKG8pe2NvbnN0IHQ9di5nZXQoKTsoc3x8aHx8KG0/dC5zb21lKCgodCxlKT0+TCh0LHlbZV0pKSk6TCh0LHkpKSkmJihwJiZwKCksZihvLGxuLFt0LHk9PT1wbj92b2lkIDA6eSxnXSkseT10KX1lbHNlIHYuZ2V0KCl9LFwic3luY1wiPT09Yz92LnVwZGF0ZT12LnJ1bjpcInBvc3RcIj09PWM/KHYucG9zdD0hMCx2LnVwZGF0ZT0oKT0+Y24odikpOnYudXBkYXRlPSgpPT57aWYodSYmdT09PWF0JiYhdS5faXNNb3VudGVkKXtjb25zdCB0PXUuX3ByZVdhdGNoZXJzfHwodS5fcHJlV2F0Y2hlcnM9W10pO3QuaW5kZXhPZih2KTwwJiZ0LnB1c2godil9ZWxzZSBjbih2KX0sbz9yP3YucnVuKCk6eT12LmdldCgpOlwicG9zdFwiPT09YyYmdT91LiRvbmNlKFwiaG9vazptb3VudGVkXCIsKCgpPT52LmdldCgpKSk6di5nZXQoKSwoKT0+e3YudGVhcmRvd24oKX19ZnVuY3Rpb24gbW4odCl7Y29uc3QgZT10Ll9wcm92aWRlZCxuPXQuJHBhcmVudCYmdC4kcGFyZW50Ll9wcm92aWRlZDtyZXR1cm4gbj09PWU/dC5fcHJvdmlkZWQ9T2JqZWN0LmNyZWF0ZShuKTplfWZ1bmN0aW9uIGduKHQsZSxuKXtfdCgpO3RyeXtpZihlKXtsZXQgbz1lO2Zvcig7bz1vLiRwYXJlbnQ7KXtjb25zdCByPW8uJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtpZihyKWZvcihsZXQgcz0wO3M8ci5sZW5ndGg7cysrKXRyeXtpZighMT09PXJbc10uY2FsbChvLHQsZSxuKSlyZXR1cm59Y2F0Y2godCl7eW4odCxvLFwiZXJyb3JDYXB0dXJlZCBob29rXCIpfX19eW4odCxlLG4pfWZpbmFsbHl7JHQoKX19ZnVuY3Rpb24gdm4odCxlLG4sbyxyKXtsZXQgczt0cnl7cz1uP3QuYXBwbHkoZSxuKTp0LmNhbGwoZSkscyYmIXMuX2lzVnVlJiZmKHMpJiYhcy5faGFuZGxlZCYmKHMuY2F0Y2goKHQ9PmduKHQsbyxyK1wiIChQcm9taXNlL2FzeW5jKVwiKSkpLHMuX2hhbmRsZWQ9ITApfWNhdGNoKHQpe2duKHQsbyxyKX1yZXR1cm4gc31mdW5jdGlvbiB5bih0LGUsbil7aWYoQi5lcnJvckhhbmRsZXIpdHJ5e3JldHVybiBCLmVycm9ySGFuZGxlci5jYWxsKG51bGwsdCxlLG4pfWNhdGNoKGUpe2UhPT10JiZfbihlKX1fbih0KX1mdW5jdGlvbiBfbih0LGUsbil7aWYoIXF8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBjb25zb2xlKXRocm93IHQ7Y29uc29sZS5lcnJvcih0KX1sZXQgJG49ITE7Y29uc3QgYm49W107bGV0IHduLHhuPSExO2Z1bmN0aW9uIENuKCl7eG49ITE7Y29uc3QgdD1ibi5zbGljZSgwKTtibi5sZW5ndGg9MDtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdKCl9aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJnN0KFByb21pc2UpKXtjb25zdCB0PVByb21pc2UucmVzb2x2ZSgpO3duPSgpPT57dC50aGVuKENuKSxZJiZzZXRUaW1lb3V0KEUpfSwkbj0hMH1lbHNlIGlmKFp8fFwidW5kZWZpbmVkXCI9PXR5cGVvZiBNdXRhdGlvbk9ic2VydmVyfHwhc3QoTXV0YXRpb25PYnNlcnZlcikmJlwiW29iamVjdCBNdXRhdGlvbk9ic2VydmVyQ29uc3RydWN0b3JdXCIhPT1NdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkpd249XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNldEltbWVkaWF0ZSYmc3Qoc2V0SW1tZWRpYXRlKT8oKT0+e3NldEltbWVkaWF0ZShDbil9OigpPT57c2V0VGltZW91dChDbiwwKX07ZWxzZXtsZXQgdD0xO2NvbnN0IGU9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoQ24pLG49ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHQpKTtlLm9ic2VydmUobix7Y2hhcmFjdGVyRGF0YTohMH0pLHduPSgpPT57dD0odCsxKSUyLG4uZGF0YT1TdHJpbmcodCl9LCRuPSEwfWZ1bmN0aW9uIGtuKHQsZSl7bGV0IG47aWYoYm4ucHVzaCgoKCk9PntpZih0KXRyeXt0LmNhbGwoZSl9Y2F0Y2godCl7Z24odCxlLFwibmV4dFRpY2tcIil9ZWxzZSBuJiZuKGUpfSkpLHhufHwoeG49ITAsd24oKSksIXQmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlKXJldHVybiBuZXcgUHJvbWlzZSgodD0+e249dH0pKX1mdW5jdGlvbiBTbih0KXtyZXR1cm4oZSxuPWF0KT0+e2lmKG4pcmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtjb25zdCBvPXQuJG9wdGlvbnM7b1tlXT1nbyhvW2VdLG4pfShuLHQsZSl9fWNvbnN0IE9uPVNuKFwiYmVmb3JlTW91bnRcIiksVG49U24oXCJtb3VudGVkXCIpLEFuPVNuKFwiYmVmb3JlVXBkYXRlXCIpLGpuPVNuKFwidXBkYXRlZFwiKSxFbj1TbihcImJlZm9yZURlc3Ryb3lcIiksTm49U24oXCJkZXN0cm95ZWRcIiksUG49U24oXCJhY3RpdmF0ZWRcIiksRG49U24oXCJkZWFjdGl2YXRlZFwiKSxNbj1TbihcInNlcnZlclByZWZldGNoXCIpLEluPVNuKFwicmVuZGVyVHJhY2tlZFwiKSxMbj1TbihcInJlbmRlclRyaWdnZXJlZFwiKSxSbj1TbihcImVycm9yQ2FwdHVyZWRcIik7Y29uc3QgRm49XCIyLjcuMTZcIjt2YXIgSG49T2JqZWN0LmZyZWV6ZSh7X19wcm90b19fOm51bGwsdmVyc2lvbjpGbixkZWZpbmVDb21wb25lbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHR9LHJlZjpmdW5jdGlvbih0KXtyZXR1cm4gQnQodCwhMSl9LHNoYWxsb3dSZWY6ZnVuY3Rpb24odCl7cmV0dXJuIEJ0KHQsITApfSxpc1JlZjpIdCx0b1JlZjp6dCx0b1JlZnM6ZnVuY3Rpb24odCl7Y29uc3Qgbj1lKHQpP25ldyBBcnJheSh0Lmxlbmd0aCk6e307Zm9yKGNvbnN0IGUgaW4gdCluW2VdPXp0KHQsZSk7cmV0dXJuIG59LHVucmVmOmZ1bmN0aW9uKHQpe3JldHVybiBIdCh0KT90LnZhbHVlOnR9LHByb3h5UmVmczpmdW5jdGlvbih0KXtpZihJdCh0KSlyZXR1cm4gdDtjb25zdCBlPXt9LG49T2JqZWN0LmtleXModCk7Zm9yKGxldCBvPTA7bzxuLmxlbmd0aDtvKyspVXQoZSx0LG5bb10pO3JldHVybiBlfSxjdXN0b21SZWY6ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgdnQse2dldDpuLHNldDpvfT10KCgoKT0+e2UuZGVwZW5kKCl9KSwoKCk9PntlLm5vdGlmeSgpfSkpLHI9e2dldCB2YWx1ZSgpe3JldHVybiBuKCl9LHNldCB2YWx1ZSh0KXtvKHQpfX07cmV0dXJuIFYocixGdCwhMCkscn0sdHJpZ2dlclJlZjpmdW5jdGlvbih0KXt0LmRlcCYmdC5kZXAubm90aWZ5KCl9LHJlYWN0aXZlOmZ1bmN0aW9uKHQpe3JldHVybiBNdCh0LCExKSx0fSxpc1JlYWN0aXZlOkl0LGlzUmVhZG9ubHk6UnQsaXNTaGFsbG93Okx0LGlzUHJveHk6ZnVuY3Rpb24odCl7cmV0dXJuIEl0KHQpfHxSdCh0KX0sc2hhbGxvd1JlYWN0aXZlOkR0LG1hcmtSYXc6ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUodCkmJlYodCxcIl9fdl9za2lwXCIsITApLHR9LHRvUmF3OmZ1bmN0aW9uIHQoZSl7Y29uc3Qgbj1lJiZlLl9fdl9yYXc7cmV0dXJuIG4/dChuKTplfSxyZWFkb25seTpKdCxzaGFsbG93UmVhZG9ubHk6ZnVuY3Rpb24odCl7cmV0dXJuIHF0KHQsITApfSxjb21wdXRlZDpmdW5jdGlvbih0LGUpe2xldCBuLG87Y29uc3Qgcj1pKHQpO3I/KG49dCxvPUUpOihuPXQuZ2V0LG89dC5zZXQpO2NvbnN0IHM9b3QoKT9udWxsOm5ldyBLbihhdCxuLEUse2xhenk6ITB9KSxjPXtlZmZlY3Q6cyxnZXQgdmFsdWUoKXtyZXR1cm4gcz8ocy5kaXJ0eSYmcy5ldmFsdWF0ZSgpLHZ0LnRhcmdldCYmcy5kZXBlbmQoKSxzLnZhbHVlKTpuKCl9LHNldCB2YWx1ZSh0KXtvKHQpfX07cmV0dXJuIFYoYyxGdCwhMCksVihjLFwiX192X2lzUmVhZG9ubHlcIixyKSxjfSx3YXRjaDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIGhuKHQsZSxuKX0sd2F0Y2hFZmZlY3Q6ZnVuY3Rpb24odCxlKXtyZXR1cm4gaG4odCxudWxsLGUpfSx3YXRjaFBvc3RFZmZlY3Q6ZG4sd2F0Y2hTeW5jRWZmZWN0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhuKHQsbnVsbCx7Zmx1c2g6XCJzeW5jXCJ9KX0sRWZmZWN0U2NvcGU6VWUsZWZmZWN0U2NvcGU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBVZSh0KX0sb25TY29wZURpc3Bvc2U6ZnVuY3Rpb24odCl7RGUmJkRlLmNsZWFudXBzLnB1c2godCl9LGdldEN1cnJlbnRTY29wZTp6ZSxwcm92aWRlOmZ1bmN0aW9uKHQsZSl7YXQmJihtbihhdClbdF09ZSl9LGluamVjdDpmdW5jdGlvbih0LGUsbj0hMSl7Y29uc3Qgbz1hdDtpZihvKXtjb25zdCByPW8uJHBhcmVudCYmby4kcGFyZW50Ll9wcm92aWRlZDtpZihyJiZ0IGluIHIpcmV0dXJuIHJbdF07aWYoYXJndW1lbnRzLmxlbmd0aD4xKXJldHVybiBuJiZpKGUpP2UuY2FsbChvKTplfX0saDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHNlKGF0LHQsZSxuLDIsITApfSxnZXRDdXJyZW50SW5zdGFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gYXQmJntwcm94eTphdH19LHVzZVNsb3RzOmZ1bmN0aW9uKCl7cmV0dXJuIE5lKCkuc2xvdHN9LHVzZUF0dHJzOmZ1bmN0aW9uKCl7cmV0dXJuIE5lKCkuYXR0cnN9LHVzZUxpc3RlbmVyczpmdW5jdGlvbigpe3JldHVybiBOZSgpLmxpc3RlbmVyc30sbWVyZ2VEZWZhdWx0czpmdW5jdGlvbih0LG4pe2NvbnN0IG89ZSh0KT90LnJlZHVjZSgoKHQsZSk9Pih0W2VdPXt9LHQpKSx7fSk6dDtmb3IoY29uc3QgdCBpbiBuKXtjb25zdCByPW9bdF07cj9lKHIpfHxpKHIpP29bdF09e3R5cGU6cixkZWZhdWx0Om5bdF19OnIuZGVmYXVsdD1uW3RdOm51bGw9PT1yJiYob1t0XT17ZGVmYXVsdDpuW3RdfSl9cmV0dXJuIG99LG5leHRUaWNrOmtuLHNldDpFdCxkZWw6TnQsdXNlQ3NzTW9kdWxlOmZ1bmN0aW9uKGU9XCIkc3R5bGVcIil7e2lmKCFhdClyZXR1cm4gdDtjb25zdCBuPWF0W2VdO3JldHVybiBufHx0fX0sdXNlQ3NzVmFyczpmdW5jdGlvbih0KXtpZighcSlyZXR1cm47Y29uc3QgZT1hdDtlJiZkbigoKCk9Pntjb25zdCBuPWUuJGVsLG89dChlLGUuX3NldHVwUHJveHkpO2lmKG4mJjE9PT1uLm5vZGVUeXBlKXtjb25zdCB0PW4uc3R5bGU7Zm9yKGNvbnN0IGUgaW4gbyl0LnNldFByb3BlcnR5KGAtLSR7ZX1gLG9bZV0pfX0pKX0sZGVmaW5lQXN5bmNDb21wb25lbnQ6ZnVuY3Rpb24odCl7aSh0KSYmKHQ9e2xvYWRlcjp0fSk7Y29uc3R7bG9hZGVyOmUsbG9hZGluZ0NvbXBvbmVudDpuLGVycm9yQ29tcG9uZW50Om8sZGVsYXk6cj0yMDAsdGltZW91dDpzLHN1c3BlbnNpYmxlOmM9ITEsb25FcnJvcjphfT10O2xldCBsPW51bGwsdT0wO2NvbnN0IGY9KCk9PntsZXQgdDtyZXR1cm4gbHx8KHQ9bD1lKCkuY2F0Y2goKHQ9PntpZih0PXQgaW5zdGFuY2VvZiBFcnJvcj90Om5ldyBFcnJvcihTdHJpbmcodCkpLGEpcmV0dXJuIG5ldyBQcm9taXNlKCgoZSxuKT0+e2EodCwoKCk9PmUoKHUrKyxsPW51bGwsZigpKSkpLCgoKT0+bih0KSksdSsxKX0pKTt0aHJvdyB0fSkpLnRoZW4oKGU9PnQhPT1sJiZsP2w6KGUmJihlLl9fZXNNb2R1bGV8fFwiTW9kdWxlXCI9PT1lW1N5bWJvbC50b1N0cmluZ1RhZ10pJiYoZT1lLmRlZmF1bHQpLGUpKSkpfTtyZXR1cm4oKT0+KHtjb21wb25lbnQ6ZigpLGRlbGF5OnIsdGltZW91dDpzLGVycm9yOm8sbG9hZGluZzpufSl9LG9uQmVmb3JlTW91bnQ6T24sb25Nb3VudGVkOlRuLG9uQmVmb3JlVXBkYXRlOkFuLG9uVXBkYXRlZDpqbixvbkJlZm9yZVVubW91bnQ6RW4sb25Vbm1vdW50ZWQ6Tm4sb25BY3RpdmF0ZWQ6UG4sb25EZWFjdGl2YXRlZDpEbixvblNlcnZlclByZWZldGNoOk1uLG9uUmVuZGVyVHJhY2tlZDpJbixvblJlbmRlclRyaWdnZXJlZDpMbixvbkVycm9yQ2FwdHVyZWQ6ZnVuY3Rpb24odCxlPWF0KXtSbih0LGUpfX0pO2NvbnN0IEJuPW5ldyBjdDtmdW5jdGlvbiBVbih0KXtyZXR1cm4gem4odCxCbiksQm4uY2xlYXIoKSx0fWZ1bmN0aW9uIHpuKHQsbil7bGV0IG8scjtjb25zdCBzPWUodCk7aWYoISghcyYmIWModCl8fHQuX192X3NraXB8fE9iamVjdC5pc0Zyb3plbih0KXx8dCBpbnN0YW5jZW9mIHV0KSl7aWYodC5fX29iX18pe2NvbnN0IGU9dC5fX29iX18uZGVwLmlkO2lmKG4uaGFzKGUpKXJldHVybjtuLmFkZChlKX1pZihzKWZvcihvPXQubGVuZ3RoO28tLTspem4odFtvXSxuKTtlbHNlIGlmKEh0KHQpKXpuKHQudmFsdWUsbik7ZWxzZSBmb3Iocj1PYmplY3Qua2V5cyh0KSxvPXIubGVuZ3RoO28tLTspem4odFtyW29dXSxuKX19bGV0IFZuPTA7Y2xhc3MgS257Y29uc3RydWN0b3IodCxlLG4sbyxyKXshZnVuY3Rpb24odCxlPURlKXtlJiZlLmFjdGl2ZSYmZS5lZmZlY3RzLnB1c2godCl9KHRoaXMsRGUmJiFEZS5fdm0/RGU6dD90Ll9zY29wZTp2b2lkIDApLCh0aGlzLnZtPXQpJiZyJiYodC5fd2F0Y2hlcj10aGlzKSxvPyh0aGlzLmRlZXA9ISFvLmRlZXAsdGhpcy51c2VyPSEhby51c2VyLHRoaXMubGF6eT0hIW8ubGF6eSx0aGlzLnN5bmM9ISFvLnN5bmMsdGhpcy5iZWZvcmU9by5iZWZvcmUpOnRoaXMuZGVlcD10aGlzLnVzZXI9dGhpcy5sYXp5PXRoaXMuc3luYz0hMSx0aGlzLmNiPW4sdGhpcy5pZD0rK1ZuLHRoaXMuYWN0aXZlPSEwLHRoaXMucG9zdD0hMSx0aGlzLmRpcnR5PXRoaXMubGF6eSx0aGlzLmRlcHM9W10sdGhpcy5uZXdEZXBzPVtdLHRoaXMuZGVwSWRzPW5ldyBjdCx0aGlzLm5ld0RlcElkcz1uZXcgY3QsdGhpcy5leHByZXNzaW9uPVwiXCIsaShlKT90aGlzLmdldHRlcj1lOih0aGlzLmdldHRlcj1mdW5jdGlvbih0KXtpZihLLnRlc3QodCkpcmV0dXJuO2NvbnN0IGU9dC5zcGxpdChcIi5cIik7cmV0dXJuIGZ1bmN0aW9uKHQpe2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXtpZighdClyZXR1cm47dD10W2Vbbl1dfXJldHVybiB0fX0oZSksdGhpcy5nZXR0ZXJ8fCh0aGlzLmdldHRlcj1FKSksdGhpcy52YWx1ZT10aGlzLmxhenk/dm9pZCAwOnRoaXMuZ2V0KCl9Z2V0KCl7bGV0IHQ7X3QodGhpcyk7Y29uc3QgZT10aGlzLnZtO3RyeXt0PXRoaXMuZ2V0dGVyLmNhbGwoZSxlKX1jYXRjaCh0KXtpZighdGhpcy51c2VyKXRocm93IHQ7Z24odCxlLGBnZXR0ZXIgZm9yIHdhdGNoZXIgXCIke3RoaXMuZXhwcmVzc2lvbn1cImApfWZpbmFsbHl7dGhpcy5kZWVwJiZVbih0KSwkdCgpLHRoaXMuY2xlYW51cERlcHMoKX1yZXR1cm4gdH1hZGREZXAodCl7Y29uc3QgZT10LmlkO3RoaXMubmV3RGVwSWRzLmhhcyhlKXx8KHRoaXMubmV3RGVwSWRzLmFkZChlKSx0aGlzLm5ld0RlcHMucHVzaCh0KSx0aGlzLmRlcElkcy5oYXMoZSl8fHQuYWRkU3ViKHRoaXMpKX1jbGVhbnVwRGVwcygpe2xldCB0PXRoaXMuZGVwcy5sZW5ndGg7Zm9yKDt0LS07KXtjb25zdCBlPXRoaXMuZGVwc1t0XTt0aGlzLm5ld0RlcElkcy5oYXMoZS5pZCl8fGUucmVtb3ZlU3ViKHRoaXMpfWxldCBlPXRoaXMuZGVwSWRzO3RoaXMuZGVwSWRzPXRoaXMubmV3RGVwSWRzLHRoaXMubmV3RGVwSWRzPWUsdGhpcy5uZXdEZXBJZHMuY2xlYXIoKSxlPXRoaXMuZGVwcyx0aGlzLmRlcHM9dGhpcy5uZXdEZXBzLHRoaXMubmV3RGVwcz1lLHRoaXMubmV3RGVwcy5sZW5ndGg9MH11cGRhdGUoKXt0aGlzLmxhenk/dGhpcy5kaXJ0eT0hMDp0aGlzLnN5bmM/dGhpcy5ydW4oKTpjbih0aGlzKX1ydW4oKXtpZih0aGlzLmFjdGl2ZSl7Y29uc3QgdD10aGlzLmdldCgpO2lmKHQhPT10aGlzLnZhbHVlfHxjKHQpfHx0aGlzLmRlZXApe2NvbnN0IGU9dGhpcy52YWx1ZTtpZih0aGlzLnZhbHVlPXQsdGhpcy51c2VyKXtjb25zdCBuPWBjYWxsYmFjayBmb3Igd2F0Y2hlciBcIiR7dGhpcy5leHByZXNzaW9ufVwiYDt2bih0aGlzLmNiLHRoaXMudm0sW3QsZV0sdGhpcy52bSxuKX1lbHNlIHRoaXMuY2IuY2FsbCh0aGlzLnZtLHQsZSl9fX1ldmFsdWF0ZSgpe3RoaXMudmFsdWU9dGhpcy5nZXQoKSx0aGlzLmRpcnR5PSExfWRlcGVuZCgpe2xldCB0PXRoaXMuZGVwcy5sZW5ndGg7Zm9yKDt0LS07KXRoaXMuZGVwc1t0XS5kZXBlbmQoKX10ZWFyZG93bigpe2lmKHRoaXMudm0mJiF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkJiZ5KHRoaXMudm0uX3Njb3BlLmVmZmVjdHMsdGhpcyksdGhpcy5hY3RpdmUpe2xldCB0PXRoaXMuZGVwcy5sZW5ndGg7Zm9yKDt0LS07KXRoaXMuZGVwc1t0XS5yZW1vdmVTdWIodGhpcyk7dGhpcy5hY3RpdmU9ITEsdGhpcy5vblN0b3AmJnRoaXMub25TdG9wKCl9fX1jb25zdCBKbj17ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OkUsc2V0OkV9O2Z1bmN0aW9uIHFuKHQsZSxuKXtKbi5nZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1tlXVtuXX0sSm4uc2V0PWZ1bmN0aW9uKHQpe3RoaXNbZV1bbl09dH0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbixKbil9ZnVuY3Rpb24gV24odCl7Y29uc3Qgbj10LiRvcHRpb25zO2lmKG4ucHJvcHMmJmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10LiRvcHRpb25zLnByb3BzRGF0YXx8e30sbz10Ll9wcm9wcz1EdCh7fSkscj10LiRvcHRpb25zLl9wcm9wS2V5cz1bXSxzPSF0LiRwYXJlbnQ7c3x8U3QoITEpO2Zvcihjb25zdCBzIGluIGUpe3IucHVzaChzKTtqdChvLHMsYm8ocyxlLG4sdCksdm9pZCAwLCEwKSxzIGluIHR8fHFuKHQsXCJfcHJvcHNcIixzKX1TdCghMCl9KHQsbi5wcm9wcyksZnVuY3Rpb24odCl7Y29uc3QgZT10LiRvcHRpb25zLG49ZS5zZXR1cDtpZihuKXtjb25zdCBvPXQuX3NldHVwQ29udGV4dD1UZSh0KTtsdCh0KSxfdCgpO2NvbnN0IHI9dm4obixudWxsLFt0Ll9wcm9wc3x8RHQoe30pLG9dLHQsXCJzZXR1cFwiKTtpZigkdCgpLGx0KCksaShyKSllLnJlbmRlcj1yO2Vsc2UgaWYoYyhyKSlpZih0Ll9zZXR1cFN0YXRlPXIsci5fX3NmYyl7Y29uc3QgZT10Ll9zZXR1cFByb3h5PXt9O2Zvcihjb25zdCB0IGluIHIpXCJfX3NmY1wiIT09dCYmVXQoZSxyLHQpfWVsc2UgZm9yKGNvbnN0IGUgaW4gcil6KGUpfHxVdCh0LHIsZSl9fSh0KSxuLm1ldGhvZHMmJmZ1bmN0aW9uKHQsZSl7dC4kb3B0aW9ucy5wcm9wcztmb3IoY29uc3QgbiBpbiBlKXRbbl09XCJmdW5jdGlvblwiIT10eXBlb2YgZVtuXT9FOk8oZVtuXSx0KX0odCxuLm1ldGhvZHMpLG4uZGF0YSkhZnVuY3Rpb24odCl7bGV0IGU9dC4kb3B0aW9ucy5kYXRhO2U9dC5fZGF0YT1pKGUpP2Z1bmN0aW9uKHQsZSl7X3QoKTt0cnl7cmV0dXJuIHQuY2FsbChlLGUpfWNhdGNoKHQpe3JldHVybiBnbih0LGUsXCJkYXRhKClcIikse319ZmluYWxseXskdCgpfX0oZSx0KTplfHx7fSxsKGUpfHwoZT17fSk7Y29uc3Qgbj1PYmplY3Qua2V5cyhlKSxvPXQuJG9wdGlvbnMucHJvcHM7dC4kb3B0aW9ucy5tZXRob2RzO2xldCByPW4ubGVuZ3RoO2Zvcig7ci0tOyl7Y29uc3QgZT1uW3JdO28mJiQobyxlKXx8eihlKXx8cW4odCxcIl9kYXRhXCIsZSl9Y29uc3Qgcz1BdChlKTtzJiZzLnZtQ291bnQrK30odCk7ZWxzZXtjb25zdCBlPUF0KHQuX2RhdGE9e30pO2UmJmUudm1Db3VudCsrfW4uY29tcHV0ZWQmJmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10Ll9jb21wdXRlZFdhdGNoZXJzPU9iamVjdC5jcmVhdGUobnVsbCksbz1vdCgpO2Zvcihjb25zdCByIGluIGUpe2NvbnN0IHM9ZVtyXSxjPWkocyk/czpzLmdldDtvfHwobltyXT1uZXcgS24odCxjfHxFLEUsWm4pKSxyIGluIHR8fEduKHQscixzKX19KHQsbi5jb21wdXRlZCksbi53YXRjaCYmbi53YXRjaCE9PXR0JiZmdW5jdGlvbih0LG4pe2Zvcihjb25zdCBvIGluIG4pe2NvbnN0IHI9bltvXTtpZihlKHIpKWZvcihsZXQgZT0wO2U8ci5sZW5ndGg7ZSsrKVFuKHQsbyxyW2VdKTtlbHNlIFFuKHQsbyxyKX19KHQsbi53YXRjaCl9Y29uc3QgWm49e2xhenk6ITB9O2Z1bmN0aW9uIEduKHQsZSxuKXtjb25zdCBvPSFvdCgpO2kobik/KEpuLmdldD1vP1huKGUpOlluKG4pLEpuLnNldD1FKTooSm4uZ2V0PW4uZ2V0P28mJiExIT09bi5jYWNoZT9YbihlKTpZbihuLmdldCk6RSxKbi5zZXQ9bi5zZXR8fEUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUsSm4pfWZ1bmN0aW9uIFhuKHQpe3JldHVybiBmdW5jdGlvbigpe2NvbnN0IGU9dGhpcy5fY29tcHV0ZWRXYXRjaGVycyYmdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1t0XTtpZihlKXJldHVybiBlLmRpcnR5JiZlLmV2YWx1YXRlKCksdnQudGFyZ2V0JiZlLmRlcGVuZCgpLGUudmFsdWV9fWZ1bmN0aW9uIFluKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmNhbGwodGhpcyx0aGlzKX19ZnVuY3Rpb24gUW4odCxlLG4sbyl7cmV0dXJuIGwobikmJihvPW4sbj1uLmhhbmRsZXIpLFwic3RyaW5nXCI9PXR5cGVvZiBuJiYobj10W25dKSx0LiR3YXRjaChlLG4sbyl9ZnVuY3Rpb24gdG8odCxlKXtpZih0KXtjb25zdCBuPU9iamVjdC5jcmVhdGUobnVsbCksbz1pdD9SZWZsZWN0Lm93bktleXModCk6T2JqZWN0LmtleXModCk7Zm9yKGxldCByPTA7cjxvLmxlbmd0aDtyKyspe2NvbnN0IHM9b1tyXTtpZihcIl9fb2JfX1wiPT09cyljb250aW51ZTtjb25zdCBjPXRbc10uZnJvbTtpZihjIGluIGUuX3Byb3ZpZGVkKW5bc109ZS5fcHJvdmlkZWRbY107ZWxzZSBpZihcImRlZmF1bHRcImluIHRbc10pe2NvbnN0IG89dFtzXS5kZWZhdWx0O25bc109aShvKT9vLmNhbGwoZSk6b319cmV0dXJuIG59fWxldCBlbz0wO2Z1bmN0aW9uIG5vKHQpe2xldCBlPXQub3B0aW9ucztpZih0LnN1cGVyKXtjb25zdCBuPW5vKHQuc3VwZXIpO2lmKG4hPT10LnN1cGVyT3B0aW9ucyl7dC5zdXBlck9wdGlvbnM9bjtjb25zdCBvPWZ1bmN0aW9uKHQpe2xldCBlO2NvbnN0IG49dC5vcHRpb25zLG89dC5zZWFsZWRPcHRpb25zO2Zvcihjb25zdCB0IGluIG4pblt0XSE9PW9bdF0mJihlfHwoZT17fSksZVt0XT1uW3RdKTtyZXR1cm4gZX0odCk7byYmQSh0LmV4dGVuZE9wdGlvbnMsbyksZT10Lm9wdGlvbnM9X28obix0LmV4dGVuZE9wdGlvbnMpLGUubmFtZSYmKGUuY29tcG9uZW50c1tlLm5hbWVdPXQpfX1yZXR1cm4gZX1mdW5jdGlvbiBvbyhuLG8scyxpLGMpe2NvbnN0IGE9Yy5vcHRpb25zO2xldCBsOyQoaSxcIl91aWRcIik/KGw9T2JqZWN0LmNyZWF0ZShpKSxsLl9vcmlnaW5hbD1pKToobD1pLGk9aS5fb3JpZ2luYWwpO2NvbnN0IHU9cihhLl9jb21waWxlZCksZj0hdTt0aGlzLmRhdGE9bix0aGlzLnByb3BzPW8sdGhpcy5jaGlsZHJlbj1zLHRoaXMucGFyZW50PWksdGhpcy5saXN0ZW5lcnM9bi5vbnx8dCx0aGlzLmluamVjdGlvbnM9dG8oYS5pbmplY3QsaSksdGhpcy5zbG90cz0oKT0+KHRoaXMuJHNsb3RzfHxrZShpLG4uc2NvcGVkU2xvdHMsdGhpcy4kc2xvdHM9d2UocyxpKSksdGhpcy4kc2xvdHMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwic2NvcGVkU2xvdHNcIix7ZW51bWVyYWJsZTohMCxnZXQoKXtyZXR1cm4ga2UoaSxuLnNjb3BlZFNsb3RzLHRoaXMuc2xvdHMoKSl9fSksdSYmKHRoaXMuJG9wdGlvbnM9YSx0aGlzLiRzbG90cz10aGlzLnNsb3RzKCksdGhpcy4kc2NvcGVkU2xvdHM9a2UoaSxuLnNjb3BlZFNsb3RzLHRoaXMuJHNsb3RzKSksYS5fc2NvcGVJZD90aGlzLl9jPSh0LG4sbyxyKT0+e2NvbnN0IHM9c2UobCx0LG4sbyxyLGYpO3JldHVybiBzJiYhZShzKSYmKHMuZm5TY29wZUlkPWEuX3Njb3BlSWQscy5mbkNvbnRleHQ9aSksc306dGhpcy5fYz0odCxlLG4sbyk9PnNlKGwsdCxlLG4sbyxmKX1mdW5jdGlvbiBybyh0LGUsbixvLHIpe2NvbnN0IHM9cHQodCk7cmV0dXJuIHMuZm5Db250ZXh0PW4scy5mbk9wdGlvbnM9byxlLnNsb3QmJigocy5kYXRhfHwocy5kYXRhPXt9KSkuc2xvdD1lLnNsb3QpLHN9ZnVuY3Rpb24gc28odCxlKXtmb3IoY29uc3QgbiBpbiBlKXRbeChuKV09ZVtuXX1mdW5jdGlvbiBpbyh0KXtyZXR1cm4gdC5uYW1lfHx0Ll9fbmFtZXx8dC5fY29tcG9uZW50VGFnfWJlKG9vLnByb3RvdHlwZSk7Y29uc3QgY289e2luaXQodCxlKXtpZih0LmNvbXBvbmVudEluc3RhbmNlJiYhdC5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQmJnQuZGF0YS5rZWVwQWxpdmUpe2NvbnN0IGU9dDtjby5wcmVwYXRjaChlLGUpfWVsc2V7KHQuY29tcG9uZW50SW5zdGFuY2U9ZnVuY3Rpb24odCxlKXtjb25zdCBuPXtfaXNDb21wb25lbnQ6ITAsX3BhcmVudFZub2RlOnQscGFyZW50OmV9LHI9dC5kYXRhLmlubGluZVRlbXBsYXRlO28ocikmJihuLnJlbmRlcj1yLnJlbmRlcixuLnN0YXRpY1JlbmRlckZucz1yLnN0YXRpY1JlbmRlckZucyk7cmV0dXJuIG5ldyB0LmNvbXBvbmVudE9wdGlvbnMuQ3RvcihuKX0odCxWZSkpLiRtb3VudChlP3QuZWxtOnZvaWQgMCxlKX19LHByZXBhdGNoKGUsbil7Y29uc3Qgbz1uLmNvbXBvbmVudE9wdGlvbnM7IWZ1bmN0aW9uKGUsbixvLHIscyl7Y29uc3QgaT1yLmRhdGEuc2NvcGVkU2xvdHMsYz1lLiRzY29wZWRTbG90cyxhPSEhKGkmJiFpLiRzdGFibGV8fGMhPT10JiYhYy4kc3RhYmxlfHxpJiZlLiRzY29wZWRTbG90cy4ka2V5IT09aS4ka2V5fHwhaSYmZS4kc2NvcGVkU2xvdHMuJGtleSk7bGV0IGw9ISEoc3x8ZS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW58fGEpO2NvbnN0IHU9ZS4kdm5vZGU7ZS4kb3B0aW9ucy5fcGFyZW50Vm5vZGU9cixlLiR2bm9kZT1yLGUuX3Zub2RlJiYoZS5fdm5vZGUucGFyZW50PXIpLGUuJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuPXM7Y29uc3QgZj1yLmRhdGEuYXR0cnN8fHQ7ZS5fYXR0cnNQcm94eSYmQWUoZS5fYXR0cnNQcm94eSxmLHUuZGF0YSYmdS5kYXRhLmF0dHJzfHx0LGUsXCIkYXR0cnNcIikmJihsPSEwKSxlLiRhdHRycz1mLG89b3x8dDtjb25zdCBkPWUuJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztpZihlLl9saXN0ZW5lcnNQcm94eSYmQWUoZS5fbGlzdGVuZXJzUHJveHksbyxkfHx0LGUsXCIkbGlzdGVuZXJzXCIpLGUuJGxpc3RlbmVycz1lLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM9byxCZShlLG8sZCksbiYmZS4kb3B0aW9ucy5wcm9wcyl7U3QoITEpO2NvbnN0IHQ9ZS5fcHJvcHMsbz1lLiRvcHRpb25zLl9wcm9wS2V5c3x8W107Zm9yKGxldCByPTA7cjxvLmxlbmd0aDtyKyspe2NvbnN0IHM9b1tyXSxpPWUuJG9wdGlvbnMucHJvcHM7dFtzXT1ibyhzLGksbixlKX1TdCghMCksZS4kb3B0aW9ucy5wcm9wc0RhdGE9bn1sJiYoZS4kc2xvdHM9d2UocyxyLmNvbnRleHQpLGUuJGZvcmNlVXBkYXRlKCkpfShuLmNvbXBvbmVudEluc3RhbmNlPWUuY29tcG9uZW50SW5zdGFuY2Usby5wcm9wc0RhdGEsby5saXN0ZW5lcnMsbixvLmNoaWxkcmVuKX0saW5zZXJ0KHQpe2NvbnN0e2NvbnRleHQ6ZSxjb21wb25lbnRJbnN0YW5jZTpufT10O3ZhciBvO24uX2lzTW91bnRlZHx8KG4uX2lzTW91bnRlZD0hMCxaZShuLFwibW91bnRlZFwiKSksdC5kYXRhLmtlZXBBbGl2ZSYmKGUuX2lzTW91bnRlZD8oKG89bikuX2luYWN0aXZlPSExLFhlLnB1c2gobykpOnFlKG4sITApKX0sZGVzdHJveSh0KXtjb25zdHtjb21wb25lbnRJbnN0YW5jZTplfT10O2UuX2lzRGVzdHJveWVkfHwodC5kYXRhLmtlZXBBbGl2ZT9XZShlLCEwKTplLiRkZXN0cm95KCkpfX0sYW89T2JqZWN0LmtleXMoY28pO2Z1bmN0aW9uIGxvKHMsaSxhLGwsdSl7aWYobihzKSlyZXR1cm47Y29uc3QgZD1hLiRvcHRpb25zLl9iYXNlO2lmKGMocykmJihzPWQuZXh0ZW5kKHMpKSxcImZ1bmN0aW9uXCIhPXR5cGVvZiBzKXJldHVybjtsZXQgcDtpZihuKHMuY2lkKSYmKHA9cyxzPWZ1bmN0aW9uKHQsZSl7aWYocih0LmVycm9yKSYmbyh0LmVycm9yQ29tcCkpcmV0dXJuIHQuZXJyb3JDb21wO2lmKG8odC5yZXNvbHZlZCkpcmV0dXJuIHQucmVzb2x2ZWQ7Y29uc3Qgcz1NZTtpZihzJiZvKHQub3duZXJzKSYmLTE9PT10Lm93bmVycy5pbmRleE9mKHMpJiZ0Lm93bmVycy5wdXNoKHMpLHIodC5sb2FkaW5nKSYmbyh0LmxvYWRpbmdDb21wKSlyZXR1cm4gdC5sb2FkaW5nQ29tcDtpZihzJiYhbyh0Lm93bmVycykpe2NvbnN0IHI9dC5vd25lcnM9W3NdO2xldCBpPSEwLGE9bnVsbCxsPW51bGw7cy4kb24oXCJob29rOmRlc3Ryb3llZFwiLCgoKT0+eShyLHMpKSk7Y29uc3QgdT10PT57Zm9yKGxldCB0PTAsZT1yLmxlbmd0aDt0PGU7dCsrKXJbdF0uJGZvcmNlVXBkYXRlKCk7dCYmKHIubGVuZ3RoPTAsbnVsbCE9PWEmJihjbGVhclRpbWVvdXQoYSksYT1udWxsKSxudWxsIT09bCYmKGNsZWFyVGltZW91dChsKSxsPW51bGwpKX0sZD1JKChuPT57dC5yZXNvbHZlZD1JZShuLGUpLGk/ci5sZW5ndGg9MDp1KCEwKX0pKSxwPUkoKGU9PntvKHQuZXJyb3JDb21wKSYmKHQuZXJyb3I9ITAsdSghMCkpfSkpLGg9dChkLHApO3JldHVybiBjKGgpJiYoZihoKT9uKHQucmVzb2x2ZWQpJiZoLnRoZW4oZCxwKTpmKGguY29tcG9uZW50KSYmKGguY29tcG9uZW50LnRoZW4oZCxwKSxvKGguZXJyb3IpJiYodC5lcnJvckNvbXA9SWUoaC5lcnJvcixlKSksbyhoLmxvYWRpbmcpJiYodC5sb2FkaW5nQ29tcD1JZShoLmxvYWRpbmcsZSksMD09PWguZGVsYXk/dC5sb2FkaW5nPSEwOmE9c2V0VGltZW91dCgoKCk9PnthPW51bGwsbih0LnJlc29sdmVkKSYmbih0LmVycm9yKSYmKHQubG9hZGluZz0hMCx1KCExKSl9KSxoLmRlbGF5fHwyMDApKSxvKGgudGltZW91dCkmJihsPXNldFRpbWVvdXQoKCgpPT57bD1udWxsLG4odC5yZXNvbHZlZCkmJnAobnVsbCl9KSxoLnRpbWVvdXQpKSkpLGk9ITEsdC5sb2FkaW5nP3QubG9hZGluZ0NvbXA6dC5yZXNvbHZlZH19KHAsZCksdm9pZCAwPT09cykpcmV0dXJuIGZ1bmN0aW9uKHQsZSxuLG8scil7Y29uc3Qgcz1mdCgpO3JldHVybiBzLmFzeW5jRmFjdG9yeT10LHMuYXN5bmNNZXRhPXtkYXRhOmUsY29udGV4dDpuLGNoaWxkcmVuOm8sdGFnOnJ9LHN9KHAsaSxhLGwsdSk7aT1pfHx7fSxubyhzKSxvKGkubW9kZWwpJiZmdW5jdGlvbih0LG4pe2NvbnN0IHI9dC5tb2RlbCYmdC5tb2RlbC5wcm9wfHxcInZhbHVlXCIscz10Lm1vZGVsJiZ0Lm1vZGVsLmV2ZW50fHxcImlucHV0XCI7KG4uYXR0cnN8fChuLmF0dHJzPXt9KSlbcl09bi5tb2RlbC52YWx1ZTtjb25zdCBpPW4ub258fChuLm9uPXt9KSxjPWlbc10sYT1uLm1vZGVsLmNhbGxiYWNrO28oYyk/KGUoYyk/LTE9PT1jLmluZGV4T2YoYSk6YyE9PWEpJiYoaVtzXT1bYV0uY29uY2F0KGMpKTppW3NdPWF9KHMub3B0aW9ucyxpKTtjb25zdCBoPWZ1bmN0aW9uKHQsZSxyKXtjb25zdCBzPWUub3B0aW9ucy5wcm9wcztpZihuKHMpKXJldHVybjtjb25zdCBpPXt9LHthdHRyczpjLHByb3BzOmF9PXQ7aWYobyhjKXx8byhhKSlmb3IoY29uc3QgdCBpbiBzKXtjb25zdCBlPVModCk7UXQoaSxhLHQsZSwhMCl8fFF0KGksYyx0LGUsITEpfXJldHVybiBpfShpLHMpO2lmKHIocy5vcHRpb25zLmZ1bmN0aW9uYWwpKXJldHVybiBmdW5jdGlvbihuLHIscyxpLGMpe2NvbnN0IGE9bi5vcHRpb25zLGw9e30sdT1hLnByb3BzO2lmKG8odSkpZm9yKGNvbnN0IGUgaW4gdSlsW2VdPWJvKGUsdSxyfHx0KTtlbHNlIG8ocy5hdHRycykmJnNvKGwscy5hdHRycyksbyhzLnByb3BzKSYmc28obCxzLnByb3BzKTtjb25zdCBmPW5ldyBvbyhzLGwsYyxpLG4pLGQ9YS5yZW5kZXIuY2FsbChudWxsLGYuX2MsZik7aWYoZCBpbnN0YW5jZW9mIHV0KXJldHVybiBybyhkLHMsZi5wYXJlbnQsYSk7aWYoZShkKSl7Y29uc3QgdD10ZShkKXx8W10sZT1uZXcgQXJyYXkodC5sZW5ndGgpO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKWVbbl09cm8odFtuXSxzLGYucGFyZW50LGEpO3JldHVybiBlfX0ocyxoLGksYSxsKTtjb25zdCBtPWkub247aWYoaS5vbj1pLm5hdGl2ZU9uLHIocy5vcHRpb25zLmFic3RyYWN0KSl7Y29uc3QgdD1pLnNsb3Q7aT17fSx0JiYoaS5zbG90PXQpfSFmdW5jdGlvbih0KXtjb25zdCBlPXQuaG9va3x8KHQuaG9vaz17fSk7Zm9yKGxldCB0PTA7dDxhby5sZW5ndGg7dCsrKXtjb25zdCBuPWFvW3RdLG89ZVtuXSxyPWNvW25dO289PT1yfHxvJiZvLl9tZXJnZWR8fChlW25dPW8/dW8ocixvKTpyKX19KGkpO2NvbnN0IGc9aW8ocy5vcHRpb25zKXx8dTtyZXR1cm4gbmV3IHV0KGB2dWUtY29tcG9uZW50LSR7cy5jaWR9JHtnP2AtJHtnfWA6XCJcIn1gLGksdm9pZCAwLHZvaWQgMCx2b2lkIDAsYSx7Q3RvcjpzLHByb3BzRGF0YTpoLGxpc3RlbmVyczptLHRhZzp1LGNoaWxkcmVuOmx9LHApfWZ1bmN0aW9uIHVvKHQsZSl7Y29uc3Qgbj0obixvKT0+e3QobixvKSxlKG4sbyl9O3JldHVybiBuLl9tZXJnZWQ9ITAsbn1sZXQgZm89RTtjb25zdCBwbz1CLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztmdW5jdGlvbiBobyh0LGUsbj0hMCl7aWYoIWUpcmV0dXJuIHQ7bGV0IG8scixzO2NvbnN0IGk9aXQ/UmVmbGVjdC5vd25LZXlzKGUpOk9iamVjdC5rZXlzKGUpO2ZvcihsZXQgYz0wO2M8aS5sZW5ndGg7YysrKW89aVtjXSxcIl9fb2JfX1wiIT09byYmKHI9dFtvXSxzPWVbb10sbiYmJCh0LG8pP3IhPT1zJiZsKHIpJiZsKHMpJiZobyhyLHMpOkV0KHQsbyxzKSk7cmV0dXJuIHR9ZnVuY3Rpb24gbW8odCxlLG4pe3JldHVybiBuP2Z1bmN0aW9uKCl7Y29uc3Qgbz1pKGUpP2UuY2FsbChuLG4pOmUscj1pKHQpP3QuY2FsbChuLG4pOnQ7cmV0dXJuIG8/aG8obyxyKTpyfTplP3Q/ZnVuY3Rpb24oKXtyZXR1cm4gaG8oaShlKT9lLmNhbGwodGhpcyx0aGlzKTplLGkodCk/dC5jYWxsKHRoaXMsdGhpcyk6dCl9OmU6dH1mdW5jdGlvbiBnbyh0LG4pe2NvbnN0IG89bj90P3QuY29uY2F0KG4pOmUobik/bjpbbl06dDtyZXR1cm4gbz9mdW5jdGlvbih0KXtjb25zdCBlPVtdO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKS0xPT09ZS5pbmRleE9mKHRbbl0pJiZlLnB1c2godFtuXSk7cmV0dXJuIGV9KG8pOm99ZnVuY3Rpb24gdm8odCxlLG4sbyl7Y29uc3Qgcj1PYmplY3QuY3JlYXRlKHR8fG51bGwpO3JldHVybiBlP0EocixlKTpyfXBvLmRhdGE9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBuP21vKHQsZSxuKTplJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP3Q6bW8odCxlKX0sSC5mb3JFYWNoKCh0PT57cG9bdF09Z299KSksRi5mb3JFYWNoKChmdW5jdGlvbih0KXtwb1t0K1wic1wiXT12b30pKSxwby53YXRjaD1mdW5jdGlvbih0LG4sbyxyKXtpZih0PT09dHQmJih0PXZvaWQgMCksbj09PXR0JiYobj12b2lkIDApLCFuKXJldHVybiBPYmplY3QuY3JlYXRlKHR8fG51bGwpO2lmKCF0KXJldHVybiBuO2NvbnN0IHM9e307QShzLHQpO2Zvcihjb25zdCB0IGluIG4pe2xldCBvPXNbdF07Y29uc3Qgcj1uW3RdO28mJiFlKG8pJiYobz1bb10pLHNbdF09bz9vLmNvbmNhdChyKTplKHIpP3I6W3JdfXJldHVybiBzfSxwby5wcm9wcz1wby5tZXRob2RzPXBvLmluamVjdD1wby5jb21wdXRlZD1mdW5jdGlvbih0LGUsbixvKXtpZighdClyZXR1cm4gZTtjb25zdCByPU9iamVjdC5jcmVhdGUobnVsbCk7cmV0dXJuIEEocix0KSxlJiZBKHIsZSkscn0scG8ucHJvdmlkZT1mdW5jdGlvbih0LGUpe3JldHVybiB0P2Z1bmN0aW9uKCl7Y29uc3Qgbj1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBobyhuLGkodCk/dC5jYWxsKHRoaXMpOnQpLGUmJmhvKG4saShlKT9lLmNhbGwodGhpcyk6ZSwhMSksbn06ZX07Y29uc3QgeW89ZnVuY3Rpb24odCxlKXtyZXR1cm4gdm9pZCAwPT09ZT90OmV9O2Z1bmN0aW9uIF9vKHQsbixvKXtpZihpKG4pJiYobj1uLm9wdGlvbnMpLGZ1bmN0aW9uKHQsbil7Y29uc3Qgbz10LnByb3BzO2lmKCFvKXJldHVybjtjb25zdCByPXt9O2xldCBzLGksYztpZihlKG8pKWZvcihzPW8ubGVuZ3RoO3MtLTspaT1vW3NdLFwic3RyaW5nXCI9PXR5cGVvZiBpJiYoYz14KGkpLHJbY109e3R5cGU6bnVsbH0pO2Vsc2UgaWYobChvKSlmb3IoY29uc3QgdCBpbiBvKWk9b1t0XSxjPXgodCkscltjXT1sKGkpP2k6e3R5cGU6aX07dC5wcm9wcz1yfShuKSxmdW5jdGlvbih0LG4pe2NvbnN0IG89dC5pbmplY3Q7aWYoIW8pcmV0dXJuO2NvbnN0IHI9dC5pbmplY3Q9e307aWYoZShvKSlmb3IobGV0IHQ9MDt0PG8ubGVuZ3RoO3QrKylyW29bdF1dPXtmcm9tOm9bdF19O2Vsc2UgaWYobChvKSlmb3IoY29uc3QgdCBpbiBvKXtjb25zdCBlPW9bdF07clt0XT1sKGUpP0Eoe2Zyb206dH0sZSk6e2Zyb206ZX19fShuKSxmdW5jdGlvbih0KXtjb25zdCBlPXQuZGlyZWN0aXZlcztpZihlKWZvcihjb25zdCB0IGluIGUpe2NvbnN0IG49ZVt0XTtpKG4pJiYoZVt0XT17YmluZDpuLHVwZGF0ZTpufSl9fShuKSwhbi5fYmFzZSYmKG4uZXh0ZW5kcyYmKHQ9X28odCxuLmV4dGVuZHMsbykpLG4ubWl4aW5zKSlmb3IobGV0IGU9MCxyPW4ubWl4aW5zLmxlbmd0aDtlPHI7ZSsrKXQ9X28odCxuLm1peGluc1tlXSxvKTtjb25zdCByPXt9O2xldCBzO2ZvcihzIGluIHQpYyhzKTtmb3IocyBpbiBuKSQodCxzKXx8YyhzKTtmdW5jdGlvbiBjKGUpe2NvbnN0IHM9cG9bZV18fHlvO3JbZV09cyh0W2VdLG5bZV0sbyxlKX1yZXR1cm4gcn1mdW5jdGlvbiAkbyh0LGUsbixvKXtpZihcInN0cmluZ1wiIT10eXBlb2YgbilyZXR1cm47Y29uc3Qgcj10W2VdO2lmKCQocixuKSlyZXR1cm4gcltuXTtjb25zdCBzPXgobik7aWYoJChyLHMpKXJldHVybiByW3NdO2NvbnN0IGk9QyhzKTtpZigkKHIsaSkpcmV0dXJuIHJbaV07cmV0dXJuIHJbbl18fHJbc118fHJbaV19ZnVuY3Rpb24gYm8odCxlLG4sbyl7Y29uc3Qgcj1lW3RdLHM9ISQobix0KTtsZXQgYz1uW3RdO2NvbnN0IGE9a28oQm9vbGVhbixyLnR5cGUpO2lmKGE+LTEpaWYocyYmISQocixcImRlZmF1bHRcIikpYz0hMTtlbHNlIGlmKFwiXCI9PT1jfHxjPT09Uyh0KSl7Y29uc3QgdD1rbyhTdHJpbmcsci50eXBlKTsodDwwfHxhPHQpJiYoYz0hMCl9aWYodm9pZCAwPT09Yyl7Yz1mdW5jdGlvbih0LGUsbil7aWYoISQoZSxcImRlZmF1bHRcIikpcmV0dXJuO2NvbnN0IG89ZS5kZWZhdWx0O2lmKHQmJnQuJG9wdGlvbnMucHJvcHNEYXRhJiZ2b2lkIDA9PT10LiRvcHRpb25zLnByb3BzRGF0YVtuXSYmdm9pZCAwIT09dC5fcHJvcHNbbl0pcmV0dXJuIHQuX3Byb3BzW25dO3JldHVybiBpKG8pJiZcIkZ1bmN0aW9uXCIhPT14byhlLnR5cGUpP28uY2FsbCh0KTpvfShvLHIsdCk7Y29uc3QgZT1rdDtTdCghMCksQXQoYyksU3QoZSl9cmV0dXJuIGN9Y29uc3Qgd289L15cXHMqZnVuY3Rpb24gKFxcdyspLztmdW5jdGlvbiB4byh0KXtjb25zdCBlPXQmJnQudG9TdHJpbmcoKS5tYXRjaCh3byk7cmV0dXJuIGU/ZVsxXTpcIlwifWZ1bmN0aW9uIENvKHQsZSl7cmV0dXJuIHhvKHQpPT09eG8oZSl9ZnVuY3Rpb24ga28odCxuKXtpZighZShuKSlyZXR1cm4gQ28obix0KT8wOi0xO2ZvcihsZXQgZT0wLG89bi5sZW5ndGg7ZTxvO2UrKylpZihDbyhuW2VdLHQpKXJldHVybiBlO3JldHVybi0xfWZ1bmN0aW9uIFNvKHQpe3RoaXMuX2luaXQodCl9ZnVuY3Rpb24gT28odCl7dC5jaWQ9MDtsZXQgZT0xO3QuZXh0ZW5kPWZ1bmN0aW9uKHQpe3Q9dHx8e307Y29uc3Qgbj10aGlzLG89bi5jaWQscj10Ll9DdG9yfHwodC5fQ3Rvcj17fSk7aWYocltvXSlyZXR1cm4gcltvXTtjb25zdCBzPWlvKHQpfHxpbyhuLm9wdGlvbnMpLGk9ZnVuY3Rpb24odCl7dGhpcy5faW5pdCh0KX07cmV0dXJuKGkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUobi5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1pLGkuY2lkPWUrKyxpLm9wdGlvbnM9X28obi5vcHRpb25zLHQpLGkuc3VwZXI9bixpLm9wdGlvbnMucHJvcHMmJmZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5vcHRpb25zLnByb3BzO2Zvcihjb25zdCBuIGluIGUpcW4odC5wcm90b3R5cGUsXCJfcHJvcHNcIixuKX0oaSksaS5vcHRpb25zLmNvbXB1dGVkJiZmdW5jdGlvbih0KXtjb25zdCBlPXQub3B0aW9ucy5jb21wdXRlZDtmb3IoY29uc3QgbiBpbiBlKUduKHQucHJvdG90eXBlLG4sZVtuXSl9KGkpLGkuZXh0ZW5kPW4uZXh0ZW5kLGkubWl4aW49bi5taXhpbixpLnVzZT1uLnVzZSxGLmZvckVhY2goKGZ1bmN0aW9uKHQpe2lbdF09blt0XX0pKSxzJiYoaS5vcHRpb25zLmNvbXBvbmVudHNbc109aSksaS5zdXBlck9wdGlvbnM9bi5vcHRpb25zLGkuZXh0ZW5kT3B0aW9ucz10LGkuc2VhbGVkT3B0aW9ucz1BKHt9LGkub3B0aW9ucykscltvXT1pLGl9fWZ1bmN0aW9uIFRvKHQpe3JldHVybiB0JiYoaW8odC5DdG9yLm9wdGlvbnMpfHx0LnRhZyl9ZnVuY3Rpb24gQW8odCxuKXtyZXR1cm4gZSh0KT90LmluZGV4T2Yobik+LTE6XCJzdHJpbmdcIj09dHlwZW9mIHQ/dC5zcGxpdChcIixcIikuaW5kZXhPZihuKT4tMToobz10LFwiW29iamVjdCBSZWdFeHBdXCI9PT1hLmNhbGwobykmJnQudGVzdChuKSk7dmFyIG99ZnVuY3Rpb24gam8odCxlKXtjb25zdHtjYWNoZTpuLGtleXM6byxfdm5vZGU6ciwkdm5vZGU6c309dDtmb3IoY29uc3QgdCBpbiBuKXtjb25zdCBzPW5bdF07aWYocyl7Y29uc3QgaT1zLm5hbWU7aSYmIWUoaSkmJkVvKG4sdCxvLHIpfX1zLmNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW49dm9pZCAwfWZ1bmN0aW9uIEVvKHQsZSxuLG8pe2NvbnN0IHI9dFtlXTshcnx8byYmci50YWc9PT1vLnRhZ3x8ci5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpLHRbZV09bnVsbCx5KG4sZSl9IWZ1bmN0aW9uKGUpe2UucHJvdG90eXBlLl9pbml0PWZ1bmN0aW9uKGUpe2NvbnN0IG49dGhpcztuLl91aWQ9ZW8rKyxuLl9pc1Z1ZT0hMCxuLl9fdl9za2lwPSEwLG4uX3Njb3BlPW5ldyBVZSghMCksbi5fc2NvcGUucGFyZW50PXZvaWQgMCxuLl9zY29wZS5fdm09ITAsZSYmZS5faXNDb21wb25lbnQ/ZnVuY3Rpb24odCxlKXtjb25zdCBuPXQuJG9wdGlvbnM9T2JqZWN0LmNyZWF0ZSh0LmNvbnN0cnVjdG9yLm9wdGlvbnMpLG89ZS5fcGFyZW50Vm5vZGU7bi5wYXJlbnQ9ZS5wYXJlbnQsbi5fcGFyZW50Vm5vZGU9bztjb25zdCByPW8uY29tcG9uZW50T3B0aW9ucztuLnByb3BzRGF0YT1yLnByb3BzRGF0YSxuLl9wYXJlbnRMaXN0ZW5lcnM9ci5saXN0ZW5lcnMsbi5fcmVuZGVyQ2hpbGRyZW49ci5jaGlsZHJlbixuLl9jb21wb25lbnRUYWc9ci50YWcsZS5yZW5kZXImJihuLnJlbmRlcj1lLnJlbmRlcixuLnN0YXRpY1JlbmRlckZucz1lLnN0YXRpY1JlbmRlckZucyl9KG4sZSk6bi4kb3B0aW9ucz1fbyhubyhuLmNvbnN0cnVjdG9yKSxlfHx7fSxuKSxuLl9yZW5kZXJQcm94eT1uLG4uX3NlbGY9bixmdW5jdGlvbih0KXtjb25zdCBlPXQuJG9wdGlvbnM7bGV0IG49ZS5wYXJlbnQ7aWYobiYmIWUuYWJzdHJhY3Qpe2Zvcig7bi4kb3B0aW9ucy5hYnN0cmFjdCYmbi4kcGFyZW50OyluPW4uJHBhcmVudDtuLiRjaGlsZHJlbi5wdXNoKHQpfXQuJHBhcmVudD1uLHQuJHJvb3Q9bj9uLiRyb290OnQsdC4kY2hpbGRyZW49W10sdC4kcmVmcz17fSx0Ll9wcm92aWRlZD1uP24uX3Byb3ZpZGVkOk9iamVjdC5jcmVhdGUobnVsbCksdC5fd2F0Y2hlcj1udWxsLHQuX2luYWN0aXZlPW51bGwsdC5fZGlyZWN0SW5hY3RpdmU9ITEsdC5faXNNb3VudGVkPSExLHQuX2lzRGVzdHJveWVkPSExLHQuX2lzQmVpbmdEZXN0cm95ZWQ9ITF9KG4pLGZ1bmN0aW9uKHQpe3QuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLHQuX2hhc0hvb2tFdmVudD0hMTtjb25zdCBlPXQuJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztlJiZCZSh0LGUpfShuKSxmdW5jdGlvbihlKXtlLl92bm9kZT1udWxsLGUuX3N0YXRpY1RyZWVzPW51bGw7Y29uc3Qgbj1lLiRvcHRpb25zLG89ZS4kdm5vZGU9bi5fcGFyZW50Vm5vZGUscj1vJiZvLmNvbnRleHQ7ZS4kc2xvdHM9d2Uobi5fcmVuZGVyQ2hpbGRyZW4sciksZS4kc2NvcGVkU2xvdHM9bz9rZShlLiRwYXJlbnQsby5kYXRhLnNjb3BlZFNsb3RzLGUuJHNsb3RzKTp0LGUuX2M9KHQsbixvLHIpPT5zZShlLHQsbixvLHIsITEpLGUuJGNyZWF0ZUVsZW1lbnQ9KHQsbixvLHIpPT5zZShlLHQsbixvLHIsITApO2NvbnN0IHM9byYmby5kYXRhO2p0KGUsXCIkYXR0cnNcIixzJiZzLmF0dHJzfHx0LG51bGwsITApLGp0KGUsXCIkbGlzdGVuZXJzXCIsbi5fcGFyZW50TGlzdGVuZXJzfHx0LG51bGwsITApfShuKSxaZShuLFwiYmVmb3JlQ3JlYXRlXCIsdm9pZCAwLCExKSxmdW5jdGlvbih0KXtjb25zdCBlPXRvKHQuJG9wdGlvbnMuaW5qZWN0LHQpO2UmJihTdCghMSksT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgobj0+e2p0KHQsbixlW25dKX0pKSxTdCghMCkpfShuKSxXbihuKSxmdW5jdGlvbih0KXtjb25zdCBlPXQuJG9wdGlvbnMucHJvdmlkZTtpZihlKXtjb25zdCBuPWkoZSk/ZS5jYWxsKHQpOmU7aWYoIWMobikpcmV0dXJuO2NvbnN0IG89bW4odCkscj1pdD9SZWZsZWN0Lm93bktleXMobik6T2JqZWN0LmtleXMobik7Zm9yKGxldCB0PTA7dDxyLmxlbmd0aDt0Kyspe2NvbnN0IGU9clt0XTtPYmplY3QuZGVmaW5lUHJvcGVydHkobyxlLE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobixlKSl9fX0obiksWmUobixcImNyZWF0ZWRcIiksbi4kb3B0aW9ucy5lbCYmbi4kbW91bnQobi4kb3B0aW9ucy5lbCl9fShTbyksZnVuY3Rpb24odCl7Y29uc3QgZT17Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2RhdGF9fSxuPXtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvcHN9fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodC5wcm90b3R5cGUsXCIkZGF0YVwiLGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LnByb3RvdHlwZSxcIiRwcm9wc1wiLG4pLHQucHJvdG90eXBlLiRzZXQ9RXQsdC5wcm90b3R5cGUuJGRlbGV0ZT1OdCx0LnByb3RvdHlwZS4kd2F0Y2g9ZnVuY3Rpb24odCxlLG4pe2NvbnN0IG89dGhpcztpZihsKGUpKXJldHVybiBRbihvLHQsZSxuKTsobj1ufHx7fSkudXNlcj0hMDtjb25zdCByPW5ldyBLbihvLHQsZSxuKTtpZihuLmltbWVkaWF0ZSl7Y29uc3QgdD1gY2FsbGJhY2sgZm9yIGltbWVkaWF0ZSB3YXRjaGVyIFwiJHtyLmV4cHJlc3Npb259XCJgO190KCksdm4oZSxvLFtyLnZhbHVlXSxvLHQpLCR0KCl9cmV0dXJuIGZ1bmN0aW9uKCl7ci50ZWFyZG93bigpfX19KFNvKSxmdW5jdGlvbih0KXtjb25zdCBuPS9eaG9vazovO3QucHJvdG90eXBlLiRvbj1mdW5jdGlvbih0LG8pe2NvbnN0IHI9dGhpcztpZihlKHQpKWZvcihsZXQgZT0wLG49dC5sZW5ndGg7ZTxuO2UrKylyLiRvbih0W2VdLG8pO2Vsc2Uoci5fZXZlbnRzW3RdfHwoci5fZXZlbnRzW3RdPVtdKSkucHVzaChvKSxuLnRlc3QodCkmJihyLl9oYXNIb29rRXZlbnQ9ITApO3JldHVybiByfSx0LnByb3RvdHlwZS4kb25jZT1mdW5jdGlvbih0LGUpe2NvbnN0IG49dGhpcztmdW5jdGlvbiBvKCl7bi4kb2ZmKHQsbyksZS5hcHBseShuLGFyZ3VtZW50cyl9cmV0dXJuIG8uZm49ZSxuLiRvbih0LG8pLG59LHQucHJvdG90eXBlLiRvZmY9ZnVuY3Rpb24odCxuKXtjb25zdCBvPXRoaXM7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG8uX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLG87aWYoZSh0KSl7Zm9yKGxldCBlPTAscj10Lmxlbmd0aDtlPHI7ZSsrKW8uJG9mZih0W2VdLG4pO3JldHVybiBvfWNvbnN0IHI9by5fZXZlbnRzW3RdO2lmKCFyKXJldHVybiBvO2lmKCFuKXJldHVybiBvLl9ldmVudHNbdF09bnVsbCxvO2xldCBzLGk9ci5sZW5ndGg7Zm9yKDtpLS07KWlmKHM9cltpXSxzPT09bnx8cy5mbj09PW4pe3Iuc3BsaWNlKGksMSk7YnJlYWt9cmV0dXJuIG99LHQucHJvdG90eXBlLiRlbWl0PWZ1bmN0aW9uKHQpe2NvbnN0IGU9dGhpcztsZXQgbj1lLl9ldmVudHNbdF07aWYobil7bj1uLmxlbmd0aD4xP1Qobik6bjtjb25zdCBvPVQoYXJndW1lbnRzLDEpLHI9YGV2ZW50IGhhbmRsZXIgZm9yIFwiJHt0fVwiYDtmb3IobGV0IHQ9MCxzPW4ubGVuZ3RoO3Q8czt0Kyspdm4oblt0XSxlLG8sZSxyKX1yZXR1cm4gZX19KFNvKSxmdW5jdGlvbih0KXt0LnByb3RvdHlwZS5fdXBkYXRlPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10aGlzLG89bi4kZWwscj1uLl92bm9kZSxzPUtlKG4pO24uX3Zub2RlPXQsbi4kZWw9cj9uLl9fcGF0Y2hfXyhyLHQpOm4uX19wYXRjaF9fKG4uJGVsLHQsZSwhMSkscygpLG8mJihvLl9fdnVlX189bnVsbCksbi4kZWwmJihuLiRlbC5fX3Z1ZV9fPW4pO2xldCBpPW47Zm9yKDtpJiZpLiR2bm9kZSYmaS4kcGFyZW50JiZpLiR2bm9kZT09PWkuJHBhcmVudC5fdm5vZGU7KWkuJHBhcmVudC4kZWw9aS4kZWwsaT1pLiRwYXJlbnR9LHQucHJvdG90eXBlLiRmb3JjZVVwZGF0ZT1mdW5jdGlvbigpe2NvbnN0IHQ9dGhpczt0Ll93YXRjaGVyJiZ0Ll93YXRjaGVyLnVwZGF0ZSgpfSx0LnByb3RvdHlwZS4kZGVzdHJveT1mdW5jdGlvbigpe2NvbnN0IHQ9dGhpcztpZih0Ll9pc0JlaW5nRGVzdHJveWVkKXJldHVybjtaZSh0LFwiYmVmb3JlRGVzdHJveVwiKSx0Ll9pc0JlaW5nRGVzdHJveWVkPSEwO2NvbnN0IGU9dC4kcGFyZW50OyFlfHxlLl9pc0JlaW5nRGVzdHJveWVkfHx0LiRvcHRpb25zLmFic3RyYWN0fHx5KGUuJGNoaWxkcmVuLHQpLHQuX3Njb3BlLnN0b3AoKSx0Ll9kYXRhLl9fb2JfXyYmdC5fZGF0YS5fX29iX18udm1Db3VudC0tLHQuX2lzRGVzdHJveWVkPSEwLHQuX19wYXRjaF9fKHQuX3Zub2RlLG51bGwpLFplKHQsXCJkZXN0cm95ZWRcIiksdC4kb2ZmKCksdC4kZWwmJih0LiRlbC5fX3Z1ZV9fPW51bGwpLHQuJHZub2RlJiYodC4kdm5vZGUucGFyZW50PW51bGwpfX0oU28pLGZ1bmN0aW9uKHQpe2JlKHQucHJvdG90eXBlKSx0LnByb3RvdHlwZS4kbmV4dFRpY2s9ZnVuY3Rpb24odCl7cmV0dXJuIGtuKHQsdGhpcyl9LHQucHJvdG90eXBlLl9yZW5kZXI9ZnVuY3Rpb24oKXtjb25zdCB0PXRoaXMse3JlbmRlcjpuLF9wYXJlbnRWbm9kZTpvfT10LiRvcHRpb25zO28mJnQuX2lzTW91bnRlZCYmKHQuJHNjb3BlZFNsb3RzPWtlKHQuJHBhcmVudCxvLmRhdGEuc2NvcGVkU2xvdHMsdC4kc2xvdHMsdC4kc2NvcGVkU2xvdHMpLHQuX3Nsb3RzUHJveHkmJkVlKHQuX3Nsb3RzUHJveHksdC4kc2NvcGVkU2xvdHMpKSx0LiR2bm9kZT1vO2NvbnN0IHI9YXQscz1NZTtsZXQgaTt0cnl7bHQodCksTWU9dCxpPW4uY2FsbCh0Ll9yZW5kZXJQcm94eSx0LiRjcmVhdGVFbGVtZW50KX1jYXRjaChlKXtnbihlLHQsXCJyZW5kZXJcIiksaT10Ll92bm9kZX1maW5hbGx5e01lPXMsbHQocil9cmV0dXJuIGUoaSkmJjE9PT1pLmxlbmd0aCYmKGk9aVswXSksaSBpbnN0YW5jZW9mIHV0fHwoaT1mdCgpKSxpLnBhcmVudD1vLGl9fShTbyk7Y29uc3QgTm89W1N0cmluZyxSZWdFeHAsQXJyYXldO3ZhciBQbz17S2VlcEFsaXZlOntuYW1lOlwia2VlcC1hbGl2ZVwiLGFic3RyYWN0OiEwLHByb3BzOntpbmNsdWRlOk5vLGV4Y2x1ZGU6Tm8sbWF4OltTdHJpbmcsTnVtYmVyXX0sbWV0aG9kczp7Y2FjaGVWTm9kZSgpe2NvbnN0e2NhY2hlOnQsa2V5czplLHZub2RlVG9DYWNoZTpuLGtleVRvQ2FjaGU6b309dGhpcztpZihuKXtjb25zdHt0YWc6cixjb21wb25lbnRJbnN0YW5jZTpzLGNvbXBvbmVudE9wdGlvbnM6aX09bjt0W29dPXtuYW1lOlRvKGkpLHRhZzpyLGNvbXBvbmVudEluc3RhbmNlOnN9LGUucHVzaChvKSx0aGlzLm1heCYmZS5sZW5ndGg+cGFyc2VJbnQodGhpcy5tYXgpJiZFbyh0LGVbMF0sZSx0aGlzLl92bm9kZSksdGhpcy52bm9kZVRvQ2FjaGU9bnVsbH19fSxjcmVhdGVkKCl7dGhpcy5jYWNoZT1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMua2V5cz1bXX0sZGVzdHJveWVkKCl7Zm9yKGNvbnN0IHQgaW4gdGhpcy5jYWNoZSlFbyh0aGlzLmNhY2hlLHQsdGhpcy5rZXlzKX0sbW91bnRlZCgpe3RoaXMuY2FjaGVWTm9kZSgpLHRoaXMuJHdhdGNoKFwiaW5jbHVkZVwiLCh0PT57am8odGhpcywoZT0+QW8odCxlKSkpfSkpLHRoaXMuJHdhdGNoKFwiZXhjbHVkZVwiLCh0PT57am8odGhpcywoZT0+IUFvKHQsZSkpKX0pKX0sdXBkYXRlZCgpe3RoaXMuY2FjaGVWTm9kZSgpfSxyZW5kZXIoKXtjb25zdCB0PXRoaXMuJHNsb3RzLmRlZmF1bHQsZT1MZSh0KSxuPWUmJmUuY29tcG9uZW50T3B0aW9ucztpZihuKXtjb25zdCB0PVRvKG4pLHtpbmNsdWRlOm8sZXhjbHVkZTpyfT10aGlzO2lmKG8mJighdHx8IUFvKG8sdCkpfHxyJiZ0JiZBbyhyLHQpKXJldHVybiBlO2NvbnN0e2NhY2hlOnMsa2V5czppfT10aGlzLGM9bnVsbD09ZS5rZXk/bi5DdG9yLmNpZCsobi50YWc/YDo6JHtuLnRhZ31gOlwiXCIpOmUua2V5O3NbY10/KGUuY29tcG9uZW50SW5zdGFuY2U9c1tjXS5jb21wb25lbnRJbnN0YW5jZSx5KGksYyksaS5wdXNoKGMpKToodGhpcy52bm9kZVRvQ2FjaGU9ZSx0aGlzLmtleVRvQ2FjaGU9YyksZS5kYXRhLmtlZXBBbGl2ZT0hMH1yZXR1cm4gZXx8dCYmdFswXX19fTshZnVuY3Rpb24odCl7Y29uc3QgZT17Z2V0OigpPT5CfTtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcImNvbmZpZ1wiLGUpLHQudXRpbD17d2FybjpmbyxleHRlbmQ6QSxtZXJnZU9wdGlvbnM6X28sZGVmaW5lUmVhY3RpdmU6anR9LHQuc2V0PUV0LHQuZGVsZXRlPU50LHQubmV4dFRpY2s9a24sdC5vYnNlcnZhYmxlPXQ9PihBdCh0KSx0KSx0Lm9wdGlvbnM9T2JqZWN0LmNyZWF0ZShudWxsKSxGLmZvckVhY2goKGU9Pnt0Lm9wdGlvbnNbZStcInNcIl09T2JqZWN0LmNyZWF0ZShudWxsKX0pKSx0Lm9wdGlvbnMuX2Jhc2U9dCxBKHQub3B0aW9ucy5jb21wb25lbnRzLFBvKSxmdW5jdGlvbih0KXt0LnVzZT1mdW5jdGlvbih0KXtjb25zdCBlPXRoaXMuX2luc3RhbGxlZFBsdWdpbnN8fCh0aGlzLl9pbnN0YWxsZWRQbHVnaW5zPVtdKTtpZihlLmluZGV4T2YodCk+LTEpcmV0dXJuIHRoaXM7Y29uc3Qgbj1UKGFyZ3VtZW50cywxKTtyZXR1cm4gbi51bnNoaWZ0KHRoaXMpLGkodC5pbnN0YWxsKT90Lmluc3RhbGwuYXBwbHkodCxuKTppKHQpJiZ0LmFwcGx5KG51bGwsbiksZS5wdXNoKHQpLHRoaXN9fSh0KSxmdW5jdGlvbih0KXt0Lm1peGluPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm9wdGlvbnM9X28odGhpcy5vcHRpb25zLHQpLHRoaXN9fSh0KSxPbyh0KSxmdW5jdGlvbih0KXtGLmZvckVhY2goKGU9Pnt0W2VdPWZ1bmN0aW9uKHQsbil7cmV0dXJuIG4/KFwiY29tcG9uZW50XCI9PT1lJiZsKG4pJiYobi5uYW1lPW4ubmFtZXx8dCxuPXRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQobikpLFwiZGlyZWN0aXZlXCI9PT1lJiZpKG4pJiYobj17YmluZDpuLHVwZGF0ZTpufSksdGhpcy5vcHRpb25zW2UrXCJzXCJdW3RdPW4sbik6dGhpcy5vcHRpb25zW2UrXCJzXCJdW3RdfX0pKX0odCl9KFNvKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoU28ucHJvdG90eXBlLFwiJGlzU2VydmVyXCIse2dldDpvdH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTby5wcm90b3R5cGUsXCIkc3NyQ29udGV4dFwiLHtnZXQoKXtyZXR1cm4gdGhpcy4kdm5vZGUmJnRoaXMuJHZub2RlLnNzckNvbnRleHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFNvLFwiRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcIix7dmFsdWU6b299KSxTby52ZXJzaW9uPUZuO2NvbnN0IERvPW0oXCJzdHlsZSxjbGFzc1wiKSxNbz1tKFwiaW5wdXQsdGV4dGFyZWEsb3B0aW9uLHNlbGVjdCxwcm9ncmVzc1wiKSxJbz0odCxlLG4pPT5cInZhbHVlXCI9PT1uJiZNbyh0KSYmXCJidXR0b25cIiE9PWV8fFwic2VsZWN0ZWRcIj09PW4mJlwib3B0aW9uXCI9PT10fHxcImNoZWNrZWRcIj09PW4mJlwiaW5wdXRcIj09PXR8fFwibXV0ZWRcIj09PW4mJlwidmlkZW9cIj09PXQsTG89bShcImNvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVja1wiKSxSbz1tKFwiZXZlbnRzLGNhcmV0LHR5cGluZyxwbGFpbnRleHQtb25seVwiKSxGbz0odCxlKT0+Vm8oZSl8fFwiZmFsc2VcIj09PWU/XCJmYWxzZVwiOlwiY29udGVudGVkaXRhYmxlXCI9PT10JiZSbyhlKT9lOlwidHJ1ZVwiLEhvPW0oXCJhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLGRlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCxlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLG11dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHkscmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRydWVzcGVlZCx0eXBlbXVzdG1hdGNoLHZpc2libGVcIiksQm89XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsVW89dD0+XCI6XCI9PT10LmNoYXJBdCg1KSYmXCJ4bGlua1wiPT09dC5zbGljZSgwLDUpLHpvPXQ9PlVvKHQpP3Quc2xpY2UoNix0Lmxlbmd0aCk6XCJcIixWbz10PT5udWxsPT10fHwhMT09PXQ7ZnVuY3Rpb24gS28odCl7bGV0IGU9dC5kYXRhLG49dCxyPXQ7Zm9yKDtvKHIuY29tcG9uZW50SW5zdGFuY2UpOylyPXIuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLHImJnIuZGF0YSYmKGU9Sm8oci5kYXRhLGUpKTtmb3IoO28obj1uLnBhcmVudCk7KW4mJm4uZGF0YSYmKGU9Sm8oZSxuLmRhdGEpKTtyZXR1cm4gZnVuY3Rpb24odCxlKXtpZihvKHQpfHxvKGUpKXJldHVybiBxbyh0LFdvKGUpKTtyZXR1cm5cIlwifShlLnN0YXRpY0NsYXNzLGUuY2xhc3MpfWZ1bmN0aW9uIEpvKHQsZSl7cmV0dXJue3N0YXRpY0NsYXNzOnFvKHQuc3RhdGljQ2xhc3MsZS5zdGF0aWNDbGFzcyksY2xhc3M6byh0LmNsYXNzKT9bdC5jbGFzcyxlLmNsYXNzXTplLmNsYXNzfX1mdW5jdGlvbiBxbyh0LGUpe3JldHVybiB0P2U/dCtcIiBcIitlOnQ6ZXx8XCJcIn1mdW5jdGlvbiBXbyh0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT9mdW5jdGlvbih0KXtsZXQgZSxuPVwiXCI7Zm9yKGxldCByPTAscz10Lmxlbmd0aDtyPHM7cisrKW8oZT1Xbyh0W3JdKSkmJlwiXCIhPT1lJiYobiYmKG4rPVwiIFwiKSxuKz1lKTtyZXR1cm4gbn0odCk6Yyh0KT9mdW5jdGlvbih0KXtsZXQgZT1cIlwiO2Zvcihjb25zdCBuIGluIHQpdFtuXSYmKGUmJihlKz1cIiBcIiksZSs9bik7cmV0dXJuIGV9KHQpOlwic3RyaW5nXCI9PXR5cGVvZiB0P3Q6XCJcIn1jb25zdCBabz17c3ZnOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixtYXRoOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwifSxHbz1tKFwiaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLGRpdixkZCxkbCxkdCxmaWdjYXB0aW9uLGZpZ3VyZSxwaWN0dXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLGEsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSxzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbyxlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucyxjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0cixidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLG91dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LGNvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3RcIiksWG89bShcInN2ZyxhbmltYXRlLGNpcmNsZSxjbGlwcGF0aCxjdXJzb3IsZGVmcyxkZXNjLGVsbGlwc2UsZmlsdGVyLGZvbnQtZmFjZSxmb3JlaWdub2JqZWN0LGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybixwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3XCIsITApLFlvPXQ9PkdvKHQpfHxYbyh0KTtmdW5jdGlvbiBRbyh0KXtyZXR1cm4gWG8odCk/XCJzdmdcIjpcIm1hdGhcIj09PXQ/XCJtYXRoXCI6dm9pZCAwfWNvbnN0IHRyPU9iamVjdC5jcmVhdGUobnVsbCk7Y29uc3QgZXI9bShcInRleHQsbnVtYmVyLHBhc3N3b3JkLHNlYXJjaCxlbWFpbCx0ZWwsdXJsXCIpO2Z1bmN0aW9uIG5yKHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXtjb25zdCBlPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCk7cmV0dXJuIGV8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIil9cmV0dXJuIHR9dmFyIG9yPU9iamVjdC5mcmVlemUoe19fcHJvdG9fXzpudWxsLGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24odCxlKXtjb25zdCBuPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7cmV0dXJuXCJzZWxlY3RcIiE9PXR8fGUuZGF0YSYmZS5kYXRhLmF0dHJzJiZ2b2lkIDAhPT1lLmRhdGEuYXR0cnMubXVsdGlwbGUmJm4uc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIixcIm11bHRpcGxlXCIpLG59LGNyZWF0ZUVsZW1lbnROUzpmdW5jdGlvbih0LGUpe3JldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoWm9bdF0sZSl9LGNyZWF0ZVRleHROb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0KX0sY3JlYXRlQ29tbWVudDpmdW5jdGlvbih0KXtyZXR1cm4gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCh0KX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKHQsZSxuKXt0Lmluc2VydEJlZm9yZShlLG4pfSxyZW1vdmVDaGlsZDpmdW5jdGlvbih0LGUpe3QucmVtb3ZlQ2hpbGQoZSl9LGFwcGVuZENoaWxkOmZ1bmN0aW9uKHQsZSl7dC5hcHBlbmRDaGlsZChlKX0scGFyZW50Tm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5wYXJlbnROb2RlfSxuZXh0U2libGluZzpmdW5jdGlvbih0KXtyZXR1cm4gdC5uZXh0U2libGluZ30sdGFnTmFtZTpmdW5jdGlvbih0KXtyZXR1cm4gdC50YWdOYW1lfSxzZXRUZXh0Q29udGVudDpmdW5jdGlvbih0LGUpe3QudGV4dENvbnRlbnQ9ZX0sc2V0U3R5bGVTY29wZTpmdW5jdGlvbih0LGUpe3Quc2V0QXR0cmlidXRlKGUsXCJcIil9fSkscnI9e2NyZWF0ZSh0LGUpe3NyKGUpfSx1cGRhdGUodCxlKXt0LmRhdGEucmVmIT09ZS5kYXRhLnJlZiYmKHNyKHQsITApLHNyKGUpKX0sZGVzdHJveSh0KXtzcih0LCEwKX19O2Z1bmN0aW9uIHNyKHQsbil7Y29uc3Qgcj10LmRhdGEucmVmO2lmKCFvKHIpKXJldHVybjtjb25zdCBzPXQuY29udGV4dCxjPXQuY29tcG9uZW50SW5zdGFuY2V8fHQuZWxtLGE9bj9udWxsOmMsbD1uP3ZvaWQgMDpjO2lmKGkocikpcmV0dXJuIHZvaWQgdm4ocixzLFthXSxzLFwidGVtcGxhdGUgcmVmIGZ1bmN0aW9uXCIpO2NvbnN0IHU9dC5kYXRhLnJlZkluRm9yLGY9XCJzdHJpbmdcIj09dHlwZW9mIHJ8fFwibnVtYmVyXCI9PXR5cGVvZiByLGQ9SHQocikscD1zLiRyZWZzO2lmKGZ8fGQpaWYodSl7Y29uc3QgdD1mP3Bbcl06ci52YWx1ZTtuP2UodCkmJnkodCxjKTplKHQpP3QuaW5jbHVkZXMoYyl8fHQucHVzaChjKTpmPyhwW3JdPVtjXSxpcihzLHIscFtyXSkpOnIudmFsdWU9W2NdfWVsc2UgaWYoZil7aWYobiYmcFtyXSE9PWMpcmV0dXJuO3Bbcl09bCxpcihzLHIsYSl9ZWxzZSBpZihkKXtpZihuJiZyLnZhbHVlIT09YylyZXR1cm47ci52YWx1ZT1hfX1mdW5jdGlvbiBpcih7X3NldHVwU3RhdGU6dH0sZSxuKXt0JiYkKHQsZSkmJihIdCh0W2VdKT90W2VdLnZhbHVlPW46dFtlXT1uKX1jb25zdCBjcj1uZXcgdXQoXCJcIix7fSxbXSksYXI9W1wiY3JlYXRlXCIsXCJhY3RpdmF0ZVwiLFwidXBkYXRlXCIsXCJyZW1vdmVcIixcImRlc3Ryb3lcIl07ZnVuY3Rpb24gbHIodCxlKXtyZXR1cm4gdC5rZXk9PT1lLmtleSYmdC5hc3luY0ZhY3Rvcnk9PT1lLmFzeW5jRmFjdG9yeSYmKHQudGFnPT09ZS50YWcmJnQuaXNDb21tZW50PT09ZS5pc0NvbW1lbnQmJm8odC5kYXRhKT09PW8oZS5kYXRhKSYmZnVuY3Rpb24odCxlKXtpZihcImlucHV0XCIhPT10LnRhZylyZXR1cm4hMDtsZXQgbjtjb25zdCByPW8obj10LmRhdGEpJiZvKG49bi5hdHRycykmJm4udHlwZSxzPW8obj1lLmRhdGEpJiZvKG49bi5hdHRycykmJm4udHlwZTtyZXR1cm4gcj09PXN8fGVyKHIpJiZlcihzKX0odCxlKXx8cih0LmlzQXN5bmNQbGFjZWhvbGRlcikmJm4oZS5hc3luY0ZhY3RvcnkuZXJyb3IpKX1mdW5jdGlvbiB1cih0LGUsbil7bGV0IHIscztjb25zdCBpPXt9O2ZvcihyPWU7cjw9bjsrK3Ipcz10W3JdLmtleSxvKHMpJiYoaVtzXT1yKTtyZXR1cm4gaX12YXIgZnI9e2NyZWF0ZTpkcix1cGRhdGU6ZHIsZGVzdHJveTpmdW5jdGlvbih0KXtkcih0LGNyKX19O2Z1bmN0aW9uIGRyKHQsZSl7KHQuZGF0YS5kaXJlY3RpdmVzfHxlLmRhdGEuZGlyZWN0aXZlcykmJmZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10PT09Y3Isbz1lPT09Y3Iscj1ocih0LmRhdGEuZGlyZWN0aXZlcyx0LmNvbnRleHQpLHM9aHIoZS5kYXRhLmRpcmVjdGl2ZXMsZS5jb250ZXh0KSxpPVtdLGM9W107bGV0IGEsbCx1O2ZvcihhIGluIHMpbD1yW2FdLHU9c1thXSxsPyh1Lm9sZFZhbHVlPWwudmFsdWUsdS5vbGRBcmc9bC5hcmcsZ3IodSxcInVwZGF0ZVwiLGUsdCksdS5kZWYmJnUuZGVmLmNvbXBvbmVudFVwZGF0ZWQmJmMucHVzaCh1KSk6KGdyKHUsXCJiaW5kXCIsZSx0KSx1LmRlZiYmdS5kZWYuaW5zZXJ0ZWQmJmkucHVzaCh1KSk7aWYoaS5sZW5ndGgpe2NvbnN0IG89KCk9Pntmb3IobGV0IG49MDtuPGkubGVuZ3RoO24rKylncihpW25dLFwiaW5zZXJ0ZWRcIixlLHQpfTtuP1l0KGUsXCJpbnNlcnRcIixvKTpvKCl9Yy5sZW5ndGgmJll0KGUsXCJwb3N0cGF0Y2hcIiwoKCk9Pntmb3IobGV0IG49MDtuPGMubGVuZ3RoO24rKylncihjW25dLFwiY29tcG9uZW50VXBkYXRlZFwiLGUsdCl9KSk7aWYoIW4pZm9yKGEgaW4gcilzW2FdfHxncihyW2FdLFwidW5iaW5kXCIsdCx0LG8pfSh0LGUpfWNvbnN0IHByPU9iamVjdC5jcmVhdGUobnVsbCk7ZnVuY3Rpb24gaHIodCxlKXtjb25zdCBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoIXQpcmV0dXJuIG47bGV0IG8scjtmb3Iobz0wO288dC5sZW5ndGg7bysrKXtpZihyPXRbb10sci5tb2RpZmllcnN8fChyLm1vZGlmaWVycz1wciksblttcihyKV09cixlLl9zZXR1cFN0YXRlJiZlLl9zZXR1cFN0YXRlLl9fc2ZjKXtjb25zdCB0PXIuZGVmfHwkbyhlLFwiX3NldHVwU3RhdGVcIixcInYtXCIrci5uYW1lKTtyLmRlZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3tiaW5kOnQsdXBkYXRlOnR9OnR9ci5kZWY9ci5kZWZ8fCRvKGUuJG9wdGlvbnMsXCJkaXJlY3RpdmVzXCIsci5uYW1lKX1yZXR1cm4gbn1mdW5jdGlvbiBtcih0KXtyZXR1cm4gdC5yYXdOYW1lfHxgJHt0Lm5hbWV9LiR7T2JqZWN0LmtleXModC5tb2RpZmllcnN8fHt9KS5qb2luKFwiLlwiKX1gfWZ1bmN0aW9uIGdyKHQsZSxuLG8scil7Y29uc3Qgcz10LmRlZiYmdC5kZWZbZV07aWYocyl0cnl7cyhuLmVsbSx0LG4sbyxyKX1jYXRjaChvKXtnbihvLG4uY29udGV4dCxgZGlyZWN0aXZlICR7dC5uYW1lfSAke2V9IGhvb2tgKX19dmFyIHZyPVtycixmcl07ZnVuY3Rpb24geXIodCxlKXtjb25zdCBzPWUuY29tcG9uZW50T3B0aW9ucztpZihvKHMpJiYhMT09PXMuQ3Rvci5vcHRpb25zLmluaGVyaXRBdHRycylyZXR1cm47aWYobih0LmRhdGEuYXR0cnMpJiZuKGUuZGF0YS5hdHRycykpcmV0dXJuO2xldCBpLGMsYTtjb25zdCBsPWUuZWxtLHU9dC5kYXRhLmF0dHJzfHx7fTtsZXQgZj1lLmRhdGEuYXR0cnN8fHt9O2ZvcihpIGluKG8oZi5fX29iX18pfHxyKGYuX3ZfYXR0cl9wcm94eSkpJiYoZj1lLmRhdGEuYXR0cnM9QSh7fSxmKSksZiljPWZbaV0sYT11W2ldLGEhPT1jJiZfcihsLGksYyxlLmRhdGEucHJlKTtmb3IoaSBpbihafHxYKSYmZi52YWx1ZSE9PXUudmFsdWUmJl9yKGwsXCJ2YWx1ZVwiLGYudmFsdWUpLHUpbihmW2ldKSYmKFVvKGkpP2wucmVtb3ZlQXR0cmlidXRlTlMoQm8sem8oaSkpOkxvKGkpfHxsLnJlbW92ZUF0dHJpYnV0ZShpKSl9ZnVuY3Rpb24gX3IodCxlLG4sbyl7b3x8dC50YWdOYW1lLmluZGV4T2YoXCItXCIpPi0xPyRyKHQsZSxuKTpIbyhlKT9WbyhuKT90LnJlbW92ZUF0dHJpYnV0ZShlKToobj1cImFsbG93ZnVsbHNjcmVlblwiPT09ZSYmXCJFTUJFRFwiPT09dC50YWdOYW1lP1widHJ1ZVwiOmUsdC5zZXRBdHRyaWJ1dGUoZSxuKSk6TG8oZSk/dC5zZXRBdHRyaWJ1dGUoZSxGbyhlLG4pKTpVbyhlKT9WbyhuKT90LnJlbW92ZUF0dHJpYnV0ZU5TKEJvLHpvKGUpKTp0LnNldEF0dHJpYnV0ZU5TKEJvLGUsbik6JHIodCxlLG4pfWZ1bmN0aW9uICRyKHQsZSxuKXtpZihWbyhuKSl0LnJlbW92ZUF0dHJpYnV0ZShlKTtlbHNle2lmKFomJiFHJiZcIlRFWFRBUkVBXCI9PT10LnRhZ05hbWUmJlwicGxhY2Vob2xkZXJcIj09PWUmJlwiXCIhPT1uJiYhdC5fX2llcGgpe2NvbnN0IGU9bj0+e24uc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiaW5wdXRcIixlKX07dC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIixlKSx0Ll9faWVwaD0hMH10LnNldEF0dHJpYnV0ZShlLG4pfX12YXIgYnI9e2NyZWF0ZTp5cix1cGRhdGU6eXJ9O2Z1bmN0aW9uIHdyKHQsZSl7Y29uc3Qgcj1lLmVsbSxzPWUuZGF0YSxpPXQuZGF0YTtpZihuKHMuc3RhdGljQ2xhc3MpJiZuKHMuY2xhc3MpJiYobihpKXx8bihpLnN0YXRpY0NsYXNzKSYmbihpLmNsYXNzKSkpcmV0dXJuO2xldCBjPUtvKGUpO2NvbnN0IGE9ci5fdHJhbnNpdGlvbkNsYXNzZXM7byhhKSYmKGM9cW8oYyxXbyhhKSkpLGMhPT1yLl9wcmV2Q2xhc3MmJihyLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYyksci5fcHJldkNsYXNzPWMpfXZhciB4cj17Y3JlYXRlOndyLHVwZGF0ZTp3cn07Y29uc3QgQ3I9L1tcXHcpLitcXC1fJFxcXV0vO2Z1bmN0aW9uIGtyKHQpe2xldCBlLG4sbyxyLHMsaT0hMSxjPSExLGE9ITEsbD0hMSx1PTAsZj0wLGQ9MCxwPTA7Zm9yKG89MDtvPHQubGVuZ3RoO28rKylpZihuPWUsZT10LmNoYXJDb2RlQXQobyksaSkzOT09PWUmJjkyIT09biYmKGk9ITEpO2Vsc2UgaWYoYykzND09PWUmJjkyIT09biYmKGM9ITEpO2Vsc2UgaWYoYSk5Nj09PWUmJjkyIT09biYmKGE9ITEpO2Vsc2UgaWYobCk0Nz09PWUmJjkyIT09biYmKGw9ITEpO2Vsc2UgaWYoMTI0IT09ZXx8MTI0PT09dC5jaGFyQ29kZUF0KG8rMSl8fDEyND09PXQuY2hhckNvZGVBdChvLTEpfHx1fHxmfHxkKXtzd2l0Y2goZSl7Y2FzZSAzNDpjPSEwO2JyZWFrO2Nhc2UgMzk6aT0hMDticmVhaztjYXNlIDk2OmE9ITA7YnJlYWs7Y2FzZSA0MDpkKys7YnJlYWs7Y2FzZSA0MTpkLS07YnJlYWs7Y2FzZSA5MTpmKys7YnJlYWs7Y2FzZSA5MzpmLS07YnJlYWs7Y2FzZSAxMjM6dSsrO2JyZWFrO2Nhc2UgMTI1OnUtLX1pZig0Nz09PWUpe2xldCBlLG49by0xO2Zvcig7bj49MCYmKGU9dC5jaGFyQXQobiksXCIgXCI9PT1lKTtuLS0pO2UmJkNyLnRlc3QoZSl8fChsPSEwKX19ZWxzZSB2b2lkIDA9PT1yPyhwPW8rMSxyPXQuc2xpY2UoMCxvKS50cmltKCkpOmgoKTtmdW5jdGlvbiBoKCl7KHN8fChzPVtdKSkucHVzaCh0LnNsaWNlKHAsbykudHJpbSgpKSxwPW8rMX1pZih2b2lkIDA9PT1yP3I9dC5zbGljZSgwLG8pLnRyaW0oKTowIT09cCYmaCgpLHMpZm9yKG89MDtvPHMubGVuZ3RoO28rKylyPVNyKHIsc1tvXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gU3IodCxlKXtjb25zdCBuPWUuaW5kZXhPZihcIihcIik7aWYobjwwKXJldHVybmBfZihcIiR7ZX1cIikoJHt0fSlgO3tjb25zdCBvPWUuc2xpY2UoMCxuKSxyPWUuc2xpY2UobisxKTtyZXR1cm5gX2YoXCIke299XCIpKCR7dH0ke1wiKVwiIT09cj9cIixcIityOnJ9YH19ZnVuY3Rpb24gT3IodCxlKXtjb25zb2xlLmVycm9yKGBbVnVlIGNvbXBpbGVyXTogJHt0fWApfWZ1bmN0aW9uIFRyKHQsZSl7cmV0dXJuIHQ/dC5tYXAoKHQ9PnRbZV0pKS5maWx0ZXIoKHQ9PnQpKTpbXX1mdW5jdGlvbiBBcih0LGUsbixvLHIpeyh0LnByb3BzfHwodC5wcm9wcz1bXSkpLnB1c2goUnIoe25hbWU6ZSx2YWx1ZTpuLGR5bmFtaWM6cn0sbykpLHQucGxhaW49ITF9ZnVuY3Rpb24ganIodCxlLG4sbyxyKXsocj90LmR5bmFtaWNBdHRyc3x8KHQuZHluYW1pY0F0dHJzPVtdKTp0LmF0dHJzfHwodC5hdHRycz1bXSkpLnB1c2goUnIoe25hbWU6ZSx2YWx1ZTpuLGR5bmFtaWM6cn0sbykpLHQucGxhaW49ITF9ZnVuY3Rpb24gRXIodCxlLG4sbyl7dC5hdHRyc01hcFtlXT1uLHQuYXR0cnNMaXN0LnB1c2goUnIoe25hbWU6ZSx2YWx1ZTpufSxvKSl9ZnVuY3Rpb24gTnIodCxlLG4sbyxyLHMsaSxjKXsodC5kaXJlY3RpdmVzfHwodC5kaXJlY3RpdmVzPVtdKSkucHVzaChScih7bmFtZTplLHJhd05hbWU6bix2YWx1ZTpvLGFyZzpyLGlzRHluYW1pY0FyZzpzLG1vZGlmaWVyczppfSxjKSksdC5wbGFpbj0hMX1mdW5jdGlvbiBQcih0LGUsbil7cmV0dXJuIG4/YF9wKCR7ZX0sXCIke3R9XCIpYDp0K2V9ZnVuY3Rpb24gRHIoZSxuLG8scixzLGksYyxhKXtsZXQgbDsocj1yfHx0KS5yaWdodD9hP249YCgke259KT09PSdjbGljayc/J2NvbnRleHRtZW51JzooJHtufSlgOlwiY2xpY2tcIj09PW4mJihuPVwiY29udGV4dG1lbnVcIixkZWxldGUgci5yaWdodCk6ci5taWRkbGUmJihhP249YCgke259KT09PSdjbGljayc/J21vdXNldXAnOigke259KWA6XCJjbGlja1wiPT09biYmKG49XCJtb3VzZXVwXCIpKSxyLmNhcHR1cmUmJihkZWxldGUgci5jYXB0dXJlLG49UHIoXCIhXCIsbixhKSksci5vbmNlJiYoZGVsZXRlIHIub25jZSxuPVByKFwiflwiLG4sYSkpLHIucGFzc2l2ZSYmKGRlbGV0ZSByLnBhc3NpdmUsbj1QcihcIiZcIixuLGEpKSxyLm5hdGl2ZT8oZGVsZXRlIHIubmF0aXZlLGw9ZS5uYXRpdmVFdmVudHN8fChlLm5hdGl2ZUV2ZW50cz17fSkpOmw9ZS5ldmVudHN8fChlLmV2ZW50cz17fSk7Y29uc3QgdT1Scih7dmFsdWU6by50cmltKCksZHluYW1pYzphfSxjKTtyIT09dCYmKHUubW9kaWZpZXJzPXIpO2NvbnN0IGY9bFtuXTtBcnJheS5pc0FycmF5KGYpP3M/Zi51bnNoaWZ0KHUpOmYucHVzaCh1KTpsW25dPWY/cz9bdSxmXTpbZix1XTp1LGUucGxhaW49ITF9ZnVuY3Rpb24gTXIodCxlLG4pe2NvbnN0IG89SXIodCxcIjpcIitlKXx8SXIodCxcInYtYmluZDpcIitlKTtpZihudWxsIT1vKXJldHVybiBrcihvKTtpZighMSE9PW4pe2NvbnN0IG49SXIodCxlKTtpZihudWxsIT1uKXJldHVybiBKU09OLnN0cmluZ2lmeShuKX19ZnVuY3Rpb24gSXIodCxlLG4pe2xldCBvO2lmKG51bGwhPShvPXQuYXR0cnNNYXBbZV0pKXtjb25zdCBuPXQuYXR0cnNMaXN0O2ZvcihsZXQgdD0wLG89bi5sZW5ndGg7dDxvO3QrKylpZihuW3RdLm5hbWU9PT1lKXtuLnNwbGljZSh0LDEpO2JyZWFrfX1yZXR1cm4gbiYmZGVsZXRlIHQuYXR0cnNNYXBbZV0sb31mdW5jdGlvbiBMcih0LGUpe2NvbnN0IG49dC5hdHRyc0xpc3Q7Zm9yKGxldCB0PTAsbz1uLmxlbmd0aDt0PG87dCsrKXtjb25zdCBvPW5bdF07aWYoZS50ZXN0KG8ubmFtZSkpcmV0dXJuIG4uc3BsaWNlKHQsMSksb319ZnVuY3Rpb24gUnIodCxlKXtyZXR1cm4gZSYmKG51bGwhPWUuc3RhcnQmJih0LnN0YXJ0PWUuc3RhcnQpLG51bGwhPWUuZW5kJiYodC5lbmQ9ZS5lbmQpKSx0fWZ1bmN0aW9uIEZyKHQsZSxuKXtjb25zdHtudW1iZXI6byx0cmltOnJ9PW58fHt9LHM9XCIkJHZcIjtsZXQgaT1zO3ImJihpPWAodHlwZW9mICR7c30gPT09ICdzdHJpbmcnPyAke3N9LnRyaW0oKTogJHtzfSlgKSxvJiYoaT1gX24oJHtpfSlgKTtjb25zdCBjPUhyKGUsaSk7dC5tb2RlbD17dmFsdWU6YCgke2V9KWAsZXhwcmVzc2lvbjpKU09OLnN0cmluZ2lmeShlKSxjYWxsYmFjazpgZnVuY3Rpb24gKCR7c30pIHske2N9fWB9fWZ1bmN0aW9uIEhyKHQsZSl7Y29uc3Qgbj1mdW5jdGlvbih0KXtpZih0PXQudHJpbSgpLEJyPXQubGVuZ3RoLHQuaW5kZXhPZihcIltcIik8MHx8dC5sYXN0SW5kZXhPZihcIl1cIik8QnItMSlyZXR1cm4gVnI9dC5sYXN0SW5kZXhPZihcIi5cIiksVnI+LTE/e2V4cDp0LnNsaWNlKDAsVnIpLGtleTonXCInK3Quc2xpY2UoVnIrMSkrJ1wiJ306e2V4cDp0LGtleTpudWxsfTtVcj10LFZyPUtyPUpyPTA7Zm9yKDshV3IoKTspenI9cXIoKSxacih6cik/WHIoenIpOjkxPT09enImJkdyKHpyKTtyZXR1cm57ZXhwOnQuc2xpY2UoMCxLciksa2V5OnQuc2xpY2UoS3IrMSxKcil9fSh0KTtyZXR1cm4gbnVsbD09PW4ua2V5P2Ake3R9PSR7ZX1gOmAkc2V0KCR7bi5leHB9LCAke24ua2V5fSwgJHtlfSlgfWxldCBCcixVcix6cixWcixLcixKcjtmdW5jdGlvbiBxcigpe3JldHVybiBVci5jaGFyQ29kZUF0KCsrVnIpfWZ1bmN0aW9uIFdyKCl7cmV0dXJuIFZyPj1Ccn1mdW5jdGlvbiBacih0KXtyZXR1cm4gMzQ9PT10fHwzOT09PXR9ZnVuY3Rpb24gR3IodCl7bGV0IGU9MTtmb3IoS3I9VnI7IVdyKCk7KWlmKFpyKHQ9cXIoKSkpWHIodCk7ZWxzZSBpZig5MT09PXQmJmUrKyw5Mz09PXQmJmUtLSwwPT09ZSl7SnI9VnI7YnJlYWt9fWZ1bmN0aW9uIFhyKHQpe2NvbnN0IGU9dDtmb3IoOyFXcigpJiYodD1xcigpKSE9PWU7KTt9Y29uc3QgWXI9XCJfX3JcIixRcj1cIl9fY1wiO2xldCB0cztmdW5jdGlvbiBlcyh0LGUsbil7Y29uc3Qgbz10cztyZXR1cm4gZnVuY3Rpb24gcigpe251bGwhPT1lLmFwcGx5KG51bGwsYXJndW1lbnRzKSYmcnModCxyLG4sbyl9fWNvbnN0IG5zPSRuJiYhKFEmJk51bWJlcihRWzFdKTw9NTMpO2Z1bmN0aW9uIG9zKHQsZSxuLG8pe2lmKG5zKXtjb25zdCB0PW5uLG49ZTtlPW4uX3dyYXBwZXI9ZnVuY3Rpb24oZSl7aWYoZS50YXJnZXQ9PT1lLmN1cnJlbnRUYXJnZXR8fGUudGltZVN0YW1wPj10fHxlLnRpbWVTdGFtcDw9MHx8ZS50YXJnZXQub3duZXJEb2N1bWVudCE9PWRvY3VtZW50KXJldHVybiBuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dHMuYWRkRXZlbnRMaXN0ZW5lcih0LGUsbnQ/e2NhcHR1cmU6bixwYXNzaXZlOm99Om4pfWZ1bmN0aW9uIHJzKHQsZSxuLG8peyhvfHx0cykucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LGUuX3dyYXBwZXJ8fGUsbil9ZnVuY3Rpb24gc3ModCxlKXtpZihuKHQuZGF0YS5vbikmJm4oZS5kYXRhLm9uKSlyZXR1cm47Y29uc3Qgcj1lLmRhdGEub258fHt9LHM9dC5kYXRhLm9ufHx7fTt0cz1lLmVsbXx8dC5lbG0sZnVuY3Rpb24odCl7aWYobyh0W1lyXSkpe2NvbnN0IGU9Wj9cImNoYW5nZVwiOlwiaW5wdXRcIjt0W2VdPVtdLmNvbmNhdCh0W1lyXSx0W2VdfHxbXSksZGVsZXRlIHRbWXJdfW8odFtRcl0pJiYodC5jaGFuZ2U9W10uY29uY2F0KHRbUXJdLHQuY2hhbmdlfHxbXSksZGVsZXRlIHRbUXJdKX0ociksWHQocixzLG9zLHJzLGVzLGUuY29udGV4dCksdHM9dm9pZCAwfXZhciBpcz17Y3JlYXRlOnNzLHVwZGF0ZTpzcyxkZXN0cm95OnQ9PnNzKHQsY3IpfTtsZXQgY3M7ZnVuY3Rpb24gYXModCxlKXtpZihuKHQuZGF0YS5kb21Qcm9wcykmJm4oZS5kYXRhLmRvbVByb3BzKSlyZXR1cm47bGV0IHMsaTtjb25zdCBjPWUuZWxtLGE9dC5kYXRhLmRvbVByb3BzfHx7fTtsZXQgbD1lLmRhdGEuZG9tUHJvcHN8fHt9O2ZvcihzIGluKG8obC5fX29iX18pfHxyKGwuX3ZfYXR0cl9wcm94eSkpJiYobD1lLmRhdGEuZG9tUHJvcHM9QSh7fSxsKSksYSlzIGluIGx8fChjW3NdPVwiXCIpO2ZvcihzIGluIGwpe2lmKGk9bFtzXSxcInRleHRDb250ZW50XCI9PT1zfHxcImlubmVySFRNTFwiPT09cyl7aWYoZS5jaGlsZHJlbiYmKGUuY2hpbGRyZW4ubGVuZ3RoPTApLGk9PT1hW3NdKWNvbnRpbnVlOzE9PT1jLmNoaWxkTm9kZXMubGVuZ3RoJiZjLnJlbW92ZUNoaWxkKGMuY2hpbGROb2Rlc1swXSl9aWYoXCJ2YWx1ZVwiPT09cyYmXCJQUk9HUkVTU1wiIT09Yy50YWdOYW1lKXtjLl92YWx1ZT1pO2NvbnN0IHQ9bihpKT9cIlwiOlN0cmluZyhpKTtscyhjLHQpJiYoYy52YWx1ZT10KX1lbHNlIGlmKFwiaW5uZXJIVE1MXCI9PT1zJiZYbyhjLnRhZ05hbWUpJiZuKGMuaW5uZXJIVE1MKSl7Y3M9Y3N8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksY3MuaW5uZXJIVE1MPWA8c3ZnPiR7aX08L3N2Zz5gO2NvbnN0IHQ9Y3MuZmlyc3RDaGlsZDtmb3IoO2MuZmlyc3RDaGlsZDspYy5yZW1vdmVDaGlsZChjLmZpcnN0Q2hpbGQpO2Zvcig7dC5maXJzdENoaWxkOyljLmFwcGVuZENoaWxkKHQuZmlyc3RDaGlsZCl9ZWxzZSBpZihpIT09YVtzXSl0cnl7Y1tzXT1pfWNhdGNoKHQpe319fWZ1bmN0aW9uIGxzKHQsZSl7cmV0dXJuIXQuY29tcG9zaW5nJiYoXCJPUFRJT05cIj09PXQudGFnTmFtZXx8ZnVuY3Rpb24odCxlKXtsZXQgbj0hMDt0cnl7bj1kb2N1bWVudC5hY3RpdmVFbGVtZW50IT09dH1jYXRjaCh0KXt9cmV0dXJuIG4mJnQudmFsdWUhPT1lfSh0LGUpfHxmdW5jdGlvbih0LGUpe2NvbnN0IG49dC52YWx1ZSxyPXQuX3ZNb2RpZmllcnM7aWYobyhyKSl7aWYoci5udW1iZXIpcmV0dXJuIGgobikhPT1oKGUpO2lmKHIudHJpbSlyZXR1cm4gbi50cmltKCkhPT1lLnRyaW0oKX1yZXR1cm4gbiE9PWV9KHQsZSkpfXZhciB1cz17Y3JlYXRlOmFzLHVwZGF0ZTphc307Y29uc3QgZnM9YigoZnVuY3Rpb24odCl7Y29uc3QgZT17fSxuPS86KC4rKS87cmV0dXJuIHQuc3BsaXQoLzsoPyFbXihdKlxcKSkvZykuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYodCl7Y29uc3Qgbz10LnNwbGl0KG4pO28ubGVuZ3RoPjEmJihlW29bMF0udHJpbSgpXT1vWzFdLnRyaW0oKSl9fSkpLGV9KSk7ZnVuY3Rpb24gZHModCl7Y29uc3QgZT1wcyh0LnN0eWxlKTtyZXR1cm4gdC5zdGF0aWNTdHlsZT9BKHQuc3RhdGljU3R5bGUsZSk6ZX1mdW5jdGlvbiBwcyh0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT9qKHQpOlwic3RyaW5nXCI9PXR5cGVvZiB0P2ZzKHQpOnR9Y29uc3QgaHM9L14tLS8sbXM9L1xccyohaW1wb3J0YW50JC8sZ3M9KHQsZSxuKT0+e2lmKGhzLnRlc3QoZSkpdC5zdHlsZS5zZXRQcm9wZXJ0eShlLG4pO2Vsc2UgaWYobXMudGVzdChuKSl0LnN0eWxlLnNldFByb3BlcnR5KFMoZSksbi5yZXBsYWNlKG1zLFwiXCIpLFwiaW1wb3J0YW50XCIpO2Vsc2V7Y29uc3Qgbz1fcyhlKTtpZihBcnJheS5pc0FycmF5KG4pKWZvcihsZXQgZT0wLHI9bi5sZW5ndGg7ZTxyO2UrKyl0LnN0eWxlW29dPW5bZV07ZWxzZSB0LnN0eWxlW29dPW59fSx2cz1bXCJXZWJraXRcIixcIk1velwiLFwibXNcIl07bGV0IHlzO2NvbnN0IF9zPWIoKGZ1bmN0aW9uKHQpe2lmKHlzPXlzfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFwiZmlsdGVyXCIhPT0odD14KHQpKSYmdCBpbiB5cylyZXR1cm4gdDtjb25zdCBlPXQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrdC5zbGljZSgxKTtmb3IobGV0IHQ9MDt0PHZzLmxlbmd0aDt0Kyspe2NvbnN0IG49dnNbdF0rZTtpZihuIGluIHlzKXJldHVybiBufX0pKTtmdW5jdGlvbiAkcyh0LGUpe2NvbnN0IHI9ZS5kYXRhLHM9dC5kYXRhO2lmKG4oci5zdGF0aWNTdHlsZSkmJm4oci5zdHlsZSkmJm4ocy5zdGF0aWNTdHlsZSkmJm4ocy5zdHlsZSkpcmV0dXJuO2xldCBpLGM7Y29uc3QgYT1lLmVsbSxsPXMuc3RhdGljU3R5bGUsdT1zLm5vcm1hbGl6ZWRTdHlsZXx8cy5zdHlsZXx8e30sZj1sfHx1LGQ9cHMoZS5kYXRhLnN0eWxlKXx8e307ZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZT1vKGQuX19vYl9fKT9BKHt9LGQpOmQ7Y29uc3QgcD1mdW5jdGlvbih0LGUpe2NvbnN0IG49e307bGV0IG87aWYoZSl7bGV0IGU9dDtmb3IoO2UuY29tcG9uZW50SW5zdGFuY2U7KWU9ZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUsZSYmZS5kYXRhJiYobz1kcyhlLmRhdGEpKSYmQShuLG8pfShvPWRzKHQuZGF0YSkpJiZBKG4sbyk7bGV0IHI9dDtmb3IoO3I9ci5wYXJlbnQ7KXIuZGF0YSYmKG89ZHMoci5kYXRhKSkmJkEobixvKTtyZXR1cm4gbn0oZSwhMCk7Zm9yKGMgaW4gZiluKHBbY10pJiZncyhhLGMsXCJcIik7Zm9yKGMgaW4gcClpPXBbY10sZ3MoYSxjLG51bGw9PWk/XCJcIjppKX12YXIgYnM9e2NyZWF0ZTokcyx1cGRhdGU6JHN9O2NvbnN0IHdzPS9cXHMrLztmdW5jdGlvbiB4cyh0LGUpe2lmKGUmJihlPWUudHJpbSgpKSlpZih0LmNsYXNzTGlzdCllLmluZGV4T2YoXCIgXCIpPi0xP2Uuc3BsaXQod3MpLmZvckVhY2goKGU9PnQuY2xhc3NMaXN0LmFkZChlKSkpOnQuY2xhc3NMaXN0LmFkZChlKTtlbHNle2NvbnN0IG49YCAke3QuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCJ9IGA7bi5pbmRleE9mKFwiIFwiK2UrXCIgXCIpPDAmJnQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwobitlKS50cmltKCkpfX1mdW5jdGlvbiBDcyh0LGUpe2lmKGUmJihlPWUudHJpbSgpKSlpZih0LmNsYXNzTGlzdCllLmluZGV4T2YoXCIgXCIpPi0xP2Uuc3BsaXQod3MpLmZvckVhY2goKGU9PnQuY2xhc3NMaXN0LnJlbW92ZShlKSkpOnQuY2xhc3NMaXN0LnJlbW92ZShlKSx0LmNsYXNzTGlzdC5sZW5ndGh8fHQucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7ZWxzZXtsZXQgbj1gICR7dC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIn0gYDtjb25zdCBvPVwiIFwiK2UrXCIgXCI7Zm9yKDtuLmluZGV4T2Yobyk+PTA7KW49bi5yZXBsYWNlKG8sXCIgXCIpO249bi50cmltKCksbj90LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsbik6dC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKX19ZnVuY3Rpb24ga3ModCl7aWYodCl7aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpe2NvbnN0IGU9e307cmV0dXJuITEhPT10LmNzcyYmQShlLFNzKHQubmFtZXx8XCJ2XCIpKSxBKGUsdCksZX1yZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD9Tcyh0KTp2b2lkIDB9fWNvbnN0IFNzPWIoKHQ9Pih7ZW50ZXJDbGFzczpgJHt0fS1lbnRlcmAsZW50ZXJUb0NsYXNzOmAke3R9LWVudGVyLXRvYCxlbnRlckFjdGl2ZUNsYXNzOmAke3R9LWVudGVyLWFjdGl2ZWAsbGVhdmVDbGFzczpgJHt0fS1sZWF2ZWAsbGVhdmVUb0NsYXNzOmAke3R9LWxlYXZlLXRvYCxsZWF2ZUFjdGl2ZUNsYXNzOmAke3R9LWxlYXZlLWFjdGl2ZWB9KSkpLE9zPXEmJiFHLFRzPVwidHJhbnNpdGlvblwiLEFzPVwiYW5pbWF0aW9uXCI7bGV0IGpzPVwidHJhbnNpdGlvblwiLEVzPVwidHJhbnNpdGlvbmVuZFwiLE5zPVwiYW5pbWF0aW9uXCIsUHM9XCJhbmltYXRpb25lbmRcIjtPcyYmKHZvaWQgMD09PXdpbmRvdy5vbnRyYW5zaXRpb25lbmQmJnZvaWQgMCE9PXdpbmRvdy5vbndlYmtpdHRyYW5zaXRpb25lbmQmJihqcz1cIldlYmtpdFRyYW5zaXRpb25cIixFcz1cIndlYmtpdFRyYW5zaXRpb25FbmRcIiksdm9pZCAwPT09d2luZG93Lm9uYW5pbWF0aW9uZW5kJiZ2b2lkIDAhPT13aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQmJihOcz1cIldlYmtpdEFuaW1hdGlvblwiLFBzPVwid2Via2l0QW5pbWF0aW9uRW5kXCIpKTtjb25zdCBEcz1xP3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU/d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyk6c2V0VGltZW91dDp0PT50KCk7ZnVuY3Rpb24gTXModCl7RHMoKCgpPT57RHModCl9KSl9ZnVuY3Rpb24gSXModCxlKXtjb25zdCBuPXQuX3RyYW5zaXRpb25DbGFzc2VzfHwodC5fdHJhbnNpdGlvbkNsYXNzZXM9W10pO24uaW5kZXhPZihlKTwwJiYobi5wdXNoKGUpLHhzKHQsZSkpfWZ1bmN0aW9uIExzKHQsZSl7dC5fdHJhbnNpdGlvbkNsYXNzZXMmJnkodC5fdHJhbnNpdGlvbkNsYXNzZXMsZSksQ3ModCxlKX1mdW5jdGlvbiBScyh0LGUsbil7Y29uc3R7dHlwZTpvLHRpbWVvdXQ6cixwcm9wQ291bnQ6c309SHModCxlKTtpZighbylyZXR1cm4gbigpO2NvbnN0IGk9bz09PVRzP0VzOlBzO2xldCBjPTA7Y29uc3QgYT0oKT0+e3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihpLGwpLG4oKX0sbD1lPT57ZS50YXJnZXQ9PT10JiYrK2M+PXMmJmEoKX07c2V0VGltZW91dCgoKCk9PntjPHMmJmEoKX0pLHIrMSksdC5hZGRFdmVudExpc3RlbmVyKGksbCl9Y29uc3QgRnM9L1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLztmdW5jdGlvbiBIcyh0LGUpe2NvbnN0IG49d2luZG93LmdldENvbXB1dGVkU3R5bGUodCksbz0obltqcytcIkRlbGF5XCJdfHxcIlwiKS5zcGxpdChcIiwgXCIpLHI9KG5banMrXCJEdXJhdGlvblwiXXx8XCJcIikuc3BsaXQoXCIsIFwiKSxzPUJzKG8sciksaT0obltOcytcIkRlbGF5XCJdfHxcIlwiKS5zcGxpdChcIiwgXCIpLGM9KG5bTnMrXCJEdXJhdGlvblwiXXx8XCJcIikuc3BsaXQoXCIsIFwiKSxhPUJzKGksYyk7bGV0IGwsdT0wLGY9MDtlPT09VHM/cz4wJiYobD1Ucyx1PXMsZj1yLmxlbmd0aCk6ZT09PUFzP2E+MCYmKGw9QXMsdT1hLGY9Yy5sZW5ndGgpOih1PU1hdGgubWF4KHMsYSksbD11PjA/cz5hP1RzOkFzOm51bGwsZj1sP2w9PT1Ucz9yLmxlbmd0aDpjLmxlbmd0aDowKTtyZXR1cm57dHlwZTpsLHRpbWVvdXQ6dSxwcm9wQ291bnQ6ZixoYXNUcmFuc2Zvcm06bD09PVRzJiZGcy50ZXN0KG5banMrXCJQcm9wZXJ0eVwiXSl9fWZ1bmN0aW9uIEJzKHQsZSl7Zm9yKDt0Lmxlbmd0aDxlLmxlbmd0aDspdD10LmNvbmNhdCh0KTtyZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCxlLm1hcCgoKGUsbik9PlVzKGUpK1VzKHRbbl0pKSkpfWZ1bmN0aW9uIFVzKHQpe3JldHVybiAxZTMqTnVtYmVyKHQuc2xpY2UoMCwtMSkucmVwbGFjZShcIixcIixcIi5cIikpfWZ1bmN0aW9uIHpzKHQsZSl7Y29uc3Qgcj10LmVsbTtvKHIuX2xlYXZlQ2IpJiYoci5fbGVhdmVDYi5jYW5jZWxsZWQ9ITAsci5fbGVhdmVDYigpKTtjb25zdCBzPWtzKHQuZGF0YS50cmFuc2l0aW9uKTtpZihuKHMpKXJldHVybjtpZihvKHIuX2VudGVyQ2IpfHwxIT09ci5ub2RlVHlwZSlyZXR1cm47Y29uc3R7Y3NzOmEsdHlwZTpsLGVudGVyQ2xhc3M6dSxlbnRlclRvQ2xhc3M6ZixlbnRlckFjdGl2ZUNsYXNzOmQsYXBwZWFyQ2xhc3M6cCxhcHBlYXJUb0NsYXNzOm0sYXBwZWFyQWN0aXZlQ2xhc3M6ZyxiZWZvcmVFbnRlcjp2LGVudGVyOnksYWZ0ZXJFbnRlcjpfLGVudGVyQ2FuY2VsbGVkOiQsYmVmb3JlQXBwZWFyOmIsYXBwZWFyOncsYWZ0ZXJBcHBlYXI6eCxhcHBlYXJDYW5jZWxsZWQ6QyxkdXJhdGlvbjprfT1zO2xldCBTPVZlLE89VmUuJHZub2RlO2Zvcig7TyYmTy5wYXJlbnQ7KVM9Ty5jb250ZXh0LE89Ty5wYXJlbnQ7Y29uc3QgVD0hUy5faXNNb3VudGVkfHwhdC5pc1Jvb3RJbnNlcnQ7aWYoVCYmIXcmJlwiXCIhPT13KXJldHVybjtjb25zdCBBPVQmJnA/cDp1LGo9VCYmZz9nOmQsRT1UJiZtP206ZixOPVQmJmJ8fHYsUD1UJiZpKHcpP3c6eSxEPVQmJnh8fF8sTT1UJiZDfHwkLEw9aChjKGspP2suZW50ZXI6ayksUj0hMSE9PWEmJiFHLEY9SnMoUCksSD1yLl9lbnRlckNiPUkoKCgpPT57UiYmKExzKHIsRSksTHMocixqKSksSC5jYW5jZWxsZWQ/KFImJkxzKHIsQSksTSYmTShyKSk6RCYmRChyKSxyLl9lbnRlckNiPW51bGx9KSk7dC5kYXRhLnNob3d8fFl0KHQsXCJpbnNlcnRcIiwoKCk9Pntjb25zdCBlPXIucGFyZW50Tm9kZSxuPWUmJmUuX3BlbmRpbmcmJmUuX3BlbmRpbmdbdC5rZXldO24mJm4udGFnPT09dC50YWcmJm4uZWxtLl9sZWF2ZUNiJiZuLmVsbS5fbGVhdmVDYigpLFAmJlAocixIKX0pKSxOJiZOKHIpLFImJihJcyhyLEEpLElzKHIsaiksTXMoKCgpPT57THMocixBKSxILmNhbmNlbGxlZHx8KElzKHIsRSksRnx8KEtzKEwpP3NldFRpbWVvdXQoSCxMKTpScyhyLGwsSCkpKX0pKSksdC5kYXRhLnNob3cmJihlJiZlKCksUCYmUChyLEgpKSxSfHxGfHxIKCl9ZnVuY3Rpb24gVnModCxlKXtjb25zdCByPXQuZWxtO28oci5fZW50ZXJDYikmJihyLl9lbnRlckNiLmNhbmNlbGxlZD0hMCxyLl9lbnRlckNiKCkpO2NvbnN0IHM9a3ModC5kYXRhLnRyYW5zaXRpb24pO2lmKG4ocyl8fDEhPT1yLm5vZGVUeXBlKXJldHVybiBlKCk7aWYobyhyLl9sZWF2ZUNiKSlyZXR1cm47Y29uc3R7Y3NzOmksdHlwZTphLGxlYXZlQ2xhc3M6bCxsZWF2ZVRvQ2xhc3M6dSxsZWF2ZUFjdGl2ZUNsYXNzOmYsYmVmb3JlTGVhdmU6ZCxsZWF2ZTpwLGFmdGVyTGVhdmU6bSxsZWF2ZUNhbmNlbGxlZDpnLGRlbGF5TGVhdmU6dixkdXJhdGlvbjp5fT1zLF89ITEhPT1pJiYhRywkPUpzKHApLGI9aChjKHkpP3kubGVhdmU6eSksdz1yLl9sZWF2ZUNiPUkoKCgpPT57ci5wYXJlbnROb2RlJiZyLnBhcmVudE5vZGUuX3BlbmRpbmcmJihyLnBhcmVudE5vZGUuX3BlbmRpbmdbdC5rZXldPW51bGwpLF8mJihMcyhyLHUpLExzKHIsZikpLHcuY2FuY2VsbGVkPyhfJiZMcyhyLGwpLGcmJmcocikpOihlKCksbSYmbShyKSksci5fbGVhdmVDYj1udWxsfSkpO2Z1bmN0aW9uIHgoKXt3LmNhbmNlbGxlZHx8KCF0LmRhdGEuc2hvdyYmci5wYXJlbnROb2RlJiYoKHIucGFyZW50Tm9kZS5fcGVuZGluZ3x8KHIucGFyZW50Tm9kZS5fcGVuZGluZz17fSkpW3Qua2V5XT10KSxkJiZkKHIpLF8mJihJcyhyLGwpLElzKHIsZiksTXMoKCgpPT57THMocixsKSx3LmNhbmNlbGxlZHx8KElzKHIsdSksJHx8KEtzKGIpP3NldFRpbWVvdXQodyxiKTpScyhyLGEsdykpKX0pKSkscCYmcChyLHcpLF98fCR8fHcoKSl9dj92KHgpOngoKX1mdW5jdGlvbiBLcyh0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmIWlzTmFOKHQpfWZ1bmN0aW9uIEpzKHQpe2lmKG4odCkpcmV0dXJuITE7Y29uc3QgZT10LmZucztyZXR1cm4gbyhlKT9KcyhBcnJheS5pc0FycmF5KGUpP2VbMF06ZSk6KHQuX2xlbmd0aHx8dC5sZW5ndGgpPjF9ZnVuY3Rpb24gcXModCxlKXshMCE9PWUuZGF0YS5zaG93JiZ6cyhlKX1jb25zdCBXcz1mdW5jdGlvbih0KXtsZXQgaSxjO2NvbnN0IGE9e30se21vZHVsZXM6bCxub2RlT3BzOnV9PXQ7Zm9yKGk9MDtpPGFyLmxlbmd0aDsrK2kpZm9yKGFbYXJbaV1dPVtdLGM9MDtjPGwubGVuZ3RoOysrYylvKGxbY11bYXJbaV1dKSYmYVthcltpXV0ucHVzaChsW2NdW2FyW2ldXSk7ZnVuY3Rpb24gZih0KXtjb25zdCBlPXUucGFyZW50Tm9kZSh0KTtvKGUpJiZ1LnJlbW92ZUNoaWxkKGUsdCl9ZnVuY3Rpb24gZCh0LGUsbixzLGksYyxsKXtpZihvKHQuZWxtKSYmbyhjKSYmKHQ9Y1tsXT1wdCh0KSksdC5pc1Jvb3RJbnNlcnQ9IWksZnVuY3Rpb24odCxlLG4scyl7bGV0IGk9dC5kYXRhO2lmKG8oaSkpe2NvbnN0IGM9byh0LmNvbXBvbmVudEluc3RhbmNlKSYmaS5rZWVwQWxpdmU7aWYobyhpPWkuaG9vaykmJm8oaT1pLmluaXQpJiZpKHQsITEpLG8odC5jb21wb25lbnRJbnN0YW5jZSkpcmV0dXJuIHAodCxlKSxoKG4sdC5lbG0scykscihjKSYmZnVuY3Rpb24odCxlLG4scil7bGV0IHMsaT10O2Zvcig7aS5jb21wb25lbnRJbnN0YW5jZTspaWYoaT1pLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSxvKHM9aS5kYXRhKSYmbyhzPXMudHJhbnNpdGlvbikpe2ZvcihzPTA7czxhLmFjdGl2YXRlLmxlbmd0aDsrK3MpYS5hY3RpdmF0ZVtzXShjcixpKTtlLnB1c2goaSk7YnJlYWt9aChuLHQuZWxtLHIpfSh0LGUsbixzKSwhMH19KHQsZSxuLHMpKXJldHVybjtjb25zdCBmPXQuZGF0YSxkPXQuY2hpbGRyZW4sbT10LnRhZztvKG0pPyh0LmVsbT10Lm5zP3UuY3JlYXRlRWxlbWVudE5TKHQubnMsbSk6dS5jcmVhdGVFbGVtZW50KG0sdCksXyh0KSxnKHQsZCxlKSxvKGYpJiZ5KHQsZSksaChuLHQuZWxtLHMpKTpyKHQuaXNDb21tZW50KT8odC5lbG09dS5jcmVhdGVDb21tZW50KHQudGV4dCksaChuLHQuZWxtLHMpKToodC5lbG09dS5jcmVhdGVUZXh0Tm9kZSh0LnRleHQpLGgobix0LmVsbSxzKSl9ZnVuY3Rpb24gcCh0LGUpe28odC5kYXRhLnBlbmRpbmdJbnNlcnQpJiYoZS5wdXNoLmFwcGx5KGUsdC5kYXRhLnBlbmRpbmdJbnNlcnQpLHQuZGF0YS5wZW5kaW5nSW5zZXJ0PW51bGwpLHQuZWxtPXQuY29tcG9uZW50SW5zdGFuY2UuJGVsLHYodCk/KHkodCxlKSxfKHQpKTooc3IodCksZS5wdXNoKHQpKX1mdW5jdGlvbiBoKHQsZSxuKXtvKHQpJiYobyhuKT91LnBhcmVudE5vZGUobik9PT10JiZ1Lmluc2VydEJlZm9yZSh0LGUsbik6dS5hcHBlbmRDaGlsZCh0LGUpKX1mdW5jdGlvbiBnKHQsbixvKXtpZihlKG4pKWZvcihsZXQgZT0wO2U8bi5sZW5ndGg7KytlKWQobltlXSxvLHQuZWxtLG51bGwsITAsbixlKTtlbHNlIHModC50ZXh0KSYmdS5hcHBlbmRDaGlsZCh0LmVsbSx1LmNyZWF0ZVRleHROb2RlKFN0cmluZyh0LnRleHQpKSl9ZnVuY3Rpb24gdih0KXtmb3IoO3QuY29tcG9uZW50SW5zdGFuY2U7KXQ9dC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7cmV0dXJuIG8odC50YWcpfWZ1bmN0aW9uIHkodCxlKXtmb3IobGV0IGU9MDtlPGEuY3JlYXRlLmxlbmd0aDsrK2UpYS5jcmVhdGVbZV0oY3IsdCk7aT10LmRhdGEuaG9vayxvKGkpJiYobyhpLmNyZWF0ZSkmJmkuY3JlYXRlKGNyLHQpLG8oaS5pbnNlcnQpJiZlLnB1c2godCkpfWZ1bmN0aW9uIF8odCl7bGV0IGU7aWYobyhlPXQuZm5TY29wZUlkKSl1LnNldFN0eWxlU2NvcGUodC5lbG0sZSk7ZWxzZXtsZXQgbj10O2Zvcig7bjspbyhlPW4uY29udGV4dCkmJm8oZT1lLiRvcHRpb25zLl9zY29wZUlkKSYmdS5zZXRTdHlsZVNjb3BlKHQuZWxtLGUpLG49bi5wYXJlbnR9byhlPVZlKSYmZSE9PXQuY29udGV4dCYmZSE9PXQuZm5Db250ZXh0JiZvKGU9ZS4kb3B0aW9ucy5fc2NvcGVJZCkmJnUuc2V0U3R5bGVTY29wZSh0LmVsbSxlKX1mdW5jdGlvbiAkKHQsZSxuLG8scixzKXtmb3IoO288PXI7KytvKWQobltvXSxzLHQsZSwhMSxuLG8pfWZ1bmN0aW9uIGIodCl7bGV0IGUsbjtjb25zdCByPXQuZGF0YTtpZihvKHIpKWZvcihvKGU9ci5ob29rKSYmbyhlPWUuZGVzdHJveSkmJmUodCksZT0wO2U8YS5kZXN0cm95Lmxlbmd0aDsrK2UpYS5kZXN0cm95W2VdKHQpO2lmKG8oZT10LmNoaWxkcmVuKSlmb3Iobj0wO248dC5jaGlsZHJlbi5sZW5ndGg7KytuKWIodC5jaGlsZHJlbltuXSl9ZnVuY3Rpb24gdyh0LGUsbil7Zm9yKDtlPD1uOysrZSl7Y29uc3Qgbj10W2VdO28obikmJihvKG4udGFnKT8oeChuKSxiKG4pKTpmKG4uZWxtKSl9fWZ1bmN0aW9uIHgodCxlKXtpZihvKGUpfHxvKHQuZGF0YSkpe2xldCBuO2NvbnN0IHI9YS5yZW1vdmUubGVuZ3RoKzE7Zm9yKG8oZSk/ZS5saXN0ZW5lcnMrPXI6ZT1mdW5jdGlvbih0LGUpe2Z1bmN0aW9uIG4oKXswPT0tLW4ubGlzdGVuZXJzJiZmKHQpfXJldHVybiBuLmxpc3RlbmVycz1lLG59KHQuZWxtLHIpLG8obj10LmNvbXBvbmVudEluc3RhbmNlKSYmbyhuPW4uX3Zub2RlKSYmbyhuLmRhdGEpJiZ4KG4sZSksbj0wO248YS5yZW1vdmUubGVuZ3RoOysrbilhLnJlbW92ZVtuXSh0LGUpO28obj10LmRhdGEuaG9vaykmJm8obj1uLnJlbW92ZSk/bih0LGUpOmUoKX1lbHNlIGYodC5lbG0pfWZ1bmN0aW9uIEModCxlLG4scil7Zm9yKGxldCBzPW47czxyO3MrKyl7Y29uc3Qgbj1lW3NdO2lmKG8obikmJmxyKHQsbikpcmV0dXJuIHN9fWZ1bmN0aW9uIGsodCxlLHMsaSxjLGwpe2lmKHQ9PT1lKXJldHVybjtvKGUuZWxtKSYmbyhpKSYmKGU9aVtjXT1wdChlKSk7Y29uc3QgZj1lLmVsbT10LmVsbTtpZihyKHQuaXNBc3luY1BsYWNlaG9sZGVyKSlyZXR1cm4gdm9pZChvKGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKT9UKHQuZWxtLGUscyk6ZS5pc0FzeW5jUGxhY2Vob2xkZXI9ITApO2lmKHIoZS5pc1N0YXRpYykmJnIodC5pc1N0YXRpYykmJmUua2V5PT09dC5rZXkmJihyKGUuaXNDbG9uZWQpfHxyKGUuaXNPbmNlKSkpcmV0dXJuIHZvaWQoZS5jb21wb25lbnRJbnN0YW5jZT10LmNvbXBvbmVudEluc3RhbmNlKTtsZXQgcDtjb25zdCBoPWUuZGF0YTtvKGgpJiZvKHA9aC5ob29rKSYmbyhwPXAucHJlcGF0Y2gpJiZwKHQsZSk7Y29uc3QgbT10LmNoaWxkcmVuLGc9ZS5jaGlsZHJlbjtpZihvKGgpJiZ2KGUpKXtmb3IocD0wO3A8YS51cGRhdGUubGVuZ3RoOysrcClhLnVwZGF0ZVtwXSh0LGUpO28ocD1oLmhvb2spJiZvKHA9cC51cGRhdGUpJiZwKHQsZSl9bihlLnRleHQpP28obSkmJm8oZyk/bSE9PWcmJmZ1bmN0aW9uKHQsZSxyLHMsaSl7bGV0IGMsYSxsLGYscD0wLGg9MCxtPWUubGVuZ3RoLTEsZz1lWzBdLHY9ZVttXSx5PXIubGVuZ3RoLTEsXz1yWzBdLGI9clt5XTtjb25zdCB4PSFpO2Zvcig7cDw9bSYmaDw9eTspbihnKT9nPWVbKytwXTpuKHYpP3Y9ZVstLW1dOmxyKGcsXyk/KGsoZyxfLHMscixoKSxnPWVbKytwXSxfPXJbKytoXSk6bHIodixiKT8oayh2LGIscyxyLHkpLHY9ZVstLW1dLGI9clstLXldKTpscihnLGIpPyhrKGcsYixzLHIseSkseCYmdS5pbnNlcnRCZWZvcmUodCxnLmVsbSx1Lm5leHRTaWJsaW5nKHYuZWxtKSksZz1lWysrcF0sYj1yWy0teV0pOmxyKHYsXyk/KGsodixfLHMscixoKSx4JiZ1Lmluc2VydEJlZm9yZSh0LHYuZWxtLGcuZWxtKSx2PWVbLS1tXSxfPXJbKytoXSk6KG4oYykmJihjPXVyKGUscCxtKSksYT1vKF8ua2V5KT9jW18ua2V5XTpDKF8sZSxwLG0pLG4oYSk/ZChfLHMsdCxnLmVsbSwhMSxyLGgpOihsPWVbYV0sbHIobCxfKT8oayhsLF8scyxyLGgpLGVbYV09dm9pZCAwLHgmJnUuaW5zZXJ0QmVmb3JlKHQsbC5lbG0sZy5lbG0pKTpkKF8scyx0LGcuZWxtLCExLHIsaCkpLF89clsrK2hdKTtwPm0/KGY9bihyW3krMV0pP251bGw6clt5KzFdLmVsbSwkKHQsZixyLGgseSxzKSk6aD55JiZ3KGUscCxtKX0oZixtLGcscyxsKTpvKGcpPyhvKHQudGV4dCkmJnUuc2V0VGV4dENvbnRlbnQoZixcIlwiKSwkKGYsbnVsbCxnLDAsZy5sZW5ndGgtMSxzKSk6byhtKT93KG0sMCxtLmxlbmd0aC0xKTpvKHQudGV4dCkmJnUuc2V0VGV4dENvbnRlbnQoZixcIlwiKTp0LnRleHQhPT1lLnRleHQmJnUuc2V0VGV4dENvbnRlbnQoZixlLnRleHQpLG8oaCkmJm8ocD1oLmhvb2spJiZvKHA9cC5wb3N0cGF0Y2gpJiZwKHQsZSl9ZnVuY3Rpb24gUyh0LGUsbil7aWYocihuKSYmbyh0LnBhcmVudCkpdC5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0PWU7ZWxzZSBmb3IobGV0IHQ9MDt0PGUubGVuZ3RoOysrdCllW3RdLmRhdGEuaG9vay5pbnNlcnQoZVt0XSl9Y29uc3QgTz1tKFwiYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5XCIpO2Z1bmN0aW9uIFQodCxlLG4scyl7bGV0IGk7Y29uc3R7dGFnOmMsZGF0YTphLGNoaWxkcmVuOmx9PWU7aWYocz1zfHxhJiZhLnByZSxlLmVsbT10LHIoZS5pc0NvbW1lbnQpJiZvKGUuYXN5bmNGYWN0b3J5KSlyZXR1cm4gZS5pc0FzeW5jUGxhY2Vob2xkZXI9ITAsITA7aWYobyhhKSYmKG8oaT1hLmhvb2spJiZvKGk9aS5pbml0KSYmaShlLCEwKSxvKGk9ZS5jb21wb25lbnRJbnN0YW5jZSkpKXJldHVybiBwKGUsbiksITA7aWYobyhjKSl7aWYobyhsKSlpZih0Lmhhc0NoaWxkTm9kZXMoKSlpZihvKGk9YSkmJm8oaT1pLmRvbVByb3BzKSYmbyhpPWkuaW5uZXJIVE1MKSl7aWYoaSE9PXQuaW5uZXJIVE1MKXJldHVybiExfWVsc2V7bGV0IGU9ITAsbz10LmZpcnN0Q2hpbGQ7Zm9yKGxldCB0PTA7dDxsLmxlbmd0aDt0Kyspe2lmKCFvfHwhVChvLGxbdF0sbixzKSl7ZT0hMTticmVha31vPW8ubmV4dFNpYmxpbmd9aWYoIWV8fG8pcmV0dXJuITF9ZWxzZSBnKGUsbCxuKTtpZihvKGEpKXtsZXQgdD0hMTtmb3IoY29uc3QgbyBpbiBhKWlmKCFPKG8pKXt0PSEwLHkoZSxuKTticmVha30hdCYmYS5jbGFzcyYmVW4oYS5jbGFzcyl9fWVsc2UgdC5kYXRhIT09ZS50ZXh0JiYodC5kYXRhPWUudGV4dCk7cmV0dXJuITB9cmV0dXJuIGZ1bmN0aW9uKHQsZSxzLGkpe2lmKG4oZSkpcmV0dXJuIHZvaWQobyh0KSYmYih0KSk7bGV0IGM9ITE7Y29uc3QgbD1bXTtpZihuKHQpKWM9ITAsZChlLGwpO2Vsc2V7Y29uc3Qgbj1vKHQubm9kZVR5cGUpO2lmKCFuJiZscih0LGUpKWsodCxlLGwsbnVsbCxudWxsLGkpO2Vsc2V7aWYobil7aWYoMT09PXQubm9kZVR5cGUmJnQuaGFzQXR0cmlidXRlKFIpJiYodC5yZW1vdmVBdHRyaWJ1dGUoUikscz0hMCkscihzKSYmVCh0LGUsbCkpcmV0dXJuIFMoZSxsLCEwKSx0O2Y9dCx0PW5ldyB1dCh1LnRhZ05hbWUoZikudG9Mb3dlckNhc2UoKSx7fSxbXSx2b2lkIDAsZil9Y29uc3QgaT10LmVsbSxjPXUucGFyZW50Tm9kZShpKTtpZihkKGUsbCxpLl9sZWF2ZUNiP251bGw6Yyx1Lm5leHRTaWJsaW5nKGkpKSxvKGUucGFyZW50KSl7bGV0IHQ9ZS5wYXJlbnQ7Y29uc3Qgbj12KGUpO2Zvcig7dDspe2ZvcihsZXQgZT0wO2U8YS5kZXN0cm95Lmxlbmd0aDsrK2UpYS5kZXN0cm95W2VdKHQpO2lmKHQuZWxtPWUuZWxtLG4pe2ZvcihsZXQgZT0wO2U8YS5jcmVhdGUubGVuZ3RoOysrZSlhLmNyZWF0ZVtlXShjcix0KTtjb25zdCBlPXQuZGF0YS5ob29rLmluc2VydDtpZihlLm1lcmdlZCl7Y29uc3QgdD1lLmZucy5zbGljZSgxKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdKCl9fWVsc2Ugc3IodCk7dD10LnBhcmVudH19byhjKT93KFt0XSwwLDApOm8odC50YWcpJiZiKHQpfX12YXIgZjtyZXR1cm4gUyhlLGwsYyksZS5lbG19fSh7bm9kZU9wczpvcixtb2R1bGVzOlticix4cixpcyx1cyxicyxxP3tjcmVhdGU6cXMsYWN0aXZhdGU6cXMscmVtb3ZlKHQsZSl7ITAhPT10LmRhdGEuc2hvdz9Wcyh0LGUpOmUoKX19Ont9XS5jb25jYXQodnIpfSk7RyYmZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCgoKT0+e2NvbnN0IHQ9ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDt0JiZ0LnZtb2RlbCYmbmkodCxcImlucHV0XCIpfSkpO2NvbnN0IFpzPXtpbnNlcnRlZCh0LGUsbixvKXtcInNlbGVjdFwiPT09bi50YWc/KG8uZWxtJiYhby5lbG0uX3ZPcHRpb25zP1l0KG4sXCJwb3N0cGF0Y2hcIiwoKCk9Pntacy5jb21wb25lbnRVcGRhdGVkKHQsZSxuKX0pKTpHcyh0LGUsbi5jb250ZXh0KSx0Ll92T3B0aW9ucz1bXS5tYXAuY2FsbCh0Lm9wdGlvbnMsUXMpKTooXCJ0ZXh0YXJlYVwiPT09bi50YWd8fGVyKHQudHlwZSkpJiYodC5fdk1vZGlmaWVycz1lLm1vZGlmaWVycyxlLm1vZGlmaWVycy5sYXp5fHwodC5hZGRFdmVudExpc3RlbmVyKFwiY29tcG9zaXRpb25zdGFydFwiLHRpKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb21wb3NpdGlvbmVuZFwiLGVpKSx0LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixlaSksRyYmKHQudm1vZGVsPSEwKSkpfSxjb21wb25lbnRVcGRhdGVkKHQsZSxuKXtpZihcInNlbGVjdFwiPT09bi50YWcpe0dzKHQsZSxuLmNvbnRleHQpO2NvbnN0IG89dC5fdk9wdGlvbnMscj10Ll92T3B0aW9ucz1bXS5tYXAuY2FsbCh0Lm9wdGlvbnMsUXMpO2lmKHIuc29tZSgoKHQsZSk9PiFEKHQsb1tlXSkpKSl7KHQubXVsdGlwbGU/ZS52YWx1ZS5zb21lKCh0PT5Zcyh0LHIpKSk6ZS52YWx1ZSE9PWUub2xkVmFsdWUmJllzKGUudmFsdWUscikpJiZuaSh0LFwiY2hhbmdlXCIpfX19fTtmdW5jdGlvbiBHcyh0LGUsbil7WHModCxlKSwoWnx8WCkmJnNldFRpbWVvdXQoKCgpPT57WHModCxlKX0pLDApfWZ1bmN0aW9uIFhzKHQsZSxuKXtjb25zdCBvPWUudmFsdWUscj10Lm11bHRpcGxlO2lmKHImJiFBcnJheS5pc0FycmF5KG8pKXJldHVybjtsZXQgcyxpO2ZvcihsZXQgZT0wLG49dC5vcHRpb25zLmxlbmd0aDtlPG47ZSsrKWlmKGk9dC5vcHRpb25zW2VdLHIpcz1NKG8sUXMoaSkpPi0xLGkuc2VsZWN0ZWQhPT1zJiYoaS5zZWxlY3RlZD1zKTtlbHNlIGlmKEQoUXMoaSksbykpcmV0dXJuIHZvaWQodC5zZWxlY3RlZEluZGV4IT09ZSYmKHQuc2VsZWN0ZWRJbmRleD1lKSk7cnx8KHQuc2VsZWN0ZWRJbmRleD0tMSl9ZnVuY3Rpb24gWXModCxlKXtyZXR1cm4gZS5ldmVyeSgoZT0+IUQoZSx0KSkpfWZ1bmN0aW9uIFFzKHQpe3JldHVyblwiX3ZhbHVlXCJpbiB0P3QuX3ZhbHVlOnQudmFsdWV9ZnVuY3Rpb24gdGkodCl7dC50YXJnZXQuY29tcG9zaW5nPSEwfWZ1bmN0aW9uIGVpKHQpe3QudGFyZ2V0LmNvbXBvc2luZyYmKHQudGFyZ2V0LmNvbXBvc2luZz0hMSxuaSh0LnRhcmdldCxcImlucHV0XCIpKX1mdW5jdGlvbiBuaSh0LGUpe2NvbnN0IG49ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJIVE1MRXZlbnRzXCIpO24uaW5pdEV2ZW50KGUsITAsITApLHQuZGlzcGF0Y2hFdmVudChuKX1mdW5jdGlvbiBvaSh0KXtyZXR1cm4hdC5jb21wb25lbnRJbnN0YW5jZXx8dC5kYXRhJiZ0LmRhdGEudHJhbnNpdGlvbj90Om9pKHQuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlKX12YXIgcmk9e2JpbmQodCx7dmFsdWU6ZX0sbil7Y29uc3Qgbz0obj1vaShuKSkuZGF0YSYmbi5kYXRhLnRyYW5zaXRpb24scj10Ll9fdk9yaWdpbmFsRGlzcGxheT1cIm5vbmVcIj09PXQuc3R5bGUuZGlzcGxheT9cIlwiOnQuc3R5bGUuZGlzcGxheTtlJiZvPyhuLmRhdGEuc2hvdz0hMCx6cyhuLCgoKT0+e3Quc3R5bGUuZGlzcGxheT1yfSkpKTp0LnN0eWxlLmRpc3BsYXk9ZT9yOlwibm9uZVwifSx1cGRhdGUodCx7dmFsdWU6ZSxvbGRWYWx1ZTpufSxvKXtpZighZT09IW4pcmV0dXJuOyhvPW9pKG8pKS5kYXRhJiZvLmRhdGEudHJhbnNpdGlvbj8oby5kYXRhLnNob3c9ITAsZT96cyhvLCgoKT0+e3Quc3R5bGUuZGlzcGxheT10Ll9fdk9yaWdpbmFsRGlzcGxheX0pKTpWcyhvLCgoKT0+e3Quc3R5bGUuZGlzcGxheT1cIm5vbmVcIn0pKSk6dC5zdHlsZS5kaXNwbGF5PWU/dC5fX3ZPcmlnaW5hbERpc3BsYXk6XCJub25lXCJ9LHVuYmluZCh0LGUsbixvLHIpe3J8fCh0LnN0eWxlLmRpc3BsYXk9dC5fX3ZPcmlnaW5hbERpc3BsYXkpfX0sc2k9e21vZGVsOlpzLHNob3c6cml9O2NvbnN0IGlpPXtuYW1lOlN0cmluZyxhcHBlYXI6Qm9vbGVhbixjc3M6Qm9vbGVhbixtb2RlOlN0cmluZyx0eXBlOlN0cmluZyxlbnRlckNsYXNzOlN0cmluZyxsZWF2ZUNsYXNzOlN0cmluZyxlbnRlclRvQ2xhc3M6U3RyaW5nLGxlYXZlVG9DbGFzczpTdHJpbmcsZW50ZXJBY3RpdmVDbGFzczpTdHJpbmcsbGVhdmVBY3RpdmVDbGFzczpTdHJpbmcsYXBwZWFyQ2xhc3M6U3RyaW5nLGFwcGVhckFjdGl2ZUNsYXNzOlN0cmluZyxhcHBlYXJUb0NsYXNzOlN0cmluZyxkdXJhdGlvbjpbTnVtYmVyLFN0cmluZyxPYmplY3RdfTtmdW5jdGlvbiBjaSh0KXtjb25zdCBlPXQmJnQuY29tcG9uZW50T3B0aW9ucztyZXR1cm4gZSYmZS5DdG9yLm9wdGlvbnMuYWJzdHJhY3Q/Y2koTGUoZS5jaGlsZHJlbikpOnR9ZnVuY3Rpb24gYWkodCl7Y29uc3QgZT17fSxuPXQuJG9wdGlvbnM7Zm9yKGNvbnN0IG8gaW4gbi5wcm9wc0RhdGEpZVtvXT10W29dO2NvbnN0IG89bi5fcGFyZW50TGlzdGVuZXJzO2Zvcihjb25zdCB0IGluIG8pZVt4KHQpXT1vW3RdO3JldHVybiBlfWZ1bmN0aW9uIGxpKHQsZSl7aWYoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChlLnRhZykpcmV0dXJuIHQoXCJrZWVwLWFsaXZlXCIse3Byb3BzOmUuY29tcG9uZW50T3B0aW9ucy5wcm9wc0RhdGF9KX1jb25zdCB1aT10PT50LnRhZ3x8Q2UodCksZmk9dD0+XCJzaG93XCI9PT10Lm5hbWU7dmFyIGRpPXtuYW1lOlwidHJhbnNpdGlvblwiLHByb3BzOmlpLGFic3RyYWN0OiEwLHJlbmRlcih0KXtsZXQgZT10aGlzLiRzbG90cy5kZWZhdWx0O2lmKCFlKXJldHVybjtpZihlPWUuZmlsdGVyKHVpKSwhZS5sZW5ndGgpcmV0dXJuO2NvbnN0IG49dGhpcy5tb2RlLG89ZVswXTtpZihmdW5jdGlvbih0KXtmb3IoO3Q9dC5wYXJlbnQ7KWlmKHQuZGF0YS50cmFuc2l0aW9uKXJldHVybiEwfSh0aGlzLiR2bm9kZSkpcmV0dXJuIG87Y29uc3Qgcj1jaShvKTtpZighcilyZXR1cm4gbztpZih0aGlzLl9sZWF2aW5nKXJldHVybiBsaSh0LG8pO2NvbnN0IGk9YF9fdHJhbnNpdGlvbi0ke3RoaXMuX3VpZH0tYDtyLmtleT1udWxsPT1yLmtleT9yLmlzQ29tbWVudD9pK1wiY29tbWVudFwiOmkrci50YWc6cyhyLmtleSk/MD09PVN0cmluZyhyLmtleSkuaW5kZXhPZihpKT9yLmtleTppK3Iua2V5OnIua2V5O2NvbnN0IGM9KHIuZGF0YXx8KHIuZGF0YT17fSkpLnRyYW5zaXRpb249YWkodGhpcyksYT10aGlzLl92bm9kZSxsPWNpKGEpO2lmKHIuZGF0YS5kaXJlY3RpdmVzJiZyLmRhdGEuZGlyZWN0aXZlcy5zb21lKGZpKSYmKHIuZGF0YS5zaG93PSEwKSxsJiZsLmRhdGEmJiFmdW5jdGlvbih0LGUpe3JldHVybiBlLmtleT09PXQua2V5JiZlLnRhZz09PXQudGFnfShyLGwpJiYhQ2UobCkmJighbC5jb21wb25lbnRJbnN0YW5jZXx8IWwuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlLmlzQ29tbWVudCkpe2NvbnN0IGU9bC5kYXRhLnRyYW5zaXRpb249QSh7fSxjKTtpZihcIm91dC1pblwiPT09bilyZXR1cm4gdGhpcy5fbGVhdmluZz0hMCxZdChlLFwiYWZ0ZXJMZWF2ZVwiLCgoKT0+e3RoaXMuX2xlYXZpbmc9ITEsdGhpcy4kZm9yY2VVcGRhdGUoKX0pKSxsaSh0LG8pO2lmKFwiaW4tb3V0XCI9PT1uKXtpZihDZShyKSlyZXR1cm4gYTtsZXQgdDtjb25zdCBuPSgpPT57dCgpfTtZdChjLFwiYWZ0ZXJFbnRlclwiLG4pLFl0KGMsXCJlbnRlckNhbmNlbGxlZFwiLG4pLFl0KGUsXCJkZWxheUxlYXZlXCIsKGU9Pnt0PWV9KSl9fXJldHVybiBvfX07Y29uc3QgcGk9QSh7dGFnOlN0cmluZyxtb3ZlQ2xhc3M6U3RyaW5nfSxpaSk7ZGVsZXRlIHBpLm1vZGU7dmFyIGhpPXtwcm9wczpwaSxiZWZvcmVNb3VudCgpe2NvbnN0IHQ9dGhpcy5fdXBkYXRlO3RoaXMuX3VwZGF0ZT0oZSxuKT0+e2NvbnN0IG89S2UodGhpcyk7dGhpcy5fX3BhdGNoX18odGhpcy5fdm5vZGUsdGhpcy5rZXB0LCExLCEwKSx0aGlzLl92bm9kZT10aGlzLmtlcHQsbygpLHQuY2FsbCh0aGlzLGUsbil9fSxyZW5kZXIodCl7Y29uc3QgZT10aGlzLnRhZ3x8dGhpcy4kdm5vZGUuZGF0YS50YWd8fFwic3BhblwiLG49T2JqZWN0LmNyZWF0ZShudWxsKSxvPXRoaXMucHJldkNoaWxkcmVuPXRoaXMuY2hpbGRyZW4scj10aGlzLiRzbG90cy5kZWZhdWx0fHxbXSxzPXRoaXMuY2hpbGRyZW49W10saT1haSh0aGlzKTtmb3IobGV0IHQ9MDt0PHIubGVuZ3RoO3QrKyl7Y29uc3QgZT1yW3RdO2UudGFnJiZudWxsIT1lLmtleSYmMCE9PVN0cmluZyhlLmtleSkuaW5kZXhPZihcIl9fdmxpc3RcIikmJihzLnB1c2goZSksbltlLmtleV09ZSwoZS5kYXRhfHwoZS5kYXRhPXt9KSkudHJhbnNpdGlvbj1pKX1pZihvKXtjb25zdCByPVtdLHM9W107Zm9yKGxldCB0PTA7dDxvLmxlbmd0aDt0Kyspe2NvbnN0IGU9b1t0XTtlLmRhdGEudHJhbnNpdGlvbj1pLGUuZGF0YS5wb3M9ZS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksbltlLmtleV0/ci5wdXNoKGUpOnMucHVzaChlKX10aGlzLmtlcHQ9dChlLG51bGwsciksdGhpcy5yZW1vdmVkPXN9cmV0dXJuIHQoZSxudWxsLHMpfSx1cGRhdGVkKCl7Y29uc3QgdD10aGlzLnByZXZDaGlsZHJlbixlPXRoaXMubW92ZUNsYXNzfHwodGhpcy5uYW1lfHxcInZcIikrXCItbW92ZVwiO3QubGVuZ3RoJiZ0aGlzLmhhc01vdmUodFswXS5lbG0sZSkmJih0LmZvckVhY2gobWkpLHQuZm9yRWFjaChnaSksdC5mb3JFYWNoKHZpKSx0aGlzLl9yZWZsb3c9ZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsdC5mb3JFYWNoKCh0PT57aWYodC5kYXRhLm1vdmVkKXtjb25zdCBuPXQuZWxtLG89bi5zdHlsZTtJcyhuLGUpLG8udHJhbnNmb3JtPW8uV2Via2l0VHJhbnNmb3JtPW8udHJhbnNpdGlvbkR1cmF0aW9uPVwiXCIsbi5hZGRFdmVudExpc3RlbmVyKEVzLG4uX21vdmVDYj1mdW5jdGlvbiB0KG8pe28mJm8udGFyZ2V0IT09bnx8byYmIS90cmFuc2Zvcm0kLy50ZXN0KG8ucHJvcGVydHlOYW1lKXx8KG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFcyx0KSxuLl9tb3ZlQ2I9bnVsbCxMcyhuLGUpKX0pfX0pKSl9LG1ldGhvZHM6e2hhc01vdmUodCxlKXtpZighT3MpcmV0dXJuITE7aWYodGhpcy5faGFzTW92ZSlyZXR1cm4gdGhpcy5faGFzTW92ZTtjb25zdCBuPXQuY2xvbmVOb2RlKCk7dC5fdHJhbnNpdGlvbkNsYXNzZXMmJnQuX3RyYW5zaXRpb25DbGFzc2VzLmZvckVhY2goKHQ9PntDcyhuLHQpfSkpLHhzKG4sZSksbi5zdHlsZS5kaXNwbGF5PVwibm9uZVwiLHRoaXMuJGVsLmFwcGVuZENoaWxkKG4pO2NvbnN0IG89SHMobik7cmV0dXJuIHRoaXMuJGVsLnJlbW92ZUNoaWxkKG4pLHRoaXMuX2hhc01vdmU9by5oYXNUcmFuc2Zvcm19fX07ZnVuY3Rpb24gbWkodCl7dC5lbG0uX21vdmVDYiYmdC5lbG0uX21vdmVDYigpLHQuZWxtLl9lbnRlckNiJiZ0LmVsbS5fZW50ZXJDYigpfWZ1bmN0aW9uIGdpKHQpe3QuZGF0YS5uZXdQb3M9dC5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCl9ZnVuY3Rpb24gdmkodCl7Y29uc3QgZT10LmRhdGEucG9zLG49dC5kYXRhLm5ld1BvcyxvPWUubGVmdC1uLmxlZnQscj1lLnRvcC1uLnRvcDtpZihvfHxyKXt0LmRhdGEubW92ZWQ9ITA7Y29uc3QgZT10LmVsbS5zdHlsZTtlLnRyYW5zZm9ybT1lLldlYmtpdFRyYW5zZm9ybT1gdHJhbnNsYXRlKCR7b31weCwke3J9cHgpYCxlLnRyYW5zaXRpb25EdXJhdGlvbj1cIjBzXCJ9fXZhciB5aT17VHJhbnNpdGlvbjpkaSxUcmFuc2l0aW9uR3JvdXA6aGl9O1NvLmNvbmZpZy5tdXN0VXNlUHJvcD1JbyxTby5jb25maWcuaXNSZXNlcnZlZFRhZz1ZbyxTby5jb25maWcuaXNSZXNlcnZlZEF0dHI9RG8sU28uY29uZmlnLmdldFRhZ05hbWVzcGFjZT1RbyxTby5jb25maWcuaXNVbmtub3duRWxlbWVudD1mdW5jdGlvbih0KXtpZighcSlyZXR1cm4hMDtpZihZbyh0KSlyZXR1cm4hMTtpZih0PXQudG9Mb3dlckNhc2UoKSxudWxsIT10clt0XSlyZXR1cm4gdHJbdF07Y29uc3QgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KHQpO3JldHVybiB0LmluZGV4T2YoXCItXCIpPi0xP3RyW3RdPWUuY29uc3RydWN0b3I9PT13aW5kb3cuSFRNTFVua25vd25FbGVtZW50fHxlLmNvbnN0cnVjdG9yPT09d2luZG93LkhUTUxFbGVtZW50OnRyW3RdPS9IVE1MVW5rbm93bkVsZW1lbnQvLnRlc3QoZS50b1N0cmluZygpKX0sQShTby5vcHRpb25zLmRpcmVjdGl2ZXMsc2kpLEEoU28ub3B0aW9ucy5jb21wb25lbnRzLHlpKSxTby5wcm90b3R5cGUuX19wYXRjaF9fPXE/V3M6RSxTby5wcm90b3R5cGUuJG1vdW50PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxuKXtsZXQgbzt0LiRlbD1lLHQuJG9wdGlvbnMucmVuZGVyfHwodC4kb3B0aW9ucy5yZW5kZXI9ZnQpLFplKHQsXCJiZWZvcmVNb3VudFwiKSxvPSgpPT57dC5fdXBkYXRlKHQuX3JlbmRlcigpLG4pfSxuZXcgS24odCxvLEUse2JlZm9yZSgpe3QuX2lzTW91bnRlZCYmIXQuX2lzRGVzdHJveWVkJiZaZSh0LFwiYmVmb3JlVXBkYXRlXCIpfX0sITApLG49ITE7Y29uc3Qgcj10Ll9wcmVXYXRjaGVycztpZihyKWZvcihsZXQgdD0wO3Q8ci5sZW5ndGg7dCsrKXJbdF0ucnVuKCk7cmV0dXJuIG51bGw9PXQuJHZub2RlJiYodC5faXNNb3VudGVkPSEwLFplKHQsXCJtb3VudGVkXCIpKSx0fSh0aGlzLHQ9dCYmcT9ucih0KTp2b2lkIDAsZSl9LHEmJnNldFRpbWVvdXQoKCgpPT57Qi5kZXZ0b29scyYmcnQmJnJ0LmVtaXQoXCJpbml0XCIsU28pfSksMCk7Y29uc3QgX2k9L1xce1xceygoPzoufFxccj9cXG4pKz8pXFx9XFx9L2csJGk9L1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZyxiaT1iKCh0PT57Y29uc3QgZT10WzBdLnJlcGxhY2UoJGksXCJcXFxcJCZcIiksbj10WzFdLnJlcGxhY2UoJGksXCJcXFxcJCZcIik7cmV0dXJuIG5ldyBSZWdFeHAoZStcIigoPzoufFxcXFxuKSs/KVwiK24sXCJnXCIpfSkpO3ZhciB3aT17c3RhdGljS2V5czpbXCJzdGF0aWNDbGFzc1wiXSx0cmFuc2Zvcm1Ob2RlOmZ1bmN0aW9uKHQsZSl7ZS53YXJuO2NvbnN0IG49SXIodCxcImNsYXNzXCIpO24mJih0LnN0YXRpY0NsYXNzPUpTT04uc3RyaW5naWZ5KG4ucmVwbGFjZSgvXFxzKy9nLFwiIFwiKS50cmltKCkpKTtjb25zdCBvPU1yKHQsXCJjbGFzc1wiLCExKTtvJiYodC5jbGFzc0JpbmRpbmc9byl9LGdlbkRhdGE6ZnVuY3Rpb24odCl7bGV0IGU9XCJcIjtyZXR1cm4gdC5zdGF0aWNDbGFzcyYmKGUrPWBzdGF0aWNDbGFzczoke3Quc3RhdGljQ2xhc3N9LGApLHQuY2xhc3NCaW5kaW5nJiYoZSs9YGNsYXNzOiR7dC5jbGFzc0JpbmRpbmd9LGApLGV9fTt2YXIgeGk9e3N0YXRpY0tleXM6W1wic3RhdGljU3R5bGVcIl0sdHJhbnNmb3JtTm9kZTpmdW5jdGlvbih0LGUpe2Uud2Fybjtjb25zdCBuPUlyKHQsXCJzdHlsZVwiKTtuJiYodC5zdGF0aWNTdHlsZT1KU09OLnN0cmluZ2lmeShmcyhuKSkpO2NvbnN0IG89TXIodCxcInN0eWxlXCIsITEpO28mJih0LnN0eWxlQmluZGluZz1vKX0sZ2VuRGF0YTpmdW5jdGlvbih0KXtsZXQgZT1cIlwiO3JldHVybiB0LnN0YXRpY1N0eWxlJiYoZSs9YHN0YXRpY1N0eWxlOiR7dC5zdGF0aWNTdHlsZX0sYCksdC5zdHlsZUJpbmRpbmcmJihlKz1gc3R5bGU6KCR7dC5zdHlsZUJpbmRpbmd9KSxgKSxlfX07bGV0IENpO3ZhciBraT17ZGVjb2RlOnQ9PihDaT1DaXx8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxDaS5pbm5lckhUTUw9dCxDaS50ZXh0Q29udGVudCl9O2NvbnN0IFNpPW0oXCJhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbixsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdiclwiKSxPaT1tKFwiY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZVwiKSxUaT1tKFwiYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLGRldGFpbHMsZGlhbG9nLGRpdixkbCxkdCxmaWVsZHNldCxmaWdjYXB0aW9uLGZpZ3VyZSxmb290ZXIsZm9ybSxoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSxvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsdGl0bGUsdHIsdHJhY2tcIiksQWk9L15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy8samk9L15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XSs/XFxdW15cXHNcIic8PlxcLz1dKikoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/LyxFaT1gW2EtekEtWl9dW1xcXFwtXFxcXC4wLTlfYS16QS1aJHtVLnNvdXJjZX1dKmAsTmk9YCgoPzoke0VpfVxcXFw6KT8ke0VpfSlgLFBpPW5ldyBSZWdFeHAoYF48JHtOaX1gKSxEaT0vXlxccyooXFwvPyk+LyxNaT1uZXcgUmVnRXhwKGBePFxcXFwvJHtOaX1bXj5dKj5gKSxJaT0vXjwhRE9DVFlQRSBbXj5dKz4vaSxMaT0vXjwhXFwtLS8sUmk9L148IVxcWy8sRmk9bShcInNjcmlwdCxzdHlsZSx0ZXh0YXJlYVwiLCEwKSxIaT17fSxCaT17XCImbHQ7XCI6XCI8XCIsXCImZ3Q7XCI6XCI+XCIsXCImcXVvdDtcIjonXCInLFwiJmFtcDtcIjpcIiZcIixcIiYjMTA7XCI6XCJcXG5cIixcIiYjOTtcIjpcIlxcdFwiLFwiJiMzOTtcIjpcIidcIn0sVWk9LyYoPzpsdHxndHxxdW90fGFtcHwjMzkpOy9nLHppPS8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5fCMxMHwjOSk7L2csVmk9bShcInByZSx0ZXh0YXJlYVwiLCEwKSxLaT0odCxlKT0+dCYmVmkodCkmJlwiXFxuXCI9PT1lWzBdO2Z1bmN0aW9uIEppKHQsZSl7Y29uc3Qgbj1lP3ppOlVpO3JldHVybiB0LnJlcGxhY2UobiwodD0+QmlbdF0pKX1jb25zdCBxaT0vXkB8XnYtb246LyxXaT0vXnYtfF5AfF46fF4jLyxaaT0vKFtcXHNcXFNdKj8pXFxzKyg/OmlufG9mKVxccysoW1xcc1xcU10qKS8sR2k9LywoW14sXFx9XFxdXSopKD86LChbXixcXH1cXF1dKikpPyQvLFhpPS9eXFwofFxcKSQvZyxZaT0vXlxcWy4qXFxdJC8sUWk9LzooLiopJC8sdGM9L146fF5cXC58XnYtYmluZDovLGVjPS9cXC5bXi5cXF1dKyg/PVteXFxdXSokKS9nLG5jPS9edi1zbG90KDp8JCl8XiMvLG9jPS9bXFxyXFxuXS8scmM9L1sgXFxmXFx0XFxyXFxuXSsvZyxzYz1iKGtpLmRlY29kZSksaWM9XCJfZW1wdHlfXCI7bGV0IGNjLGFjLGxjLHVjLGZjLGRjLHBjLGhjO2Z1bmN0aW9uIG1jKHQsZSxuKXtyZXR1cm57dHlwZToxLHRhZzp0LGF0dHJzTGlzdDplLGF0dHJzTWFwOndjKGUpLHJhd0F0dHJzTWFwOnt9LHBhcmVudDpuLGNoaWxkcmVuOltdfX1mdW5jdGlvbiBnYyh0LGUpe2NjPWUud2Fybnx8T3IsZGM9ZS5pc1ByZVRhZ3x8TixwYz1lLm11c3RVc2VQcm9wfHxOLGhjPWUuZ2V0VGFnTmFtZXNwYWNlfHxOLGUuaXNSZXNlcnZlZFRhZyxsYz1UcihlLm1vZHVsZXMsXCJ0cmFuc2Zvcm1Ob2RlXCIpLHVjPVRyKGUubW9kdWxlcyxcInByZVRyYW5zZm9ybU5vZGVcIiksZmM9VHIoZS5tb2R1bGVzLFwicG9zdFRyYW5zZm9ybU5vZGVcIiksYWM9ZS5kZWxpbWl0ZXJzO2NvbnN0IG49W10sbz0hMSE9PWUucHJlc2VydmVXaGl0ZXNwYWNlLHI9ZS53aGl0ZXNwYWNlO2xldCBzLGksYz0hMSxhPSExO2Z1bmN0aW9uIGwodCl7aWYodSh0KSxjfHx0LnByb2Nlc3NlZHx8KHQ9dmModCxlKSksbi5sZW5ndGh8fHQ9PT1zfHxzLmlmJiYodC5lbHNlaWZ8fHQuZWxzZSkmJl9jKHMse2V4cDp0LmVsc2VpZixibG9jazp0fSksaSYmIXQuZm9yYmlkZGVuKWlmKHQuZWxzZWlmfHx0LmVsc2UpIWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1mdW5jdGlvbih0KXtsZXQgZT10Lmxlbmd0aDtmb3IoO2UtLTspe2lmKDE9PT10W2VdLnR5cGUpcmV0dXJuIHRbZV07dC5wb3AoKX19KGUuY2hpbGRyZW4pO24mJm4uaWYmJl9jKG4se2V4cDp0LmVsc2VpZixibG9jazp0fSl9KHQsaSk7ZWxzZXtpZih0LnNsb3RTY29wZSl7Y29uc3QgZT10LnNsb3RUYXJnZXR8fCdcImRlZmF1bHRcIic7KGkuc2NvcGVkU2xvdHN8fChpLnNjb3BlZFNsb3RzPXt9KSlbZV09dH1pLmNoaWxkcmVuLnB1c2godCksdC5wYXJlbnQ9aX10LmNoaWxkcmVuPXQuY2hpbGRyZW4uZmlsdGVyKCh0PT4hdC5zbG90U2NvcGUpKSx1KHQpLHQucHJlJiYoYz0hMSksZGModC50YWcpJiYoYT0hMSk7Zm9yKGxldCBuPTA7bjxmYy5sZW5ndGg7bisrKWZjW25dKHQsZSl9ZnVuY3Rpb24gdSh0KXtpZighYSl7bGV0IGU7Zm9yKDsoZT10LmNoaWxkcmVuW3QuY2hpbGRyZW4ubGVuZ3RoLTFdKSYmMz09PWUudHlwZSYmXCIgXCI9PT1lLnRleHQ7KXQuY2hpbGRyZW4ucG9wKCl9fXJldHVybiBmdW5jdGlvbih0LGUpe2NvbnN0IG49W10sbz1lLmV4cGVjdEhUTUwscj1lLmlzVW5hcnlUYWd8fE4scz1lLmNhbkJlTGVmdE9wZW5UYWd8fE47bGV0IGksYyxhPTA7Zm9yKDt0Oyl7aWYoaT10LGMmJkZpKGMpKXtsZXQgbj0wO2NvbnN0IG89Yy50b0xvd2VyQ2FzZSgpLHI9SGlbb118fChIaVtvXT1uZXcgUmVnRXhwKFwiKFtcXFxcc1xcXFxTXSo/KSg8L1wiK28rXCJbXj5dKj4pXCIsXCJpXCIpKSxzPXQucmVwbGFjZShyLChmdW5jdGlvbih0LHIscyl7cmV0dXJuIG49cy5sZW5ndGgsRmkobyl8fFwibm9zY3JpcHRcIj09PW98fChyPXIucmVwbGFjZSgvPCFcXC0tKFtcXHNcXFNdKj8pLS0+L2csXCIkMVwiKS5yZXBsYWNlKC88IVxcW0NEQVRBXFxbKFtcXHNcXFNdKj8pXV0+L2csXCIkMVwiKSksS2kobyxyKSYmKHI9ci5zbGljZSgxKSksZS5jaGFycyYmZS5jaGFycyhyKSxcIlwifSkpO2ErPXQubGVuZ3RoLXMubGVuZ3RoLHQ9cyxkKG8sYS1uLGEpfWVsc2V7bGV0IG4sbyxyLHM9dC5pbmRleE9mKFwiPFwiKTtpZigwPT09cyl7aWYoTGkudGVzdCh0KSl7Y29uc3Qgbj10LmluZGV4T2YoXCItLVxceDNlXCIpO2lmKG4+PTApe2Uuc2hvdWxkS2VlcENvbW1lbnQmJmUuY29tbWVudCYmZS5jb21tZW50KHQuc3Vic3RyaW5nKDQsbiksYSxhK24rMyksbChuKzMpO2NvbnRpbnVlfX1pZihSaS50ZXN0KHQpKXtjb25zdCBlPXQuaW5kZXhPZihcIl0+XCIpO2lmKGU+PTApe2woZSsyKTtjb250aW51ZX19Y29uc3Qgbj10Lm1hdGNoKElpKTtpZihuKXtsKG5bMF0ubGVuZ3RoKTtjb250aW51ZX1jb25zdCBvPXQubWF0Y2goTWkpO2lmKG8pe2NvbnN0IHQ9YTtsKG9bMF0ubGVuZ3RoKSxkKG9bMV0sdCxhKTtjb250aW51ZX1jb25zdCByPXUoKTtpZihyKXtmKHIpLEtpKHIudGFnTmFtZSx0KSYmbCgxKTtjb250aW51ZX19aWYocz49MCl7Zm9yKG89dC5zbGljZShzKTshKE1pLnRlc3Qobyl8fFBpLnRlc3Qobyl8fExpLnRlc3Qobyl8fFJpLnRlc3Qobyl8fChyPW8uaW5kZXhPZihcIjxcIiwxKSxyPDApKTspcys9cixvPXQuc2xpY2Uocyk7bj10LnN1YnN0cmluZygwLHMpfXM8MCYmKG49dCksbiYmbChuLmxlbmd0aCksZS5jaGFycyYmbiYmZS5jaGFycyhuLGEtbi5sZW5ndGgsYSl9aWYodD09PWkpe2UuY2hhcnMmJmUuY2hhcnModCk7YnJlYWt9fWZ1bmN0aW9uIGwoZSl7YSs9ZSx0PXQuc3Vic3RyaW5nKGUpfWZ1bmN0aW9uIHUoKXtjb25zdCBlPXQubWF0Y2goUGkpO2lmKGUpe2NvbnN0IG49e3RhZ05hbWU6ZVsxXSxhdHRyczpbXSxzdGFydDphfTtsZXQgbyxyO2ZvcihsKGVbMF0ubGVuZ3RoKTshKG89dC5tYXRjaChEaSkpJiYocj10Lm1hdGNoKGppKXx8dC5tYXRjaChBaSkpOylyLnN0YXJ0PWEsbChyWzBdLmxlbmd0aCksci5lbmQ9YSxuLmF0dHJzLnB1c2gocik7aWYobylyZXR1cm4gbi51bmFyeVNsYXNoPW9bMV0sbChvWzBdLmxlbmd0aCksbi5lbmQ9YSxufX1mdW5jdGlvbiBmKHQpe2NvbnN0IGk9dC50YWdOYW1lLGE9dC51bmFyeVNsYXNoO28mJihcInBcIj09PWMmJlRpKGkpJiZkKGMpLHMoaSkmJmM9PT1pJiZkKGkpKTtjb25zdCBsPXIoaSl8fCEhYSx1PXQuYXR0cnMubGVuZ3RoLGY9bmV3IEFycmF5KHUpO2ZvcihsZXQgbj0wO248dTtuKyspe2NvbnN0IG89dC5hdHRyc1tuXSxyPW9bM118fG9bNF18fG9bNV18fFwiXCIscz1cImFcIj09PWkmJlwiaHJlZlwiPT09b1sxXT9lLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZjplLnNob3VsZERlY29kZU5ld2xpbmVzO2Zbbl09e25hbWU6b1sxXSx2YWx1ZTpKaShyLHMpfX1sfHwobi5wdXNoKHt0YWc6aSxsb3dlckNhc2VkVGFnOmkudG9Mb3dlckNhc2UoKSxhdHRyczpmLHN0YXJ0OnQuc3RhcnQsZW5kOnQuZW5kfSksYz1pKSxlLnN0YXJ0JiZlLnN0YXJ0KGksZixsLHQuc3RhcnQsdC5lbmQpfWZ1bmN0aW9uIGQodCxvLHIpe2xldCBzLGk7aWYobnVsbD09byYmKG89YSksbnVsbD09ciYmKHI9YSksdClmb3IoaT10LnRvTG93ZXJDYXNlKCkscz1uLmxlbmd0aC0xO3M+PTAmJm5bc10ubG93ZXJDYXNlZFRhZyE9PWk7cy0tKTtlbHNlIHM9MDtpZihzPj0wKXtmb3IobGV0IHQ9bi5sZW5ndGgtMTt0Pj1zO3QtLSllLmVuZCYmZS5lbmQoblt0XS50YWcsbyxyKTtuLmxlbmd0aD1zLGM9cyYmbltzLTFdLnRhZ31lbHNlXCJiclwiPT09aT9lLnN0YXJ0JiZlLnN0YXJ0KHQsW10sITAsbyxyKTpcInBcIj09PWkmJihlLnN0YXJ0JiZlLnN0YXJ0KHQsW10sITEsbyxyKSxlLmVuZCYmZS5lbmQodCxvLHIpKX1kKCl9KHQse3dhcm46Y2MsZXhwZWN0SFRNTDplLmV4cGVjdEhUTUwsaXNVbmFyeVRhZzplLmlzVW5hcnlUYWcsY2FuQmVMZWZ0T3BlblRhZzplLmNhbkJlTGVmdE9wZW5UYWcsc2hvdWxkRGVjb2RlTmV3bGluZXM6ZS5zaG91bGREZWNvZGVOZXdsaW5lcyxzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6ZS5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWYsc2hvdWxkS2VlcENvbW1lbnQ6ZS5jb21tZW50cyxvdXRwdXRTb3VyY2VSYW5nZTplLm91dHB1dFNvdXJjZVJhbmdlLHN0YXJ0KHQsbyxyLHUsZil7Y29uc3QgZD1pJiZpLm5zfHxoYyh0KTtaJiZcInN2Z1wiPT09ZCYmKG89ZnVuY3Rpb24odCl7Y29uc3QgZT1bXTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7Y29uc3Qgbz10W25dO3hjLnRlc3Qoby5uYW1lKXx8KG8ubmFtZT1vLm5hbWUucmVwbGFjZShDYyxcIlwiKSxlLnB1c2gobykpfXJldHVybiBlfShvKSk7bGV0IHA9bWModCxvLGkpO3ZhciBoO2QmJihwLm5zPWQpLFwic3R5bGVcIiE9PShoPXApLnRhZyYmKFwic2NyaXB0XCIhPT1oLnRhZ3x8aC5hdHRyc01hcC50eXBlJiZcInRleHQvamF2YXNjcmlwdFwiIT09aC5hdHRyc01hcC50eXBlKXx8b3QoKXx8KHAuZm9yYmlkZGVuPSEwKTtmb3IobGV0IHQ9MDt0PHVjLmxlbmd0aDt0KyspcD11Y1t0XShwLGUpfHxwO2N8fCghZnVuY3Rpb24odCl7bnVsbCE9SXIodCxcInYtcHJlXCIpJiYodC5wcmU9ITApfShwKSxwLnByZSYmKGM9ITApKSxkYyhwLnRhZykmJihhPSEwKSxjP2Z1bmN0aW9uKHQpe2NvbnN0IGU9dC5hdHRyc0xpc3Qsbj1lLmxlbmd0aDtpZihuKXtjb25zdCBvPXQuYXR0cnM9bmV3IEFycmF5KG4pO2ZvcihsZXQgdD0wO3Q8bjt0Kyspb1t0XT17bmFtZTplW3RdLm5hbWUsdmFsdWU6SlNPTi5zdHJpbmdpZnkoZVt0XS52YWx1ZSl9LG51bGwhPWVbdF0uc3RhcnQmJihvW3RdLnN0YXJ0PWVbdF0uc3RhcnQsb1t0XS5lbmQ9ZVt0XS5lbmQpfWVsc2UgdC5wcmV8fCh0LnBsYWluPSEwKX0ocCk6cC5wcm9jZXNzZWR8fCh5YyhwKSxmdW5jdGlvbih0KXtjb25zdCBlPUlyKHQsXCJ2LWlmXCIpO2lmKGUpdC5pZj1lLF9jKHQse2V4cDplLGJsb2NrOnR9KTtlbHNle251bGwhPUlyKHQsXCJ2LWVsc2VcIikmJih0LmVsc2U9ITApO2NvbnN0IGU9SXIodCxcInYtZWxzZS1pZlwiKTtlJiYodC5lbHNlaWY9ZSl9fShwKSxmdW5jdGlvbih0KXtjb25zdCBlPUlyKHQsXCJ2LW9uY2VcIik7bnVsbCE9ZSYmKHQub25jZT0hMCl9KHApKSxzfHwocz1wKSxyP2wocCk6KGk9cCxuLnB1c2gocCkpfSxlbmQodCxlLG8pe2NvbnN0IHI9bltuLmxlbmd0aC0xXTtuLmxlbmd0aC09MSxpPW5bbi5sZW5ndGgtMV0sbChyKX0sY2hhcnModCxlLG4pe2lmKCFpKXJldHVybjtpZihaJiZcInRleHRhcmVhXCI9PT1pLnRhZyYmaS5hdHRyc01hcC5wbGFjZWhvbGRlcj09PXQpcmV0dXJuO2NvbnN0IHM9aS5jaGlsZHJlbjt2YXIgbDtpZih0PWF8fHQudHJpbSgpP1wic2NyaXB0XCI9PT0obD1pKS50YWd8fFwic3R5bGVcIj09PWwudGFnP3Q6c2ModCk6cy5sZW5ndGg/cj9cImNvbmRlbnNlXCI9PT1yJiZvYy50ZXN0KHQpP1wiXCI6XCIgXCI6bz9cIiBcIjpcIlwiOlwiXCIpe2xldCBlLG47YXx8XCJjb25kZW5zZVwiIT09cnx8KHQ9dC5yZXBsYWNlKHJjLFwiIFwiKSksIWMmJlwiIFwiIT09dCYmKGU9ZnVuY3Rpb24odCxlKXtjb25zdCBuPWU/YmkoZSk6X2k7aWYoIW4udGVzdCh0KSlyZXR1cm47Y29uc3Qgbz1bXSxyPVtdO2xldCBzLGksYyxhPW4ubGFzdEluZGV4PTA7Zm9yKDtzPW4uZXhlYyh0KTspe2k9cy5pbmRleCxpPmEmJihyLnB1c2goYz10LnNsaWNlKGEsaSkpLG8ucHVzaChKU09OLnN0cmluZ2lmeShjKSkpO2NvbnN0IGU9a3Ioc1sxXS50cmltKCkpO28ucHVzaChgX3MoJHtlfSlgKSxyLnB1c2goe1wiQGJpbmRpbmdcIjplfSksYT1pK3NbMF0ubGVuZ3RofXJldHVybiBhPHQubGVuZ3RoJiYoci5wdXNoKGM9dC5zbGljZShhKSksby5wdXNoKEpTT04uc3RyaW5naWZ5KGMpKSkse2V4cHJlc3Npb246by5qb2luKFwiK1wiKSx0b2tlbnM6cn19KHQsYWMpKT9uPXt0eXBlOjIsZXhwcmVzc2lvbjplLmV4cHJlc3Npb24sdG9rZW5zOmUudG9rZW5zLHRleHQ6dH06XCIgXCI9PT10JiZzLmxlbmd0aCYmXCIgXCI9PT1zW3MubGVuZ3RoLTFdLnRleHR8fChuPXt0eXBlOjMsdGV4dDp0fSksbiYmcy5wdXNoKG4pfX0sY29tbWVudCh0LGUsbil7aWYoaSl7Y29uc3QgZT17dHlwZTozLHRleHQ6dCxpc0NvbW1lbnQ6ITB9O2kuY2hpbGRyZW4ucHVzaChlKX19fSksc31mdW5jdGlvbiB2Yyh0LGUpe3ZhciBuOyFmdW5jdGlvbih0KXtjb25zdCBlPU1yKHQsXCJrZXlcIik7ZSYmKHQua2V5PWUpfSh0KSx0LnBsYWluPSF0LmtleSYmIXQuc2NvcGVkU2xvdHMmJiF0LmF0dHJzTGlzdC5sZW5ndGgsZnVuY3Rpb24odCl7Y29uc3QgZT1Ncih0LFwicmVmXCIpO2UmJih0LnJlZj1lLHQucmVmSW5Gb3I9ZnVuY3Rpb24odCl7bGV0IGU9dDtmb3IoO2U7KXtpZih2b2lkIDAhPT1lLmZvcilyZXR1cm4hMDtlPWUucGFyZW50fXJldHVybiExfSh0KSl9KHQpLGZ1bmN0aW9uKHQpe2xldCBlO1widGVtcGxhdGVcIj09PXQudGFnPyhlPUlyKHQsXCJzY29wZVwiKSx0LnNsb3RTY29wZT1lfHxJcih0LFwic2xvdC1zY29wZVwiKSk6KGU9SXIodCxcInNsb3Qtc2NvcGVcIikpJiYodC5zbG90U2NvcGU9ZSk7Y29uc3Qgbj1Ncih0LFwic2xvdFwiKTtuJiYodC5zbG90VGFyZ2V0PSdcIlwiJz09PW4/J1wiZGVmYXVsdFwiJzpuLHQuc2xvdFRhcmdldER5bmFtaWM9ISghdC5hdHRyc01hcFtcIjpzbG90XCJdJiYhdC5hdHRyc01hcFtcInYtYmluZDpzbG90XCJdKSxcInRlbXBsYXRlXCI9PT10LnRhZ3x8dC5zbG90U2NvcGV8fGpyKHQsXCJzbG90XCIsbixmdW5jdGlvbih0LGUpe3JldHVybiB0LnJhd0F0dHJzTWFwW1wiOlwiK2VdfHx0LnJhd0F0dHJzTWFwW1widi1iaW5kOlwiK2VdfHx0LnJhd0F0dHJzTWFwW2VdfSh0LFwic2xvdFwiKSkpO2lmKFwidGVtcGxhdGVcIj09PXQudGFnKXtjb25zdCBlPUxyKHQsbmMpO2lmKGUpe2NvbnN0e25hbWU6bixkeW5hbWljOm99PSRjKGUpO3Quc2xvdFRhcmdldD1uLHQuc2xvdFRhcmdldER5bmFtaWM9byx0LnNsb3RTY29wZT1lLnZhbHVlfHxpY319ZWxzZXtjb25zdCBlPUxyKHQsbmMpO2lmKGUpe2NvbnN0IG49dC5zY29wZWRTbG90c3x8KHQuc2NvcGVkU2xvdHM9e30pLHtuYW1lOm8sZHluYW1pYzpyfT0kYyhlKSxzPW5bb109bWMoXCJ0ZW1wbGF0ZVwiLFtdLHQpO3Muc2xvdFRhcmdldD1vLHMuc2xvdFRhcmdldER5bmFtaWM9cixzLmNoaWxkcmVuPXQuY2hpbGRyZW4uZmlsdGVyKCh0PT57aWYoIXQuc2xvdFNjb3BlKXJldHVybiB0LnBhcmVudD1zLCEwfSkpLHMuc2xvdFNjb3BlPWUudmFsdWV8fGljLHQuY2hpbGRyZW49W10sdC5wbGFpbj0hMX19fSh0KSxcInNsb3RcIj09PShuPXQpLnRhZyYmKG4uc2xvdE5hbWU9TXIobixcIm5hbWVcIikpLGZ1bmN0aW9uKHQpe2xldCBlOyhlPU1yKHQsXCJpc1wiKSkmJih0LmNvbXBvbmVudD1lKTtudWxsIT1Jcih0LFwiaW5saW5lLXRlbXBsYXRlXCIpJiYodC5pbmxpbmVUZW1wbGF0ZT0hMCl9KHQpO2ZvcihsZXQgbj0wO248bGMubGVuZ3RoO24rKyl0PWxjW25dKHQsZSl8fHQ7cmV0dXJuIGZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5hdHRyc0xpc3Q7bGV0IG4sbyxyLHMsaSxjLGEsbDtmb3Iobj0wLG89ZS5sZW5ndGg7bjxvO24rKylpZihyPXM9ZVtuXS5uYW1lLGk9ZVtuXS52YWx1ZSxXaS50ZXN0KHIpKWlmKHQuaGFzQmluZGluZ3M9ITAsYz1iYyhyLnJlcGxhY2UoV2ksXCJcIikpLGMmJihyPXIucmVwbGFjZShlYyxcIlwiKSksdGMudGVzdChyKSlyPXIucmVwbGFjZSh0YyxcIlwiKSxpPWtyKGkpLGw9WWkudGVzdChyKSxsJiYocj1yLnNsaWNlKDEsLTEpKSxjJiYoYy5wcm9wJiYhbCYmKHI9eChyKSxcImlubmVySHRtbFwiPT09ciYmKHI9XCJpbm5lckhUTUxcIikpLGMuY2FtZWwmJiFsJiYocj14KHIpKSxjLnN5bmMmJihhPUhyKGksXCIkZXZlbnRcIiksbD9Ecih0LGBcInVwZGF0ZTpcIisoJHtyfSlgLGEsbnVsbCwhMSwwLGVbbl0sITApOihEcih0LGB1cGRhdGU6JHt4KHIpfWAsYSxudWxsLCExLDAsZVtuXSksUyhyKSE9PXgocikmJkRyKHQsYHVwZGF0ZToke1Mocil9YCxhLG51bGwsITEsMCxlW25dKSkpKSxjJiZjLnByb3B8fCF0LmNvbXBvbmVudCYmcGModC50YWcsdC5hdHRyc01hcC50eXBlLHIpP0FyKHQscixpLGVbbl0sbCk6anIodCxyLGksZVtuXSxsKTtlbHNlIGlmKHFpLnRlc3Qocikpcj1yLnJlcGxhY2UocWksXCJcIiksbD1ZaS50ZXN0KHIpLGwmJihyPXIuc2xpY2UoMSwtMSkpLERyKHQscixpLGMsITEsMCxlW25dLGwpO2Vsc2V7cj1yLnJlcGxhY2UoV2ksXCJcIik7Y29uc3Qgbz1yLm1hdGNoKFFpKTtsZXQgYT1vJiZvWzFdO2w9ITEsYSYmKHI9ci5zbGljZSgwLC0oYS5sZW5ndGgrMSkpLFlpLnRlc3QoYSkmJihhPWEuc2xpY2UoMSwtMSksbD0hMCkpLE5yKHQscixzLGksYSxsLGMsZVtuXSl9ZWxzZSBqcih0LHIsSlNPTi5zdHJpbmdpZnkoaSksZVtuXSksIXQuY29tcG9uZW50JiZcIm11dGVkXCI9PT1yJiZwYyh0LnRhZyx0LmF0dHJzTWFwLnR5cGUscikmJkFyKHQscixcInRydWVcIixlW25dKX0odCksdH1mdW5jdGlvbiB5Yyh0KXtsZXQgZTtpZihlPUlyKHQsXCJ2LWZvclwiKSl7Y29uc3Qgbj1mdW5jdGlvbih0KXtjb25zdCBlPXQubWF0Y2goWmkpO2lmKCFlKXJldHVybjtjb25zdCBuPXt9O24uZm9yPWVbMl0udHJpbSgpO2NvbnN0IG89ZVsxXS50cmltKCkucmVwbGFjZShYaSxcIlwiKSxyPW8ubWF0Y2goR2kpO3I/KG4uYWxpYXM9by5yZXBsYWNlKEdpLFwiXCIpLnRyaW0oKSxuLml0ZXJhdG9yMT1yWzFdLnRyaW0oKSxyWzJdJiYobi5pdGVyYXRvcjI9clsyXS50cmltKCkpKTpuLmFsaWFzPW87cmV0dXJuIG59KGUpO24mJkEodCxuKX19ZnVuY3Rpb24gX2ModCxlKXt0LmlmQ29uZGl0aW9uc3x8KHQuaWZDb25kaXRpb25zPVtdKSx0LmlmQ29uZGl0aW9ucy5wdXNoKGUpfWZ1bmN0aW9uICRjKHQpe2xldCBlPXQubmFtZS5yZXBsYWNlKG5jLFwiXCIpO3JldHVybiBlfHxcIiNcIiE9PXQubmFtZVswXSYmKGU9XCJkZWZhdWx0XCIpLFlpLnRlc3QoZSk/e25hbWU6ZS5zbGljZSgxLC0xKSxkeW5hbWljOiEwfTp7bmFtZTpgXCIke2V9XCJgLGR5bmFtaWM6ITF9fWZ1bmN0aW9uIGJjKHQpe2NvbnN0IGU9dC5tYXRjaChlYyk7aWYoZSl7Y29uc3QgdD17fTtyZXR1cm4gZS5mb3JFYWNoKChlPT57dFtlLnNsaWNlKDEpXT0hMH0pKSx0fX1mdW5jdGlvbiB3Yyh0KXtjb25zdCBlPXt9O2ZvcihsZXQgbj0wLG89dC5sZW5ndGg7bjxvO24rKyllW3Rbbl0ubmFtZV09dFtuXS52YWx1ZTtyZXR1cm4gZX1jb25zdCB4Yz0vXnhtbG5zOk5TXFxkKy8sQ2M9L15OU1xcZCs6LztmdW5jdGlvbiBrYyh0KXtyZXR1cm4gbWModC50YWcsdC5hdHRyc0xpc3Quc2xpY2UoKSx0LnBhcmVudCl9dmFyIFNjPVt3aSx4aSx7cHJlVHJhbnNmb3JtTm9kZTpmdW5jdGlvbih0LGUpe2lmKFwiaW5wdXRcIj09PXQudGFnKXtjb25zdCBuPXQuYXR0cnNNYXA7aWYoIW5bXCJ2LW1vZGVsXCJdKXJldHVybjtsZXQgbztpZigobltcIjp0eXBlXCJdfHxuW1widi1iaW5kOnR5cGVcIl0pJiYobz1Ncih0LFwidHlwZVwiKSksbi50eXBlfHxvfHwhbltcInYtYmluZFwiXXx8KG89YCgke25bXCJ2LWJpbmRcIl19KS50eXBlYCksbyl7Y29uc3Qgbj1Jcih0LFwidi1pZlwiLCEwKSxyPW4/YCYmKCR7bn0pYDpcIlwiLHM9bnVsbCE9SXIodCxcInYtZWxzZVwiLCEwKSxpPUlyKHQsXCJ2LWVsc2UtaWZcIiwhMCksYz1rYyh0KTt5YyhjKSxFcihjLFwidHlwZVwiLFwiY2hlY2tib3hcIiksdmMoYyxlKSxjLnByb2Nlc3NlZD0hMCxjLmlmPWAoJHtvfSk9PT0nY2hlY2tib3gnYCtyLF9jKGMse2V4cDpjLmlmLGJsb2NrOmN9KTtjb25zdCBhPWtjKHQpO0lyKGEsXCJ2LWZvclwiLCEwKSxFcihhLFwidHlwZVwiLFwicmFkaW9cIiksdmMoYSxlKSxfYyhjLHtleHA6YCgke299KT09PSdyYWRpbydgK3IsYmxvY2s6YX0pO2NvbnN0IGw9a2ModCk7cmV0dXJuIElyKGwsXCJ2LWZvclwiLCEwKSxFcihsLFwiOnR5cGVcIixvKSx2YyhsLGUpLF9jKGMse2V4cDpuLGJsb2NrOmx9KSxzP2MuZWxzZT0hMDppJiYoYy5lbHNlaWY9aSksY319fX1dO2NvbnN0IE9jPXtleHBlY3RIVE1MOiEwLG1vZHVsZXM6U2MsZGlyZWN0aXZlczp7bW9kZWw6ZnVuY3Rpb24odCxlLG4pe2NvbnN0IG89ZS52YWx1ZSxyPWUubW9kaWZpZXJzLHM9dC50YWcsaT10LmF0dHJzTWFwLnR5cGU7aWYodC5jb21wb25lbnQpcmV0dXJuIEZyKHQsbyxyKSwhMTtpZihcInNlbGVjdFwiPT09cykhZnVuY3Rpb24odCxlLG4pe2NvbnN0IG89biYmbi5udW1iZXI7bGV0IHI9YHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO3JldHVybiAke28/XCJfbih2YWwpXCI6XCJ2YWxcIn19KTtgO3I9YCR7cn0gJHtIcihlLFwiJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdXCIpfWAsRHIodCxcImNoYW5nZVwiLHIsbnVsbCwhMCl9KHQsbyxyKTtlbHNlIGlmKFwiaW5wdXRcIj09PXMmJlwiY2hlY2tib3hcIj09PWkpIWZ1bmN0aW9uKHQsZSxuKXtjb25zdCBvPW4mJm4ubnVtYmVyLHI9TXIodCxcInZhbHVlXCIpfHxcIm51bGxcIixzPU1yKHQsXCJ0cnVlLXZhbHVlXCIpfHxcInRydWVcIixpPU1yKHQsXCJmYWxzZS12YWx1ZVwiKXx8XCJmYWxzZVwiO0FyKHQsXCJjaGVja2VkXCIsYEFycmF5LmlzQXJyYXkoJHtlfSk/X2koJHtlfSwke3J9KT4tMWArKFwidHJ1ZVwiPT09cz9gOigke2V9KWA6YDpfcSgke2V9LCR7c30pYCkpLERyKHQsXCJjaGFuZ2VcIixgdmFyICQkYT0ke2V9LCQkZWw9JGV2ZW50LnRhcmdldCwkJGM9JCRlbC5jaGVja2VkPygke3N9KTooJHtpfSk7aWYoQXJyYXkuaXNBcnJheSgkJGEpKXt2YXIgJCR2PSR7bz9cIl9uKFwiK3IrXCIpXCI6cn0sJCRpPV9pKCQkYSwkJHYpO2lmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJigke0hyKGUsXCIkJGEuY29uY2F0KFskJHZdKVwiKX0pfWVsc2V7JCRpPi0xJiYoJHtIcihlLFwiJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSlcIil9KX19ZWxzZXske0hyKGUsXCIkJGNcIil9fWAsbnVsbCwhMCl9KHQsbyxyKTtlbHNlIGlmKFwiaW5wdXRcIj09PXMmJlwicmFkaW9cIj09PWkpIWZ1bmN0aW9uKHQsZSxuKXtjb25zdCBvPW4mJm4ubnVtYmVyO2xldCByPU1yKHQsXCJ2YWx1ZVwiKXx8XCJudWxsXCI7cj1vP2Bfbigke3J9KWA6cixBcih0LFwiY2hlY2tlZFwiLGBfcSgke2V9LCR7cn0pYCksRHIodCxcImNoYW5nZVwiLEhyKGUsciksbnVsbCwhMCl9KHQsbyxyKTtlbHNlIGlmKFwiaW5wdXRcIj09PXN8fFwidGV4dGFyZWFcIj09PXMpIWZ1bmN0aW9uKHQsZSxuKXtjb25zdCBvPXQuYXR0cnNNYXAudHlwZSx7bGF6eTpyLG51bWJlcjpzLHRyaW06aX09bnx8e30sYz0hciYmXCJyYW5nZVwiIT09byxhPXI/XCJjaGFuZ2VcIjpcInJhbmdlXCI9PT1vP1lyOlwiaW5wdXRcIjtsZXQgbD1cIiRldmVudC50YXJnZXQudmFsdWVcIjtpJiYobD1cIiRldmVudC50YXJnZXQudmFsdWUudHJpbSgpXCIpO3MmJihsPWBfbigke2x9KWApO2xldCB1PUhyKGUsbCk7YyYmKHU9YGlmKCRldmVudC50YXJnZXQuY29tcG9zaW5nKXJldHVybjske3V9YCk7QXIodCxcInZhbHVlXCIsYCgke2V9KWApLERyKHQsYSx1LG51bGwsITApLChpfHxzKSYmRHIodCxcImJsdXJcIixcIiRmb3JjZVVwZGF0ZSgpXCIpfSh0LG8scik7ZWxzZSBpZighQi5pc1Jlc2VydmVkVGFnKHMpKXJldHVybiBGcih0LG8sciksITE7cmV0dXJuITB9LHRleHQ6ZnVuY3Rpb24odCxlKXtlLnZhbHVlJiZBcih0LFwidGV4dENvbnRlbnRcIixgX3MoJHtlLnZhbHVlfSlgLGUpfSxodG1sOmZ1bmN0aW9uKHQsZSl7ZS52YWx1ZSYmQXIodCxcImlubmVySFRNTFwiLGBfcygke2UudmFsdWV9KWAsZSl9fSxpc1ByZVRhZzp0PT5cInByZVwiPT09dCxpc1VuYXJ5VGFnOlNpLG11c3RVc2VQcm9wOklvLGNhbkJlTGVmdE9wZW5UYWc6T2ksaXNSZXNlcnZlZFRhZzpZbyxnZXRUYWdOYW1lc3BhY2U6UW8sc3RhdGljS2V5czpmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWR1Y2UoKCh0LGUpPT50LmNvbmNhdChlLnN0YXRpY0tleXN8fFtdKSksW10pLmpvaW4oXCIsXCIpfShTYyl9O2xldCBUYyxBYztjb25zdCBqYz1iKChmdW5jdGlvbih0KXtyZXR1cm4gbShcInR5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwXCIrKHQ/XCIsXCIrdDpcIlwiKSl9KSk7ZnVuY3Rpb24gRWModCxlKXt0JiYoVGM9amMoZS5zdGF0aWNLZXlzfHxcIlwiKSxBYz1lLmlzUmVzZXJ2ZWRUYWd8fE4sTmModCksUGModCwhMSkpfWZ1bmN0aW9uIE5jKHQpe2lmKHQuc3RhdGljPWZ1bmN0aW9uKHQpe2lmKDI9PT10LnR5cGUpcmV0dXJuITE7aWYoMz09PXQudHlwZSlyZXR1cm4hMDtyZXR1cm4hKCF0LnByZSYmKHQuaGFzQmluZGluZ3N8fHQuaWZ8fHQuZm9yfHxnKHQudGFnKXx8IUFjKHQudGFnKXx8ZnVuY3Rpb24odCl7Zm9yKDt0LnBhcmVudDspe2lmKFwidGVtcGxhdGVcIiE9PSh0PXQucGFyZW50KS50YWcpcmV0dXJuITE7aWYodC5mb3IpcmV0dXJuITB9cmV0dXJuITF9KHQpfHwhT2JqZWN0LmtleXModCkuZXZlcnkoVGMpKSl9KHQpLDE9PT10LnR5cGUpe2lmKCFBYyh0LnRhZykmJlwic2xvdFwiIT09dC50YWcmJm51bGw9PXQuYXR0cnNNYXBbXCJpbmxpbmUtdGVtcGxhdGVcIl0pcmV0dXJuO2ZvcihsZXQgZT0wLG49dC5jaGlsZHJlbi5sZW5ndGg7ZTxuO2UrKyl7Y29uc3Qgbj10LmNoaWxkcmVuW2VdO05jKG4pLG4uc3RhdGljfHwodC5zdGF0aWM9ITEpfWlmKHQuaWZDb25kaXRpb25zKWZvcihsZXQgZT0xLG49dC5pZkNvbmRpdGlvbnMubGVuZ3RoO2U8bjtlKyspe2NvbnN0IG49dC5pZkNvbmRpdGlvbnNbZV0uYmxvY2s7TmMobiksbi5zdGF0aWN8fCh0LnN0YXRpYz0hMSl9fX1mdW5jdGlvbiBQYyh0LGUpe2lmKDE9PT10LnR5cGUpe2lmKCh0LnN0YXRpY3x8dC5vbmNlKSYmKHQuc3RhdGljSW5Gb3I9ZSksdC5zdGF0aWMmJnQuY2hpbGRyZW4ubGVuZ3RoJiYoMSE9PXQuY2hpbGRyZW4ubGVuZ3RofHwzIT09dC5jaGlsZHJlblswXS50eXBlKSlyZXR1cm4gdm9pZCh0LnN0YXRpY1Jvb3Q9ITApO2lmKHQuc3RhdGljUm9vdD0hMSx0LmNoaWxkcmVuKWZvcihsZXQgbj0wLG89dC5jaGlsZHJlbi5sZW5ndGg7bjxvO24rKylQYyh0LmNoaWxkcmVuW25dLGV8fCEhdC5mb3IpO2lmKHQuaWZDb25kaXRpb25zKWZvcihsZXQgbj0xLG89dC5pZkNvbmRpdGlvbnMubGVuZ3RoO248bztuKyspUGModC5pZkNvbmRpdGlvbnNbbl0uYmxvY2ssZSl9fWNvbnN0IERjPS9eKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uKD86XFxzK1tcXHckXSspP1xccypcXCgvLE1jPS9cXChbXildKj9cXCk7KiQvLEljPS9eW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnW14nXSo/J118XFxbXCJbXlwiXSo/XCJdfFxcW1xcZCtdfFxcW1tBLVphLXpfJF1bXFx3JF0qXSkqJC8sTGM9e2VzYzoyNyx0YWI6OSxlbnRlcjoxMyxzcGFjZTozMix1cDozOCxsZWZ0OjM3LHJpZ2h0OjM5LGRvd246NDAsZGVsZXRlOls4LDQ2XX0sUmM9e2VzYzpbXCJFc2NcIixcIkVzY2FwZVwiXSx0YWI6XCJUYWJcIixlbnRlcjpcIkVudGVyXCIsc3BhY2U6W1wiIFwiLFwiU3BhY2ViYXJcIl0sdXA6W1wiVXBcIixcIkFycm93VXBcIl0sbGVmdDpbXCJMZWZ0XCIsXCJBcnJvd0xlZnRcIl0scmlnaHQ6W1wiUmlnaHRcIixcIkFycm93UmlnaHRcIl0sZG93bjpbXCJEb3duXCIsXCJBcnJvd0Rvd25cIl0sZGVsZXRlOltcIkJhY2tzcGFjZVwiLFwiRGVsZXRlXCIsXCJEZWxcIl19LEZjPXQ9PmBpZigke3R9KXJldHVybiBudWxsO2AsSGM9e3N0b3A6XCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XCIscHJldmVudDpcIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1wiLHNlbGY6RmMoXCIkZXZlbnQudGFyZ2V0ICE9PSAkZXZlbnQuY3VycmVudFRhcmdldFwiKSxjdHJsOkZjKFwiISRldmVudC5jdHJsS2V5XCIpLHNoaWZ0OkZjKFwiISRldmVudC5zaGlmdEtleVwiKSxhbHQ6RmMoXCIhJGV2ZW50LmFsdEtleVwiKSxtZXRhOkZjKFwiISRldmVudC5tZXRhS2V5XCIpLGxlZnQ6RmMoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxtaWRkbGU6RmMoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMVwiKSxyaWdodDpGYyhcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAyXCIpfTtmdW5jdGlvbiBCYyh0LGUpe2NvbnN0IG49ZT9cIm5hdGl2ZU9uOlwiOlwib246XCI7bGV0IG89XCJcIixyPVwiXCI7Zm9yKGNvbnN0IGUgaW4gdCl7Y29uc3Qgbj1VYyh0W2VdKTt0W2VdJiZ0W2VdLmR5bmFtaWM/cis9YCR7ZX0sJHtufSxgOm8rPWBcIiR7ZX1cIjoke259LGB9cmV0dXJuIG89YHske28uc2xpY2UoMCwtMSl9fWAscj9uK2BfZCgke299LFske3Iuc2xpY2UoMCwtMSl9XSlgOm4rb31mdW5jdGlvbiBVYyh0KXtpZighdClyZXR1cm5cImZ1bmN0aW9uKCl7fVwiO2lmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuYFske3QubWFwKCh0PT5VYyh0KSkpLmpvaW4oXCIsXCIpfV1gO2NvbnN0IGU9SWMudGVzdCh0LnZhbHVlKSxuPURjLnRlc3QodC52YWx1ZSksbz1JYy50ZXN0KHQudmFsdWUucmVwbGFjZShNYyxcIlwiKSk7aWYodC5tb2RpZmllcnMpe2xldCByPVwiXCIscz1cIlwiO2NvbnN0IGk9W107Zm9yKGNvbnN0IGUgaW4gdC5tb2RpZmllcnMpaWYoSGNbZV0pcys9SGNbZV0sTGNbZV0mJmkucHVzaChlKTtlbHNlIGlmKFwiZXhhY3RcIj09PWUpe2NvbnN0IGU9dC5tb2RpZmllcnM7cys9RmMoW1wiY3RybFwiLFwic2hpZnRcIixcImFsdFwiLFwibWV0YVwiXS5maWx0ZXIoKHQ9PiFlW3RdKSkubWFwKCh0PT5gJGV2ZW50LiR7dH1LZXlgKSkuam9pbihcInx8XCIpKX1lbHNlIGkucHVzaChlKTtpLmxlbmd0aCYmKHIrPWZ1bmN0aW9uKHQpe3JldHVybmBpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJiR7dC5tYXAoemMpLmpvaW4oXCImJlwiKX0pcmV0dXJuIG51bGw7YH0oaSkpLHMmJihyKz1zKTtyZXR1cm5gZnVuY3Rpb24oJGV2ZW50KXske3J9JHtlP2ByZXR1cm4gJHt0LnZhbHVlfS5hcHBseShudWxsLCBhcmd1bWVudHMpYDpuP2ByZXR1cm4gKCR7dC52YWx1ZX0pLmFwcGx5KG51bGwsIGFyZ3VtZW50cylgOm8/YHJldHVybiAke3QudmFsdWV9YDp0LnZhbHVlfX1gfXJldHVybiBlfHxuP3QudmFsdWU6YGZ1bmN0aW9uKCRldmVudCl7JHtvP2ByZXR1cm4gJHt0LnZhbHVlfWA6dC52YWx1ZX19YH1mdW5jdGlvbiB6Yyh0KXtjb25zdCBlPXBhcnNlSW50KHQsMTApO2lmKGUpcmV0dXJuYCRldmVudC5rZXlDb2RlIT09JHtlfWA7Y29uc3Qgbj1MY1t0XSxvPVJjW3RdO3JldHVybmBfaygkZXZlbnQua2V5Q29kZSwke0pTT04uc3RyaW5naWZ5KHQpfSwke0pTT04uc3RyaW5naWZ5KG4pfSwkZXZlbnQua2V5LCR7SlNPTi5zdHJpbmdpZnkobyl9KWB9dmFyIFZjPXtvbjpmdW5jdGlvbih0LGUpe3Qud3JhcExpc3RlbmVycz10PT5gX2coJHt0fSwke2UudmFsdWV9KWB9LGJpbmQ6ZnVuY3Rpb24odCxlKXt0LndyYXBEYXRhPW49PmBfYigke259LCcke3QudGFnfScsJHtlLnZhbHVlfSwke2UubW9kaWZpZXJzJiZlLm1vZGlmaWVycy5wcm9wP1widHJ1ZVwiOlwiZmFsc2VcIn0ke2UubW9kaWZpZXJzJiZlLm1vZGlmaWVycy5zeW5jP1wiLHRydWVcIjpcIlwifSlgfSxjbG9hazpFfTtjbGFzcyBLY3tjb25zdHJ1Y3Rvcih0KXt0aGlzLm9wdGlvbnM9dCx0aGlzLndhcm49dC53YXJufHxPcix0aGlzLnRyYW5zZm9ybXM9VHIodC5tb2R1bGVzLFwidHJhbnNmb3JtQ29kZVwiKSx0aGlzLmRhdGFHZW5GbnM9VHIodC5tb2R1bGVzLFwiZ2VuRGF0YVwiKSx0aGlzLmRpcmVjdGl2ZXM9QShBKHt9LFZjKSx0LmRpcmVjdGl2ZXMpO2NvbnN0IGU9dC5pc1Jlc2VydmVkVGFnfHxOO3RoaXMubWF5YmVDb21wb25lbnQ9dD0+ISF0LmNvbXBvbmVudHx8IWUodC50YWcpLHRoaXMub25jZUlkPTAsdGhpcy5zdGF0aWNSZW5kZXJGbnM9W10sdGhpcy5wcmU9ITF9fWZ1bmN0aW9uIEpjKHQsZSl7Y29uc3Qgbj1uZXcgS2MoZSk7cmV0dXJue3JlbmRlcjpgd2l0aCh0aGlzKXtyZXR1cm4gJHt0P1wic2NyaXB0XCI9PT10LnRhZz9cIm51bGxcIjpxYyh0LG4pOidfYyhcImRpdlwiKSd9fWAsc3RhdGljUmVuZGVyRm5zOm4uc3RhdGljUmVuZGVyRm5zfX1mdW5jdGlvbiBxYyh0LGUpe2lmKHQucGFyZW50JiYodC5wcmU9dC5wcmV8fHQucGFyZW50LnByZSksdC5zdGF0aWNSb290JiYhdC5zdGF0aWNQcm9jZXNzZWQpcmV0dXJuIFdjKHQsZSk7aWYodC5vbmNlJiYhdC5vbmNlUHJvY2Vzc2VkKXJldHVybiBaYyh0LGUpO2lmKHQuZm9yJiYhdC5mb3JQcm9jZXNzZWQpcmV0dXJuIFljKHQsZSk7aWYodC5pZiYmIXQuaWZQcm9jZXNzZWQpcmV0dXJuIEdjKHQsZSk7aWYoXCJ0ZW1wbGF0ZVwiIT09dC50YWd8fHQuc2xvdFRhcmdldHx8ZS5wcmUpe2lmKFwic2xvdFwiPT09dC50YWcpcmV0dXJuIGZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj10LnNsb3ROYW1lfHwnXCJkZWZhdWx0XCInLG89bmEodCxlKTtsZXQgcj1gX3QoJHtufSR7bz9gLGZ1bmN0aW9uKCl7cmV0dXJuICR7b319YDpcIlwifWA7Y29uc3Qgcz10LmF0dHJzfHx0LmR5bmFtaWNBdHRycz9zYSgodC5hdHRyc3x8W10pLmNvbmNhdCh0LmR5bmFtaWNBdHRyc3x8W10pLm1hcCgodD0+KHtuYW1lOngodC5uYW1lKSx2YWx1ZTp0LnZhbHVlLGR5bmFtaWM6dC5keW5hbWljfSkpKSk6bnVsbCxpPXQuYXR0cnNNYXBbXCJ2LWJpbmRcIl07IXMmJiFpfHxvfHwocis9XCIsbnVsbFwiKTtzJiYocis9YCwke3N9YCk7aSYmKHIrPWAke3M/XCJcIjpcIixudWxsXCJ9LCR7aX1gKTtyZXR1cm4gcitcIilcIn0odCxlKTt7bGV0IG47aWYodC5jb21wb25lbnQpbj1mdW5jdGlvbih0LGUsbil7Y29uc3Qgbz1lLmlubGluZVRlbXBsYXRlP251bGw6bmEoZSxuLCEwKTtyZXR1cm5gX2MoJHt0fSwke1FjKGUsbil9JHtvP2AsJHtvfWA6XCJcIn0pYH0odC5jb21wb25lbnQsdCxlKTtlbHNle2xldCBvO2NvbnN0IHI9ZS5tYXliZUNvbXBvbmVudCh0KTtsZXQgczsoIXQucGxhaW58fHQucHJlJiZyKSYmKG89UWModCxlKSk7Y29uc3QgaT1lLm9wdGlvbnMuYmluZGluZ3M7ciYmaSYmITEhPT1pLl9faXNTY3JpcHRTZXR1cCYmKHM9ZnVuY3Rpb24odCxlKXtjb25zdCBuPXgoZSksbz1DKG4pLHI9cj0+dFtlXT09PXI/ZTp0W25dPT09cj9uOnRbb109PT1yP286dm9pZCAwLHM9cihcInNldHVwLWNvbnN0XCIpfHxyKFwic2V0dXAtcmVhY3RpdmUtY29uc3RcIik7aWYocylyZXR1cm4gcztjb25zdCBpPXIoXCJzZXR1cC1sZXRcIil8fHIoXCJzZXR1cC1yZWZcIil8fHIoXCJzZXR1cC1tYXliZS1yZWZcIik7aWYoaSlyZXR1cm4gaX0oaSx0LnRhZykpLHN8fChzPWAnJHt0LnRhZ30nYCk7Y29uc3QgYz10LmlubGluZVRlbXBsYXRlP251bGw6bmEodCxlLCEwKTtuPWBfYygke3N9JHtvP2AsJHtvfWA6XCJcIn0ke2M/YCwke2N9YDpcIlwifSlgfWZvcihsZXQgbz0wO288ZS50cmFuc2Zvcm1zLmxlbmd0aDtvKyspbj1lLnRyYW5zZm9ybXNbb10odCxuKTtyZXR1cm4gbn19cmV0dXJuIG5hKHQsZSl8fFwidm9pZCAwXCJ9ZnVuY3Rpb24gV2ModCxlKXt0LnN0YXRpY1Byb2Nlc3NlZD0hMDtjb25zdCBuPWUucHJlO3JldHVybiB0LnByZSYmKGUucHJlPXQucHJlKSxlLnN0YXRpY1JlbmRlckZucy5wdXNoKGB3aXRoKHRoaXMpe3JldHVybiAke3FjKHQsZSl9fWApLGUucHJlPW4sYF9tKCR7ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoLTF9JHt0LnN0YXRpY0luRm9yP1wiLHRydWVcIjpcIlwifSlgfWZ1bmN0aW9uIFpjKHQsZSl7aWYodC5vbmNlUHJvY2Vzc2VkPSEwLHQuaWYmJiF0LmlmUHJvY2Vzc2VkKXJldHVybiBHYyh0LGUpO2lmKHQuc3RhdGljSW5Gb3Ipe2xldCBuPVwiXCIsbz10LnBhcmVudDtmb3IoO287KXtpZihvLmZvcil7bj1vLmtleTticmVha31vPW8ucGFyZW50fXJldHVybiBuP2Bfbygke3FjKHQsZSl9LCR7ZS5vbmNlSWQrK30sJHtufSlgOnFjKHQsZSl9cmV0dXJuIFdjKHQsZSl9ZnVuY3Rpb24gR2ModCxlLG4sbyl7cmV0dXJuIHQuaWZQcm9jZXNzZWQ9ITAsWGModC5pZkNvbmRpdGlvbnMuc2xpY2UoKSxlLG4sbyl9ZnVuY3Rpb24gWGModCxlLG4sbyl7aWYoIXQubGVuZ3RoKXJldHVybiBvfHxcIl9lKClcIjtjb25zdCByPXQuc2hpZnQoKTtyZXR1cm4gci5leHA/YCgke3IuZXhwfSk/JHtzKHIuYmxvY2spfToke1hjKHQsZSxuLG8pfWA6YCR7cyhyLmJsb2NrKX1gO2Z1bmN0aW9uIHModCl7cmV0dXJuIG4/bih0LGUpOnQub25jZT9aYyh0LGUpOnFjKHQsZSl9fWZ1bmN0aW9uIFljKHQsZSxuLG8pe2NvbnN0IHI9dC5mb3Iscz10LmFsaWFzLGk9dC5pdGVyYXRvcjE/YCwke3QuaXRlcmF0b3IxfWA6XCJcIixjPXQuaXRlcmF0b3IyP2AsJHt0Lml0ZXJhdG9yMn1gOlwiXCI7cmV0dXJuIHQuZm9yUHJvY2Vzc2VkPSEwLGAke298fFwiX2xcIn0oKCR7cn0pLGZ1bmN0aW9uKCR7c30ke2l9JHtjfSl7cmV0dXJuICR7KG58fHFjKSh0LGUpfX0pYH1mdW5jdGlvbiBRYyh0LGUpe2xldCBuPVwie1wiO2NvbnN0IG89ZnVuY3Rpb24odCxlKXtjb25zdCBuPXQuZGlyZWN0aXZlcztpZighbilyZXR1cm47bGV0IG8scixzLGksYz1cImRpcmVjdGl2ZXM6W1wiLGE9ITE7Zm9yKG89MCxyPW4ubGVuZ3RoO288cjtvKyspe3M9bltvXSxpPSEwO2NvbnN0IHI9ZS5kaXJlY3RpdmVzW3MubmFtZV07ciYmKGk9ISFyKHQscyxlLndhcm4pKSxpJiYoYT0hMCxjKz1ge25hbWU6XCIke3MubmFtZX1cIixyYXdOYW1lOlwiJHtzLnJhd05hbWV9XCIke3MudmFsdWU/YCx2YWx1ZTooJHtzLnZhbHVlfSksZXhwcmVzc2lvbjoke0pTT04uc3RyaW5naWZ5KHMudmFsdWUpfWA6XCJcIn0ke3MuYXJnP2AsYXJnOiR7cy5pc0R5bmFtaWNBcmc/cy5hcmc6YFwiJHtzLmFyZ31cImB9YDpcIlwifSR7cy5tb2RpZmllcnM/YCxtb2RpZmllcnM6JHtKU09OLnN0cmluZ2lmeShzLm1vZGlmaWVycyl9YDpcIlwifX0sYCl9aWYoYSlyZXR1cm4gYy5zbGljZSgwLC0xKStcIl1cIn0odCxlKTtvJiYobis9bytcIixcIiksdC5rZXkmJihuKz1ga2V5OiR7dC5rZXl9LGApLHQucmVmJiYobis9YHJlZjoke3QucmVmfSxgKSx0LnJlZkluRm9yJiYobis9XCJyZWZJbkZvcjp0cnVlLFwiKSx0LnByZSYmKG4rPVwicHJlOnRydWUsXCIpLHQuY29tcG9uZW50JiYobis9YHRhZzpcIiR7dC50YWd9XCIsYCk7Zm9yKGxldCBvPTA7bzxlLmRhdGFHZW5GbnMubGVuZ3RoO28rKyluKz1lLmRhdGFHZW5GbnNbb10odCk7aWYodC5hdHRycyYmKG4rPWBhdHRyczoke3NhKHQuYXR0cnMpfSxgKSx0LnByb3BzJiYobis9YGRvbVByb3BzOiR7c2EodC5wcm9wcyl9LGApLHQuZXZlbnRzJiYobis9YCR7QmModC5ldmVudHMsITEpfSxgKSx0Lm5hdGl2ZUV2ZW50cyYmKG4rPWAke0JjKHQubmF0aXZlRXZlbnRzLCEwKX0sYCksdC5zbG90VGFyZ2V0JiYhdC5zbG90U2NvcGUmJihuKz1gc2xvdDoke3Quc2xvdFRhcmdldH0sYCksdC5zY29wZWRTbG90cyYmKG4rPWAke2Z1bmN0aW9uKHQsZSxuKXtsZXQgbz10LmZvcnx8T2JqZWN0LmtleXMoZSkuc29tZSgodD0+e2NvbnN0IG49ZVt0XTtyZXR1cm4gbi5zbG90VGFyZ2V0RHluYW1pY3x8bi5pZnx8bi5mb3J8fHRhKG4pfSkpLHI9ISF0LmlmO2lmKCFvKXtsZXQgZT10LnBhcmVudDtmb3IoO2U7KXtpZihlLnNsb3RTY29wZSYmZS5zbG90U2NvcGUhPT1pY3x8ZS5mb3Ipe289ITA7YnJlYWt9ZS5pZiYmKHI9ITApLGU9ZS5wYXJlbnR9fWNvbnN0IHM9T2JqZWN0LmtleXMoZSkubWFwKCh0PT5lYShlW3RdLG4pKSkuam9pbihcIixcIik7cmV0dXJuYHNjb3BlZFNsb3RzOl91KFske3N9XSR7bz9cIixudWxsLHRydWVcIjpcIlwifSR7IW8mJnI/YCxudWxsLGZhbHNlLCR7ZnVuY3Rpb24odCl7bGV0IGU9NTM4MSxuPXQubGVuZ3RoO2Zvcig7bjspZT0zMyplXnQuY2hhckNvZGVBdCgtLW4pO3JldHVybiBlPj4+MH0ocyl9YDpcIlwifSlgfSh0LHQuc2NvcGVkU2xvdHMsZSl9LGApLHQubW9kZWwmJihuKz1gbW9kZWw6e3ZhbHVlOiR7dC5tb2RlbC52YWx1ZX0sY2FsbGJhY2s6JHt0Lm1vZGVsLmNhbGxiYWNrfSxleHByZXNzaW9uOiR7dC5tb2RlbC5leHByZXNzaW9ufX0sYCksdC5pbmxpbmVUZW1wbGF0ZSl7Y29uc3Qgbz1mdW5jdGlvbih0LGUpe2NvbnN0IG49dC5jaGlsZHJlblswXTtpZihuJiYxPT09bi50eXBlKXtjb25zdCB0PUpjKG4sZS5vcHRpb25zKTtyZXR1cm5gaW5saW5lVGVtcGxhdGU6e3JlbmRlcjpmdW5jdGlvbigpeyR7dC5yZW5kZXJ9fSxzdGF0aWNSZW5kZXJGbnM6WyR7dC5zdGF0aWNSZW5kZXJGbnMubWFwKCh0PT5gZnVuY3Rpb24oKXske3R9fWApKS5qb2luKFwiLFwiKX1dfWB9fSh0LGUpO28mJihuKz1gJHtvfSxgKX1yZXR1cm4gbj1uLnJlcGxhY2UoLywkLyxcIlwiKStcIn1cIix0LmR5bmFtaWNBdHRycyYmKG49YF9iKCR7bn0sXCIke3QudGFnfVwiLCR7c2EodC5keW5hbWljQXR0cnMpfSlgKSx0LndyYXBEYXRhJiYobj10LndyYXBEYXRhKG4pKSx0LndyYXBMaXN0ZW5lcnMmJihuPXQud3JhcExpc3RlbmVycyhuKSksbn1mdW5jdGlvbiB0YSh0KXtyZXR1cm4gMT09PXQudHlwZSYmKFwic2xvdFwiPT09dC50YWd8fHQuY2hpbGRyZW4uc29tZSh0YSkpfWZ1bmN0aW9uIGVhKHQsZSl7Y29uc3Qgbj10LmF0dHJzTWFwW1wic2xvdC1zY29wZVwiXTtpZih0LmlmJiYhdC5pZlByb2Nlc3NlZCYmIW4pcmV0dXJuIEdjKHQsZSxlYSxcIm51bGxcIik7aWYodC5mb3ImJiF0LmZvclByb2Nlc3NlZClyZXR1cm4gWWModCxlLGVhKTtjb25zdCBvPXQuc2xvdFNjb3BlPT09aWM/XCJcIjpTdHJpbmcodC5zbG90U2NvcGUpLHI9YGZ1bmN0aW9uKCR7b30pe3JldHVybiAke1widGVtcGxhdGVcIj09PXQudGFnP3QuaWYmJm4/YCgke3QuaWZ9KT8ke25hKHQsZSl8fFwidW5kZWZpbmVkXCJ9OnVuZGVmaW5lZGA6bmEodCxlKXx8XCJ1bmRlZmluZWRcIjpxYyh0LGUpfX1gLHM9bz9cIlwiOlwiLHByb3h5OnRydWVcIjtyZXR1cm5ge2tleToke3Quc2xvdFRhcmdldHx8J1wiZGVmYXVsdFwiJ30sZm46JHtyfSR7c319YH1mdW5jdGlvbiBuYSh0LGUsbixvLHIpe2NvbnN0IHM9dC5jaGlsZHJlbjtpZihzLmxlbmd0aCl7Y29uc3QgdD1zWzBdO2lmKDE9PT1zLmxlbmd0aCYmdC5mb3ImJlwidGVtcGxhdGVcIiE9PXQudGFnJiZcInNsb3RcIiE9PXQudGFnKXtjb25zdCByPW4/ZS5tYXliZUNvbXBvbmVudCh0KT9cIiwxXCI6XCIsMFwiOlwiXCI7cmV0dXJuYCR7KG98fHFjKSh0LGUpfSR7cn1gfWNvbnN0IGk9bj9mdW5jdGlvbih0LGUpe2xldCBuPTA7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDtvKyspe2NvbnN0IHI9dFtvXTtpZigxPT09ci50eXBlKXtpZihvYShyKXx8ci5pZkNvbmRpdGlvbnMmJnIuaWZDb25kaXRpb25zLnNvbWUoKHQ9Pm9hKHQuYmxvY2spKSkpe249MjticmVha30oZShyKXx8ci5pZkNvbmRpdGlvbnMmJnIuaWZDb25kaXRpb25zLnNvbWUoKHQ9PmUodC5ibG9jaykpKSkmJihuPTEpfX1yZXR1cm4gbn0ocyxlLm1heWJlQ29tcG9uZW50KTowLGM9cnx8cmE7cmV0dXJuYFske3MubWFwKCh0PT5jKHQsZSkpKS5qb2luKFwiLFwiKX1dJHtpP2AsJHtpfWA6XCJcIn1gfX1mdW5jdGlvbiBvYSh0KXtyZXR1cm4gdm9pZCAwIT09dC5mb3J8fFwidGVtcGxhdGVcIj09PXQudGFnfHxcInNsb3RcIj09PXQudGFnfWZ1bmN0aW9uIHJhKHQsZSl7cmV0dXJuIDE9PT10LnR5cGU/cWModCxlKTozPT09dC50eXBlJiZ0LmlzQ29tbWVudD9mdW5jdGlvbih0KXtyZXR1cm5gX2UoJHtKU09OLnN0cmluZ2lmeSh0LnRleHQpfSlgfSh0KTpmdW5jdGlvbih0KXtyZXR1cm5gX3YoJHsyPT09dC50eXBlP3QuZXhwcmVzc2lvbjppYShKU09OLnN0cmluZ2lmeSh0LnRleHQpKX0pYH0odCl9ZnVuY3Rpb24gc2EodCl7bGV0IGU9XCJcIixuPVwiXCI7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDtvKyspe2NvbnN0IHI9dFtvXSxzPWlhKHIudmFsdWUpO3IuZHluYW1pYz9uKz1gJHtyLm5hbWV9LCR7c30sYDplKz1gXCIke3IubmFtZX1cIjoke3N9LGB9cmV0dXJuIGU9YHske2Uuc2xpY2UoMCwtMSl9fWAsbj9gX2QoJHtlfSxbJHtuLnNsaWNlKDAsLTEpfV0pYDplfWZ1bmN0aW9uIGlhKHQpe3JldHVybiB0LnJlcGxhY2UoL1xcdTIwMjgvZyxcIlxcXFx1MjAyOFwiKS5yZXBsYWNlKC9cXHUyMDI5L2csXCJcXFxcdTIwMjlcIil9ZnVuY3Rpb24gY2EodCxlKXt0cnl7cmV0dXJuIG5ldyBGdW5jdGlvbih0KX1jYXRjaChuKXtyZXR1cm4gZS5wdXNoKHtlcnI6bixjb2RlOnR9KSxFfX1mdW5jdGlvbiBhYSh0KXtjb25zdCBlPU9iamVjdC5jcmVhdGUobnVsbCk7cmV0dXJuIGZ1bmN0aW9uKG4sbyxyKXsobz1BKHt9LG8pKS53YXJuLGRlbGV0ZSBvLndhcm47Y29uc3Qgcz1vLmRlbGltaXRlcnM/U3RyaW5nKG8uZGVsaW1pdGVycykrbjpuO2lmKGVbc10pcmV0dXJuIGVbc107Y29uc3QgaT10KG4sbyksYz17fSxhPVtdO3JldHVybiBjLnJlbmRlcj1jYShpLnJlbmRlcixhKSxjLnN0YXRpY1JlbmRlckZucz1pLnN0YXRpY1JlbmRlckZucy5tYXAoKHQ9PmNhKHQsYSkpKSxlW3NdPWN9fW5ldyBSZWdFeHAoXCJcXFxcYlwiK1wiZG8saWYsZm9yLGxldCxuZXcsdHJ5LHZhcixjYXNlLGVsc2Usd2l0aCxhd2FpdCxicmVhayxjYXRjaCxjbGFzcyxjb25zdCxzdXBlcix0aHJvdyx3aGlsZSx5aWVsZCxkZWxldGUsZXhwb3J0LGltcG9ydCxyZXR1cm4sc3dpdGNoLGRlZmF1bHQsZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50c1wiLnNwbGl0KFwiLFwiKS5qb2luKFwiXFxcXGJ8XFxcXGJcIikrXCJcXFxcYlwiKSxuZXcgUmVnRXhwKFwiXFxcXGJcIitcImRlbGV0ZSx0eXBlb2Ysdm9pZFwiLnNwbGl0KFwiLFwiKS5qb2luKFwiXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYlwiKStcIlxcXFxzKlxcXFwoW15cXFxcKV0qXFxcXClcIik7Y29uc3QgbGE9KHVhPWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1nYyh0LnRyaW0oKSxlKTshMSE9PWUub3B0aW1pemUmJkVjKG4sZSk7Y29uc3Qgbz1KYyhuLGUpO3JldHVybnthc3Q6bixyZW5kZXI6by5yZW5kZXIsc3RhdGljUmVuZGVyRm5zOm8uc3RhdGljUmVuZGVyRm5zfX0sZnVuY3Rpb24odCl7ZnVuY3Rpb24gZShlLG4pe2NvbnN0IG89T2JqZWN0LmNyZWF0ZSh0KSxyPVtdLHM9W107aWYobil7bi5tb2R1bGVzJiYoby5tb2R1bGVzPSh0Lm1vZHVsZXN8fFtdKS5jb25jYXQobi5tb2R1bGVzKSksbi5kaXJlY3RpdmVzJiYoby5kaXJlY3RpdmVzPUEoT2JqZWN0LmNyZWF0ZSh0LmRpcmVjdGl2ZXN8fG51bGwpLG4uZGlyZWN0aXZlcykpO2Zvcihjb25zdCB0IGluIG4pXCJtb2R1bGVzXCIhPT10JiZcImRpcmVjdGl2ZXNcIiE9PXQmJihvW3RdPW5bdF0pfW8ud2Fybj0odCxlLG4pPT57KG4/czpyKS5wdXNoKHQpfTtjb25zdCBpPXVhKGUudHJpbSgpLG8pO3JldHVybiBpLmVycm9ycz1yLGkudGlwcz1zLGl9cmV0dXJue2NvbXBpbGU6ZSxjb21waWxlVG9GdW5jdGlvbnM6YWEoZSl9fSk7dmFyIHVhO2NvbnN0e2NvbXBpbGU6ZmEsY29tcGlsZVRvRnVuY3Rpb25zOmRhfT1sYShPYyk7bGV0IHBhO2Z1bmN0aW9uIGhhKHQpe3JldHVybiBwYT1wYXx8ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxwYS5pbm5lckhUTUw9dD8nPGEgaHJlZj1cIlxcblwiLz4nOic8ZGl2IGE9XCJcXG5cIi8+JyxwYS5pbm5lckhUTUwuaW5kZXhPZihcIiYjMTA7XCIpPjB9Y29uc3QgbWE9ISFxJiZoYSghMSksZ2E9ISFxJiZoYSghMCksdmE9YigodD0+e2NvbnN0IGU9bnIodCk7cmV0dXJuIGUmJmUuaW5uZXJIVE1MfSkpLHlhPVNvLnByb3RvdHlwZS4kbW91bnQ7U28ucHJvdG90eXBlLiRtb3VudD1mdW5jdGlvbih0LGUpe2lmKCh0PXQmJm5yKHQpKT09PWRvY3VtZW50LmJvZHl8fHQ9PT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpcmV0dXJuIHRoaXM7Y29uc3Qgbj10aGlzLiRvcHRpb25zO2lmKCFuLnJlbmRlcil7bGV0IGU9bi50ZW1wbGF0ZTtpZihlKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBlKVwiI1wiPT09ZS5jaGFyQXQoMCkmJihlPXZhKGUpKTtlbHNle2lmKCFlLm5vZGVUeXBlKXJldHVybiB0aGlzO2U9ZS5pbm5lckhUTUx9ZWxzZSB0JiYoZT1mdW5jdGlvbih0KXtpZih0Lm91dGVySFRNTClyZXR1cm4gdC5vdXRlckhUTUw7e2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gZS5hcHBlbmRDaGlsZCh0LmNsb25lTm9kZSghMCkpLGUuaW5uZXJIVE1MfX0odCkpO2lmKGUpe2NvbnN0e3JlbmRlcjp0LHN0YXRpY1JlbmRlckZuczpvfT1kYShlLHtvdXRwdXRTb3VyY2VSYW5nZTohMSxzaG91bGREZWNvZGVOZXdsaW5lczptYSxzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6Z2EsZGVsaW1pdGVyczpuLmRlbGltaXRlcnMsY29tbWVudHM6bi5jb21tZW50c30sdGhpcyk7bi5yZW5kZXI9dCxuLnN0YXRpY1JlbmRlckZucz1vfX1yZXR1cm4geWEuY2FsbCh0aGlzLHQsZSl9LFNvLmNvbXBpbGU9ZGEsQShTbyxIbiksU28uZWZmZWN0PWZ1bmN0aW9uKHQsZSl7Y29uc3Qgbj1uZXcgS24oYXQsdCxFLHtzeW5jOiEwfSk7ZSYmKG4udXBkYXRlPSgpPT57ZSgoKCk9Pm4ucnVuKCkpKX0pfSxtb2R1bGUuZXhwb3J0cz1TbzsiXX0=
